[{"id": "heq.elim", "parentIds": []}, {"id": "heq", "parentIds": ["heq.elim", "heq_of_eq_rec_left", "proof_irrel_heq", "subsingleton.helim", "sum.lex_acc_inr", "nat.not_succ_le_zero", "mul_dvd_mul", "list.length_le_of_sublist", "of_heq_true", "quotient.hrec_on", "congr_arg_heq", "heq_of_eq_mp", "quot.hrec_on", "list.chain_cons", "let_value_heq", "nat.shiftl'_sub", "plift.down_inj", "eq_of_heq", "fin.eq_of_veq", "rec_heq_of_heq", "char.veq_of_eq", "heq_of_eq_of_heq", "prod.mk.inj_iff", "option.eq_some_of_is_some", "fin.veq_of_eq", "eq_rec_compose", "sum.lex_inl_inl", "nat.dvd_add_iff_right", "heq.rfl", "function.hfunext", "sum.lex_acc_inl", "list.bex_cons", "nat.le.dest", "sum.inl_ne_inr", "sum.lex_inr_inr", "type_eq_of_heq", "heq.symm", "subtype.eq", "applicative.ext", "int.pos_of_sign_eq_one", "char.eq_of_veq", "int.neg_of_sign_eq_neg_one", "bool.ff_ne_tt", "sum.lex_inr_inl", "heq.subst", "heq_of_eq_rec_right", "int.nat_abs_of_nonneg", "psigma.lex_accessible", "heq_self_iff_true", "prod.lex_def", "list.pairwise_cons", "heq_iff_eq", "int.sign_eq_neg_one_of_neg", "eq_rec_heq", "heq.trans", "int.eq_zero_of_sign_eq_zero", "psigma.eq", "cast_heq", "sum.inr_ne_inl", "int.sign_eq_one_of_pos", "sigma.eq", "option.eq_none_of_is_none", "eq_mpr_heq", "heq_of_heq_of_eq", "functor.ext", "heq_of_eq"]}, {"id": "eq", "parentIds": ["heq.elim", "function.right_inverse.comp_eq_id", "ordering.ite_eq_gt_distrib", "partial_order", "list.mem_append", "eq_ff_of_not_eq_tt", "is_cond_left_inv", "decidable.lt_or_gt_of_ne", "iff_not_comm", "neg_mul_eq_neg_mul_symm", "false_of_a_eq_not_a", "function.right_id", "lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "int.neg_succ_of_nat_coe'", "neg_eq_iff_neg_eq", "nat.eq_zero_of_add_eq_zero", "nat.pred_zero", "function.id_of_left_inverse", "comm_semiring", "char.val_of_nat_eq_of_is_valid", "option.decidable_eq_none", "add_left_eq_self", "binder.decidable_eq", "sub_eq_sub_iff_sub_eq_sub", "le_mul_of_div_le", "int.of_nat_ge_zero", "fin.of_nat_zero", "bool.bor_inl", "div_zero", "eq_zero_or_eq_zero_of_mul_eq_zero", "one_add_one_eq_two", "functor.map_comp_map", "bool.bxor_comm", "parser.eof", "nat.sub_succ", "max_add_add_left", "bool.coe_bool_iff", "le_iff_lt_or_eq", "punit.decidable_eq", "heq_of_eq_rec_left", "int.add_comm", "commutative", "dlist.to_list_empty", "le_add_of_nonneg_right", "string.quote", "bnot_eq_true_eq_eq_ff", "if_t_t", "ne_zero_of_mul_ne_zero_left", "neg_add_le_of_le_add", "norm_num.add_comm_four", "neg_add_self", "eq_add_neg_iff_add_eq", "id.is_comm_applicative", "nat.pos_of_ne_zero", "nat.mod_lt", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "nat.eq_zero_or_eq_succ_pred", "ne_of_eq_of_ne", "min_neg_neg", "int.le.dest", "nat.div_eq_of_lt", "ne_of_mem_of_not_mem", "division_def", "norm_num.bit0_add_bit1", "abs_mul_abs_self", "imp_or_distrib'", "tactic.revertible_local_context", "nat.bitwise_zero", "mul_lt_mul_of_neg_left", "comp.run_pure", "nat.one_ne_zero", "auto_param_eq", "add_lt_of_lt_neg_add", "nat.bit_zero", "char.decidable_eq", "if_ctx_simp_congr", "subsingleton.elim", "function.surjective.of_comp", "int.nat_abs_of_nat", "add_right_eq_self", "list.subset_cons_of_subset", "decidable.eq_or_lt_of_le", "coe_sort_coe_base", "tt_band", "bool.to_bool_not", "add_eq_of_eq_sub'", "nat.add_right_cancel", "right_commutative", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "ring.mul_zero", "discrete_field", "comp.map_pure", "le_of_eq", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "expr.is_iff", "option.lift_or_get_comm", "norm_num.mul_bit0", "div_sub_div", "proof_irrel_heq", "int.coe_nat_add_out", "eqv_lt_iff_eq", "nat.shiftl'_add", "nat.add_mul_mod_self_right", "int.lt.intro", "decidable_eq_inl_refl", "function.surj_inv_eq", "subsingleton.helim", "nat.lxor_bit", "int.nat_abs_bit1_nonneg_step", "tactic.elide.unelide", "nat.one_lt_bit0", "div_pos_of_neg_of_neg", "dvd.intro", "list.mem_append_eq", "mul_nonpos_of_nonpos_of_nonneg", "nat.test_bit_ldiff", "add_assoc", "imp_congr_ctx_eq", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "sum.lex_acc_inr", "eq_inv_iff_mul_eq_one", "to_additive.target_name", "bit0_zero", "list.length_cons", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "option.is_lawful_monad", "tactic.suggest.head_symbol_match.decidable_eq", "add_sub_comm", "le_add_of_sub_left_le", "nat.mul_one", "abs_of_pos", "nat.mul_div_mul", "lt_or_gt_of_ne", "prod.id_prod", "is_cond_right_inv", "mjoin_map_map", "nat.not_succ_le_zero", "coe_fn_coe_trans", "bnot_eq_ff_eq_eq_tt", "where.trace_namespace", "option_t.run_pure", "nat.succ_eq_add_one", "classical.forall_or_distrib", "nat.eq_zero_of_add_eq_zero_left", "eq.symm", "nat.succ_sub_sub_succ", "unused_arguments", "push_neg.not_eq", "quot.exact", "applicative_transformation.preserves_map", "function.uncurry_curry", "linear_ordered_semiring", "applicative.map_seq_map", "eq_zero_of_zero_dvd", "norm_num.add1_bit1", "is_symm_op", "mul_nonneg_of_nonpos_of_nonpos", "eq_ff_eq_not_eq_tt", "abs_sub_le", "neg_add_lt_of_lt_add", "function.comp.assoc", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "char.of_nat_eq_of_not_is_valid", "functor.add_const.is_lawful_applicative", "native.rb_map.add", "mul_right_eq_self", "mul_dvd_mul", "eq_mul_inv_iff_mul_eq", "sub_right_comm", "propext", "int.add_assoc", "function.inv_fun_on_eq", "not_imp_eq_of_eq_false_right", "int.neg_ne_of_pos", "nat.mul_div_assoc", "add_midpoint", "fin.vne_of_ne", "tactic.interactive.propagate_tags", "int.le_of_coe_nat_le_coe_nat", "expr.to_nat", "norm_num.bit1_add_one_helper", "right_distrib", "function.involutive.surjective", "prod.mk.eta", "list.length_take_le", "except_t.ext", "add_add_sub_cancel", "list.eq_or_mem_of_mem_cons", "congr_arg2", "ne.decidable", "function.surjective", "mul_inv_rev", "array.read_mem", "norm_num.bit1_add_one", "band_eq_true_eq_eq_tt_and_eq_tt", "function.inv_fun_on_neg", "tactic.simplify_top_down", "mul_inv_eq", "tactic.suggest.unfold_head_symbol", "add_comm_group", "decidable_linear_ordered_semiring", "nat.lt_or_ge", "neg_add_eq_sub", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "int.nat_abs_mul_self", "tactic.interactive.guard_tags", "function.inv_fun_eq", "eq_false_intro", "min_eq_left_of_lt", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "nat.div_def", "norm_num.mul_bit1_helper", "functor.comp.ext", "nat.sub_eq_zero_of_le", "int.le.dest_sub", "dvd_mul_left", "tactic.is_prop", "max_self", "let_body_eq", "empty.decidable_eq", "except_t.run_pure", "eq_zero_of_mul_eq_self_right", "transport_multiplicative_to_additive", "add_left_cancel_semigroup", "nat_add_zero", "nat.test_bit_bitwise", "nat.eq_of_mul_eq_mul_right", "eq_of_sub_eq_zero", "antisymm", "sub_add_add_cancel", "nat.sub_sub_self", "int.nat_abs_eq", "dlist.to_list_concat", "nat.add_div_left", "eq_of_mul_eq_mul_right", "nat.gcd_succ", "nat.bodd_add_div2", "bool.band_comm", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "add_sub_cancel'", "list.length_le_of_sublist", "int.ne_of_nat_ne_nonneg_case", "nat.succ_mul_succ_eq", "is_dec_eq", "abs_one_div", "nat.add_mul_div_right", "eq.congr_left", "nat.bodd_add", "mul_eq_one_iff_inv_eq", "one_inv", "mul_eq_of_eq_div", "norm_num.mul_one", "and_eq_of_eq_true_left", "bind_pure", "nat.shiftl_sub", "reader_t.run_read", "add_right_surjective", "tt_eq_ff_eq_false", "add_zero", "abs_sub_square", "int.zero_mul", "ordered_comm_group.lt_of_add_lt_add_left", "mul_zero_lt_mul_inv_of_neg", "nat.gcd_zero_left", "expr.is_napp_of", "norm_num.subst_into_sum", "applicative_transformation", "int.neg_of_nat_zero", "push_neg.not_le_eq", "sub_left_le_of_le_add", "incorrect_def_lemma", "sum.elim_injective", "mul_right_cancel", "dvd_add_iff_right", "add_sub_sub_cancel", "list.cons_subset_cons", "dlist.to_list_cons", "and_eq_of_eq_true_right", "expr.is_ne", "nat.test_bit_lor", "congr_fun", "max_comm", "if_false_left_eq_and", "ne_false_of_self", "sub_eq_zero_of_eq", "imp_eq_of_eq_false_right", "not_iff_not", "list.length_append", "neg_inj'", "set.image", "dvd_of_mul_left_dvd", "nat.bit0_val", "associative", "string.iterator.length_next_to_string_next", "comm_group", "nat.pow_lt_pow_of_lt_right", "left_commutative", "is_right_id", "one_div_mul_one_div'", "bor_ff", "int.neg_ne_zero_of_ne", "if_congr", "div_le_div_of_le_of_neg", "field.div_mul_eq_div_mul_one_div", "mul_right_inj", "list.is_prefix", "state_t.run_map", "option.eq_of_eq_some", "one_div_eq_inv", "implies_of_if_pos", "prod.lex.decidable", "imp_eq_of_eq_false_left", "bxor_self", "exists_add_lt_and_pos_of_lt", "int.lt.elim", "one_le_one_div", "nat.bodd_succ", "ne_true_of_not", "div_div_eq_div_mul", "int.add_zero", "nat.zero_lt_one_add", "neg_mul_eq_neg_mul", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "function.injective", "nat.add_right_comm", "nat.lt_trichotomy", "add_le_of_le_neg_add", "nat.ldiff_bit", "is_lawful_functor", "to_additive.proceed_fields", "inv_ne_zero", "expr.to_int", "mul_one", "mul_div_mul_left'", "max_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "functor.const.ext", "function.left_inverse_inv_fun", "nat.le_mul_self", "integral_domain", "array.read_write_of_ne", "tactic.non_dep_prop_hyps", "nat.lt_add_of_pos_left", "int.distrib_right", "sum.is_lawful_monad", "is_left_cancel", "nat.mul_div_right", "reader_t.run_map", "list.map_append", "norm_num.add_comm_middle", "function.update", "congr_arg_heq", "le_neg_of_le_neg", "option.some_inj", "mul_assoc", "le_of_neg_le_neg", "nat.shiftr_eq_div_pow", "semiring", "sub_le_of_abs_sub_le_left", "is_dec_refl", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "nat.mod_one", "prod.map_snd'", "char.val_of_nat_eq_of_not_is_valid", "lt_of_le_of_ne", "max_assoc", "vm_obj_kind.decidable_eq", "functor.comp.comp_map", "classical.cases_true_false", "true_ne_false", "mul_zero_class", "nat.binary_rec_eq", "one_div_lt_neg_one", "id.bind_eq", "nat.eq_zero_or_pos", "coe_ff", "nat.pred_lt_pred", "int.of_nat_inj", "fin.mod_def", "nat.nat_zero_eq_zero", "div_two_sub_self", "is_associative", "exists_unique_of_exists_of_unique", "reader_t.run_pure", "dlist.of_list_to_list", "smt_tactic.when_tracing", "right_comm", "dif_pos", "function.injective.eq_iff", "le_min", "heq_of_eq_mp", "function.injective_of_partial_inv_right", "nat.lor_bit", "option.lift_or_get_is_left_id", "add_neg_eq_iff_eq_add", "sub_ne_zero_of_ne", "int.of_nat_zero", "max_eq_right", "le_max_left", "int.nat_abs_add_neg", "prod.map_fst'", "tactic.library_search", "function.inv_fun_eq_of_injective_of_right_inverse", "functor.const.is_lawful_functor", "lt_of_not_ge", "monad_lift_refl", "ne_of_gt", "int.sub_nat_nat_elim", "lt_of_add_lt_add_right", "mul_inv", "state_t.run_monad_map", "decidable_linear_ordered_cancel_comm_monoid", "function.curry_uncurry'", "option_t.run_map", "nat.mod_two_of_bodd", "eq_of_incomp", "expr.decidable_rel", "nat.lt_wf", "eq_add_neg_of_add_eq", "one_dvd", "quotient.decidable_eq", "div_neg_of_pos_of_neg", "int.nat_abs_pos_of_ne_zero", "cast", "if_pos", "eq_of_mul_eq_mul_of_nonzero_right", "false_ne_true", "sub_eq_iff_eq_add", "nat.binary_rec_zero", "eq_or_lt_of_not_lt", "one_mul", "list.func.equiv", "ordering.compares.eq_lt", "expr.is_heq", "functor.comp.map_mk", "int.lt_add_succ", "forall_congr_eq", "tactic.revert_all", "norm_num.add1_zero", "int.sign_one", "max_eq_neg_min_neg_neg", "function.update_same", "list.filter_cons_of_neg", "list.length_drop", "nat.add_mul_div_left", "tactic.choose1", "comp.seq_mk", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "is_comm_applicative", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "function.surjective_of_has_right_inverse", "eq_min", "list.ne_nil_of_length_eq_succ", "eq_true_of_and_eq_true_right", "nat.add_self_ne_one", "nat.sub_eq_iff_eq_add", "function.surj_inv", "nat.succ_sub_succ_eq_sub", "iff_iff_eq", "one_div_zero", "function.curry_uncurry", "div_mul_cancel", "nat.le_of_eq", "list.length_map", "list.is_infix", "push_neg.not_lt_eq", "nat.succ_inj", "forall_iff_forall_surj", "decidable.lt_by_cases", "mul_ne_zero", "list.filter_append", "no_zero_divisors", "nat.sub_eq_sub_min", "sub_sub_cancel", "nat.sub_mul_mod", "opt_param_eq", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "mul_div_cancel_left", "lt_min", "exists_unique.intro", "add_sub_cancel'_right", "lt_add_of_neg_add_lt_left", "coe_sort_bool", "nat.zero_mul", "state_t.run_adapt", "ff_eq_tt_eq_false", "int.sign_eq_neg_one_iff_neg", "nat.succ_add_eq_succ_add", "to_bool_false_eq_ff", "bool.bxor_iff_ne", "nat.bit0_inj", "list.filter_nil", "nat.bodd_one", "neg_lt_neg", "tactic.constr_to_prop", "if_true_right_eq_or", "mul_left_comm", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "if_ctx_congr", "nat.bitwise_zero_left", "nat.zero_shiftr", "function.injective.of_comp", "nat.add_comm", "norm_num.bit1_add_bit0_helper", "dvd_of_mul_right_dvd", "list.chain_cons", "le_mul_of_ge_one_right", "eq_zero_of_mul_self_eq_zero", "mul_le_mul_of_mul_div_le", "int.neg_succ_of_nat_inj_iff", "mjoin_pure", "mul_zero_lt_mul_inv_of_pos", "prod_has_decidable_lt", "nat.add_succ", "quotient.lift_on\u2082", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "mul_lt_mul_of_neg_right", "exists_unique", "bex_imp_distrib", "function.inv_fun_on_eq'", "is_left_null", "int.mul_one", "ordering.compares.eq_gt", "let_value_heq", "ulift.up_down", "bool.to_bool_false", "expr.is_constant_of", "can_lift", "int.eq_coe_or_neg", "eq_true_of_not_eq_false", "eq_inv_iff_eq_inv", "ne_zero_of_mul_ne_zero_right", "nat.one_le_bit0", "one_div_lt_one_div_of_lt_of_neg", "is_idempotent", "expr.is_eta_expansion_of", "div_helper", "eq.congr", "int.add_left_neg", "mul_self_iff_eq_one", "bor_eq_false_eq_eq_ff_and_eq_ff", "inv_eq_iff_inv_eq", "int.nat_abs_bit0_step", "list.subset_cons", "expr.is_eq", "parser.is_lawful_monad", "div_mul_le_div_mul_of_div_le_div_pos", "nat.lt_of_sub_eq_succ", "function.inv_fun_on", "function.inv_fun_on_pos", "eq.substr", "int.of_nat_nat_abs_of_nonpos", "option.has_mem", "quotient.exact", "nat.shiftl'_sub", "tactic.apply_auto_param", "norm_num.neg_add_pos_eq_of_eq_add", "string.map_tokens", "to_bool_true_eq_tt", "nat.one_shiftl", "sum.elim_inl", "iff_eq_true_of_eq", "exists_eq", "of_to_bool_ff", "add_mul_self_eq", "norm_num.neg_add_pos_helper2", "sum.inl.inj_iff", "eq_neg_iff_eq_neg", "add_add_add_comm", "ring", "option_t.run_monad_map", "ordering.swap_or_else", "function.id_of_right_inverse", "dlist.to_list_append", "reader_t.is_lawful_monad", "int.coe_nat_lt_coe_nat_iff", "push_neg.not_and_eq", "neg_add", "if_true", "norm_num.zero_mul", "plift.down_inj", "monad_map_refl", "nat.mul_le_mul_left", "is_comm_applicative.commutative_map", "div_mul_left", "decidable_eq", "quot.lift_beta", "exists_of_exists_unique", "eq_of_heq", "list.mem_cons_iff", "imp_eq_true_of_eq", "int.coe_nat_mul_out", "trans_rel_right", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "mul_pos", "subsingleton", "nat.add_sub_cancel", "not_of_eq_false", "division_ring", "nat.mul_zero", "exists_eq_mul_left_of_dvd", "neg_neg_sub_neg", "conv.funext", "left_identity", "list.split_on", "tactic.change_with_at", "quotient.sound", "plift.ext", "zero_sub", "int.of_nat_sub", "int.coe_nat_zero", "min_eq_left", "nat.div_le_of_le_mul", "string.iterator.next_to_string_mk_iterator", "option.is_none_iff_eq_none", "mul_right_surjective", "add_eq_zero_iff_neg_eq", "rbnode.color.decidable_eq", "le_of_eq_or_lt", "linear_ordered_comm_ring", "psigma.rev_lex_accessible", "mul_sub_mul_div_mul_neg", "bool.to_bool_true", "old_conv.funext", "fin.eq_of_veq", "quot.lift_on", "anti_symmetric", "eq_inv_mul_iff_mul_eq", "nat.sub_pos_of_lt", "int.of_nat_nat_abs_eq_of_nonneg", "division_ring.one_div_one_div", "norm_num.neg_zero_helper", "add_self_iff_eq_zero", "neg_mul_comm", "add_div_eq_mul_add_div", "funext", "nat.mul_mod_mul_left", "bool.dichotomy", "int.ne_neg_of_ne", "dvd.elim", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "array.read_write", "fish_pipe", "int.distrib_left", "tactic.interactive.guard_hyp_nums", "quot.ind_beta", "list.cons_append", "is_left_id", "bool.coe_sort_ff", "function.uncurry_bicompr", "int.lt_irrefl", "one_div_one", "classical.dec_eq", "list.map_id", "nat.div2_zero", "nat.bodd_zero", "prod.swap_swap", "quot.exists_rep", "int.add_lt_add_left", "not_iff", "function.uncurry'_curry", "bor_self", "mul_eq_one_iff_eq_inv", "congr_arg", "nat.coprime", "neg_add_eq_iff_eq_add", "nat.mod_le", "tactic.interactive.simp_core_aux", "nat.mk_numeral", "neg_add_cancel_right", "comp.run_seq", "nat.add_le_add_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "prod.map_fst", "id.map_eq", "nat.zero_sub", "decidable.lt_or_eq_of_le", "id.def", "int.of_nat_mul", "eq.mp", "nat.div_mul_cancel", "nat.eq_zero_of_mul_eq_zero", "left_cancelative", "add_sub_add_right_eq_sub", "mul_eq_of_eq_inv_mul", "nat.pos_of_dvd_of_pos", "eq_comm", "nat.lt_by_cases", "function.injective_of_partial_inv", "nat.div_eq_of_eq_mul_right", "expr.is_false", "list.map_cons", "list.indexes_of", "int.coe_nat_add_one_out", "nat.mul_div_cancel'", "inv_ne_one", "mul_one_div_cancel", "int.le_antisymm", "norm_num.bit0_add_bit1_helper", "imp_congr_eq", "list.is_suffix", "decidable_linear_order", "nat.succ_sub_succ", "eq_tt_eq_not_eq_ff", "list.mem_cons_self", "mul_left_eq_self", "except_t.run_map", "int.eq_one_of_mul_eq_self_left", "mul_right_comm", "int.sign_eq_one_iff_pos", "state_t.run_monad_lift", "zero_div", "add_left_inj", "nat.lt_add_of_zero_lt_left", "ordered_semiring", "abs_nonneg", "string.str_ne_str_right", "exists_eq_mul_right_of_dvd", "state_t.run_get", "rec_heq_of_heq", "true_eq_false_of_false", "not_lt_iff_eq_or_lt", "functor.comp.functor_id_comp", "lt_add_of_pos_left", "left_distributive", "nat.sub_self", "lt_trichotomy", "eq_iff_eq_cancel_right", "fin.ne_of_vne", "lt_of_one_lt_div", "field.div_div_div_div_eq", "int.lt_iff_le_and_ne", "eq_add_of_add_neg_eq", "abs_mul", "function.partial_inv", "neg_le_neg", "nat.add_left_cancel", "right_inverse", "subtype.decidable_eq", "nat.zero_mod", "function.injective_prod", "is_right_cancel", "coe_sort_coe_trans", "list.append_nil", "right_distributive", "functor.comp.functor_comp_id", "left_distrib", "is_commutative", "neg_add_le_right_of_le_add", "norm_num.div_add_helper", "char.veq_of_eq", "bool.ff_eq_to_bool_iff", "function.is_partial_inv", "applicative_transformation.preserves_seq", "nat.digit_char", "false_of_true_eq_false", "min_comm", "bool.eq_tt_of_bnot_eq_ff", "tactic.when_tracing", "sub_add_cancel", "tactic.mk_inhabited_instance", "mul_inv_eq_iff_eq_mul", "list.qsort_cons", "and_eq_of_eq_false_right", "zero_mul", "sub_sub", "bool.coe_sort_tt", "string.is_empty", "add_le_of_le_sub_left", "heq_of_eq_of_heq", "add_le_of_le_sub_right", "to_bool_true", "mul_sub", "discrete_linear_ordered_field", "is_left_inv", "nat.add_mod_right", "int.le.intro", "exists_and_distrib_right", "nat.add_sub_add_right", "ff_bor", "eq.subst", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "abs_of_neg", "dvd.intro_left", "nat.bit_decomp", "nat.le_of_add_le_add_right", "trichotomous_of", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "nat.add_sub_cancel_left", "well_founded_tactics.cancel_nat_add_lt", "nat.bit1_ne_bit0", "bool.forall_bool", "except_t.run_monad_lift", "prod.mk.inj_iff", "option.eq_some_of_is_some", "eq_div_of_mul_eq", "add_right_cancel_semigroup", "sub_eq_zero", "add_neg_self", "mjoin_map_pure", "nat.gcd_one_left", "comp.applicative_id_comp", "mul_inv_cancel_left", "add_right_cancel", "neg_add_le_left_of_le_add", "nat.eq_zero_of_le_zero", "eq_true_intro", "is_right_inv", "eq_false_of_or_eq_false_right", "ne_of_ne_of_eq", "max_le", "le_mul_of_ge_one_left", "fin.veq_of_eq", "one_div_le_of_one_div_le_of_pos", "comm_ring", "function.restrict_eq", "name.is_private", "bool.eq_tt_of_ne_ff", "nat.bitwise_swap", "nat.bitwise_zero_right", "int.coe_nat_add", "nat.shiftr_add", "lt_of_sub_pos", "eq.mpr", "char.ne_of_vne", "int.one_mul", "min_add_add_right", "eq_rec_compose", "mul_left_cancel", "nat.pow_succ", "int.le_trans", "list.length_take", "ne.symm", "buffer.write_eq_write'", "int.coe_nat_eq", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "string.empty_ne_str", "prod.swap_swap_eq", "add_group", "linear_ordered_ring", "sum.lex_inl_inl", "option.map_id", "sub_right_le_of_le_add", "sub_ne_zero", "fin.mul_def", "mul_neg_of_neg_of_pos", "well_founded_tactics.is_psigma_mk", "add_comm", "le_sub_left_of_add_le", "not_eq_of_eq_false", "name.deinternalize_field", "eq_iff_eq_of_sub_eq_sub", "nat.bitwise_bit", "eq_iff_eq_cancel_left", "sub_sub_assoc_swap", "min_add_add_left", "nat.dvd_add_iff_right", "int.nat_abs_neg", "ne_zero_of_one_div_ne_zero", "mul_pos_of_neg_of_neg", "int.eq_neg_succ_of_lt_zero", "classical.prop_complete", "neg_of_neg_pos", "function.comp_apply", "nat.dvd_mod_iff", "forall_eq", "one_div_ne_zero", "int.ne_of_lt", "eq_equivalence", "nat.dvd_sub", "bool_iff_false", "decidable.le_iff_lt_or_eq", "eq_of_add_eq_add_right", "exists_eq_left", "d_array.of_beq_aux_eq_ff", "distrib", "eq_zero_of_neg_eq", "eq_of_forall_ge_iff", "mul_right_inv", "field.div_mul_left", "sub_lt_self", "linear_order", "bool.eq_ff_of_bnot_eq_tt", "incomp_iff_eq", "push_neg.not_forall_eq", "dif_ctx_congr", "list.lt_eq_not_ge", "rsimp.rsimplify_at", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "d_array.write", "norm_num.nonneg_bit0_helper", "sub_sub_sub_cancel_left", "prod.fst_swap", "to_bool_ff", "not_iff_comm", "int.nat_abs_bit0", "field.div_mul_eq_mul_div_comm", "nat.eq_one_of_dvd_one", "mul_le_mul_of_nonpos_left", "mul_inv_self", "int.abs_eq_nat_abs", "sub_sub_self", "le_of_mul_le_of_ge_one", "or_eq_of_eq_true_right", "option_t.run_bind", "int.coe_nat_one", "expr.is_or", "int.mul_zero", "sub_eq_of_eq_add'", "expr.replace_with", "bool.to_bool_and", "quotient.lift_on", "neg_dvd_of_dvd", "nat.le.intro", "one_inv_eq", "ordering.swap_swap", "norm_num.one_add_bit1", "neg_comm_of_comm", "iff_of_eq", "coe_decidable_eq", "comm_monoid", "le_of_not_gt", "bool.cond_ff", "old_conv.congr_core", "subsingleton_pempty", "nat.sub_self_add", "rbnode.well_formed", "id.is_lawful_monad", "le_antisymm", "reader_t.run_monad_lift", "eq_inv_of_eq_inv", "abs_neg", "prod.has_lt", "mul_eq_zero_iff_eq_zero_or_eq_zero", "le_add_of_neg_add_le", "ne_self_iff_false", "int.sign_mul_abs", "nat.discriminate", "eq_self_iff_true", "nat.test_bit_lxor", "inv_mul_cancel_left", "le_add_of_sub_right_le", "nat.sub_one_sub_lt", "div_mul_le_div_mul_of_div_le_div_pos'", "array.mem", "array.ext'", "nat.succ_add", "not_exists_not", "norm_num.add1_bit1_helper", "int.sign_neg_one", "group", "bool.eq_ff_of_ne_tt", "tactic.simplify_bottom_up", "neg_nonpos_of_nonneg", "le_of_lt_or_eq", "add_neg_cancel_right", "mul_inv_cancel", "quot.lift", "function.inv_fun_neg", "add_group.add_right_cancel", "int.sign_zero", "function.comp_app", "add_mul", "int.nat_abs_of_nat_core", "min_le_right", "quotient.lift", "function.inv_fun_on_mem", "map_seq", "sub_lt_of_abs_sub_lt_left", "or_iff_not_and_not", "subtype.eta", "check_unused_arguments", "dvd_trans", "old_conv.apply_propext_lemmas_core", "div_lt_div_of_lt_of_neg", "nat.dvd_of_mul_dvd_mul_right", "int.zero_add", "norm_num.add_div_helper", "let_value_eq", "norm_num.pos_bit0_helper", "int.mul_pos", "nat.zero_min", "int.eq_succ_of_zero_lt", "prod.lt_def", "coe_sort_tt", "tactic.interactive.use", "nat.add_zero", "field.div_mul_div", "function.injective.ne", "tactic.mk_has_reflect_instance", "nat.land_bit", "functor.map_id", "division_ring.one_div_div", "one_div_mul_cancel", "function.hfunext", "norm_num.subst_into_div", "sum.lex_acc_inl", "eq_false_of_not_eq_true", "mul_eq_of_eq_mul_inv", "push_neg.not_implies_eq", "list.mem_cons_eq", "nat.succ_ne_zero", "is_antisymm", "sub_mul", "imp_eq_of_eq_true_left", "mul_right_cancel_iff", "bool.bor_assoc", "neg_eq_neg_one_mul", "function.involutive", "eq_sub_of_add_eq", "bool.cond_tt", "and_eq_of_eq_false_left", "to_bool_iff", "comp.is_comm_applicative", "list.nil_append", "lt_or_ge", "lt_mul_of_gt_one_right", "state_t.ext", "dvd_mul_of_dvd_right", "bool.cond_to_bool", "eq_of_inv_eq_inv", "band_self", "nat.mul_mod_left", "nat.add_div_right", "if_simp_congr", "unchecked_cast", "div_nonpos_of_nonpos_of_pos", "rfl", "sub_zero", "or_eq_of_eq_false_left", "list.length_tail", "function.partial_inv_left", "inv_eq_one", "tt_bor", "name.lt.decidable_rel", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "is_lawful_traversable", "eq_zero_of_abs_eq_zero", "inv_inj'", "ordered_ring.mul_le_mul_of_nonneg_right", "norm_num.nonzero_of_neg_helper", "div_eq_mul_one_div", "nat.div_lt_self", "div_mul_right", "nat.mul_mod_right", "function.comp.right_id", "iff_iff_and_or_not_and_not", "abs_zero", "exists_eq_right", "exists_unique.elim", "inv_zero", "group.mul_left_cancel", "mul_inv'", "eq_true_of_and_eq_true_left", "bool.to_bool_coe", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "nat.lt_iff_le_not_le", "char.vne_of_ne", "fin.lt_def", "nat.mul_succ", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "bor_tt", "nat.mod_zero", "nat.one_add", "nat.bit1_val", "add_self_div_two", "dvd_mul_of_dvd_left", "eq_neg_iff_add_eq_zero", "div_lt_div_of_lt_of_pos", "int.coe_nat_succ", "norm_num.bit1_add_bit0", "nat.mul_div_left", "int.coe_nat_inj", "string.has_decidable_eq", "ulift.down_up", "d_array.decidable_eq", "decidable.lt_trichotomy", "ne", "tactic.relation_lhs_rhs", "iff.to_eq", "sub_add_sub_cancel", "max_eq_left", "add_eq_of_eq_add_neg", "one_div_neg_one_eq_neg_one", "lt_add_of_neg_add_lt", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "comp.pure_seq_eq_map", "one_div_neg_eq_neg_one_div", "prod.lex_accessible", "list.bex_cons", "int.eq_coe_of_zero_le", "mul_neg_eq_neg_mul_symm", "nat.div_eq_of_lt_le", "coe_fn_coe_base", "function.left_inverse_of_surjective_of_right_inverse", "int.mul_assoc", "list.length_map_accumr", "int.coe_nat_eq_coe_nat_iff", "neg_sub", "int.nat_abs_bit1_nonneg", "ne_zero_of_abs_ne_zero", "abs_div", "bool.bnot_false", "int.add_le_add_left", "nat.le.dest", "lt_add_of_neg_add_lt_right", "function.update_noteq", "le_add_of_neg_add_le_left", "div_mul_eq_div_mul_one_div", "cc_state.in_singlenton_eqc", "nat.one_succ_zero", "prod.ext", "int.of_nat_eq_coe", "unique_of_exists_unique", "mul_self_sub_mul_self_eq", "prod.map_snd", "add_sub_cancel", "sum.inl_ne_inr", "nat.bit0_succ_eq", "quotient.exists_rep", "nat.dvd_iff_mod_eq_zero", "int.coe_nat_sub", "nat.mul_sub_left_distrib", "nat.eq_or_lt_of_le", "nat.mul_pred_right", "of_eq_true", "ne_of_lt", "functor.const.is_lawful_applicative", "function.left_inverse.comp_eq_id", "dif_eq_if", "comm_semigroup", "sum.lex_inr_inr", "int.neg_neg_of_nat_succ", "sub_left_lt_of_lt_add", "norm_num.neg_mul_pos_helper", "int.eq_nat_abs_of_zero_le", "eq_neg_add_of_add_eq", "add_right_neg", "nat.bit0_ne_one", "cast_proof_irrel", "tactic.interactive.clear_", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "type_eq_of_heq", "add_right_comm", "nat.sub_add_comm", "list.count", "neg_pos_of_neg", "zero_gt_neg_one", "nat.succ_sub", "nat.div_le_self", "bit1_zero", "nat.le_of_le_of_sub_le_sub_right", "nat.bodd_bit", "one_div_lt_one_div_of_lt", "id_map'", "applicative.pure_seq_eq_map'", "bool.bxor_bnot_bnot", "mul_div_assoc", "nat.sub_mul_div", "function.equiv", "fin.sub_def", "to_bool_ff_iff", "nat.pred_lt", "tactic.binder_info.has_decidable_eq", "function.uncurry_def", "nat.exists_eq_succ_of_ne_zero", "and_iff_not_or_not", "add_lt_of_lt_sub_right", "field.div_mul_right", "dvd_of_neg_dvd", "ne.intro", "char.of_nat_ne_of_ne", "int.lt_iff_le_not_le", "div_nonpos_of_nonneg_of_neg", "quot.eqv_gen_sound", "inv_inj", "div_div_eq_mul_div", "subtype.eq", "right_identity", "int.neg_succ_of_nat_coe", "add_comm_semigroup", "nat.sub.right_comm", "nat.left_distrib", "int.neg_succ_of_nat_eq", "division_ring.mul_ne_zero", "of_to_bool_true", "nat.mod_self", "neq_of_not_iff", "nat.shiftl_succ", "le_abs_self", "rsimp.choose", "int.coe_nat_le_coe_nat_of_le", "min_assoc", "ordering.ite_eq_eq_distrib", "add_comm_monoid", "tactic.interactive.guard_expr_strict", "norm_num.bin_zero_add", "int.sign_eq_zero_iff_zero", "eq_of_mul_eq_mul_of_nonzero_left", "norm_num.sub_nat_pos_helper", "eq_iff_le_not_lt", "imp_or_distrib", "int.sign_mul_nat_abs", "list.filter_sublist", "prod.snd_swap", "eq_iff_iff", "nat.strong_rec_on", "int.le_total", "bool.tt_eq_to_bool_iff", "mul_inv_eq_one", "nat.add_mod_left", "nat.lt_of_le_and_ne", "nat.right_distrib", "except_t.run_monad_map", "list.is_lawful_monad", "map_ext_congr", "tactic.injection_with", "tactic.interactive.convert_to", "inv_comm_of_comm", "add_sub", "abs_of_nonneg", "applicative.ext", "nat.test_bit_succ", "mul_sub_right_distrib", "le_iff_eq_or_lt", "bxor_tt", "nat.bit1_inj", "nat.eq_or_lt_of_not_lt", "eq_is_equiv", "parser.ch", "lt_neg_of_lt_neg", "state_t.run_put", "norm_num.subst_into_prod", "cmp_compares", "int.pos_of_sign_eq_one", "add_left_neg", "tactic.fail_if_no_goals", "min_left_comm", "le_sub_right_of_add_le", "division_ring.neg_div_neg_eq", "tactic.interactive.change", "or_eq_of_eq_false_right", "min_eq_neg_max_neg_neg", "bool.default_bool", "ordering.or_else_eq_lt", "let_eq", "nat.zero_ne_one", "eq_zero_of_mul_self_add_mul_self_eq_zero", "seq_bind_eq", "nat.sub_sub", "option.mem_to_list", "nat.lt_of_add_lt_add_left", "nat.div2_bit", "sum.elim_inr", "function.surjective_comp", "cmp_swap", "guard_true", "if_false", "ne.def", "eq_of_neg_eq_neg", "list_linters", "eq_tt_of_not_eq_ff", "eq_true", "dvd_add", "mul_eq_mul_of_div_eq_div", "neg_lt_of_neg_lt", "eq_mul_inv_of_mul_eq", "nat.sub_zero", "neg_inj", "ordered_comm_group", "and_eq_of_eq", "nat.mul_sub_right_distrib", "subtype.tag_irrelevant", "functor.comp.run_map", "or_eq_of_eq", "one_div_div", "nat.sub_add_min_cancel", "add_neg_cancel_left", "nat.add_le_add_left", "add_add_neg_cancel'_right", "list.append_assoc", "nat.le_of_sub_eq_zero", "if_eq_of_eq_false", "function.surjective_id", "string.str_ne_str_left", "mul_left_surjective", "nat.succ_ne_self", "trans_rel_left", "char.eq_of_veq", "nat.add_one", "mul_neg_of_pos_of_neg", "int.neg_succ_lt_zero", "classical.eq_false_or_eq_true", "int.neg_of_sign_eq_neg_one", "neg_add_rev", "dif_neg", "nat.mul_self_sub_mul_self_eq", "iff_eq_eq", "zero_add", "pure_id_seq", "div_eq_one_iff_eq", "mul_div_mul_left", "if_neg", "monoid", "comm_semiring_has_dvd", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "inv_mul_self", "sum.swap_swap_eq", "function.injective_comp", "nat.gcd_zero_right", "iff_eq_of_eq_true_left", "neg_add_cancel_left", "sum.is_lawful_functor", "tactic.simp_hyp", "add_lt_add_right", "neg_eq_iff_add_eq_zero", "function.cantor_surjective", "nat.bit_val", "nat.div_eq_sub_div", "le_add_of_neg_add_le_right", "function.comp_const_right", "nat.pow_lt_pow_of_lt_left", "add_left_surjective", "is_lawful_applicative.map_comp_pure", "dvd.elim_left", "nat.dvd_of_mod_eq_zero", "sum.swap_swap", "mul_div_mul_right'", "norm_num.one_add_one", "dvd_refl", "mjoin_map_mjoin", "add_left_cancel_iff", "bool_eq_false", "list.filter_cons_of_pos", "nat.zero_div", "neg_eq_zero", "lt_sub_right_of_add_lt", "nat.mod_def_aux", "ordered_ring.mul_lt_mul_of_pos_right", "well_founded.fix_F_eq", "list.append_bind", "one_ne_zero", "sub_add_eq_add_sub", "dif_ctx_simp_congr", "nat.bit1_eq_succ_bit0", "mul_comm", "and.rotate", "function.comp.left_id", "decidable_eq_of_bool_pred", "nat.shiftl_add", "array.read_eq_read'", "exists_eq_right'", "proof_irrel", "tactic.alias.alias_iff", "div_lt_div_of_pos_of_lt_of_pos", "seq_map_assoc", "nat.test_bit_zero", "neg_ne_zero", "bool.ff_ne_tt", "nat.mod_add_div", "le_antisymm_iff", "sum.lex_inr_inl", "eq_of_mul_eq_mul_left", "field", "max_add_add_right", "int.exists_eq_neg_of_nat", "eq.decidable", "norm_num.neg_mul_neg_helper", "reader_t.run_bind", "one_div_one_div", "abs_abs", "prod.ext_iff", "list.nil_bind", "comp.applicative_comp_id", "punit_eq", "list.mem_cons_of_mem", "eq_sub_iff_add_eq", "div_add_div_same", "sub_self_div_two", "d_array.of_beq_eq_tt", "mul_inv_eq_of_eq_mul", "abs_pos_of_pos", "punit_eq_punit", "except_t.is_lawful_monad", "nat.mod_eq_sub_mod", "except_t.run_bind", "mul_div_cancel'", "nat.mul_div_cancel_left", "heq_of_eq_rec_right", "inv_inv", "nat.test_bit_land", "name.lt", "dvd_neg_of_dvd", "eq_of_abs_sub_eq_zero", "nonpos_of_neg_nonneg", "dvd_of_mul_left_eq", "ordered_ring.mul_le_mul_of_nonneg_left", "neg_add_lt_left_of_lt_add", "option.lift_or_get_is_right_id", "bxor_ff", "mul_div_mul_right", "two_pos", "function.is_partial_inv_left", "eq_zero_of_mul_eq_self_left", "d_array.ext'", "bool.bor_inr", "char.quote_core", "if_true_left_eq_or", "nat.dvd_of_mul_dvd_mul_left", "native.float.decidable_le", "div_one", "int.nat_abs_of_nonneg", "classical.eq_true_or_eq_false", "iff_eq_of_eq_true_right", "eq_sub_of_add_eq'", "incorrect_type_class_argument", "reader_t.run_monad_map", "tactic.interactive.clean", "sub_pos_of_lt", "int.nat_abs_one", "psigma.lex_accessible", "inv_eq_of_mul_eq_one", "bool.bnot_true", "int.mul_nonneg", "one_div_le_one_div_of_le", "int.to_nat_sub", "nat.div2_succ", "int.le.elim", "rsimp.rsimplify", "int.of_nat_one", "d_array.ext", "mul_self_eq_mul_self_iff", "nat.bit1_ne_zero", "function.injective_of_left_inverse", "nat.min_zero", "int.neg_succ_of_nat_inj", "dist_bdd_within_interval", "pos_of_neg_neg", "to_bool_congr", "imp_eq_of_eq_true_right", "eq_inv_of_mul_eq_one", "prod.swap_prod_mk", "ordered_cancel_comm_monoid", "fin.decidable_eq", "int.nat_abs_of_neg_succ_of_nat", "int.of_nat_add", "add_halves", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "list.map_singleton", "add_right_inj", "expr.is_not", "neg_div_neg_eq", "distrib_three_right", "mul_div_cancel", "eq_of_div_eq_one", "inv_mul_cancel", "where.is_variable_name", "cmp_using_eq_eq", "neg_neg", "div_nonneg_of_nonneg_of_pos", "sub_nonpos_of_le", "lt_add_of_pos_right", "nat.zero_shiftl", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "mul_nonpos_of_nonneg_of_nonpos", "cond_a_a", "ff_bxor", "pure_id'_seq", "fish_assoc", "list.length_map\u2082", "eq_add_of_neg_add_eq", "eq.congr_right", "sub_sub_sub_cancel_right", "nat.le_of_add_le_add_left", "int.sign_of_succ", "fish_pure", "buffer.mem", "norm_num.pos_add_neg_helper", "quot.sound", "division_ring.eq_of_one_div_eq_one_div", "decidable_linear_ordered_comm_ring", "quot.lift_indep_pr1", "eq_neg_of_add_eq_zero", "division_ring.inv_inv", "nat.div_self", "sub_le_self", "list.length_map_accumr\u2082", "div_mul_eq_mul_div_comm", "neg_div", "lt_of_sub_neg", "to_bool_tt", "bool.band_assoc", "id.pure_eq", "nat.div_mul_le_self", "div_div_div_div_eq", "int.eq_one_of_mul_eq_self_right", "eq_of_one_div_eq_one_div", "prod.lex_def", "bool.bxor_left_comm", "function.uncurry'_bicompr", "right_cancel_semigroup", "norm_num.bit1_add_bit1_helper", "lt_of_le_of_ne'", "list.index_of", "bool.band_left_comm", "option.mem_def", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "nat.bit1_ne_one", "lt_or_eq_of_le", "list.pairwise_cons", "nat.shiftl_zero", "instance_priority", "expr.expr.lt_prop", "int.of_nat_succ", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "decidable_of_decidable_of_eq", "prod.map_def", "int.le.intro_sub", "div_neg_eq_neg_div", "nat.sub_eq_zero_iff_le", "eq_of_eqv_lt", "le_of_sub_nonneg", "nat.pow_zero", "heq_iff_eq", "int.sign_eq_neg_one_of_neg", "classical.iff_iff_not_or_and_or_not", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "mul_left_inv", "d_array.of_beq_eq_ff", "neg_lt_sub_left_of_lt_add", "bool.bor_left_comm", "eq_rec_heq", "div_sub_div_same", "min_self", "eq_one_div_of_mul_eq_one_left", "ne.elim", "norm_num.mul_zero", "norm_num.mk_cong", "mul_left_cancel_iff", "eq_one_div_of_mul_eq_one", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "min_eq_right", "mul_sub_left_distrib", "sub_eq_add_neg", "left_cancel_semigroup", "nat.mul_comm", "int.lt.dest", "one_div_add_one_div", "nat.gcd_rec", "int.neg_of_nat_of_succ", "tactic.interactive.field", "push_neg.not_exists_eq", "bool.bxor_bnot_right", "applicative_transformation.preserves_pure", "norm_num.neg_add_neg_helper", "is_lawful_monad", "fin.div_def", "psigma.eq", "cast_heq", "nat.eq_of_mul_eq_mul_left", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.ball_cons", "sub_left_inj", "abs_sub", "list.map_map", "one_div_le_one_div_of_le_of_neg", "norm_num.one_add_bit1_helper", "and.right_comm", "nat.pred_inj", "classical.epsilon_singleton", "bool.to_bool_or", "is_right_null", "push_neg.not_or_eq", "set.is_lawful_functor", "well_founded.fix_eq", "reader_t.ext", "int.decidable_eq", "plift.down_up", "expr.is_eta_expansion_test", "sum.inr_ne_inl", "nat.div2_two", "neg_add'", "mul_nonneg", "eq_or_lt_of_le", "list.qsort_nil", "guard_false", "if_eq_of_eq", "nat.bit1_succ_eq", "neg_mul_eq_mul_neg", "band_ff", "min_eq_right_of_lt", "semigroup", "sum.decidable_eq", "empty.subsingleton", "norm_num.mul_bit1", "dlist.to_list_of_list", "eq_of_forall_le_iff", "functor.comp.id_map", "push_neg.not_not_eq", "mul_mul_div", "int.of_nat_eq_of_nat_iff", "tactic.interactive.list_cast_of_aux", "sub_add_eq_sub_sub", "int.sign_eq_one_of_pos", "neg_mul_neg", "sub_eq_zero_iff_eq", "norm_num.bin_add_zero", "function.injective_id", "int.mul_comm", "sigma.eq", "nat.sub_one", "where.format_variable", "array.ext", "tactic.interactive.h_generalize", "interactive.param_desc", "forall_eq'", "eq_false_of_or_eq_false_left", "nat.bit1_ne", "nat.add_left_comm", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "nat.zero_pow", "norm_num.div_helper", "eq_neg_add_iff_add_eq", "linear_ordered_field", "norm_num.add1_one", "conv.congr", "lt_add_of_sub_left_lt", "d_array.read_write_of_ne", "field.div_div_eq_div_mul", "tactic.suggest", "abs_abs_sub_abs_le_abs_sub", "mul_zero", "sub_eq_neg_add", "function.inv_fun_comp", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "option.eq_none_of_is_none", "mul_inv_cancel_right", "ite_eq_tt_distrib", "nat.one_mul", "ff_band", "decidable_eq_inr_neg", "nat.succ_sub_one", "option.lift_or_get_assoc", "saturate_fun", "tactic.rotate_right", "eq_false", "dangerous_instance", "option_t.is_lawful_monad", "div_le_of_le_mul", "sub_right_inj", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "function.partial_inv_of_injective", "nat.mod_def", "max_left_comm", "set.insert", "right_cancelative", "nat.bit0_ne_zero", "nonneg_of_neg_nonpos", "option.iget_some", "nat.add_sub_of_le", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "expr.list_names_with_prefix", "lt_neg_add_of_add_lt", "fin.val_zero", "exists_eq_left'", "add_left_comm", "eq_zero_of_one_div_eq_zero", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "native.float.decidable_lt", "if_eq_of_eq_true", "norm_num.bit0_add_one", "mul_left_inj", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "eq_max", "sub_add_sub_cancel'", "norm_num.div_eq_div_helper", "int.le_nat_abs", "sub_add", "tactic.find_private_decl", "comp.seq_pure", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "cast_eq", "nat.decidable_dvd", "neg_nonneg_of_nonpos", "exists_eq'", "list.length_repeat", "sub_eq_iff_eq_add'", "add_monoid", "function.left_inverse.comp", "classical.em", "nat.add_le_to_le_sub", "int.le_of_lt", "max_eq_right_of_lt", "and.congr_right_iff", "eq_sub_iff_add_eq'", "bool.bor_comm", "add_left_cancel", "list.length_remove_nth", "ring.zero_mul", "ordered_ring.mul_lt_mul_of_pos_left", "tactic.replacer_attr", "is_right_distrib", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "nat.zero_add", "min_le_left", "ordered_comm_group.le_of_add_le_add_left", "norm_num.mul_div_helper", "dvd_of_dvd_neg", "tactic.interactive.suggest", "classical.type_decidable_eq", "nat.bit0_ne", "div_neg_of_neg_of_pos", "eq.trans", "nat.sub_add_cancel", "implies_of_if_neg", "option_t.run_monad_lift", "neg_eq_of_add_eq_zero", "state_t.is_lawful_monad", "not_eq_of_eq_true", "nat.dvd_add_iff_left", "eq_mul_of_mul_inv_eq", "eq.to_iff", "function.right_inverse_of_injective_of_left_inverse", "is_left_distrib", "sub_self", "div_mul_div", "function.cantor_injective", "nat.pred_succ", "or_eq_of_eq_true_left", "add_right_cancel_iff", "nat.bit1_lt_bit0", "congr", "ordered_ring", "mul_self_eq_one_iff", "nat.mul_mod_mul_right", "div_add_div", "eq_mpr_heq", "pos_and_pos_or_neg_and_neg_of_mul_pos", "seq_eq_bind_map", "bool.bxor_bnot_left", "le_of_sub_nonpos", "coe_bool_to_Prop", "trichotomous", "nat.gcd_self", "function.funext_iff", "nat.shiftl'_tt_eq_mul_pow", "function.left_id", "int.eq_zero_of_nat_abs_eq_zero", "nat.div_zero", "heq_of_heq_of_eq", "tactic.get_user_simp_lemmas", "quotient.lift\u2082", "functor.ext", "div_two_lt_of_pos", "list.le_eq_not_gt", "derive_struct_ext_lemma", "bnot_bnot", "int.coe_nat_mul", "dvd_zero", "quot.indep_coherent", "inv_eq_one_div", "coe_coe", "add_eq_of_eq_neg_add", "inv_mul_eq_iff_eq_mul", "neg_zero", "division_ring.one_div_neg_eq_neg_one_div", "le_add_of_nonneg_left", "int.zero_ne_one", "function.left_inverse", "heq_of_eq", "nat.min_succ_succ", "ordering.compares.eq_eq", "nat.gcd_def", "max_neg_neg", "band_tt", "decidable_linear_ordered_comm_group", "norm_num.one_add_bit0", "int.nat_abs_abs", "nat.cond_to_bool_mod_two", "le_of_add_le_add_right", "function.involutive_iff_iter_2_eq_id", "is_trichotomous", "nat.div_div_eq_div_mul", "coe_sort_ff", "nat.mul_sub_div", "expr.is_and", "abs_mul_self", "has_inhabited_instance", "state_t.run_pure", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "pempty.decidable_eq", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "nat.zero_lt_bit0", "eq_neg_of_eq_neg", "one_lt_one_div", "tactic.success_if_fail_with_msg", "norm_num.add1_bit0", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "sum.inr.inj_iff", "le_neg_add_of_add_le", "le_max_right", "tactic.apply_opt_param", "nat.div2_one", "expr.of_nat", "bor_eq_true_eq_eq_tt_or_eq_tt", "eq_div_iff_mul_eq", "add_group.add_left_cancel", "eq_of_add_eq_add_left", "is_lawful_applicative", "nat.div_one", "dvd_of_mul_right_eq", "tt_bxor", "max_eq_left_of_lt", "neg_neg_of_pos", "sub_nonneg_of_le", "dlist", "ordering.ite_eq_lt_distrib", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "nat.succ_pred_eq_of_pos", "nat.mod_eq_zero_of_dvd", "add_sub_assoc", "bool.not_ff", "nat.dvd_antisymm", "comp.seq_assoc", "add_neg_eq_zero", "list.cons_bind", "well_founded_tactics.check_target_is_value_lt", "int.nat_abs_zero", "group.mul_right_cancel", "nat.add_assoc", "band_eq_false_eq_eq_ff_or_eq_ff", "one_div_le_neg_one", "nat.add_sub_add_left", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "inv_mul_cancel_right", "nat.mul_div_cancel", "nat.pow_one", "map_map", "nat.eq_zero_of_add_eq_zero_right", "lt_sub_left_of_add_lt", "bool.bxor_assoc", "add_semigroup", "neg_le_of_neg_le", "list.eq_nil_of_length_eq_zero", "left_comm", "nat.le_antisymm", "ulift.ext", "function.update_comp", "dlist.to_list_singleton", "exists_unique_congr", "nat.bodd_two", "mul_le_mul_of_nonpos_right", "mul_add", "forall_or_distrib_right", "plift.up_down"]}, {"id": "eq_of_heq", "parentIds": ["heq.elim", "of_heq_true", "prod.mk.inj_iff", "function.hfunext", "applicative.ext", "psigma.lex_accessible", "heq_iff_eq"]}, {"id": "format.paren", "parentIds": ["interactive.param_desc"]}, {"id": "id_rhs", "parentIds": ["format.paren", "expr.is_sort", "prod.has_to_tactic_format", "tactic.interactive.record_lit", "tactic.eval_expr'", "tactic.unsafe_change", "reflected.has_to_tactic_format", "function.bijective_comp", "lean.parser.sep_by", "smt_tactic.interactive.assume", "native.rb_map.scale", "tactic.find_if_cond_at", "has_sizeof_derive_handler", "name_set.to_list", "tactic.interactive.constructor", "format.join", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "not_imp_of_and_not", "tactic.replace_at", "name.has_to_format", "tactic.library_search_hole_cmd", "module_info.has_repr", "tactic.trace", "environment.is_prefix_of_file", "conv.execute", "expr.local_pp_name", "declaration.is_theorem", "tactic.mk_const", "where.where_cmd", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.interactive.format_names", "le_iff_lt_or_eq", "tactic.instance_cache.get", "tactic_state.has_to_string", "get_localized", "heq_of_eq_rec_left", "smt_tactic.solve1", "int.add_comm", "tactic.cc_dbg_core", "tactic.delta", "interactive.types.ident_", "if_t_t", "tactic.interactive.skip", "list.not_bex_nil", "tactic.i_to_expr_strict", "tactic.focus1", "int.le.dest", "array.has_to_format", "print_content", "tactic.rintro_hint", "is_strict_weak_order_of_is_total_preorder", "old_conv", "tactic.interactive.with_cases", "tactic.revertible_local_context", "tactic.apply_iff", "comp.run_pure", "file_name", "infer_type_cmd", "native.rb_set", "and_imp", "smt_tactic.failed", "tactic.interactive.rsimp", "linter.incorrect_type_class_argument", "option_to_tactic_format", "function.surjective.of_comp", "tactic.get_expl_arity", "expr.is_arrow", "tactic.mk_constructor_arg_names", "lean.parser.get_variables", "tactic.admit", "print_decls_sorted", "nat.pow_le_pow_of_le_left", "and_or_distrib_left", "lean.parser.reflectable.to_parser", "old_conv.interactive.trace_state", "tactic.copy_attribute", "nat.shiftl_eq_mul_pow", "expr.is_iff", "well_founded_tactics.clear_internals", "name_set.mfold", "param_info.to_format", "smt_tactic.interactive.by_contradiction", "nat.shiftl'_add", "expr.mk_exists_lst", "decidable_eq_inl_refl", "vm", "interactive.types.opt_pexpr_list", "native.rb_set.erase", "tactic.pp", "tactic.injections_with", "tactic.interactive.any_goals", "tactic.elide.unelide", "smt_tactic.definev", "nat.one_lt_bit0", "expr.mk_binding", "smt_tactic.interactive.ematch", "tactic.rotate", "tactic.interactive.contradiction", "tactic.interactive.refl", "nonempty_sum", "tactic.interactive.recover", "nonempty_sigma", "environment.mfold", "exists_prop", "tactic.save_const_type_info", "smt_tactic.interactive.destruct", "to_additive.target_name", "tactic.timetac", "tactic.focus", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "interaction_monad", "smt_tactic.set_goals", "lt_or_gt_of_ne", "prod.id_prod", "name_map", "tactic.interactive.trivial", "option.has_to_tactic_format", "module_info.of_module_name", "tactic.find_assumption", "where.trace_namespace", "cc_state.mk_using_hs", "smt_tactic.execute_with", "format.sbracket", "exists_ge_of_linear", "tactic.interactive.field_simp", "attribute.register", "name.has_append", "try_for", "lean.parser.reflectable.optional", "tactic.cases", "and.imp", "tactic.existsi", "expr.dedup_size", "unused_arguments", "function.uncurry_curry", "format.when", "congr_arg_kind.has_to_format", "sigma.has_to_format", "tactic.cc_core", "nonempty_empty", "bex.elim", "tactic.apply_inj_lemma", "mk_definition", "tactic.interactive.from", "tactic.mk_has_sizeof_instance_core", "native.rb_map.add", "mul_dvd_mul", "smt_tactic.trace_state", "print_arguments", "tactic.get_constructors_for", "int.add_assoc", "tactic.apply_instance", "tactic.rcases_patt_inverted.inhabited", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "expr.to_nat", "cc_state.roots", "tactic.instance_cache.append_typeclasses", "tactic.dsimplify", "prod.mk.eta", "expr.mk_or_lst", "conv.monad", "tactic.interactive.loc.get_local_pp_names", "declaration.type", "wf_tacs", "interaction_monad.orelse'", "smt_tactic.add_lemmas_from_facts", "old_conv.skip", "expr.has_to_string", "string_to_format", "where.trace_variables", "interactive.types.only_flag", "tactic.mk_brec_on_rec_value", "where.strip_namespace", "tactic.simplify_top_down", "tactic.suggest.unfold_head_symbol", "tactic.get_env", "nat.lt_or_ge", "where.mk_flag", "linter.unused_arguments", "d_array.of_beq_aux_eq_tt", "int.nat_abs_mul_self", "tactic.interactive.guard_tags", "smt_tactic.add_ematch_lhs_lemma_from_decl", "old_conv.failed", "bex_def", "function.inv_fun_eq", "tactic.rcases_hint", "nonempty_ulift", "tactic.back_chaining_using_hs", "smt_tactic.add_ematch_lemma_from_decl", "tactic.cleanup", "native.rb_set.size", "conv.interactive.itactic", "tactic.is_prop", "smt_tactic.seq", "transport_multiplicative_to_additive", "sum_has_to_format", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "nat.pred_le", "using_smt", "environment.for_decl_of_imported_module", "smt_tactic.interactive.guard_target", "tactic.explode.entries.size", "conv.interactive.conv", "conv.lhs", "tactic.interactive.focus", "tactic.match_or", "int.nat_abs_eq", "hinst_lemma.has_to_tactic_format", "to_additive.tokens_dict", "name.has_lt", "nat.bodd_add_div2", "tactic.interactive.symmetry", "task.bind", "list.length_le_of_sublist", "tactic.get_unused_decl_name", "conv.alternative", "tactic.is_in_mathlib", "tactic.get_pi_binders", "expr.local_binding_info", "expr.inhabited", "tactic.interactive.by_contra", "tactic.interactive.get_rule_eqn_lemmas", "tactic.rcases_patt.format", "conv.monad_fail", "tactic.mk_simp_attribute_cmd", "conv.interactive.skip", "tactic.interactive.by_cases", "where.sort_variable_list", "exceptional.to_bool", "tactic.interactive.cc", "tactic.interactive.min_tac", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "native.rb_lmap.find", "old_conv.execute", "expr.is_napp_of", "old_conv.trace", "exceptional.to_option", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "rbtree.default_lt", "old_conv.findp", "tactic.symm_apply", "tactic.revert_kdependencies", "tactic.interactive.unfold_coes", "name_set.of_list", "restate_axiom_cmd", "tactic.interactive.dsimp", "prod.forall", "tactic.interactive.cases_matching", "expr.is_ne", "smt_tactic.interactive.intros", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "nat.zero_le", "expr_set", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "lean.parser.emit_command_here", "tactic.symmetry_hyp", "name_set.has_to_format", "tactic.note", "opt_minus", "old_conv.dsimp", "tactic.interactive.apply_opt_param", "tactic.transport_with_prefix_fun", "mk_hinst_singleton", "tactic.interactive.apply_assumption", "option.eq_of_eq_some", "int.add_zero", "tactic.elim_gen_sum", "localized_attr", "environment.is_definition", "native.rb_map.has_to_tactic_format", "expr.local_type", "tactic.repeat1", "tactic.interactive.split_ifs", "old_conv.istep", "not_lt_of_le", "smt_tactic.trace", "lean.parser", "to_additive.proceed_fields", "native.float.has_one", "if_ctx_congr_prop", "tactic.match_app_of", "expr.to_int", "expr.list_local_consts", "tactic.interactive.clear_dependent", "push_neg.normalize_negations", "tactic.interactive.rotate", "old_conv.change", "to_additive.guess_name", "nonempty.map2", "nat.le_mul_self", "tactic.interactive.apply_iff_congr_core", "tactic.non_dep_prop_hyps", "tactic.mk_iff", "use_cmd", "tactic.interactive.rename'_args_parser", "lint_cmd", "expr.is_ge", "interaction_monad.fail", "subtype.has_to_format", "tactic.left", "congr_arg_heq", "lean.parser.val", "smt_tactic.write", "tactic.interactive.triv", "tactic.mk_simp_attr", "nat.shiftr_eq_div_pow", "name_map.inhabited", "expr.is_default_local", "tactic.assoc_refl", "array.has_to_tactic_format", "tactic.interactive.have_field", "print_decls", "declaration.to_name", "tactic.mllist.empty", "smt_tactic", "tactic.independent_goal", "tactic.mllist.head", "tactic.dsimp_hyp", "interactive.types.with_ident_list", "user_attribute.parse_reflect", "functor.comp.comp_map", "mk_name_map", "smt_tactic.swap", "smt_tactic.interactive.have", "tactic.interactive.subst_vars", "interactive.types.pexpr_list", "subsingleton_info.has_to_format", "expr.binding_domain", "tactic.match_subexpr", "native.has_to_string", "native.float.has_add", "tactic.mk_dec_eq_instance", "nat.pred_lt_pred", "tactic.rcases_patt.name", "print_localized_commands", "tactic.suggest_scripts", "tactic.generalize_proofs", "tactic.interactive.refine", "tactic_format_expr", "smt_tactic.when_tracing", "nolint_attr", "dif_pos", "pexpr", "register_attribute", "heq_of_eq_mp", "apply_nolint_cmd", "interactive.loc.try_apply", "user_attribute.dflt_parser", "tactic.interactive.right", "to_additive.parser", "old_conv.apply_propext_lemmas", "tactic.alias.alias_attr", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "name_set.union", "int.nat_abs_add_neg", "tactic.library_search", "tactic.econstructor", "not_and_self_iff", "tactic.interactive.clear_aux_decl", "tactic.unsafe.type_context.list_mvars", "lt_of_not_ge", "can_lift_attr", "tactic.add_inductive", "tactic.match_hypothesis", "tactic.terminal_goal", "tactic.to_texpr", "expr.binding_body", "tactic.mk_local'", "tactic.interactive.clear'", "int.mk_numeral", "old_conv.apply_lemmas_core", "native.rb_set.mfilter", "smt_tactic.monad_fail", "eq_of_incomp", "tactic.mk_user_fresh_name", "environment.from_imported_module_name", "simps_add_projection", "expr.binding_name", "expr.decidable_rel", "tactic.interactive.lift", "tactic.trace_macro", "expr.instantiate_locals", "if_pos", "false_ne_true", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.down", "occurrences_to_format", "add_interactive", "tactic.ext_parse", "ordering.compares.eq_lt", "expr.is_heq", "old_conv.orelse", "smt_tactic.when", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "smt_tactic.slift", "localized_cmd", "tactic.mk_eq_simp_ext", "list.length_drop", "tactic.choose1", "nonempty.map", "int.nat_abs_add_nonneg", "old_conv.to_tactic", "and.swap", "conv.update_lhs", "task.monad", "function.surjective_of_has_right_inverse", "old_conv.conversion", "tactic.extract_def", "nat.add_self_ne_one", "linter.impossible_instance", "tactic.interactive.continue", "tactic.delta_target", "smt_tactic.interactive.add_eqn_lemmas", "tactic.interactive.unfreezeI", "old_conv.apply_propext_simp_set", "interactive.with_desc", "expr.mfoldl", "conv.interactive.guard_lhs", "interactive.types.tac_rbp", "tactic.interactive.abstract", "simps_tac", "list.filter_append", "tactic.mllist.enum", "tactic.interactive.apply_field", "native.has_to_format", "interaction_monad.result_to_string", "tactic.rewrite", "tactic.interactive.let", "nat.pow_le_pow_of_le_right", "tactic.i_to_expr_for_apply", "monad_from_pure_bind", "nat.mul_assoc", "module_info.has_to_tactic_format", "ext_param", "nat.sub_induction", "tactic.tactic.has_to_tactic_format", "tactic.try_apply_opt_auto_param_for_apply", "smt_tactic.classical", "nat.zero_mul", "state_t.run_adapt", "nat.bit0_inj", "tactic.constr_to_prop", "tactic.interactive.econstructor", "tactic.rintro_parse", "tactic.local_proof", "not_and_not_right", "declaration.value_task", "if_ctx_congr", "bex.imp_right", "smt_tactic.pose", "tactic.cc", "Exists.fst", "nat.add_comm", "tactic.interactive.split", "interactive.types.without_ident_list", "tactic.match_assoc_pattern", "smt_tactic.interactive.itactic", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "expr.imp", "push_neg.whnf_reducible", "tactic.solve_aux", "list.chain_cons", "smt_tactic.add_ematch_lemma_core", "module_info.module_id", "name.add_prime", "expr.traverse", "tactic.try_for", "int.mul_one", "tactic.suggest.message", "ordering.compares.eq_gt", "ulift.up_down", "tactic.propositional_goal", "expr.is_constant_of", "tactic.match_eq", "tactic.success_if_fail", "nonempty_of_exists", "tactic.match_expr", "environment.has_repr", "nat.one_le_bit0", "mk_expr_set", "smt_state.has_append", "tactic.save_info", "expr.is_eta_expansion_of", "int.add_left_neg", "old_conv.apply_lemmas", "smt_tactic.interactive.trace", "tactic.get_goal", "expr.is_eq", "tactic.resolve_constant", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "well_founded_tactics.default_dec_tac'", "expr.has_to_format", "smt_tactic.interactive.dsimp", "declaration.update_value_task", "well_founded_tactics.default", "nat.shiftl'_sub", "tactic.apply_auto_param", "nonempty_psigma", "environment.decl_filter_map", "tactic.change_core", "tactic.interactive.congr_core'", "tactic.interactive.change'", "smt_tactic.interactive.trace_state", "lint", "expr.const_name", "interaction_monad.get_result", "exceptional.has_to_string", "local_context.lc_has_to_format", "tactic.returnopt", "tactic.interactive.letI", "old_conv.trace_lhs", "tactic.unsafe.type_context.monad_fail", "environment.in_current_file", "native.float.has_to_string", "plift.down_inj", "reflected.has_to_format", "nat.mul_le_mul_left", "lt_trans", "tactic.instance_stub", "expr.get_app_fn_args", "tactic.interactive.simp", "tactic.in_open_namespaces", "where.get_includes_core", "tactic.interactive.type_check", "lean.parser.get_includes", "environment.is_refl_app", "tactic.updateex_env", "where.trace_includes", "smt_tactic.proof_for", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "where.get_namespace_core", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.trace_result", "tactic.iff_mp_core", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.rintro", "or_imp_distrib", "tactic.interactive.success_if_fail", "format.indent", "native.rb_map.map", "setoid.trans", "conv.funext", "old_conv.match_pattern", "tactic.change_with_at", "where.strip_pi_binders", "conv.interactive.done", "tactic.match_target_subexpr", "tactic.reflexivity", "int.of_nat_sub", "tactic.constructor_idx", "nat.div_le_of_le_mul", "tactic.constructor_num_fields", "tactic.clear_aux_decl", "exists_or_distrib", "declaration.is_definition", "lt_of_incomp_of_lt", "tactic.intro1", "interaction_monad_return", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "lean.parser_result", "tactic.interactive.rw_rule_p", "old_conv.funext", "fin.eq_of_veq", "tactic.interactive.refine_struct", "tactic.interactive.elide", "int.of_nat_nat_abs_eq_of_nonneg", "tactic.interactive.repeat", "cc_state.eqc_size", "fun_info.has_to_format", "tactic.interactive.rec.to_tactic_format", "tactic.has_attribute'", "tactic.is_type_app_of", "user_attribute.dflt_cache_cfg", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "format.inhabited", "smt_tactic.add_ematch_lhs_lemma", "tactic.interactive.obtain_parse", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "int.distrib_left", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "reflected_value.subst", "tactic.abstract", "tactic.interactive.iterate", "function.uncurry_bicompr", "tactic.interactive.rintros", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.whnf_no_delta", "prod.swap_swap", "tactic.interactive.try_for", "conv.dsimp", "level.has_to_format", "linter.dup_namespace", "tactic.successes", "tactic.interactive.simp_core_aux", "tactic.get_simp_lemmas_or_default", "tactic.right", "nat.mk_numeral", "tactic.fail_if_success", "buffer.has_to_tactic_format", "prod.map_fst", "nat.zero_sub", "tactic.def_replacer_cmd", "tactic.trace_error", "tactic.mk_patterns", "nat.eq_zero_of_mul_eq_zero", "lint_all_cmd", "cc_state.eqc_of", "tactic.generalizes", "tactic.istep", "conv.interactive.trace_lhs", "tactic.interactive.clear", "smt_tactic.focus1", "tactic.interactive.injection", "expr.is_gt", "conv.whnf", "expr.is_false", "expr.is_pi", "smt_tactic.alternative", "tactic.interactive.exact", "print_decls_sorted_mathlib", "doc_blame_report_defn", "smt_tactic.get_facts", "pos_line", "tactic.fapply", "tactic.assert", "tactic.rewrite_hyp", "declaration.to_definition", "local_context.to_list", "tactic.transport_with_prefix_dict", "lean.parser.get_namespace", "string.str_ne_str_right", "tactic.match_heq", "tactic.interactive.suffices", "declaration.update_name", "tactic.skip", "nat.sub_self", "loc.to_string_aux", "char.has_to_format", "options.has_to_format", "int.lt_iff_le_and_ne", "to_additive.map_namespace", "format.has_to_format", "smt_tactic.ematch", "expr.is_mvar", "nat.add_left_cancel", "smt_tactic.interactive.eblast", "print_all_content", "tactic.get_string_option", "tactic.explode.may_be_proof", "tactic.mllist.squash", "conv.interactive.rw", "interaction_monad_seq", "tactic.rcases_parse_depth", "function.injective_prod", "smt_tactic.has_andthen", "tactic.case_bash", "native.rb_set.fold", "declaration.in_current_file", "interactive.executor.execute_with_explicit", "tactic.by_cases", "smt_tactic.to_expr", "native.rb_set.contains", "char.veq_of_eq", "show_goal_cmd", "tactic.interactive.library_search", "tactic.add_theorem_by", "tactic.when_tracing", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "list.qsort_cons", "where.resolve_vars", "tactic.decorate_ex", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.interactive.rename", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "exceptional.return", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "classical.skolem", "nat.add_sub_add_right", "smt_tactic.add_ematch_eqn_lemmas_for", "conv.solve1", "name_set.mfilter", "tactic.mk_has_sizeof_instance", "name_set.insert_list", "smt_tactic.interactive.let", "conv.skip", "expr.reduce_let", "smt_tactic.interactive.try", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "well_founded_tactics.cancel_nat_add_lt", "interaction_monad.mk_exception", "nat.bit1_ne_bit0", "native.rb_lmap.contains", "bool.forall_bool", "option.eq_some_of_is_some", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "tactic.mk_theorem", "old_conv.interactive.find", "tactic.interactive.simp_rw", "list.has_to_format", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.interactive.all_goals", "old_conv.interactive.whnf", "tactic.ac_refl", "where.trace_opens", "tactic.rcases_patt.has_to_format", "fin.veq_of_eq", "tactic.set_main_tag", "tactic.to_expr_strict", "interactive.types.pexpr_list_or_texpr", "decidable.has_to_format", "name.is_private", "tactic.apply_heq_congr_core", "expr.is_lambda", "tactic.mk_constructors_arg_names", "tactic.explode.entries.head", "tactic.lock_tactic_state", "nat.shiftr_add", "eq_rec_compose", "old_conv.lhs", "tactic.read", "smt_tactic.interactive.iterate", "format.has_append", "list.length_take", "smt_tactic.all_goals", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "tactic.match_not", "smt_state", "smt_tactic.interactive.add_lemma", "le_not_le_of_lt", "conv.interactive.change", "string.empty_ne_str", "expr.mk_true", "option.map_id", "tactic.interactive.exactI", "tactic.opt_to_tac", "tactic.enum_assoc_subexpr", "reflected.has_to_pexpr", "well_founded_tactics.is_psigma_mk", "expr.list_meta_vars", "name_set.inhabited", "interactive.types.texpr", "environment.structure_fields_full", "name.deinternalize_field", "smt_tactic.define", "find_cmd", "declaration.map_value", "tactic.interactive.substs", "nat.dvd_add_iff_right", "tactic.mllist.range", "tactic.cc_dbg", "tactic.mk_local_pis_whnf", "declaration.update_value", "Exists.snd", "smt_tactic.slift_aux", "int.eq_neg_succ_of_lt_zero", "tactic.try_core", "tactic.interactive.assume", "tactic.explode.entries.find", "tactic.any_hyp", "control_laws_tac", "expr.mk_var", "binder.has_to_string", "tactic.decl_mk_const", "tactic.interactive.assumption'", "smt_tactic.add_ematch_lemma", "native.rb_set.mfold", "occurrences.has_to_format", "tactic.iterate1", "nonempty_Prop", "tactic.back_chaining", "exists_eq_left", "tactic.apply_under_pis", "d_array.of_beq_aux_eq_ff", "tactic.interactive.haveI", "library_note_attr", "eq_zero_of_neg_eq", "native.rb_map.values", "smt_tactic.get_refuted_facts", "expr.is_var", "tactic.write", "smt_tactic.save_info", "tactic.mllist.concat", "dif_ctx_congr", "tactic.match_ne", "rsimp.rsimplify_at", "declaration.is_axiom", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.dunfold_target", "smt_tactic.assertv", "environment.get_decl_names", "int.nat_abs_bit0", "native.float.of_int_coe", "tactic.suggest.apply_and_solve", "tactic.mk_local", "int.abs_eq_nat_abs", "tactic.mk_mvar", "nat.case_strong_induction_on", "expr.is_or", "old_conv.alternative", "tactic.unsafe.type_context.monad", "exceptional.to_string", "hinst_lemma.mk_from_decl", "int.mul_zero", "tactic.revert_and_transform", "forall_and_distrib", "tactic.apply_eq_congr_core", "name_with_opt", "expr.replace_with", "tactic.trace_state", "tactic.suggest_core", "declaration.value", "exceptional.fail", "tactic.local_def_value", "ordering.swap_swap", "tactic.use", "native.rb_map.for", "tactic.comp_val", "well_founded_tactics.unfold_sizeof", "tactic.interactive.loc.get_local_uniq_names", "mnot", "interaction_monad.monad", "le_of_not_gt", "old_conv.congr_core", "where.get_opens", "tactic.symmetry", "native.rb_map.keys", "smt_tactic.fail", "tactic.unsafe.type_context.print_mvars", "native.rb_set.has_to_format", "apply_nolint_tac", "tactic.interactive.obtain", "smt_tactic.try", "exists_false", "tactic.interactive.itactic", "expr.is_eta_expansion_aux", "subsingleton_info_to_format", "where.trace_end", "environment.contains", "nat.succ_add", "tactic.fold_explicit_args", "expr.of_int", "tactic.simplify_bottom_up", "reflected", "le_of_lt_or_eq", "tactic.interactive.guard_hyp", "linter.ge_or_gt", "and_congr_right", "function.inv_fun_neg", "tactic.pformat", "tactic.match_target", "tactic.interactive.resetI", "tactic.interactive.reflexivity", "tactic.apply", "linter.has_inhabited_instance", "nat.le_add_right", "tactic.contradiction", "tactic.get_main_tag", "check_unused_arguments", "dvd_trans", "old_conv.apply_propext_lemmas_core", "expr.mfold", "ex_of_psig", "lean.parser.has_coe'", "not_or", "int.eq_succ_of_zero_lt", "tactic.interactive.erw", "tactic.interactive.generalize", "tactic.interactive.use", "native.rb_map.mfilter", "tactic.rcases_patt_parse", "tactic.mk_has_reflect_instance", "tactic.try", "le_of_lt", "tactic.rcases_patt.inhabited", "tactic.iterate'", "environment.get_trusted_decls", "environment.is_ginductive'", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "to_bool_iff", "declaration.is_constant", "tactic.is_instance", "lt_or_ge", "smt_tactic.execute", "expr.pi_arity", "native.float.has_zero", "tactic.interactive.transitivity", "tactic.interactive.success_if_fail_with_msg", "tactic.split_ifs", "native.rb_set.union", "expr.app_fn", "tactic.ancestor_attr", "tactic.set_nat_option", "tactic.simp_intros", "linter.doc_blame_thm", "unchecked_cast", "tactic.match_and", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "derive_handler", "name.lt.decidable_rel", "tactic.interactive.eapply", "interactive.loc.include_goal", "conv.interactive.find", "tactic.interactive.rename'_arg_parser", "expr.mk_and_lst", "binder.to_string", "prod.has_to_format", "tactic.interactive.to_expr'", "native.float.has_div", "smt_tactic.monad_state", "not_forall_of_exists_not", "rsimp.to_repr_map", "nat.lt_iff_le_not_le", "smt_tactic.note", "tactic.step", "conv.interactive.whnf", "tactic.interactive.ext", "tactic.alias.alias_direct", "smt_tactic.istep", "tactic.interactive.unelide", "interactive.interactive.executor", "native.rb_map.inhabited", "tactic.solve_by_elim", "native.rb_map.mfold", "conv", "lint_hole_cmd", "native.rb_map.zfind", "lt_irrefl", "expr.has_to_tactic_format", "expr.is_le", "tactic.interactive.show", "tactic.ematch_all", "rsimp.collect_implied_eqs", "tactic.interactive.admit", "tactic.relation_lhs_rhs", "tactic.interactive.assoc_rw", "tactic.interactive.simp_intros", "tactic.dunfold_hyp", "tactic.pformat_macro", "tactic.interactive.erewrite", "list.bex_cons", "tactic.apply_congr_core", "expr.is_let", "format_macro", "where.get_variables_core", "int.mul_assoc", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "list.length_map_accumr", "tactic.no_mvars_in_target", "option.has_to_format", "tactic.explode.pad_right", "nat.le.dest", "tactic.iff_mpr", "tactic.retrieve", "tactic.join_user_simp_lemmas", "tactic.interactive.guard_target'", "tactic.explode_expr", "tactic.unfold_projs", "options.has_add", "cc_state.in_singlenton_eqc", "copy_decl_using", "tactic.iff_mpr_core", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "fold_over_with_cond", "tactic.define", "user_attribute.set", "prod.map_snd", "interactive.parse_binders", "expr.has_coe", "tactic.goals", "tactic.by_contradiction", "expr.has_local_constant", "nonempty_subtype", "tactic.interactive.replace", "tactic.interactive.find", "reflected_value.expr", "dif_eq_if", "tactic.interactive.subst", "int.eq_nat_abs_of_zero_le", "tactic.get_arity", "nat.bit0_ne_one", "tactic.interactive.clear_", "expr.get_app_args", "tactic.interactive.return_cast", "exists_and_distrib_left", "tactic.explode.has_to_tactic_format", "cc_state.mfold_eqc", "conv.replace_lhs", "interaction_monad.failed", "tactic.match_iff", "nat.div_le_self", "expr.has_to_pexpr", "rsimp.repr_map", "tactic.mllist.monad_lift", "vm.trace", "bool.exists_bool", "bool.has_to_format", "tactic.set_string_option", "old_conv.monad", "environment.is_structure", "tactic.rcases_patt_inverted.has_to_format", "tactic.constructor", "smt_tactic.assert", "tactic.match_refl_app", "native.rb_map.mmap", "nat.pred_lt", "tactic.binder_info.has_decidable_eq", "has_reflect", "function.uncurry_def", "tactic.suggest.process_declaration", "fun_info_to_format", "tactic.interactive.auto_simp_lemma", "tactic.assertv", "tactic.revert_kdeps", "subtype.eq", "tactic.andthen_seq_focus", "tactic.instantiate_mvars_in_goals", "tactic.get_pi_arity", "tactic.rcases", "expr.is_bin_arith_app", "tactic.fsplit", "nat.left_distrib", "not_and_of_not_or_not", "native.float.has_neg", "tactic.interactive.constructor_matching", "tactic.assoc_rewrite", "expr.simp", "open_locale_cmd", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "int.coe_nat_le_coe_nat_of_le", "strict_weak_order.esymm", "list.to_format", "lean.parser.reflectable.has_reflect", "tactic.interactive.conv", "expr.dsimp", "tactic.reset_instance_cache", "lean.parser.has_coe", "tactic.interactive.guard_expr_strict", "simps_parser", "smt_tactic.has_monad_lift", "get_linters", "eq_iff_le_not_lt", "declaration.update_with_fun", "int.sign_mul_nat_abs", "tactic.iterate", "classical.indefinite_description", "list.filter_sublist", "smt_tactic.get_goals", "tactic.interactive.trace_state", "tactic.subsingleton_goal", "tactic.revert", "native.float.has_le", "nat.right_distrib", "level.dedup_size", "expr.mk_false", "expr.is_aux_decl", "exceptional.monad", "tactic.ematch", "tactic.interactive.intro", "tactic.injection_with", "tactic.interactive.convert_to", "level.has_to_string", "applicative.ext", "expr.is_local_constant", "old_conv.apply_simp_set", "tactic.save_options", "smt_tactic.interactive.apply", "lt_of_le_not_le", "tactic.interactive.funext", "smt_tactic.interactive.close", "get_attribute_cache_dyn", "tactic.interactive.assoc_rewrite", "tactic.subst_vars", "int.pos_of_sign_eq_one", "tactic.fconstructor", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "tactic.rename", "tactic.interactive.change", "tactic.collect_ctx_simps", "tactic.simp_bottom_up'", "expr.app_arg", "native.float.mantissa", "reflected.subst", "tactic.match_stub", "nat.sub_sub", "tactic.mk_constructor_fresh_names", "interaction_monad_fmap", "bex.imp_left", "tactic.delta_hyp", "buffer.has_to_format", "where.is_in_namespace_nonsynthetic", "tactic.interactive.trace", "setoid.symm", "tactic.interactive.has_to_tactic_format", "tactic.i_to_expr_no_subgoals", "list_linters", "lint_aux", "nat.mul_sub_right_distrib", "native.rb_lmap.insert", "get_hinst_lemmas_for_attr", "declaration.is_auto_generated", "tactic.interactive.list_cast_of", "tactic.get_decl", "tactic.interactive.simp_core", "nat.add_le_add_left", "well_founded_tactics.unfold_wf_rel", "nat.le_of_sub_eq_zero", "declaration.univ_levels", "cc_state.has_to_tactic_format", "vm_core.monad", "string.str_ne_str_left", "where.binder_priority", "nat.succ_ne_self", "lean.parser.reflectable.cast", "char.eq_of_veq", "int.neg_succ_lt_zero", "tactic.def_replacer", "tactic.injection", "int.neg_of_sign_eq_neg_one", "tactic.interactive.conv_rhs", "conv.interactive.erw", "tactic.interactive.done", "dif_neg", "interaction_monad_orelse", "smt_tactic.iterate", "if_neg", "lean.parser.reflectable.expr", "tactic.interactive.match_target", "nat.mul_self_lt_mul_self", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "sum.exists", "tactic.whnf_ginductive", "expr.has_lt", "tactic.interactive.async", "debugger.attr", "monad_except.orelse'", "smt_tactic.eblast", "tactic.back_chaining_using", "tactic.simp_hyp", "function.cantor_surjective", "binder.has_to_format", "format.cbrace", "derive_handler_attr", "tactic.back_lemmas_insert", "unsigned.has_to_format", "linter.doc_blame", "tactic.mllist.mfirst", "tactic.get_options", "smt_tactic.interactive.eblast_using", "native.rb_lmap.erase", "expr.is_app", "tactic.repeat", "conv.change", "trace_val", "tactic.using_texpr", "hinst_lemmas.has_to_tactic_format", "declaration.get_kind_string", "tactic.solve1", "native.float.has_repr", "tactic.unsafe.type_context.orelse", "smt_tactic.monad", "classical.nonempty_pi", "loc.to_string", "tactic.alias.alias_iff", "tactic.ex_to_tac", "conv.interactive.for", "tactic.andthen_seq", "le_antisymm_iff", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "tactic.unsafe.type_context.trace", "int.exists_eq_neg_of_nat", "tactic.mk_local_def", "list.has_to_tactic_format", "tactic.interactive.mapply", "tactic.interactive.specialize", "smt_tactic.read", "get_name_set_for_attr", "tactic.interactive.refine_one", "my_name_to_string", "decidable.not_and_iff_or_not", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "lean.parser.alternative", "native.float.has_mul", "tactic.interactive.apply_with", "tactic.interactive.left", "where.binder_less_important", "expr.to_binder", "nat.two_step_induction", "tactic.interactive.exfalso", "old_conv.whnf", "environment.for_decl_of_imported_module_name", "tactic.pose", "tactic.funext", "heq_of_eq_rec_right", "nat.has_to_format", "name.lt", "tactic.interactive.fapply", "tactic.swap", "tactic.get_nat_option", "tactic.interactive.apply_auto_param", "sum.forall", "expr.bind_lambda", "old_conv.find", "tactic.split", "name.pop_nth_prefix", "tactic.interactive.try", "name_set.mmap", "lean.parser.itactic", "fold_over_with_cond_sorted", "decidable.not_or_iff_and_not", "tactic.instantiate_mvars_in_target", "conv.interactive.rewrite", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.returnex", "tactic.dsimp_target", "where.trace_where", "native.float.decidable_le", "tactic.interactive.casesm", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "int.nat_abs_of_nonneg", "interaction_monad.result.clamp_pos", "native.rb_set.inhabited", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "expr.is_eta_expansion", "tactic.unfold_projs_target", "native.mk_rb_set", "tactic.apply_rules", "options.inhabited", "tactic.simp_all", "native.nat_map", "native.float.has_float_pow", "environment.inhabited", "tactic.rexact", "bex_of_exists", "rsimp.rsimplify", "tactic.up", "classical.exists_true_of_nonempty", "and_not_self", "lean.parser.parser_orelse", "tactic.intro1_aux", "simp_lemmas.append", "expr.has_coe_to_fun", "expr.is_constant", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "tactic.rsimp", "environment.in_current_file'", "conv.interactive.simp", "pexpr.has_to_pexpr", "tactic.iff_mp", "conv.interactive.congr", "name_set.filter", "smt_tactic.step", "tactic.interactive.guard_expr_eq'", "conv.step", "expr.is_not", "expr.ith_arg", "nonempty_plift", "interactive.single_inductive_decl.name", "tactic.mk_constructors_fresh_names", "punit.reflect", "tactic.alias.get_alias_target", "where.is_variable_name", "lean.parser.reflect", "native.rb_lmap.inhabited", "tactic.add_meta_definition", "nat.succ_mul", "tactic.get_ancestors", "list_items", "tactic.assumption", "tactic.is_proof", "expr.to_implicit_local_const", "to_fmt", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "nat.le_of_add_le_add_left", "lean.parser.cur_pos", "tactic.interactive.apply_instance", "tactic.interactive.rw_rules", "expr.instantiate_local", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "exists_swap", "tactic.replace_target", "nat.sub_le_sub_right", "to_pexpr", "smt_tactic.interactive.by_contra", "smt_tactic.by_contradiction", "tactic.trace_call_stack", "nat_to_format", "list.length_map_accumr\u2082", "tactic.mk_replacer", "tactic.interactive.guard_target", "old_conv.bottom_up", "reflect", "nat.div_mul_le_self", "tactic.rsimp_at", "prod.lex_def", "push_neg.push_neg_at_hyp", "sformat_macro", "format.bracket", "tactic.suggest.replace_mvars", "environment.get_decls", "nat.bit1_ne_one", "lt_or_eq_of_le", "list.pairwise_cons", "instance_priority", "expr.expr.lt_prop", "tactic.interactive.introI", "native.rb_set.insert", "and.assoc", "lt_iff_le_and_ne", "tactic.interactive.dunfold", "tactic.interactive.rw", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "tactic.mk_back_lemmas", "instance_derive_handler", "smt_tactic.interactive.from", "tactic.interactive.mk_paragraph", "tactic.inhabited_instance", "int.sign_eq_neg_one_of_neg", "interaction_monad.result_has_string", "library_note", "tactic.simp_arg_list", "nat.le_of_dvd", "smt_tactic.interactive.rsimp", "declaration.is_trusted", "exists_true_iff_nonempty", "expr.is_app_of", "eq_rec_heq", "tactic.interactive.extract_goal", "tactic.setup_tactic_parser_cmd", "tactic.pformat.has_to_tactic_format", "tactic.alternative", "native.float.of_nat_coe", "exceptional.bind", "conv.istep", "native.rb_lmap", "tactic.seq", "tactic.get_mathlib_dir", "native.float.has_to_format", "tactic.simp_arg", "smt_tactic.induction", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "tactic.interactive.have", "native.rb_map.filter", "using_smt_with", "expr.is_macro", "old_conv.pure", "nat.mul_comm", "environment.mfilter", "level.inhabited", "tactic.definev", "tactic.interactive.field", "tactic.interactive.erase_simp_args", "psigma.eq", "tactic.is_prop_decl", "nat.sub_lt", "cast_heq", "tactic.add_defn_equations", "expr_map", "tactic.local_decls", "tactic.delta_instance", "list.ball_cons", "smt_tactic.interactive.simp", "nat.pred_inj", "tactic.interactive.injections", "nonempty.exists", "get_checks", "tactic.interactive.clear_except", "simp_lemmas.has_to_tactic_format", "tactic.interactive.fail_if_success", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "unsigned.reflect", "tactic.flatten", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "smt_tactic.interactive.apply_instance", "if_eq_of_eq", "tactic.mk_inj_eq", "tactic.ext_patt", "environment.is_constructor_app", "smt_tactic.interactive.change", "native.float.has_lt", "tactic.applyc", "expr.list_constant", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "format.intercalate", "smt_tactic.has_coe", "functor.comp.id_map", "conv.save_info", "environment.from_imported_module", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.interactive.apply_rules", "tactic.triv", "tactic.interactive.destruct", "exists_imp_distrib", "int.sign_eq_one_of_pos", "not_or_distrib", "int.mul_comm", "tactic.rcases_patt_parse_core", "old_conv.seq", "sigma.eq", "module_info.module_name", "tactic.decidable_eq_derive_handler", "where.format_variable", "tactic.interactive.h_generalize", "tactic.unsafe.type_context.failure", "interactive.param_desc", "tactic.mk_id_proof", "smt_tactic.skip", "tactic.interactive.intros", "tactic.funext_lst", "linter.def_lemma", "tactic.interactive.ac_change", "tactic.alias.make_left_right", "has_to_format_to_has_to_tactic_format", "conv.congr", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "lt_of_lt_of_incomp", "nonempty_psum", "tactic.interactive.case", "tactic.interactive.introv", "tactic.has_append", "option.eq_none_of_is_none", "environment.import'", "tactic.explode.entries.add", "not_nonempty_iff_imp_false", "tactic.injections_and_clear", "decidable_eq_inr_neg", "saturate_fun", "nonempty_prod", "smt_tactic.destruct", "tactic.interactive.choose", "tactic.rotate_right", "not_ball_of_bex_not", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "conv.rhs", "smt_tactic.add_ematch_eqn_lemmas_for_core", "tactic.set_options", "tactic.interactive.source_fields", "nonempty_pprod", "local_context.to_format", "tactic.interactive.solve1", "function.partial_inv_of_injective", "interactive.types.using_ident", "tactic.to_pfmt", "nat.bit0_ne_zero", "lt_of_lt_of_le", "nat.one_lt_bit1", "environment.import_until_decl", "expr.list_names_with_prefix", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "native.mk_nat_map", "conv.interactive.to_lhs", "tactic.interactive.fconstructor", "native.float.decidable_lt", "not_nonempty_pempty", "lt_of_le_of_lt", "task.delay", "expr.binding_info", "tactic.explode_cmd", "declaration.update_type", "conv.convert", "interactive.parse", "tactic.find_private_decl", "smt_tactic.interactive.all_goals", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "expr.pi_binders", "native.float.has_sub", "expr.abstract", "tactic.split_if1", "has_reflect_derive_handler", "tactic.mllist.fixl", "string.has_to_format", "conv.interactive.to_rhs", "tactic.induction'", "native.rb_map.find_def", "native.rb_set.filter", "tactic.any_goals", "native.mk_rb_map", "where.compile_variable_list", "doc_blame_report_thm", "tactic.mk_eq_proof", "tactic.interactive.introsI", "tactic.rename'", "tactic.resolve_name'", "native.rb_set.to_list", "list.length_remove_nth", "tactic.solve", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "nat.zero_add", "interactive.executor.execute_explicit", "smt_config.set_classical", "tactic.interactive.classical", "tactic.interactive.suggest", "pos.has_to_format", "old_conv.step", "old_conv.congr", "interactive.types.location", "smt_tactic.interactive.add_lhs_lemma", "tactic.has_to_tactic_format", "linter.instance_priority", "function.cantor_injective", "old_conv.interactive.dsimp", "environment.get_modifiers", "nat.bit1_lt_bit0", "interactive.types.list_of", "conv.interactive.dsimp", "tactic.interactive.ac_reflexivity", "old_conv.fail", "interaction_monad_bind", "tactic.suggest.library_defs", "tactic.failed", "pos_and_pos_or_neg_and_neg_of_mul_pos", "tactic.interactive.push_neg", "format.has_to_string", "expr.bind_pi", "smt_tactic.interactive.guard_expr_eq", "nat.shiftl'_tt_eq_mul_pow", "int.eq_zero_of_nat_abs_eq_zero", "tactic.get_user_simp_lemmas", "tactic.interactive.conv_lhs", "tactic.intros1", "tactic.get_bool_option", "mk_expr_map", "format.dcbrace", "functor.ext", "derive_struct_ext_lemma", "expr.is_lt", "tactic.exact_dec_trivial", "function.bijective_iff_has_inverse", "environment.decl_map", "smt_tactic.refutation_for", "tactic.mk_instance_cache", "old_conv.map", "where.collect_by", "tactic.interactive.rewrite", "lint_mathlib", "ordering.compares.eq_eq", "tactic.done", "tactic.reduce_ifs_at", "rec_subsingleton", "tactic.num_goals", "ge_or_gt_in_statement", "tactic", "lint_all", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "tactic.interactive.collect_struct", "expr.is_and", "old_conv.interactive.change", "tactic.interactive.sorry", "nonempty.forall", "has_inhabited_instance", "smt_tactic.interactive.executor", "exists_of_bex", "tactic.interactive.apply", "list.partition_eq_filter_filter", "tactic.run_async", "old_conv.lift_tactic", "dedup", "tactic.import_private_cmd", "tactic.expanded_field_list", "tactic.transitivity", "tactic.interactive.delta", "tactic.metavariables", "name.last", "lint_mathlib_cmd", "nat.zero_lt_bit0", "tactic.success_if_fail_with_msg", "dup_namespace", "tactic.triv'", "setoid.refl", "old_conv.mk_match_expr", "module_info.has_to_string", "tactic.congr_core", "native.rb_map.to_list", "tactic.unfold_projs_hyp", "unit.has_to_format", "tactic.apply_opt_param", "tactic.i_to_expr", "native.rb_set.empty", "expr.of_nat", "conv.discharge_eq_lhs", "interactive.types.brackets", "native.rb_map.ifind", "prod.exists", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "tactic.interactive.congr", "linter.dangerous_instance", "expr.lift", "tactic.interactive.ac_refl", "tactic.fail_macro", "interaction_monad.monad_fail", "old_conv.interactive.itactic", "param_info.has_to_format", "name.pop_prefix", "rsimp.mk_repr_map", "cc_state.fold_eqc", "print_name", "native.float.has_nat_pow", "tactic_state.has_to_format", "undefined", "tactic.mk_sorry", "smt_tactic.interactive.fapply", "module_info.has_to_format", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "smt_tactic.num_goals", "tactic.pexpr_to_pattern", "user_attribute.get_param", "nat.succ_pred_eq_of_pos", "tactic.get_local_type", "tactic.interactive.comp_val", "expr.contains_constant", "tactic_result", "tactic.mk_simp_set", "tactic.get_pi_binders_dep", "reflected.to_expr", "expr.local_uniq_name", "nat.dvd_antisymm", "tactic.interactive.generalize_proofs", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "expr.to_implicit_binder", "smt_tactic.solve_goals", "exists_const", "tactic.eapply", "nat.add_assoc", "declaration.univ_params", "tactic.interactive.assumption", "tactic.apply_at", "tactic.interactive.clean_ids", "interaction_monad.silent_fail", "conv.interactive.funext", "nat.eq_zero_of_add_eq_zero_right", "tactic.note_anon", "tactic.fail", "tactic.match_fn", "transport_with_dict", "tactic.unsafe.type_context.type_context_alternative", "tactic.get_expl_pi_arity", "tactic.is_simp_lemma", "old_conv.match_expr", "plift.up_down"]}, {"id": "format.bracket", "parentIds": ["format.paren", "format.sbracket", "format.cbrace"]}, {"id": "format", "parentIds": ["format.paren", "prod.has_to_tactic_format", "format.join", "tactic.interactive.squeeze_simp", "tactic.trace", "tactic.interactive.format_names", "format.of_options", "array.has_to_format", "option_to_tactic_format", "print_decls_sorted", "param_info.to_format", "tactic.pp", "where.trace_namespace", "format.sbracket", "unused_arguments", "format.when", "congr_arg_kind.has_to_format", "sigma.has_to_format", "tactic.cc_core", "smt_tactic.trace_state", "print_arguments", "vm.pp_expr", "interaction_monad.orelse'", "string_to_format", "where.trace_variables", "sum_has_to_format", "tactic.interactive.convert", "tactic.rcases_patt.format", "exceptional.to_bool", "trace_fmt", "tactic.clear'", "exceptional.to_option", "tactic.interactive.rcases", "format.to_buffer", "name_set.has_to_format", "format.highlight", "environment.is_definition", "native.rb_map.has_to_tactic_format", "format.to_string", "vm.pp_stack_obj", "use_cmd", "tactic.rcases_patt_inverted.format_list", "tactic.assoc_refl", "array.has_to_tactic_format", "print_decls", "ematch_lhs", "tactic_format_expr", "tactic.terminal_goal", "smt_tactic.monad_fail", "simps_add_projection", "tactic.down", "occurrences_to_format", "smt_state.to_format", "old_conv.conversion", "tactic.interactive.continue", "interactive.with_desc", "native.has_to_format", "interaction_monad.result_to_string", "module_info.has_to_tactic_format", "tactic.tactic.has_to_tactic_format", "interaction_monad.result", "tactic.rintro_parse", "tactic.success_if_fail", "expr.has_to_format", "lint", "interaction_monad.get_result", "tactic.unsafe.type_context.monad_fail", "cc_state.pp_eqc", "tactic.instance_stub", "where.trace_includes", "tactic.trace_result", "tactic.suggest.tactic_statement", "format.indent", "format.space", "tactic.unprime", "tactic.interactive.rw_rule_p", "hinst_lemma.pp", "tactic.interactive.rec.to_tactic_format", "format.inhabited", "tactic.interactive.obtain_parse", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.format_result", "tactic.interactive.squeeze_simpa", "tactic.fail_if_success", "buffer.has_to_tactic_format", "tactic.trace_error", "tactic.mk_patterns", "format.flatten", "print_decls_sorted_mathlib", "format.has_to_format", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.decorate_ex", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "tactic.interactive.mk_paragraph_aux", "interaction_monad.mk_exception", "tactic.eqn_stub", "where.trace_opens", "decidable.has_to_format", "tactic.lock_tactic_state", "level.to_format", "format.has_append", "ematch", "tactic.try_core", "tactic.iterate1", "tactic.rcases_patt_inverted.format", "tactic.list_constructors_hole", "exceptional.to_string", "format.of_string", "tactic.trace_state", "exceptional.fail", "tactic.local_def_value", "tactic.use", "vm_obj.to_format", "tactic.unsafe.type_context.print_mvars", "native.rb_set.has_to_format", "smt_tactic.try", "subsingleton_info_to_format", "where.trace_end", "environment.contains", "tactic.pformat", "tactic.rcases_patt_parse", "format.compose", "print_item_crawl", "exceptional", "prod.has_to_format", "lint_hole_cmd", "tactic.interactive.rintro", "option.has_to_format", "interactive.parse_binders", "tactic.save_info_thunk", "vm.trace", "bool.has_to_format", "tactic_state.to_format", "cc_state.pp_core", "fun_info_to_format", "list.to_format", "get_linters", "tactic.interactive.convert_to", "tactic.interactive.congr'", "hinst_lemmas.pp", "tactic.match_stub", "interaction_monad_fmap", "buffer.has_to_format", "tactic.interactive.has_to_tactic_format", "lint_aux", "tactic_state.format_expr", "interaction_monad_orelse", "binder.has_to_tactic_format", "has_to_format", "tactic.explode.format_aux", "binder.has_to_format", "format.cbrace", "tactic.interactive.simpa", "tactic.ext1", "list.has_to_tactic_format", "format.line", "tactic.returnex", "interaction_monad.result.clamp_pos", "tactic.up", "lean.parser.parser_orelse", "expr.to_raw_fmt", "format.of_nat", "to_fmt", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "nat_to_format", "format.bracket", "format.nest", "instance_derive_handler", "tactic.interactive.mk_paragraph", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "exceptional.bind", "format.nil", "native.float.has_to_format", "has_to_tactic_format", "format.is_nil", "format.group", "format.intercalate", "where.format_variable", "tactic.unsafe.type_context.failure", "interactive.param_desc", "has_to_format_to_has_to_tactic_format", "tactic.get_lift_prf", "tactic.has_append", "mk_hinst_lemma_attr_core", "local_context.to_format", "tactic.to_pfmt", "tactic.interactive.parse_config", "tactic.interactive.trace_simp_set", "tactic.rename'", "simp_lemmas.pp", "tactic.replacer_attr", "equiv_type_constr", "tactic.unsafe.type_context.fail", "tactic.interactive.suggest", "pos.has_to_format", "interactive.types.location", "tactic.has_to_tactic_format", "interaction_monad_bind", "format.has_to_string", "format.dcbrace", "lint_mathlib", "lint_all", "tactic.run_async", "tactic.success_if_fail_with_msg", "interaction_monad.monad_fail", "interaction_monad.silent_fail", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "function.right_inverse.comp_eq_id", "parentIds": []}, {"id": "function.right_inverse", "parentIds": ["function.right_inverse.comp_eq_id", "sum.swap_right_inverse", "function.surjective.has_right_inverse", "function.has_right_inverse", "function.inv_fun_eq_of_injective_of_right_inverse", "function.surjective_of_has_right_inverse", "function.id_of_right_inverse", "function.right_inverse_surj_inv", "function.inv_fun_surjective", "function.left_inverse_of_surjective_of_right_inverse", "function.involutive.right_inverse", "function.right_inverse.comp", "function.right_inverse_of_injective_of_left_inverse", "function.cantor_injective", "prod.swap_right_inverse", "function.right_inverse_inv_fun", "function.bijective_iff_has_inverse"]}, {"id": "id", "parentIds": ["function.right_inverse.comp_eq_id", "ordering.ite_eq_gt_distrib", "list.mem_append", "iff_not_comm", "function.right_id", "tactic.interactive.record_lit", "abs_add_le_abs_add_abs", "interactive.loc.has_reflect", "int.neg_succ_of_nat_coe'", "neg_eq_iff_neg_eq", "function.id_of_left_inverse", "char.val_of_nat_eq_of_is_valid", "add_left_eq_self", "put", "binder.decidable_eq", "sub_eq_sub_iff_sub_eq_sub", "le_mul_of_div_le", "int.of_nat_ge_zero", "bool.bor_inl", "div_zero", "one_add_one_eq_two", "functor.map_comp_map", "state", "max_add_add_left", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "ne_zero_of_mul_ne_zero_left", "norm_num.add_comm_four", "eq_add_neg_iff_add_eq", "id.is_comm_applicative", "comp.applicative", "nat.mod_lt", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "nat.eq_zero_or_eq_succ_pred", "min_neg_neg", "int.le.dest", "nat.div_eq_of_lt", "norm_num.bit0_add_bit1", "imp_or_distrib'", "nat.bitwise_zero", "tactic.interactive.rw_rule.has_reflect", "add_right_eq_self", "tt_band", "bool.to_bool_not", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "div_sub_div", "nat.add_mul_mod_self_right", "int.nat_abs_bit1_nonneg_step", "nat.one_lt_bit0", "div_pos_of_neg_of_neg", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "option.is_lawful_monad", "tactic.suggest.head_symbol_match.decidable_eq", "add_sub_comm", "nat.mul_div_mul", "prod.id_prod", "mjoin_map_map", "bnot_eq_ff_eq_eq_tt", "id.is_lawful_traversable", "classical.forall_or_distrib", "prod.has_reflect", "nat.succ_sub_sub_succ", "expr.dedup_size", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "abs_sub_le", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "char.of_nat_eq_of_not_is_valid", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "eq_mul_inv_iff_mul_eq", "int.add_assoc", "nat.mul_div_assoc", "add_midpoint", "norm_num.bit1_add_one_helper", "list.length_take_le", "conv.monad", "except_t.ext", "add_add_sub_cancel", "mul_inv_rev", "band_eq_true_eq_eq_tt_and_eq_tt", "function.inv_fun_on_neg", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "norm_num.mul_bit1_helper", "functor.comp.ext", "nat.sub_eq_zero_of_le", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "eq_of_sub_eq_zero", "sub_add_add_cancel", "dlist.to_list_concat", "nat.add_div_left", "eq_of_mul_eq_mul_right", "nat.gcd_succ", "nat.bodd_add_div2", "field.one_div_mul_one_div", "add_sub_cancel'", "int.ne_of_nat_ne_nonneg_case", "nat.succ_mul_succ_eq", "conv.alternative", "abs_one_div", "nat.add_mul_div_right", "eq.congr_left", "nat.bodd_add", "mul_eq_one_iff_inv_eq", "norm_num.mul_one", "conv.monad_fail", "bind_pure", "tt_eq_ff_eq_false", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "nat.gcd_zero_left", "norm_num.subst_into_sum", "sum.elim_injective", "dvd_add_iff_right", "add_sub_sub_cancel", "dlist.to_list_cons", "if_false_left_eq_and", "sub_eq_zero_of_eq", "not_iff_not", "list.length_append", "neg_inj'", "ge_of_forall_ge_sub", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "nat.pow_lt_pow_of_lt_right", "one_div_mul_one_div'", "bor_ff", "int.neg_ne_zero_of_ne", "div_le_div_of_le_of_neg", "field.div_mul_eq_div_mul_one_div", "state_t.run_map", "peirce'", "bxor_self", "exists_add_lt_and_pos_of_lt", "nat.bodd_succ", "div_div_eq_div_mul", "nat.zero_lt_one_add", "neg_mul_eq_neg_mul", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "is_lawful_functor", "imp_self", "inv_ne_zero", "mul_div_mul_left'", "max_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.lt_add_of_pos_left", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "reader_t.run_map", "list.map_append", "norm_num.add_comm_middle", "or.imp_right", "option.some_inj", "nat.shiftr_eq_div_pow", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "char.val_of_nat_eq_of_not_is_valid", "vm_obj_kind.decidable_eq", "functor.comp.comp_map", "nat.binary_rec_eq", "id.bind_eq", "coe_ff", "int.of_nat_inj", "fin.mod_def", "parser.alternative", "list.band", "div_two_sub_self", "dlist.of_list_to_list", "le_min", "option.lift_or_get_is_left_id", "add_neg_eq_iff_eq_add", "sub_ne_zero_of_ne", "le_max_left", "int.nat_abs_add_neg", "function.inv_fun_eq_of_injective_of_right_inverse", "functor.const.is_lawful_functor", "monad_lift_refl", "int.sub_nat_nat_elim", "lt_of_add_lt_add_right", "mul_inv", "option_t.run_map", "nat.mod_two_of_bodd", "eq_add_neg_of_add_eq", "one_dvd", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "nat.binary_rec_zero", "int.lt_add_succ", "norm_num.add1_zero", "max_eq_neg_min_neg_neg", "or_iff_right_of_imp", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "task.monad", "list.ne_nil_of_length_eq_succ", "nat.sub_eq_iff_eq_add", "bool.has_reflect", "one_div_zero", "div_mul_cancel", "list.length_map", "nat.succ_inj", "forall_iff_forall_surj", "and.imp_left", "list.filter_append", "nat.sub_eq_sub_min", "nat.sub_mul_mod", "nat.pow_le_pow_of_le_right", "monad_from_pure_bind", "nat.mul_assoc", "mul_div_cancel_left", "lt_min", "add_sub_cancel'_right", "nat.zero_mul", "state_t.run_adapt", "ff_eq_tt_eq_false", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "tactic.constr_to_prop", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "nat.bitwise_zero_left", "norm_num.bit1_add_bit0_helper", "dvd_of_mul_right_dvd", "mul_le_mul_of_mul_div_le", "int.neg_succ_of_nat_inj_iff", "mjoin_pure", "mul_zero_lt_mul_inv_of_pos", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "to_additive.value_type.has_reflect", "sum.has_reflect", "ne_zero_of_mul_ne_zero_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "inv_eq_iff_inv_eq", "int.nat_abs_bit0_step", "parser.is_lawful_monad", "div_mul_le_div_mul_of_div_le_div_pos", "reader", "function.inv_fun_on_pos", "int.of_nat_nat_abs_of_nonpos", "sum.monad", "nat.shiftl'_sub", "mjoin", "parser.monad", "add_mul_self_eq", "norm_num.neg_add_pos_helper2", "add_add_add_comm", "function.id_of_right_inverse", "dlist.to_list_append", "reader_t.is_lawful_monad", "int.coe_nat_lt_coe_nat_iff", "neg_add", "norm_num.zero_mul", "nat.mul_le_mul_left", "is_comm_applicative.commutative_map", "div_mul_left", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "nat.add_sub_cancel", "functor.const.applicative", "tactic.interactive.generalize_a_aux", "neg_neg_sub_neg", "except.monad", "int.of_nat_sub", "nat.div_le_of_le_mul", "add_eq_zero_iff_neg_eq", "mul_sub_mul_div_mul_neg", "or.neg_resolve_left", "eq_inv_mul_iff_mul_eq", "tactic.simp_arg_type.has_reflect", "nat.sub_pos_of_lt", "norm_num.neg_zero_helper", "neg_mul_comm", "add_div_eq_mul_add_div", "nat.mul_mod_mul_left", "bool.dichotomy", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "fish_pipe", "int.distrib_left", "int.lt_irrefl", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "mul_eq_one_iff_eq_inv", "tactic.successes", "neg_add_eq_iff_eq_add", "nat.mod_le", "neg_add_cancel_right", "nat.add_le_add_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "id.map_eq", "id.def", "id_bind", "nat.div_mul_cancel", "nat.eq_zero_of_mul_eq_zero", "add_sub_add_right_eq_sub", "mul_eq_of_eq_inv_mul", "nat.div_eq_of_eq_mul_right", "mul_one_div_cancel", "int.le_antisymm", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "int.eq_one_of_mul_eq_self_left", "zero_div", "abs_nonneg", "string.str_ne_str_right", "functor.comp.functor_id_comp", "nat.sub_self", "eq_iff_eq_cancel_right", "binder_info.has_reflect", "lt_of_one_lt_div", "field.div_div_div_div_eq", "int.lt_iff_le_and_ne", "char.decidable_is_digit", "eq_add_of_add_neg_eq", "abs_mul", "format.has_to_format", "or_iff_left_of_imp", "nat.add_left_cancel", "subtype.decidable_eq", "nat.zero_mod", "function.injective_prod", "list.append_nil", "functor.comp.functor_comp_id", "norm_num.div_add_helper", "state_t.alternative", "mul_inv_eq_iff_eq_mul", "list.qsort_cons", "sub_sub", "char.decidable_is_punctuation", "nat.add_mod_right", "int.le.intro", "exists_and_distrib_right", "nat.add_sub_add_right", "ff_bor", "add_eq_zero_iff_eq_neg", "nat.le_of_add_le_add_right", "nat.add_sub_cancel_left", "bool.forall_bool", "sub_eq_zero", "mjoin_map_pure", "nat.gcd_one_left", "comp.applicative_id_comp", "mul_inv_cancel_left", "neg_add_le_left_of_le_add", "max_le", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "nat.bitwise_swap", "nat.bitwise_zero_right", "or.resolve_right", "list.sublists'", "min_add_add_right", "int.le_trans", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "prod.swap_swap_eq", "option.map_id", "fin.mul_def", "eq_iff_eq_of_sub_eq_sub", "nat.bitwise_bit", "eq_iff_eq_cancel_left", "sub_sub_assoc_swap", "min_add_add_left", "nat.dvd_add_iff_right", "neg_of_neg_pos", "one_div_ne_zero", "nat.dvd_sub", "char.decidable_is_upper", "mul_right_inv", "field.div_mul_left", "sub_lt_self", "list.decidable_chain'", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "norm_num.nonneg_bit0_helper", "sub_sub_sub_cancel_left", "not_iff_comm", "field.div_mul_eq_mul_div_comm", "sub_sub_self", "le_of_mul_le_of_ge_one", "tactic.unsafe.type_context.monad", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "interaction_monad.monad", "nat.sub_self_add", "id.is_lawful_monad", "eq_inv_of_eq_inv", "abs_neg", "mul_eq_zero_iff_eq_zero_or_eq_zero", "int.sign_mul_abs", "tactic.interactive.rw_rules_t.has_reflect", "inv_mul_cancel_left", "nat.sub_one_sub_lt", "div_mul_le_div_mul_of_div_le_div_pos'", "not_exists_not", "norm_num.add1_bit1_helper", "add_neg_cancel_right", "add_group.add_right_cancel", "min_le_right", "map_seq", "or_iff_not_and_not", "dvd_trans", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "norm_num.pos_bit0_helper", "int.mul_pos", "coe_sort_tt", "field.div_mul_div", "not_false", "functor.map_id", "division_ring.one_div_div", "one_div_mul_cancel", "norm_num.subst_into_div", "mul_eq_of_eq_mul_inv", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "comp.is_comm_applicative", "state_t.ext", "dvd_mul_of_dvd_right", "bool.cond_to_bool", "band_self", "nat.mul_mod_left", "nat.add_div_right", "div_nonpos_of_nonpos_of_pos", "sub_zero", "or_false", "inv_eq_one", "tt_bor", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "is_lawful_traversable", "inv_inj'", "norm_num.nonzero_of_neg_helper", "div_eq_mul_one_div", "div_mul_right", "nat.mul_mod_right", "function.comp.right_id", "iff_iff_and_or_not_and_not", "group.mul_left_cancel", "mul_inv'", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "bor_tt", "nat.mod_zero", "nat.one_add", "add_self_div_two", "dvd_mul_of_dvd_left", "interactive.interactive.executor", "dlist.empty", "tactic.solve_by_elim", "div_lt_div_of_lt_of_pos", "norm_num.bit1_add_bit0", "nat.mul_div_left", "string.has_decidable_eq", "sub_add_sub_cancel", "add_eq_of_eq_add_neg", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "list.split_on_p", "gt_of_mul_lt_mul_neg_left", "comp.pure_seq_eq_map", "one_div_neg_eq_neg_one_div", "where.get_variables_core", "int.mul_assoc", "list.reduce_option", "neg_sub", "int.nat_abs_bit1_nonneg", "abs_div", "int.add_le_add_left", "div_mul_eq_div_mul_one_div", "list.bor", "list.monad", "mul_self_sub_mul_self_eq", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "functor.const.is_lawful_applicative", "function.left_inverse.comp_eq_id", "norm_num.neg_mul_pos_helper", "int.eq_nat_abs_of_zero_le", "eq_neg_add_of_add_eq", "add_right_neg", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "nat.sub_add_comm", "nat.succ_sub", "nat.div_le_self", "modify", "bit1_zero", "nat.bodd_bit", "one_div_lt_one_div_of_lt", "applicative.pure_seq_eq_map'", "old_conv.monad", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "tactic.binder_info.has_decidable_eq", "and_iff_not_or_not", "field.div_mul_right", "char.of_nat_ne_of_ne", "int.lt_iff_le_not_le", "div_nonpos_of_nonneg_of_neg", "inv_inj", "div_div_eq_mul_div", "nat.sub.right_comm", "nat.left_distrib", "division_ring.mul_ne_zero", "nat.mod_self", "le_abs_self", "int.coe_nat_le_coe_nat_of_le", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "int.sign_eq_zero_iff_zero", "eq_of_mul_eq_mul_of_nonzero_left", "norm_num.sub_nat_pos_helper", "imp_or_distrib", "option.alternative", "list.filter_sublist", "int.le_total", "mul_inv_eq_one", "nat.add_mod_left", "nat.right_distrib", "level.dedup_size", "exceptional.monad", "list.is_lawful_monad", "map_ext_congr", "add_sub", "applicative.ext", "or.neg_resolve_right", "nat.test_bit_succ", "char.decidable_is_lower", "mul_sub_right_distrib", "bxor_tt", "nat.bit1_inj", "norm_num.subst_into_prod", "cmp_compares", "division_ring.neg_div_neg_eq", "min_eq_neg_max_neg_neg", "seq_bind_eq", "nat.sub_sub", "option.mem_to_list", "nat.div2_bit", "cmp_swap", "guard_true", "dvd_add", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "one_div_div", "nat.sub_add_min_cancel", "add_neg_cancel_left", "nat.add_le_add_left", "list.append_assoc", "nat.le_of_sub_eq_zero", "vm_core.monad", "function.surjective_id", "string.str_ne_str_left", "neg_add_rev", "list.permutations_aux", "nat.mul_self_sub_mul_self_eq", "pure_id_seq", "div_eq_one_iff_eq", "mul_div_mul_left", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "has_monad_lift_t_refl", "sum.swap_swap_eq", "nat.gcd_zero_right", "neg_add_cancel_left", "sum.is_lawful_functor", "add_lt_add_right", "state_t.monad_state", "nat.div_eq_sub_div", "nat.pow_lt_pow_of_lt_left", "mul_div_mul_right'", "dvd_refl", "mjoin_map_mjoin", "id.monad", "neg_eq_zero", "reader_t.alternative", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "function.comp.left_id", "array.read_eq_read'", "exists_eq_right'", "div_lt_div_of_pos_of_lt_of_pos", "seq_map_assoc", "nat.mod_add_div", "eq_of_mul_eq_mul_left", "max_add_add_right", "norm_num.neg_mul_neg_helper", "one_div_one_div", "sequence", "prod.ext_iff", "list.nil_bind", "comp.applicative_comp_id", "char.decidable_is_whitespace", "sub_self_div_two", "d_array.of_beq_eq_tt", "mul_inv_eq_of_eq_mul", "abs_pos_of_pos", "except_t.is_lawful_monad", "nat.mod_eq_sub_mod", "mul_div_cancel'", "nat.mul_div_cancel_left", "dvd_neg_of_dvd", "nonpos_of_neg_nonneg", "neg_add_lt_left_of_lt_add", "option.lift_or_get_is_right_id", "bxor_ff", "mul_div_mul_right", "two_pos", "bool.bor_inr", "if_true_left_eq_or", "div_one", "eq_sub_of_add_eq'", "inv_eq_of_mul_eq_one", "int.mul_nonneg", "one_div_le_one_div_of_le", "int.to_nat_sub", "nat.div2_succ", "except_t.monad", "mul_self_eq_mul_self_iff", "int.neg_succ_of_nat_inj", "dist_bdd_within_interval", "pos_of_neg_neg", "eq_inv_of_mul_eq_one", "pexpr.has_to_pexpr", "add_halves", "field.div_div_eq_mul_div", "neg_div_neg_eq", "distrib_three_right", "mul_div_cancel", "function.bijective_id", "cmp_using_eq_eq", "div_nonneg_of_nonneg_of_pos", "or.imp_left", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "char.decidable_is_alpha", "fish_assoc", "list.length_map\u2082", "eq_add_of_neg_add_eq", "state_t.monad", "eq.congr_right", "sub_sub_sub_cancel_right", "fish_pure", "norm_num.pos_add_neg_helper", "division_ring.eq_of_one_div_eq_one_div", "eq_neg_of_add_eq_zero", "division_ring.inv_inv", "sub_le_self", "div_mul_eq_mul_div_comm", "neg_div", "id.pure_eq", "nat.div_mul_le_self", "div_div_div_div_eq", "int.eq_one_of_mul_eq_self_right", "eq_of_one_div_eq_one_div", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "environment.get_decls", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "int.le.intro_sub", "div_neg_eq_neg_div", "classical.iff_iff_not_or_and_or_not", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "option.monad", "d_array.of_beq_eq_ff", "div_sub_div_same", "min_self", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_zero", "tactic.pformat.has_to_tactic_format", "norm_num.mk_cong", "and.imp_right", "eq_one_div_of_mul_eq_one", "mul_sub_left_distrib", "nat.mul_comm", "int.lt.dest", "one_div_add_one_div", "nat.gcd_rec", "norm_num.neg_add_neg_helper", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "abs_sub", "list.map_map", "one_div_le_one_div_of_le_of_neg", "norm_num.one_add_bit1_helper", "and.right_comm", "nat.pred_inj", "functor.add_const.run", "bool.to_bool_or", "set.is_lawful_functor", "reader_t.ext", "int.decidable_eq", "list.qsort_nil", "guard_false", "neg_mul_eq_mul_neg", "band_ff", "option.has_reflect", "sum.decidable_eq", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "function.injective_id", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "nat.zero_pow", "functor.add_const.applicative", "norm_num.div_helper", "eq_neg_add_iff_add_eq", "d_array.read_write_of_ne", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "function.inv_fun_comp", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "mul_inv_cancel_right", "ite_eq_tt_distrib", "nat.one_mul", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "div_le_of_le_mul", "abs_sub_abs_le_abs_sub", "nonneg_of_neg_nonpos", "nat.add_sub_of_le", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "sub_add_sub_cancel'", "norm_num.div_eq_div_helper", "int.le_nat_abs", "sub_add", "comp.seq_pure", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "option_t.monad", "list.length_repeat", "sub_eq_iff_eq_add'", "id.traversable", "function.left_inverse.comp", "nat.add_le_to_le_sub", "eq_sub_iff_add_eq'", "reader_t.monad", "list.length_remove_nth", "id.monad_run", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "min_le_left", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "nat.sub_add_cancel", "neg_eq_of_add_eq_zero", "state_t.is_lawful_monad", "nat.dvd_add_iff_left", "eq_mul_of_mul_inv_eq", "pos.has_reflect", "div_mul_div", "nat.bit1_lt_bit0", "nat.mul_mod_mul_right", "div_add_div", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "function.left_id", "nat.div_zero", "or.resolve_left", "div_two_lt_of_pos", "derive_struct_ext_lemma", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "add_eq_of_eq_neg_add", "inv_mul_eq_iff_eq_mul", "division_ring.one_div_neg_eq_neg_one_div", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "int.nat_abs_abs", "nat.cond_to_bool_mod_two", "le_of_add_le_add_right", "function.involutive_iff_iter_2_eq_id", "char.decidable_is_alphanum", "nat.div_div_eq_div_mul", "coe_sort_ff", "tactic.interactive.collect_struct", "nat.mul_sub_div", "abs_mul_self", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "pempty.decidable_eq", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "or_self", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "get", "le_max_right", "is_total_preorder_is_preorder", "bor_eq_true_eq_eq_tt_or_eq_tt", "eq_div_iff_mul_eq", "add_group.add_left_cancel", "expr.lift", "is_lawful_applicative", "tt_bxor", "ordering.ite_eq_lt_distrib", "nat.mod_eq_zero_of_dvd", "reflected.to_expr", "add_sub_assoc", "bool.not_ff", "comp.seq_assoc", "add_neg_eq_zero", "list.cons_bind", "group.mul_right_cancel", "nat.add_assoc", "band_eq_false_eq_eq_ff_or_eq_ff", "nat.add_sub_add_left", "div_lt_div_of_mul_sub_mul_div_neg", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "ulift.ext", "function.update_comp", "dlist.to_list_singleton", "tactic.unsafe.type_context.type_context_alternative", "forall_or_distrib_right"]}, {"id": "function.comp", "parentIds": ["function.right_inverse.comp_eq_id", "function.right_id", "function.bijective_comp", "function.id_of_left_inverse", "tactic.interactive.squeeze_simp", "functor.map_comp_map", "id.is_comm_applicative", "comp.applicative", "array.has_to_format", "imp_or_distrib'", "function.surjective.of_comp", "tactic.admit", "string.over_list", "param_info.to_format", "or_and_distrib_left", "option.is_lawful_monad", "mjoin_map_map", "applicative.map_seq_map", "function.comp.assoc", "functor.add_const.is_lawful_applicative", "option_t.monad_run", "dlist.to_list_concat", "bind_pure", "ulift.functor", "tactic.interactive.induction", "dlist.to_list_cons", "state_t.run_map", "is_lawful_functor", "functor.comp.functor", "reader_t.monad_except", "sum.is_lawful_monad", "reader_t.run_map", "prod.map_snd'", "array.has_to_tactic_format", "tactic.mllist.empty", "functor.comp.comp_map", "parser.alternative", "array.has_repr", "prod.map_fst'", "functor.const.is_lawful_functor", "option_t.run_map", "where.get_def_variables", "task.monad", "expr.mfoldl", "monad_from_pure_bind", "module_info.has_to_tactic_format", "function.injective.of_comp", "parser.is_lawful_monad", "sum.monad", "parser.monad", "string.map_tokens", "lint", "tactic.unsafe.type_context.monad_fail", "function.id_of_right_inverse", "dlist.to_list_append", "reader_t.is_lawful_monad", "is_comm_applicative.commutative_map", "set.functor", "state_t.monad_except", "functor.const.applicative", "except.monad", "where.strip_pi_binders", "function.uncurry_bicompr", "tactic.interactive.squeeze_simpa", "buffer.has_to_tactic_format", "except_t.run_map", "local_context.to_list", "state_t.alternative", "option.map", "mjoin_map_pure", "function.restrict_eq", "prod.swap_swap_eq", "reflected.has_to_pexpr", "function.comp_apply", "buffer.has_repr", "tactic.list_constructors_hole", "not.imp_symm", "tactic.unsafe.type_context.monad", "interaction_monad.monad", "id.is_lawful_monad", "subsingleton_info_to_format", "function.comp_app", "map_seq", "comp.is_comm_applicative", "is_lawful_traversable", "function.comp.right_id", "tactic.interactive.unelide", "except_t.monad_run", "tactic.no_mvars_in_target", "list.monad", "functor.const.is_lawful_applicative", "function.left_inverse.comp_eq_id", "tactic.mllist.monad_lift", "old_conv.monad", "fun_info_to_format", "option.alternative", "exceptional.monad", "list.is_lawful_monad", "applicative.ext", "tactic.simp_bottom_up'", "native.float.mantissa", "seq_bind_eq", "function.surjective_comp", "buffer.has_to_format", "tactic.interactive.list_cast_of", "vm_core.monad", "except_t.monad_except", "sum.swap_swap_eq", "function.injective_comp", "sum.is_lawful_functor", "function.comp_const_right", "is_lawful_applicative.map_comp_pure", "mjoin_map_mjoin", "id.monad", "reader_t.alternative", "function.comp.left_id", "seq_map_assoc", "tactic.interactive.refine_one", "function.right_inverse.comp", "except_t.is_lawful_monad", "state_t.monad_run", "except_t.monad", "state_t.monad", "functor.const.functor", "function.uncurry'_bicompr", "option.monad", "native.float.has_to_format", "is_lawful_monad", "list.map_map", "set.is_lawful_functor", "tactic.interactive.clear_except", "format.intercalate", "map_bind", "functor.add_const.applicative", "has_to_format_to_has_to_tactic_format", "function.inv_fun_comp", "option_t.is_lawful_monad", "tactic.interactive.source_fields", "local_context.to_format", "comp.seq_pure", "option_t.monad", "function.left_inverse.comp", "tactic.rename'", "reader_t.monad", "or_iff_not_imp_left", "state_t.is_lawful_monad", "reader_t.monad_run", "function.left_id", "functor.ext", "where.collect_by", "list.partition_eq_filter_filter", "is_lawful_applicative", "imp_imp_imp", "comp.seq_assoc", "map_map", "function.update_comp", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "funext", "parentIds": ["function.right_inverse.comp_eq_id", "function.id_of_left_inverse", "functor.map_comp_map", "option.is_lawful_monad", "prod.id_prod", "mjoin_map_map", "function.uncurry_curry", "function.update_eq_self", "state_t.run_map", "sum.is_lawful_monad", "prod.map_snd'", "dlist.of_list_to_list", "prod.map_fst'", "function.inv_fun_eq_of_injective_of_right_inverse", "function.curry_uncurry'", "d_array.read_write", "parser.is_lawful_monad", "function.id_of_right_inverse", "reader_t.is_lawful_monad", "fish_pipe", "pi.subsingleton", "function.uncurry_bicompr", "function.uncurry'_curry", "exists_and_distrib_right", "mjoin_map_pure", "nat.bitwise_swap", "bind_ext_congr", "prod.swap_swap_eq", "option.map_id", "nat.bitwise_bit_aux", "id.is_lawful_monad", "functor.map_id", "function.hfunext", "comp.is_comm_applicative", "state_t.ext", "int.eq_coe_of_zero_le", "function.left_inverse.comp_eq_id", "applicative.pure_seq_eq_map'", "function.uncurry_def", "list.is_lawful_monad", "map_ext_congr", "applicative.ext", "seq_bind_eq", "sum.swap_swap_eq", "is_lawful_applicative.map_comp_pure", "mjoin_map_mjoin", "exists_eq_right'", "seq_map_assoc", "except_t.is_lawful_monad", "d_array.ext'", "d_array.ext", "fish_assoc", "fish_pure", "prod.map_def", "set.is_lawful_functor", "reader_t.ext", "map_bind", "d_array.read_write_of_ne", "function.inv_fun_comp", "option_t.is_lawful_monad", "exists_eq_left'", "comp.seq_pure", "state_t.is_lawful_monad", "function.cantor_injective", "function.funext_iff", "functor.ext", "comp.seq_assoc", "function.update_comp"]}, {"id": "buffer.nil", "parentIds": ["string.to_char_buffer"]}, {"id": "mk_buffer", "parentIds": ["buffer.nil", "list.to_buffer"]}, {"id": "buffer", "parentIds": ["buffer.nil", "buffer.take", "format.to_buffer", "buffer.write", "buffer.to_array", "buffer.iterate", "buffer.foreach", "parser.mk_error_msg", "buffer.map", "buffer.read_eq_read'", "buffer.pop_back", "buffer.drop", "buffer.has_to_tactic_format", "buffer.reverse", "buffer.has_append", "buffer.take_right", "buffer.write_eq_write'", "buffer.append_list", "buffer.append", "buffer.has_repr", "buffer.append_string", "buffer.read'", "buffer.write'", "buffer.has_mem", "buffer.rev_iterate", "buffer.to_list", "buffer.append_array", "buffer.read", "buffer.has_to_format", "mk_buffer", "char_buffer", "buffer.to_string", "buffer.mem", "buffer.size", "buffer.foldl", "array.to_buffer", "buffer.push_back", "list.to_buffer"]}, {"id": "ordering.ite_eq_gt_distrib", "parentIds": ["cmp_using_eq_gt"]}, {"id": "ordering", "parentIds": ["ordering.ite_eq_gt_distrib", "cmp_using_eq_gt", "cmp_using_eq_lt", "ordering.compares.eq_lt", "ordering.compares.eq_gt", "ordering.decidable_eq", "ordering.swap_or_else", "ordering.has_repr", "ordering.compares", "name.lex_cmp", "ordering.swap_swap", "name.lt.decidable_rel", "ordering.ite_eq_eq_distrib", "cmp_compares", "ordering.or_else_eq_lt", "cmp_swap", "name.lt", "cmp_using", "cmp_using_eq_eq", "cmp", "native.rb_map.mk_core", "ordering.inhabited", "name.cmp", "ordering.swap", "ordering.compares.eq_eq", "ordering.or_else", "ordering.ite_eq_lt_distrib"]}, {"id": "eq_self_iff_true", "parentIds": ["ordering.ite_eq_gt_distrib", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "norm_num.add_comm_four", "id.is_comm_applicative", "nat.eq_zero_or_eq_succ_pred", "int.le.dest", "norm_num.bit0_add_bit1", "add_right_eq_self", "tt_band", "bool.to_bool_not", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "option.is_lawful_monad", "add_sub_comm", "bnot_eq_ff_eq_eq_tt", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "int.add_assoc", "except_t.ext", "band_eq_true_eq_eq_tt_and_eq_tt", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "norm_num.mul_bit1_helper", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "nat.gcd_succ", "nat.succ_mul_succ_eq", "norm_num.mul_one", "bind_pure", "abs_sub_square", "nat.gcd_zero_left", "dlist.to_list_cons", "if_false_left_eq_and", "list.length_append", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "bor_ff", "state_t.run_map", "bxor_self", "exists_add_lt_and_pos_of_lt", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "list.map_append", "norm_num.add_comm_middle", "functor.comp.comp_map", "coe_ff", "fin.mod_def", "dlist.of_list_to_list", "option.lift_or_get_is_left_id", "int.nat_abs_add_neg", "option_t.run_map", "eq_add_neg_of_add_eq", "one_dvd", "norm_num.add1_zero", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "div_mul_cancel", "list.length_map", "list.filter_append", "nat.sub_mul_mod", "nat.mul_assoc", "nat.succ_add_eq_succ_add", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "norm_num.bit1_add_bit0_helper", "int.neg_succ_of_nat_inj_iff", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "int.mul_one", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "parser.is_lawful_monad", "add_mul_self_eq", "add_add_add_comm", "reader_t.is_lawful_monad", "norm_num.zero_mul", "is_comm_applicative.commutative_map", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "norm_num.neg_zero_helper", "neg_mul_comm", "bool.dichotomy", "int.distrib_left", "list.map_id", "function.uncurry'_curry", "bor_self", "neg_add_cancel_right", "add_sub_add_right_eq_sub", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "zero_div", "eq_add_of_add_neg_eq", "nat.add_left_cancel", "nat.zero_mod", "list.append_nil", "sub_sub", "ff_bor", "nat.gcd_one_left", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "bind_ext_congr", "fin.mul_def", "sub_sub_assoc_swap", "d_array.of_beq_aux_eq_ff", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "id.is_lawful_monad", "eq_inv_of_eq_inv", "norm_num.add1_bit1_helper", "add_group.add_right_cancel", "map_seq", "dvd_trans", "int.mul_pos", "coe_sort_tt", "one_div_mul_cancel", "mul_eq_of_eq_mul_inv", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "state_t.ext", "bool.cond_to_bool", "band_self", "tt_bor", "div_eq_mul_one_div", "group.mul_left_cancel", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "bor_tt", "nat.mod_zero", "nat.one_add", "norm_num.bit1_add_bit0", "add_eq_of_eq_add_neg", "comp.pure_seq_eq_map", "int.mul_assoc", "mul_self_sub_mul_self_eq", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "nat.div_le_self", "applicative.pure_seq_eq_map'", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "int.lt_iff_le_not_le", "inv_inj", "nat.left_distrib", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "int.le_total", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "add_sub", "mul_sub_right_distrib", "bxor_tt", "norm_num.subst_into_prod", "seq_bind_eq", "cmp_swap", "guard_true", "dvd_add", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "list.append_assoc", "pure_id_seq", "div_eq_one_iff_eq", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "nat.gcd_zero_right", "dvd_refl", "list.append_bind", "sub_add_eq_add_sub", "array.read_eq_read'", "seq_map_assoc", "nat.mod_add_div", "norm_num.neg_mul_neg_helper", "list.nil_bind", "mul_inv_eq_of_eq_mul", "except_t.is_lawful_monad", "dvd_neg_of_dvd", "option.lift_or_get_is_right_id", "bxor_ff", "if_true_left_eq_or", "div_one", "eq_sub_of_add_eq'", "int.mul_nonneg", "eq_inv_of_mul_eq_one", "distrib_three_right", "mul_div_cancel", "cmp_using_eq_eq", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "list.length_map\u2082", "eq_add_of_neg_add_eq", "eq_neg_of_add_eq_zero", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "min_self", "norm_num.mul_zero", "norm_num.mk_cong", "mul_sub_left_distrib", "nat.mul_comm", "nat.gcd_rec", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.map_map", "norm_num.one_add_bit1_helper", "bool.to_bool_or", "reader_t.ext", "guard_false", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "d_array.read_write_of_ne", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "ite_eq_tt_distrib", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "int.neg_succ_of_nat_lt_zero", "inv_mul_eq_of_eq_mul", "sub_add", "comp.seq_pure", "list.length_repeat", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "state_t.is_lawful_monad", "eq_mul_of_mul_inv_eq", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "coe_sort_ff", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bor_eq_true_eq_eq_tt_or_eq_tt", "add_group.add_left_cancel", "tt_bxor", "ordering.ite_eq_lt_distrib", "comp.seq_assoc", "list.cons_bind", "group.mul_right_cancel", "band_eq_false_eq_eq_ff_or_eq_ff", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "function.update_comp", "dlist.to_list_singleton"]}, {"id": "decidable_of_decidable_of_iff", "parentIds": ["ordering.ite_eq_gt_distrib", "if_ctx_simp_congr_prop", "option.decidable_eq_none", "exists_prop_decidable", "char.decidable_eq", "if_ctx_simp_congr", "cmp_using_eq_gt", "cmp_using_eq_lt", "d_array.of_beq_aux_eq_tt", "max_self", "if_false_left_eq_and", "prod.lex.decidable", "max_lt", "le_min", "le_max_left", "lt_min", "if_true_right_eq_or", "nat.mod_eq_of_lt", "if_simp_congr_prop", "decidable_of_iff'", "nat.zero_mod", "max_le", "d_array.of_beq_aux_eq_ff", "decidable_of_iff", "min_le_right", "bool.cond_to_bool", "if_simp_congr", "nat.mod_zero", "ordering.ite_eq_eq_distrib", "cmp_compares", "cmp_swap", "bool.decidable_forall_bool", "dif_ctx_simp_congr", "if_true_left_eq_or", "bool.decidable_exists_bool", "fin.decidable_eq", "cmp_using_eq_eq", "decidable_of_decidable_of_eq", "min_self", "ite_eq_ff_distrib", "if_false_right_eq_and", "ite_eq_tt_distrib", "forall_prop_decidable", "nat.decidable_dvd", "min_le_left", "nat.div_zero", "nat.gcd_def", "list.partition_eq_filter_filter", "le_max_right", "ordering.ite_eq_lt_distrib"]}, {"id": "not", "parentIds": ["ordering.ite_eq_gt_distrib", "partial_order", "eq_ff_of_not_eq_tt", "iff_not_comm", "false_of_a_eq_not_a", "if_ctx_simp_congr_prop", "not_exists", "char.val_of_nat_eq_of_is_valid", "not_imp_of_and_not", "tactic.replace_at", "binder.decidable_eq", "list.not_mem_nil", "not_and_distrib'", "parser.sat", "classical.not_exists_not", "max_add_add_left", "if_t_t", "nat.mod_lt", "list.not_bex_nil", "not_not_em", "print_content", "is_strict_weak_order_of_is_total_preorder", "nat.div_eq_of_lt", "ne_of_mem_of_not_mem", "imp_or_distrib'", "exists_prop_decidable", "if_ctx_simp_congr", "list.decidable_ball", "bool.to_bool_not", "not_and_of_not_left", "decidable.of_not_not", "decidable_of_decidable_of_iff", "and_not_self_iff", "cmp_using_eq_gt", "non_contradictory", "decidable_eq_inl_refl", "classical.or_not", "not_imp", "unused_arguments", "push_neg.not_eq", "linear_ordered_semiring", "classical.by_cases", "classical.by_contradiction", "not_exists_of_forall_not", "lt_of_not_ge'", "nonempty_empty", "eq_ff_eq_not_eq_tt", "le_of_not_ge", "cmp_using_eq_lt", "char.of_nat_eq_of_not_is_valid", "decidable.rec_on_true", "tactic.get_constructors_for", "not_imp_eq_of_eq_false_right", "tactic.mk_assumption_set", "function.inv_fun_on_neg", "tactic.simplify_top_down", "or.by_cases", "decidable_linear_ordered_semiring", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "eq_false_intro", "nat.div_def", "max_self", "irrefl_of", "buffer.take", "nat.not_lt_zero", "not_of_iff_false", "not_lt_of_gt", "tt_eq_ff_eq_false", "push_neg.not_le_eq", "if_false_left_eq_and", "imp_eq_of_eq_false_right", "not_iff_not", "ge_of_forall_ge_sub", "not.elim", "dite.decidable", "if_congr", "ne_true_of_not", "lt_iff_not_ge", "not_lt_of_le", "if_ctx_congr_prop", "max_lt", "classical.or_iff_not_imp_left", "nat.lt_irrefl", "function.update", "non_contradictory_intro", "sub_le_of_abs_sub_le_left", "char.val_of_nat_eq_of_not_is_valid", "set.compl", "true_ne_false", "nat.binary_rec_eq", "tactic.mk_dec_eq_instance", "not_and'", "nat.lt_ge_by_cases", "not_le_of_gt", "dif_pos", "le_min", "not_and_self", "not_or_of_imp", "le_max_left", "implies.decidable", "not_and_self_iff", "lt_of_not_ge", "ne_of_gt", "not_non_contradictory_iff_absurd", "iff_false_right", "decidable_linear_ordered_cancel_comm_monoid", "iff_false_intro", "eq_of_incomp", "decidable.not_lt", "if_pos", "tactic.interactive.unfold_projs", "nat.find_min", "nat.binary_rec_zero", "eq_or_lt_of_not_lt", "not.decidable", "tactic.interactive.generalize_hyp", "function.update_same", "list.filter_cons_of_neg", "not_forall_not", "div_mul_cancel", "push_neg.not_lt_eq", "decidable.lt_by_cases", "list.filter_append", "nat.sub_eq_sub_min", "xor.decidable", "nat.div_def_aux", "lt_min", "ff_eq_tt_eq_false", "asymm", "to_bool_false_eq_ff", "if_true_right_eq_or", "imp_false", "d_array.read_write", "div_self", "not_and_not_right", "nat.mod_eq_of_lt", "if_ctx_congr", "mul_self_lt_mul_self_iff", "false_iff", "nat.mul_self_le_mul_self_iff", "eq_true_of_not_eq_false", "decidable.lt_or_le", "not_true_iff", "is_irrefl", "char.of_nat", "lt_iff_le_not_le", "function.inv_fun_on", "function.inv_fun_on_pos", "to_bool_true_eq_tt", "lint", "of_to_bool_ff", "buffer.drop", "if_simp_congr_prop", "push_neg.not_and_eq", "lt_trans", "not_of_eq_false", "not_not_not_iff", "lt_asymm", "forall_prop_of_false", "lt_of_incomp_of_lt", "linear_ordered_comm_ring", "or.neg_resolve_left", "not_le_of_lt", "array.write'", "nat.mul_mod_mul_left", "not_and", "tactic.interactive.unfold_aux", "list.remove_all", "not.intro", "tactic.lift", "int.lt_irrefl", "gt_irrefl", "not_iff", "nat.mul_self_lt_mul_self_iff", "nat.nat.lt_asymm", "decidable.lt_or_eq_of_le", "classical.not_ball", "classical.exists_cases", "decidable.by_contradiction", "mul_one_div_cancel", "incomp_trans", "decidable_linear_order", "eq_tt_eq_not_eq_ff", "not_lt_of_ge", "decidable.rec_on_false", "asymm_of", "ordered_semiring", "not_lt_iff_eq_or_lt", "function.partial_inv", "print_all_content", "subtype.decidable_eq", "nat.zero_mod", "unsigned.of_nat'", "bool.ff_eq_to_bool_iff", "classical.not_forall", "discrete_linear_ordered_field", "not_lt", "not_of_not_not_not", "strict_weak_order.equiv", "old_conv.interactive.find", "not_and_distrib", "max_le", "buffer.take_right", "or.resolve_right", "not_ball", "dec_em", "le_not_le_of_lt", "linear_ordered_ring", "not_eq_of_eq_false", "min_add_add_left", "classical.prop_complete", "non_contradictory_em", "nat.find", "not_le", "bool_iff_false", "d_array.of_beq_aux_eq_ff", "not_not", "linear_order", "incomp_iff_eq", "push_neg.not_forall_eq", "dif_ctx_congr", "list.lt_eq_not_ge", "classical.strong_indefinite_description", "d_array.write", "to_bool_ff", "not_iff_comm", "not.imp_symm", "by_contradiction", "tactic.suggest.apply_and_solve", "bool.to_bool_and", "one_inv_eq", "classical.or_iff_not_imp_right", "mnot", "le_of_not_gt", "list.of_fn_nth_val", "ne_self_iff_false", "exists_false", "not_exists_not", "array.read'", "tactic.simplify_bottom_up", "of_not_imp", "function.inv_fun_neg", "min_le_right", "sub_lt_of_abs_sub_lt_left", "or_iff_not_and_not", "push_neg.classical.implies_iff_not_or", "not_or", "not_true", "not_false", "le_of_lt", "one_div_mul_cancel", "environment.is_ginductive'", "eq_false_of_not_eq_true", "not_congr", "push_neg.not_implies_eq", "irreflexive", "to_bool_iff", "bool.cond_to_bool", "classical.not_and_distrib", "imp_iff_not_or", "if_simp_congr", "peirce", "irrefl", "conv.interactive.find", "iff_iff_and_or_not_and_not", "not_forall_of_exists_not", "nat.lt_iff_le_not_le", "nat.mod_zero", "lt_irrefl", "string.has_decidable_eq", "d_array.decidable_eq", "ne", "tactic.interactive.simp_intros", "xor", "function.update_noteq", "ne_of_lt", "dif_eq_if", "tactic.interactive.clear_", "tactic.interactive.return_cast", "iff_false_left", "assert", "not_lt_of_lt", "imp_not_comm", "to_bool_ff_iff", "and_iff_not_or_not", "tactic.suggest.process_declaration", "int.lt_iff_le_not_le", "lt_iff_lt_of_le_iff_le", "not_and_of_not_or_not", "ite", "neq_of_not_iff", "strict_weak_order.esymm", "ordering.ite_eq_eq_distrib", "eq_iff_le_not_lt", "imp_or_distrib", "preorder", "list.filter_sublist", "or.neg_resolve_right", "lt_of_le_not_le", "nat.eq_or_lt_of_not_lt", "cmp_compares", "set.diff", "or_iff_not_imp_right", "cmp_swap", "ne.def", "nat.not_succ_le_self", "where.is_in_namespace_nonsynthetic", "eq_tt_of_not_eq_ff", "classical.imp_iff_not_or", "incomp_trans_of", "ordered_comm_group", "strict_weak_order.erefl", "not_iff_self", "dif_neg", "div_eq_one_iff_eq", "if_neg", "not_not_of_not_imp", "tactic.mk_simp_set_core", "forall_not_of_not_exists", "not_false_iff", "exists_prop_of_false", "not_imp_not", "function.cantor_surjective", "not_not_intro", "not_iff_not_of_iff", "bool_eq_false", "decidable", "nat.mod_def_aux", "dif_ctx_simp_congr", "decidable_eq_of_bool_pred", "array.read_eq_read'", "iff.decidable", "nat.mod_add_div", "decidable.em", "sum.lex_inr_inl", "tactic.interactive.refine_one", "decidable.not_and_iff_or_not", "le_of_not_lt", "decidable.le_iff_le_iff_lt_iff_lt", "decidable.not_or_iff_and_not", "if_true_left_eq_or", "rsimp.rsimplify", "and_not_self", "dist_bdd_within_interval", "ordered_cancel_comm_monoid", "environment.in_current_file'", "mul_div_cancel", "cmp_using_eq_eq", "decidable.not_not_iff", "decidable.le_of_not_lt", "list_items", "decidable_linear_ordered_comm_ring", "nat.find_spec", "is_asymm", "lt_or_eq_of_le", "instance_priority", "classical.iff_iff_not_or_and_or_not", "decidable.by_cases", "min_self", "tactic.interactive.extract_goal", "nat.mod_two_eq_zero_or_one", "and.decidable", "push_neg.not_exists_eq", "ite_eq_ff_distrib", "bool.to_bool_or", "push_neg.not_or_eq", "int.decidable_eq", "tactic.interactive.clear_except", "if_eq_of_eq", "sum.decidable_eq", "push_neg.not_not_eq", "mul_mul_div", "not_or_distrib", "if_congr_prop", "array.write_eq_write'", "if_false_right_eq_and", "classical.not_imp_not", "linear_ordered_field", "d_array.read_write_of_ne", "tactic.suggest", "tactic.get_lift_prf", "lt_of_lt_of_incomp", "iff_of_false", "ite_eq_tt_distrib", "not_nonempty_iff_imp_false", "decidable_eq_inr_neg", "not_ball_of_bex_not", "eq_false", "not.imp", "function.partial_inv_of_injective", "nat.mod_def", "strict_weak_order.not_lt_of_equiv'", "forall_prop_decidable", "of_not_not", "lt_of_lt_of_le", "eq_zero_of_one_div_eq_zero", "nat.le_div_iff_mul_le", "not_nonempty_pempty", "lt_iff_lt_of_le_iff_le'", "absurd", "iff_false", "lt_of_le_of_lt", "nat.div_lt_iff_lt_mul", "le_of_not_le", "classical.em", "le_iff_le_iff_lt_iff_lt", "tactic.rename'", "dite", "or_iff_not_imp_left", "min_le_left", "implies_of_if_neg", "not_eq_of_eq_true", "function.cantor_injective", "classical.not_not", "ordered_ring", "not_forall", "or.resolve_left", "list.le", "not_imp_comm", "strict_weak_order.not_lt_of_equiv", "list.le_eq_not_gt", "or.decidable", "is_incomp_trans", "iff_not_self", "lint_mathlib", "nat.min_succ_succ", "rec_subsingleton", "decidable_linear_ordered_comm_group", "lint_all", "nat.cond_to_bool_mod_two", "decidable.to_bool", "not_of_not_imp", "list.partition_eq_filter_filter", "nat.find_x", "mt", "forall_or_distrib_left", "le_max_right", "imp_of_not_imp_not", "not_and_of_not_right", "ordering.ite_eq_lt_distrib", "not_bex", "bool.not_ff", "lt_iff_not_ge'", "function.update_comp"]}, {"id": "propext", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "iff_not_comm", "neg_eq_iff_neg_eq", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "bool.bor_inl", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "norm_num.add_comm_four", "id.is_comm_applicative", "nat.eq_zero_or_eq_succ_pred", "int.le.dest", "norm_num.bit0_add_bit1", "imp_or_distrib'", "add_right_eq_self", "tt_band", "bool.to_bool_not", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "proof_irrel_heq", "is_symm_op_of_is_symm", "list.mem_append_eq", "imp_congr_ctx_eq", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "option.is_lawful_monad", "add_sub_comm", "bnot_eq_ff_eq_eq_tt", "classical.forall_or_distrib", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "int.add_assoc", "not_imp_eq_of_eq_false_right", "list.length_take_le", "except_t.ext", "band_eq_true_eq_eq_tt_and_eq_tt", "function.inv_fun_on_neg", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "eq_false_intro", "norm_num.mul_bit1_helper", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "nat.gcd_succ", "nat.succ_mul_succ_eq", "mul_eq_one_iff_inv_eq", "norm_num.mul_one", "and_eq_of_eq_true_left", "bind_pure", "abs_sub_square", "nat.gcd_zero_left", "push_neg.not_le_eq", "dlist.to_list_cons", "and_eq_of_eq_true_right", "if_false_left_eq_and", "imp_eq_of_eq_false_right", "not_iff_not", "list.length_append", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "bor_ff", "state_t.run_map", "imp_eq_of_eq_false_left", "bxor_self", "exists_add_lt_and_pos_of_lt", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "max_lt", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "list.map_append", "norm_num.add_comm_middle", "option.some_inj", "functor.comp.comp_map", "coe_ff", "fin.mod_def", "dlist.of_list_to_list", "le_min", "option.lift_or_get_is_left_id", "le_max_left", "int.nat_abs_add_neg", "int.sub_nat_nat_elim", "option_t.run_map", "eq_add_neg_of_add_eq", "one_dvd", "forall_congr_eq", "norm_num.add1_zero", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "iff_iff_eq", "div_mul_cancel", "list.length_map", "push_neg.not_lt_eq", "list.filter_append", "nat.sub_mul_mod", "nat.mul_assoc", "lt_min", "nat.succ_add_eq_succ_add", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "norm_num.bit1_add_bit0_helper", "int.neg_succ_of_nat_inj_iff", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "inv_eq_iff_inv_eq", "parser.is_lawful_monad", "function.inv_fun_on_pos", "iff_eq_true_of_eq", "add_mul_self_eq", "add_add_add_comm", "reader_t.is_lawful_monad", "int.coe_nat_lt_coe_nat_iff", "push_neg.not_and_eq", "norm_num.zero_mul", "is_comm_applicative.commutative_map", "imp_eq_true_of_eq", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "add_eq_zero_iff_neg_eq", "norm_num.neg_zero_helper", "neg_mul_comm", "bool.dichotomy", "int.distrib_left", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "add_sub_add_right_eq_sub", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "imp_congr_eq", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "zero_div", "eq_iff_eq_cancel_right", "eq_add_of_add_neg_eq", "nat.add_left_cancel", "nat.zero_mod", "function.injective_prod", "list.append_nil", "and_eq_of_eq_false_right", "sub_sub", "exists_and_distrib_right", "ff_bor", "iff_subst", "bool.forall_bool", "nat.gcd_one_left", "eq_true_intro", "max_le", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "fin.mul_def", "not_eq_of_eq_false", "eq_iff_eq_of_sub_eq_sub", "eq_iff_eq_cancel_left", "sub_sub_assoc_swap", "d_array.of_beq_aux_eq_ff", "push_neg.not_forall_eq", "list.lt_eq_not_ge", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "not_iff_comm", "or_eq_of_eq_true_right", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "id.is_lawful_monad", "eq_inv_of_eq_inv", "not_exists_not", "norm_num.add1_bit1_helper", "add_group.add_right_cancel", "min_le_right", "map_seq", "or_iff_not_and_not", "dvd_trans", "int.mul_pos", "coe_sort_tt", "one_div_mul_cancel", "mul_eq_of_eq_mul_inv", "push_neg.not_implies_eq", "imp_eq_of_eq_true_left", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "and_eq_of_eq_false_left", "state_t.ext", "bool.cond_to_bool", "band_self", "or_eq_of_eq_false_left", "inv_eq_one", "tt_bor", "div_eq_mul_one_div", "iff_iff_and_or_not_and_not", "group.mul_left_cancel", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "bor_tt", "nat.mod_zero", "nat.one_add", "norm_num.bit1_add_bit0", "iff.to_eq", "add_eq_of_eq_add_neg", "comp.pure_seq_eq_map", "list.bex_cons", "int.mul_assoc", "mul_self_sub_mul_self_eq", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "nat.div_le_self", "applicative.pure_seq_eq_map'", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "and_iff_not_or_not", "int.lt_iff_le_not_le", "inv_inj", "nat.left_distrib", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "imp_or_distrib", "int.le_total", "mul_inv_eq_one", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "add_sub", "mul_sub_right_distrib", "bxor_tt", "norm_num.subst_into_prod", "cmp_compares", "or_eq_of_eq_false_right", "seq_bind_eq", "option.mem_to_list", "cmp_swap", "guard_true", "eq_true", "dvd_add", "eq_mul_inv_of_mul_eq", "neg_inj", "and_eq_of_eq", "nat.mul_sub_right_distrib", "or_eq_of_eq", "list.append_assoc", "iff_eq_eq", "pure_id_seq", "div_eq_one_iff_eq", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "nat.gcd_zero_right", "iff_eq_of_eq_true_left", "dvd_refl", "neg_eq_zero", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "array.read_eq_read'", "exists_eq_right'", "seq_map_assoc", "nat.mod_add_div", "norm_num.neg_mul_neg_helper", "prod.ext_iff", "list.nil_bind", "mul_inv_eq_of_eq_mul", "except_t.is_lawful_monad", "dvd_neg_of_dvd", "option.lift_or_get_is_right_id", "bxor_ff", "bool.bor_inr", "if_true_left_eq_or", "div_one", "iff_eq_of_eq_true_right", "eq_sub_of_add_eq'", "int.mul_nonneg", "imp_eq_of_eq_true_right", "eq_inv_of_mul_eq_one", "distrib_three_right", "mul_div_cancel", "cmp_using_eq_eq", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "list.length_map\u2082", "eq_add_of_neg_add_eq", "eq_neg_of_add_eq_zero", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "classical.iff_iff_not_or_and_or_not", "min_self", "norm_num.mul_zero", "norm_num.mk_cong", "mul_sub_left_distrib", "nat.mul_comm", "nat.gcd_rec", "push_neg.not_exists_eq", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.map_map", "norm_num.one_add_bit1_helper", "and.right_comm", "bool.to_bool_or", "push_neg.not_or_eq", "set.is_lawful_functor", "reader_t.ext", "guard_false", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "push_neg.not_not_eq", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "d_array.read_write_of_ne", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "ite_eq_tt_distrib", "ff_band", "option.lift_or_get_assoc", "eq_false", "option_t.is_lawful_monad", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "sub_add", "comp.seq_pure", "nat.div_lt_iff_lt_mul", "list.length_repeat", "sub_eq_iff_eq_add'", "nat.add_le_to_le_sub", "and.congr_right_iff", "eq_sub_iff_add_eq'", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "state_t.is_lawful_monad", "not_eq_of_eq_true", "eq_mul_of_mul_inv_eq", "function.cantor_injective", "or_eq_of_eq_true_left", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "coe_sort_ff", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "bor_eq_true_eq_eq_tt_or_eq_tt", "add_group.add_left_cancel", "tt_bxor", "ordering.ite_eq_lt_distrib", "bool.not_ff", "comp.seq_assoc", "add_neg_eq_zero", "list.cons_bind", "group.mul_right_cancel", "band_eq_false_eq_eq_ff_or_eq_ff", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "function.update_comp", "dlist.to_list_singleton", "forall_or_distrib_right"]}, {"id": "false", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "false_of_a_eq_not_a", "not_exists", "not_imp_of_and_not", "as_false", "binder.decidable_eq", "list.not_mem_nil", "bnot_eq_true_eq_eq_ff", "list.not_bex_nil", "nat.eq_zero_or_eq_succ_pred", "is_strict_weak_order_of_is_total_preorder", "imp_or_distrib'", "nat.one_ne_zero", "nat.lt_le_antisymm", "as_true", "bool.to_bool_not", "decidable.of_not_not", "and_not_self_iff", "cmp_using_eq_gt", "tactic.suggest.head_symbol_match.decidable_eq", "nat.not_succ_le_zero", "bnot_eq_ff_eq_eq_tt", "classical.by_contradiction", "not_exists_of_forall_not", "nonempty_empty", "eq_ff_eq_not_eq_tt", "cmp_using_eq_lt", "decidable.rec_on_true", "not_imp_eq_of_eq_false_right", "int.neg_ne_of_pos", "fin.vne_of_ne", "expr.mk_or_lst", "ne.decidable", "band_eq_true_eq_eq_tt_and_eq_tt", "or.by_cases", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "eq_false_intro", "max_self", "classical.cases", "list.nil_subset", "not_of_iff_false", "classical.type_decidable", "tt_eq_ff_eq_false", "true_iff_false", "is_asymm_of_is_trans_of_is_irrefl", "if_false_left_eq_and", "ne_false_of_self", "imp_eq_of_eq_false_right", "tactic.interactive.solve_by_elim", "ge_of_forall_ge_sub", "int.neg_ne_zero_of_ne", "imp_eq_of_eq_false_left", "ne_true_of_not", "not_lt_of_le", "max_lt", "non_contradictory_intro", "vm_obj_kind.decidable_eq", "classical.cases_true_false", "true_ne_false", "coe_ff", "le_min", "not_and_self", "le_max_left", "int.nat_abs_add_neg", "not_and_self_iff", "ne_of_gt", "tactic.interactive.clear'", "not_non_contradictory_iff_absurd", "iff_false_intro", "false_ne_true", "not.decidable", "list.ne_nil_of_length_eq_succ", "nat.add_self_ne_one", "div_mul_cancel", "mul_ne_zero", "list.filter_append", "lt_min", "ff_eq_tt_eq_false", "to_bool_false_eq_ff", "false_of_ne", "if_true_right_eq_or", "imp_false", "div_self", "not_and_not_right", "nat.mod_eq_of_lt", "false_iff", "bool.to_bool_false", "eq_true_of_not_eq_false", "not_true_iff", "bor_eq_false_eq_eq_ff_and_eq_ff", "nat.lt_of_sub_eq_succ", "to_bool_true_eq_tt", "list.mem_nil_iff", "nat.le_lt_antisymm", "false_iff_true", "not_of_eq_false", "false_implies_iff", "false_or", "lt_of_incomp_of_lt", "not_and", "bool.dichotomy", "int.ne_neg_of_ne", "not.intro", "bool.coe_sort_ff", "int.lt_irrefl", "not_iff", "string.iterator.zero_lt_length_next_to_string_of_has_next", "decidable.by_contradiction", "mul_one_div_cancel", "eq_tt_eq_not_eq_ff", "decidable.rec_on_false", "string.str_ne_str_right", "true_eq_false_of_false", "fin.ne_of_vne", "nat.zero_mod", "set.has_emptyc", "false_of_true_eq_false", "and_eq_of_eq_false_right", "not_of_not_not_not", "nat.bit1_ne_bit0", "eq_false_of_or_eq_false_right", "max_le", "char.ne_of_vne", "string.empty_ne_str", "not_eq_of_eq_false", "ne_zero_of_one_div_ne_zero", "classical.prop_complete", "non_contradictory_em", "one_div_ne_zero", "int.ne_of_lt", "ne.irrefl", "d_array.of_beq_aux_eq_ff", "not.imp_symm", "by_contradiction", "tactic.suggest.apply_and_solve", "bool.to_bool_and", "one_inv_eq", "ne_self_iff_false", "exists_false", "min_le_right", "not_or", "not_true", "not_false", "one_div_mul_cancel", "eq_false_of_not_eq_true", "nat.succ_ne_zero", "empty_relation", "and_eq_of_eq_false_left", "bool.cond_to_bool", "or_false", "or_eq_of_eq_false_left", "not_forall_of_exists_not", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "char.vne_of_ne", "nat.mod_zero", "tactic.solve_by_elim", "lt_irrefl", "nat.div_eq_of_lt_le", "sum.inl_ne_inr", "ne_of_lt", "nat.bit0_ne_one", "nat.le_of_le_of_sub_le_sub_right", "not_lt_of_lt", "imp_not_comm", "tactic.binder_info.has_decidable_eq", "ne.intro", "int.lt_iff_le_not_le", "division_ring.mul_ne_zero", "not_and_of_not_or_not", "neq_of_not_iff", "ordering.ite_eq_eq_distrib", "list.filter_sublist", "cmp_compares", "not", "or_eq_of_eq_false_right", "nat.zero_ne_one", "option.mem_to_list", "cmp_swap", "if_false", "not_iff_self", "if_eq_of_eq_false", "string.str_ne_str_left", "nat.succ_ne_self", "int.neg_succ_lt_zero", "classical.eq_false_or_eq_true", "list.disjoint", "div_eq_one_iff_eq", "not_false_iff", "function.cantor_surjective", "false.elim", "nat.zero_div", "bool.ff_ne_tt", "sum.lex_inr_inl", "empty_wf", "decidable.not_and_iff_or_not", "decidable.not_or_iff_and_not", "if_true_left_eq_or", "classical.eq_true_or_eq_false", "nat.bit1_ne_zero", "and_not_self", "pos_of_one_div_pos", "mul_div_cancel", "cmp_using_eq_eq", "nat.bit1_ne_one", "instance_derive_handler", "d_array.of_beq_eq_ff", "min_self", "eq_one_div_of_mul_eq_one_left", "ne.elim", "eq_one_div_of_mul_eq_one", "ite_eq_ff_distrib", "bool.to_bool_or", "int.decidable_eq", "sum.inr_ne_inl", "guard_false", "sum.decidable_eq", "mul_mul_div", "not_or_distrib", "eq_false_of_or_eq_false_left", "nat.bit1_ne", "if_false_right_eq_and", "d_array.read_write_of_ne", "lt_of_lt_of_incomp", "ite_eq_tt_distrib", "not_nonempty_iff_imp_false", "not_ball_of_bex_not", "eq_false", "nat.bit0_ne_zero", "nat.le_div_iff_mul_le", "not_nonempty_pempty", "absurd", "iff_false", "decidable.false", "and_false", "min_le_left", "nat.bit0_ne", "not_eq_of_eq_true", "function.cantor_injective", "exists_pempty", "nat.div_zero", "or.decidable", "iff_not_self", "division_ring.one_div_neg_eq_neg_one_div", "nat.gcd_def", "nat.cond_to_bool_mod_two", "coe_sort_ff", "false_and", "list.partition_eq_filter_filter", "le_max_right", "bor_eq_true_eq_eq_tt_or_eq_tt", "false_of_true_iff_false", "ordering.ite_eq_lt_distrib", "not_bex", "bool.not_ff", "band_eq_false_eq_eq_ff_or_eq_ff", "nat.eq_zero_of_add_eq_zero_right", "function.update_comp"]}, {"id": "trivial", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "true_and", "bool.bor_inl", "bool.bxor_comm", "bool.coe_bool_iff", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "norm_num.add_comm_four", "id.is_comm_applicative", "nat.eq_zero_or_eq_succ_pred", "int.le.dest", "norm_num.bit0_add_bit1", "imp_or_distrib'", "add_right_eq_self", "tt_band", "bool.to_bool_not", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "option.lift_or_get_comm", "norm_num.mul_bit0", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "option.is_lawful_monad", "add_sub_comm", "ball_true_iff", "bnot_eq_ff_eq_eq_tt", "classical.forall_or_distrib", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "int.add_assoc", "list.length_take_le", "except_t.ext", "band_eq_true_eq_eq_tt_and_eq_tt", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "function.inv_fun_eq", "norm_num.mul_bit1_helper", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "nat.gcd_succ", "bool.band_comm", "nat.succ_mul_succ_eq", "norm_num.mul_one", "bind_pure", "abs_sub_square", "nat.gcd_zero_left", "true_iff_false", "dlist.to_list_cons", "if_false_left_eq_and", "list.length_append", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "bor_ff", "state_t.run_map", "imp_eq_of_eq_false_left", "bxor_self", "exists_add_lt_and_pos_of_lt", "ne_true_of_not", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "max_lt", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "list.map_append", "norm_num.add_comm_middle", "option.some_inj", "functor.comp.comp_map", "true_ne_false", "coe_ff", "fin.mod_def", "dlist.of_list_to_list", "le_min", "option.lift_or_get_is_left_id", "le_max_left", "int.nat_abs_add_neg", "option_t.run_map", "eq_add_neg_of_add_eq", "one_dvd", "false_ne_true", "norm_num.add1_zero", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "iff_true_intro", "div_mul_cancel", "list.length_map", "list.filter_append", "and_true", "nat.sub_mul_mod", "nat.mul_assoc", "lt_min", "nat.succ_add_eq_succ_add", "bool.bxor_iff_ne", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "norm_num.bit1_add_bit0_helper", "int.neg_succ_of_nat_inj_iff", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "parser.is_lawful_monad", "bor_coe_iff", "add_mul_self_eq", "add_add_add_comm", "reader_t.is_lawful_monad", "if_true", "norm_num.zero_mul", "is_comm_applicative.commutative_map", "imp_eq_true_of_eq", "false_iff_true", "int.sub_nat_nat_eq_coe", "int.of_nat_nonneg", "false_implies_iff", "neg_neg_sub_neg", "norm_num.neg_zero_helper", "neg_mul_comm", "bool.dichotomy", "int.distrib_left", "true.inhabited", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "add_sub_add_right_eq_sub", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "zero_div", "bool.band_elim_left", "buffer.lt_aux_2", "eq_add_of_add_neg_eq", "nat.add_left_cancel", "nat.zero_mod", "list.append_nil", "int.zero_lt_one", "false_of_true_eq_false", "bool.eq_tt_of_bnot_eq_ff", "true_implies_iff", "sub_sub", "exists_and_distrib_right", "ff_bor", "bool.forall_bool", "nat.gcd_one_left", "max_le", "bool.eq_tt_of_ne_ff", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "fin.mul_def", "sub_sub_assoc_swap", "bool_iff_false", "bool.eq_ff_of_bnot_eq_tt", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "nat.eq_one_of_dvd_one", "implies_true_iff", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "true_or", "id.is_lawful_monad", "eq_inv_of_eq_inv", "not_exists_not", "norm_num.add1_bit1_helper", "bool.eq_ff_of_ne_tt", "add_group.add_right_cancel", "min_le_right", "map_seq", "dvd_trans", "buffer.lt_aux_3", "int.mul_pos", "not_true", "coe_sort_tt", "one_div_mul_cancel", "eq_false_of_not_eq_true", "mul_eq_of_eq_mul_inv", "imp_eq_of_eq_true_left", "bool.bor_assoc", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "state_t.ext", "bool.cond_to_bool", "band_self", "tt_bor", "div_eq_mul_one_div", "group.mul_left_cancel", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "bor_tt", "nat.mod_zero", "nat.one_add", "norm_num.bit1_add_bit0", "add_eq_of_eq_add_neg", "comp.pure_seq_eq_map", "iff_true", "int.mul_assoc", "mul_self_sub_mul_self_eq", "of_eq_true", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "nat.div_le_self", "applicative.pure_seq_eq_map'", "bool.bxor_bnot_bnot", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "inv_inj", "nat.left_distrib", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "imp_or_distrib", "int.le_total", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "add_sub", "mul_sub_right_distrib", "bxor_tt", "norm_num.subst_into_prod", "cmp_compares", "ordering.or_else_eq_lt", "seq_bind_eq", "option.mem_to_list", "nat.div2_bit", "cmp_swap", "guard_true", "dvd_add", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "of_iff_true", "list.append_assoc", "pure_id_seq", "div_eq_one_iff_eq", "or_true", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "nat.gcd_zero_right", "decidable.true", "dvd_refl", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "array.read_eq_read'", "exists_eq_right'", "seq_map_assoc", "nat.mod_add_div", "norm_num.neg_mul_neg_helper", "list.nil_bind", "mul_inv_eq_of_eq_mul", "except_t.is_lawful_monad", "bool.band_intro", "dvd_neg_of_dvd", "band_coe_iff", "option.lift_or_get_is_right_id", "bxor_ff", "bool.bor_inr", "if_true_left_eq_or", "div_one", "eq_sub_of_add_eq'", "int.mul_nonneg", "classical.exists_true_of_nonempty", "imp_eq_of_eq_true_right", "eq_inv_of_mul_eq_one", "distrib_three_right", "mul_div_cancel", "cmp_using_eq_eq", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "list.length_map\u2082", "eq_add_of_neg_add_eq", "eq_neg_of_add_eq_zero", "bool.band_assoc", "prod.lex_def", "bool.bxor_left_comm", "norm_num.bit1_add_bit1_helper", "bool.band_left_comm", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "int.le.intro_sub", "bool.bor_left_comm", "exists_true_iff_nonempty", "min_self", "norm_num.mul_zero", "norm_num.mk_cong", "nat.mod_two_eq_zero_or_one", "mul_sub_left_distrib", "nat.mul_comm", "nat.gcd_rec", "bool.bxor_bnot_right", "bool.band_elim_right", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.map_map", "norm_num.one_add_bit1_helper", "and.right_comm", "bool.to_bool_or", "reader_t.ext", "imp_true_iff", "guard_false", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "d_array.read_write_of_ne", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "ite_eq_tt_distrib", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "sub_add", "comp.seq_pure", "forall_pempty", "list.length_repeat", "bool.bor_comm", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "state_t.is_lawful_monad", "eq_mul_of_mul_inv_eq", "bool.bxor_bnot_left", "nat.gcd_self", "bxor_coe_iff", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "coe_sort_ff", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "bor_eq_true_eq_eq_tt_or_eq_tt", "add_group.add_left_cancel", "false_of_true_iff_false", "forall_true_iff", "tt_bxor", "ordering.ite_eq_lt_distrib", "bool.not_ff", "comp.seq_assoc", "list.cons_bind", "group.mul_right_cancel", "band_eq_false_eq_eq_ff_or_eq_ff", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "bool.bxor_assoc", "function.update_comp", "dlist.to_list_singleton", "forall_or_distrib_right"]}, {"id": "true", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "add_left_eq_self", "set.univ", "as_false", "sub_eq_sub_iff_sub_eq_sub", "true_and", "bool.bor_inl", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "norm_num.add_comm_four", "id.is_comm_applicative", "nat.eq_zero_or_eq_succ_pred", "int.le.dest", "norm_num.bit0_add_bit1", "imp_or_distrib'", "as_true", "add_right_eq_self", "tt_band", "bool.to_bool_not", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "option.is_lawful_monad", "add_sub_comm", "ball_true_iff", "bnot_eq_ff_eq_eq_tt", "classical.forall_or_distrib", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "int.add_assoc", "list.length_take_le", "except_t.ext", "band_eq_true_eq_eq_tt_and_eq_tt", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "norm_num.mul_bit1_helper", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "classical.cases", "nat.gcd_succ", "nat.succ_mul_succ_eq", "norm_num.mul_one", "and_eq_of_eq_true_left", "bind_pure", "abs_sub_square", "nat.gcd_zero_left", "true_iff_false", "dlist.to_list_cons", "and_eq_of_eq_true_right", "if_false_left_eq_and", "list.length_append", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "bor_ff", "state_t.run_map", "imp_eq_of_eq_false_left", "bxor_self", "exists_add_lt_and_pos_of_lt", "ne_true_of_not", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "imp_self", "max_lt", "tactic.interactive.clear_dependent", "of_heq_true", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "list.map_append", "norm_num.add_comm_middle", "option.some_inj", "functor.comp.comp_map", "classical.cases_true_false", "true_ne_false", "coe_ff", "fin.mod_def", "dlist.of_list_to_list", "le_min", "option.lift_or_get_is_left_id", "le_max_left", "int.nat_abs_add_neg", "option_t.run_map", "eq_add_neg_of_add_eq", "one_dvd", "true_iff", "false_ne_true", "norm_num.add1_zero", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "eq_true_of_and_eq_true_right", "iff_true_intro", "div_mul_cancel", "list.length_map", "list.filter_append", "and_true", "nat.sub_mul_mod", "nat.mul_assoc", "lt_min", "nat.succ_add_eq_succ_add", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "norm_num.bit1_add_bit0_helper", "int.neg_succ_of_nat_inj_iff", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "eq_true_of_not_eq_false", "not_true_iff", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "parser.is_lawful_monad", "to_bool_true_eq_tt", "iff_eq_true_of_eq", "add_mul_self_eq", "add_add_add_comm", "reader_t.is_lawful_monad", "if_true", "norm_num.zero_mul", "is_comm_applicative.commutative_map", "imp_eq_true_of_eq", "false_iff_true", "trivial", "int.sub_nat_nat_eq_coe", "false_implies_iff", "neg_neg_sub_neg", "forall_prop_of_false", "bool.to_bool_true", "norm_num.neg_zero_helper", "neg_mul_comm", "bool.dichotomy", "int.distrib_left", "true.inhabited", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "add_sub_add_right_eq_sub", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "zero_div", "list.decidable_chain", "iff_self", "true_eq_false_of_false", "eq_add_of_add_neg_eq", "nat.add_left_cancel", "nat.zero_mod", "list.append_nil", "false_of_true_eq_false", "true_implies_iff", "sub_sub", "bool.coe_sort_tt", "exists_and_distrib_right", "ff_bor", "bool.forall_bool", "prod.mk.inj_iff", "nat.gcd_one_left", "eq_true_intro", "max_le", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "fin.mul_def", "not_eq_of_eq_false", "sub_sub_assoc_swap", "classical.prop_complete", "forall_2_true_iff", "d_array.of_beq_aux_eq_ff", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "implies_true_iff", "or_eq_of_eq_true_right", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "tactic.local_def_value", "one_inv_eq", "norm_num.one_add_bit1", "true_or", "id.is_lawful_monad", "eq_inv_of_eq_inv", "eq_self_iff_true", "not_exists_not", "norm_num.add1_bit1_helper", "add_group.add_right_cancel", "min_le_right", "map_seq", "dvd_trans", "int.mul_pos", "not_true", "coe_sort_tt", "one_div_mul_cancel", "eq_false_of_not_eq_true", "mul_eq_of_eq_mul_inv", "imp_eq_of_eq_true_left", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "state_t.ext", "bool.cond_to_bool", "band_self", "tt_bor", "div_eq_mul_one_div", "expr.mk_and_lst", "group.mul_left_cancel", "eq_true_of_and_eq_true_left", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "bor_tt", "nat.mod_zero", "nat.one_add", "norm_num.bit1_add_bit0", "add_eq_of_eq_add_neg", "comp.pure_seq_eq_map", "iff_true", "int.mul_assoc", "mul_self_sub_mul_self_eq", "of_eq_true", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "nat.div_le_self", "applicative.pure_seq_eq_map'", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "int.lt_iff_le_not_le", "inv_inj", "nat.left_distrib", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "imp_or_distrib", "list.filter_sublist", "int.le_total", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "add_sub", "mul_sub_right_distrib", "bxor_tt", "norm_num.subst_into_prod", "cmp_compares", "seq_bind_eq", "option.mem_to_list", "cmp_swap", "guard_true", "eq_true", "dvd_add", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "of_iff_true", "list.append_assoc", "classical.eq_false_or_eq_true", "pure_id_seq", "div_eq_one_iff_eq", "or_true", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "not_false_iff", "nat.gcd_zero_right", "iff_eq_of_eq_true_left", "decidable.true", "dvd_refl", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "array.read_eq_read'", "exists_eq_right'", "seq_map_assoc", "nat.mod_add_div", "norm_num.neg_mul_neg_helper", "list.nil_bind", "mul_inv_eq_of_eq_mul", "except_t.is_lawful_monad", "dvd_neg_of_dvd", "option.lift_or_get_is_right_id", "bxor_ff", "bool.bor_inr", "if_true_left_eq_or", "div_one", "classical.eq_true_or_eq_false", "iff_eq_of_eq_true_right", "eq_sub_of_add_eq'", "prop.inhabited", "int.mul_nonneg", "classical.exists_true_of_nonempty", "imp_eq_of_eq_true_right", "eq_inv_of_mul_eq_one", "distrib_three_right", "mul_div_cancel", "heq_self_iff_true", "cmp_using_eq_eq", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "list.length_map\u2082", "eq_add_of_neg_add_eq", "eq_neg_of_add_eq_zero", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "instance_derive_handler", "exists_true_iff_nonempty", "forall_3_true_iff", "min_self", "tactic.interactive.extract_goal", "norm_num.mul_zero", "norm_num.mk_cong", "mul_sub_left_distrib", "nat.mul_comm", "nat.gcd_rec", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.map_map", "norm_num.one_add_bit1_helper", "and.right_comm", "bool.to_bool_or", "reader_t.ext", "imp_true_iff", "guard_false", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "d_array.read_write_of_ne", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "ite_eq_tt_distrib", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "if_eq_of_eq_true", "sub_add", "comp.seq_pure", "forall_pempty", "list.length_repeat", "and.congr_right_iff", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "min_le_left", "state_t.is_lawful_monad", "not_eq_of_eq_true", "eq_mul_of_mul_inv_eq", "or_eq_of_eq_true_left", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "forall_true_iff'", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "coe_sort_ff", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "le_max_right", "bor_eq_true_eq_eq_tt_or_eq_tt", "add_group.add_left_cancel", "false_of_true_iff_false", "forall_true_iff", "tt_bxor", "ordering.ite_eq_lt_distrib", "bool.not_ff", "comp.seq_assoc", "list.cons_bind", "group.mul_right_cancel", "band_eq_false_eq_eq_ff_or_eq_ff", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "function.update_comp", "dlist.to_list_singleton", "forall_or_distrib_right"]}, {"id": "if_true", "parentIds": ["ordering.ite_eq_gt_distrib", "if_false_left_eq_and", "if_true_right_eq_or", "bool.cond_to_bool", "ordering.ite_eq_eq_distrib", "cmp_compares", "cmp_swap", "guard_true", "if_true_left_eq_or", "ite_eq_ff_distrib", "if_false_right_eq_and", "ite_eq_tt_distrib", "nat.gcd_def", "list.partition_eq_filter_filter", "ordering.ite_eq_lt_distrib"]}, {"id": "iff_false_intro", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "nat.eq_zero_or_eq_succ_pred", "imp_or_distrib'", "bool.to_bool_not", "function.update_eq_self", "eq_false_intro", "max_self", "true_iff_false", "if_false_left_eq_and", "max_lt", "le_min", "not_and_self", "le_max_left", "div_mul_cancel", "list.filter_append", "lt_min", "if_true_right_eq_or", "div_self", "nat.mod_eq_of_lt", "false_iff_true", "not_iff", "mul_one_div_cancel", "nat.zero_mod", "max_le", "bool.to_bool_and", "one_inv_eq", "min_le_right", "not_true", "one_div_mul_cancel", "bool.cond_to_bool", "nat.mod_zero", "int.lt_iff_le_not_le", "ordering.ite_eq_eq_distrib", "list.filter_sublist", "cmp_compares", "option.mem_to_list", "cmp_swap", "not_iff_self", "div_eq_one_iff_eq", "if_true_left_eq_or", "and_not_self", "mul_div_cancel", "min_self", "ite_eq_ff_distrib", "bool.to_bool_or", "mul_mul_div", "if_false_right_eq_and", "d_array.read_write_of_ne", "ite_eq_tt_distrib", "nat.le_div_iff_mul_le", "iff_false", "and_false", "min_le_left", "nat.div_zero", "iff_not_self", "nat.gcd_def", "nat.cond_to_bool_mod_two", "false_and", "list.partition_eq_filter_filter", "le_max_right", "ordering.ite_eq_lt_distrib", "function.update_comp"]}, {"id": "dite", "parentIds": ["ordering.ite_eq_gt_distrib", "char.val_of_nat_eq_of_is_valid", "not_and_distrib'", "parser.sat", "imp_or_distrib'", "exists_prop_decidable", "list.decidable_ball", "bool.to_bool_not", "decidable_of_decidable_of_iff", "function.inv_fun_on_neg", "or.by_cases", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "nat.div_def", "max_self", "buffer.take", "if_false_left_eq_and", "dite.decidable", "max_lt", "function.update", "sub_le_of_abs_sub_le_left", "char.val_of_nat_eq_of_not_is_valid", "nat.binary_rec_eq", "dif_pos", "le_min", "not_or_of_imp", "le_max_left", "implies.decidable", "nat.binary_rec_zero", "eq_or_lt_of_not_lt", "not.decidable", "decidable.lt_by_cases", "list.filter_append", "nat.sub_eq_sub_min", "xor.decidable", "nat.div_def_aux", "lt_min", "if_true_right_eq_or", "d_array.read_write", "decidable.lt_or_le", "char.of_nat", "function.inv_fun_on", "function.inv_fun_on_pos", "buffer.drop", "array.write'", "nat.mul_mod_mul_left", "tactic.lift", "decidable.lt_or_eq_of_le", "classical.exists_cases", "decidable.by_contradiction", "function.partial_inv", "unsigned.of_nat'", "not_and_distrib", "max_le", "buffer.take_right", "dif_ctx_congr", "classical.strong_indefinite_description", "d_array.write", "bool.to_bool_and", "list.of_fn_nth_val", "array.read'", "min_le_right", "sub_lt_of_abs_sub_lt_left", "bool.cond_to_bool", "peirce", "iff_iff_and_or_not_and_not", "d_array.decidable_eq", "dif_eq_if", "assert", "ordering.ite_eq_eq_distrib", "list.filter_sublist", "cmp_compares", "cmp_swap", "dif_neg", "nat.mod_def_aux", "dif_ctx_simp_congr", "decidable_eq_of_bool_pred", "array.read_eq_read'", "iff.decidable", "if_true_left_eq_or", "decidable.by_cases", "min_self", "and.decidable", "ite_eq_ff_distrib", "bool.to_bool_or", "array.write_eq_write'", "if_false_right_eq_and", "d_array.read_write_of_ne", "tactic.suggest", "tactic.get_lift_prf", "ite_eq_tt_distrib", "function.partial_inv_of_injective", "nat.mod_def", "forall_prop_decidable", "or_iff_not_imp_left", "min_le_left", "or.decidable", "nat.cond_to_bool_mod_two", "list.partition_eq_filter_filter", "nat.find_x", "forall_or_distrib_left", "le_max_right", "ordering.ite_eq_lt_distrib", "function.update_comp"]}, {"id": "eq.mpr", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "iff_not_comm", "false_of_a_eq_not_a", "abs_add_le_abs_add_abs", "int.neg_succ_of_nat_coe'", "neg_eq_iff_neg_eq", "char.val_of_nat_eq_of_is_valid", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "le_mul_of_div_le", "int.of_nat_ge_zero", "bool.bor_inl", "div_zero", "one_add_one_eq_two", "functor.map_comp_map", "max_add_add_left", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "ne_zero_of_mul_ne_zero_left", "norm_num.add_comm_four", "eq_add_neg_iff_add_eq", "id.is_comm_applicative", "nat.mod_lt", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "nat.eq_zero_or_eq_succ_pred", "min_neg_neg", "int.le.dest", "nat.div_eq_of_lt", "norm_num.bit0_add_bit1", "imp_or_distrib'", "nat.bitwise_zero", "add_right_eq_self", "tt_band", "bool.to_bool_not", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "div_sub_div", "nat.add_mul_mod_self_right", "int.nat_abs_bit1_nonneg_step", "nat.one_lt_bit0", "div_pos_of_neg_of_neg", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "option.is_lawful_monad", "add_sub_comm", "nat.mul_div_mul", "mjoin_map_map", "bnot_eq_ff_eq_eq_tt", "classical.forall_or_distrib", "nat.succ_sub_sub_succ", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "abs_sub_le", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "char.of_nat_eq_of_not_is_valid", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "eq_mul_inv_iff_mul_eq", "int.add_assoc", "nat.mul_div_assoc", "add_midpoint", "array.decidable_eq", "norm_num.bit1_add_one_helper", "list.length_take_le", "except_t.ext", "add_add_sub_cancel", "mul_inv_rev", "band_eq_true_eq_eq_tt_and_eq_tt", "function.inv_fun_on_neg", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "norm_num.mul_bit1_helper", "nat.sub_eq_zero_of_le", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "eq_of_sub_eq_zero", "sub_add_add_cancel", "dlist.to_list_concat", "nat.add_div_left", "eq_of_mul_eq_mul_right", "nat.gcd_succ", "nat.bodd_add_div2", "field.one_div_mul_one_div", "add_sub_cancel'", "int.ne_of_nat_ne_nonneg_case", "nat.succ_mul_succ_eq", "abs_one_div", "nat.add_mul_div_right", "eq.congr_left", "nat.bodd_add", "mul_eq_one_iff_inv_eq", "norm_num.mul_one", "bind_pure", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "nat.gcd_zero_left", "norm_num.subst_into_sum", "sum.elim_injective", "dvd_add_iff_right", "add_sub_sub_cancel", "dlist.to_list_cons", "if_false_left_eq_and", "sub_eq_zero_of_eq", "not_iff_not", "list.length_append", "neg_inj'", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "nat.pow_lt_pow_of_lt_right", "one_div_mul_one_div'", "bor_ff", "int.neg_ne_zero_of_ne", "div_le_div_of_le_of_neg", "field.div_mul_eq_div_mul_one_div", "state_t.run_map", "bxor_self", "exists_add_lt_and_pos_of_lt", "nat.bodd_succ", "div_div_eq_div_mul", "nat.zero_lt_one_add", "neg_mul_eq_neg_mul", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "inv_ne_zero", "mul_div_mul_left'", "max_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.lt_add_of_pos_left", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "reader_t.run_map", "list.map_append", "norm_num.add_comm_middle", "option.some_inj", "nat.shiftr_eq_div_pow", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "char.val_of_nat_eq_of_not_is_valid", "functor.comp.comp_map", "nat.binary_rec_eq", "coe_ff", "fin.mod_def", "div_two_sub_self", "dlist.of_list_to_list", "le_min", "option.lift_or_get_is_left_id", "add_neg_eq_iff_eq_add", "le_max_left", "int.nat_abs_add_neg", "function.inv_fun_eq_of_injective_of_right_inverse", "int.sub_nat_nat_elim", "lt_of_add_lt_add_right", "mul_inv", "option_t.run_map", "nat.mod_two_of_bodd", "eq_add_neg_of_add_eq", "one_dvd", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "nat.binary_rec_zero", "int.lt_add_succ", "norm_num.add1_zero", "max_eq_neg_min_neg_neg", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "nat.sub_eq_iff_eq_add", "one_div_zero", "div_mul_cancel", "list.length_map", "forall_iff_forall_surj", "list.filter_append", "nat.sub_eq_sub_min", "nat.sub_mul_mod", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "mul_div_cancel_left", "lt_min", "add_sub_cancel'_right", "nat.zero_mul", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "nat.bitwise_zero_left", "norm_num.bit1_add_bit0_helper", "dvd_of_mul_right_dvd", "mul_le_mul_of_mul_div_le", "int.neg_succ_of_nat_inj_iff", "mul_zero_lt_mul_inv_of_pos", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "ne_zero_of_mul_ne_zero_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "inv_eq_iff_inv_eq", "int.nat_abs_bit0_step", "parser.is_lawful_monad", "div_mul_le_div_mul_of_div_le_div_pos", "function.inv_fun_on_pos", "int.of_nat_nat_abs_of_nonpos", "nat.shiftl'_sub", "add_mul_self_eq", "norm_num.neg_add_pos_helper2", "add_add_add_comm", "dlist.to_list_append", "reader_t.is_lawful_monad", "int.coe_nat_lt_coe_nat_iff", "neg_add", "norm_num.zero_mul", "nat.mul_le_mul_left", "is_comm_applicative.commutative_map", "div_mul_left", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "nat.add_sub_cancel", "neg_neg_sub_neg", "int.of_nat_sub", "nat.div_le_of_le_mul", "add_eq_zero_iff_neg_eq", "mul_sub_mul_div_mul_neg", "eq_inv_mul_iff_mul_eq", "nat.sub_pos_of_lt", "norm_num.neg_zero_helper", "neg_mul_comm", "add_div_eq_mul_add_div", "nat.mul_mod_mul_left", "bool.dichotomy", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "fish_pipe", "int.distrib_left", "int.lt_irrefl", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "mul_eq_one_iff_eq_inv", "neg_add_eq_iff_eq_add", "nat.mod_le", "neg_add_cancel_right", "nat.add_le_add_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.div_mul_cancel", "nat.eq_zero_of_mul_eq_zero", "add_sub_add_right_eq_sub", "mul_eq_of_eq_inv_mul", "nat.div_eq_of_eq_mul_right", "mul_one_div_cancel", "int.le_antisymm", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "int.eq_one_of_mul_eq_self_left", "zero_div", "abs_nonneg", "list.decidable_chain", "nat.sub_self", "eq_iff_eq_cancel_right", "lt_of_one_lt_div", "field.div_div_div_div_eq", "int.lt_iff_le_and_ne", "eq_add_of_add_neg_eq", "abs_mul", "nat.add_left_cancel", "nat.zero_mod", "function.injective_prod", "list.append_nil", "norm_num.div_add_helper", "mul_inv_eq_iff_eq_mul", "list.qsort_cons", "sub_sub", "nat.add_mod_right", "int.le.intro", "exists_and_distrib_right", "nat.add_sub_add_right", "ff_bor", "add_eq_zero_iff_eq_neg", "nat.le_of_add_le_add_right", "nat.add_sub_cancel_left", "bool.forall_bool", "sub_eq_zero", "mjoin_map_pure", "nat.gcd_one_left", "mul_inv_cancel_left", "neg_add_le_left_of_le_add", "nat.bit_cases_on", "max_le", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "nat.bitwise_swap", "nat.bitwise_zero_right", "min_add_add_right", "int.le_trans", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "fin.mul_def", "eq_iff_eq_of_sub_eq_sub", "nat.bitwise_bit", "eq_iff_eq_cancel_left", "sub_sub_assoc_swap", "min_add_add_left", "nat.dvd_add_iff_right", "neg_of_neg_pos", "one_div_ne_zero", "nat.dvd_sub", "mul_right_inv", "field.div_mul_left", "sub_lt_self", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "norm_num.nonneg_bit0_helper", "sub_sub_sub_cancel_left", "not_iff_comm", "field.div_mul_eq_mul_div_comm", "sub_sub_self", "le_of_mul_le_of_ge_one", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "nat.sub_self_add", "id.is_lawful_monad", "eq_inv_of_eq_inv", "abs_neg", "mul_eq_zero_iff_eq_zero_or_eq_zero", "int.sign_mul_abs", "inv_mul_cancel_left", "nat.sub_one_sub_lt", "div_mul_le_div_mul_of_div_le_div_pos'", "not_exists_not", "norm_num.add1_bit1_helper", "add_neg_cancel_right", "add_group.add_right_cancel", "min_le_right", "map_seq", "or_iff_not_and_not", "dvd_trans", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "norm_num.pos_bit0_helper", "int.mul_pos", "coe_sort_tt", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "norm_num.subst_into_div", "eq_false_of_not_eq_true", "mul_eq_of_eq_mul_inv", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "comp.is_comm_applicative", "state_t.ext", "dvd_mul_of_dvd_right", "bool.cond_to_bool", "band_self", "nat.mul_mod_left", "nat.add_div_right", "div_nonpos_of_nonpos_of_pos", "sub_zero", "inv_eq_one", "tt_bor", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "inv_inj'", "norm_num.nonzero_of_neg_helper", "div_eq_mul_one_div", "div_mul_right", "nat.mul_mod_right", "iff_iff_and_or_not_and_not", "group.mul_left_cancel", "mul_inv'", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "bor_tt", "nat.mod_zero", "nat.one_add", "add_self_div_two", "dvd_mul_of_dvd_left", "div_lt_div_of_lt_of_pos", "norm_num.bit1_add_bit0", "nat.mul_div_left", "sub_add_sub_cancel", "add_eq_of_eq_add_neg", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "comp.pure_seq_eq_map", "one_div_neg_eq_neg_one_div", "int.mul_assoc", "neg_sub", "int.nat_abs_bit1_nonneg", "abs_div", "int.add_le_add_left", "div_mul_eq_div_mul_one_div", "mul_self_sub_mul_self_eq", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "int.eq_nat_abs_of_zero_le", "eq_neg_add_of_add_eq", "add_right_neg", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "nat.sub_add_comm", "nat.succ_sub", "nat.div_le_self", "bit1_zero", "nat.bodd_bit", "one_div_lt_one_div_of_lt", "applicative.pure_seq_eq_map'", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "and_iff_not_or_not", "field.div_mul_right", "char.of_nat_ne_of_ne", "int.lt_iff_le_not_le", "div_nonpos_of_nonneg_of_neg", "inv_inj", "div_div_eq_mul_div", "nat.sub.right_comm", "nat.left_distrib", "division_ring.mul_ne_zero", "nat.mod_self", "le_abs_self", "int.coe_nat_le_coe_nat_of_le", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "int.sign_eq_zero_iff_zero", "eq_of_mul_eq_mul_of_nonzero_left", "norm_num.sub_nat_pos_helper", "imp_or_distrib", "list.filter_sublist", "int.le_total", "mul_inv_eq_one", "nat.add_mod_left", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "add_sub", "nat.test_bit_succ", "mul_sub_right_distrib", "bxor_tt", "nat.bit1_inj", "norm_num.subst_into_prod", "cmp_compares", "division_ring.neg_div_neg_eq", "min_eq_neg_max_neg_neg", "seq_bind_eq", "nat.sub_sub", "option.mem_to_list", "nat.div2_bit", "cmp_swap", "guard_true", "dvd_add", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "one_div_div", "nat.sub_add_min_cancel", "add_neg_cancel_left", "nat.add_le_add_left", "list.append_assoc", "nat.le_of_sub_eq_zero", "neg_add_rev", "nat.mul_self_sub_mul_self_eq", "pure_id_seq", "div_eq_one_iff_eq", "mul_div_mul_left", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "nat.gcd_zero_right", "neg_add_cancel_left", "add_lt_add_right", "nat.div_eq_sub_div", "nat.pow_lt_pow_of_lt_left", "mul_div_mul_right'", "dvd_refl", "mjoin_map_mjoin", "neg_eq_zero", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "array.read_eq_read'", "exists_eq_right'", "div_lt_div_of_pos_of_lt_of_pos", "seq_map_assoc", "nat.mod_add_div", "eq_of_mul_eq_mul_left", "max_add_add_right", "norm_num.neg_mul_neg_helper", "one_div_one_div", "prod.ext_iff", "list.nil_bind", "comp.applicative_comp_id", "sub_self_div_two", "d_array.of_beq_eq_tt", "mul_inv_eq_of_eq_mul", "abs_pos_of_pos", "except_t.is_lawful_monad", "nat.mod_eq_sub_mod", "mul_div_cancel'", "nat.mul_div_cancel_left", "dvd_neg_of_dvd", "nonpos_of_neg_nonneg", "neg_add_lt_left_of_lt_add", "option.lift_or_get_is_right_id", "bxor_ff", "mul_div_mul_right", "two_pos", "bool.bor_inr", "if_true_left_eq_or", "div_one", "eq_sub_of_add_eq'", "inv_eq_of_mul_eq_one", "int.mul_nonneg", "one_div_le_one_div_of_le", "int.to_nat_sub", "nat.div2_succ", "mul_self_eq_mul_self_iff", "dist_bdd_within_interval", "pos_of_neg_neg", "eq_inv_of_mul_eq_one", "add_halves", "field.div_div_eq_mul_div", "neg_div_neg_eq", "distrib_three_right", "mul_div_cancel", "cmp_using_eq_eq", "div_nonneg_of_nonneg_of_pos", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "fish_assoc", "list.length_map\u2082", "eq_add_of_neg_add_eq", "eq.congr_right", "sub_sub_sub_cancel_right", "fish_pure", "norm_num.pos_add_neg_helper", "division_ring.eq_of_one_div_eq_one_div", "eq_neg_of_add_eq_zero", "division_ring.inv_inv", "sub_le_self", "div_mul_eq_mul_div_comm", "neg_div", "nat.div_mul_le_self", "div_div_div_div_eq", "int.eq_one_of_mul_eq_self_right", "eq_of_one_div_eq_one_div", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "int.le.intro_sub", "div_neg_eq_neg_div", "classical.iff_iff_not_or_and_or_not", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "div_sub_div_same", "min_self", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_zero", "norm_num.mk_cong", "eq_one_div_of_mul_eq_one", "mul_sub_left_distrib", "nat.mul_comm", "int.lt.dest", "one_div_add_one_div", "nat.gcd_rec", "norm_num.neg_add_neg_helper", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "abs_sub", "list.map_map", "one_div_le_one_div_of_le_of_neg", "norm_num.one_add_bit1_helper", "and.right_comm", "nat.pred_inj", "bool.to_bool_or", "reader_t.ext", "list.qsort_nil", "guard_false", "neg_mul_eq_mul_neg", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "nat.zero_pow", "norm_num.div_helper", "eq_neg_add_iff_add_eq", "d_array.read_write_of_ne", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "mul_inv_cancel_right", "ite_eq_tt_distrib", "nat.one_mul", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "div_le_of_le_mul", "abs_sub_abs_le_abs_sub", "nonneg_of_neg_nonpos", "nat.add_sub_of_le", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "sub_add_sub_cancel'", "norm_num.div_eq_div_helper", "int.le_nat_abs", "sub_add", "comp.seq_pure", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "list.length_repeat", "sub_eq_iff_eq_add'", "function.left_inverse.comp", "nat.add_le_to_le_sub", "eq_sub_iff_add_eq'", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "min_le_left", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "nat.sub_add_cancel", "neg_eq_of_add_eq_zero", "state_t.is_lawful_monad", "nat.dvd_add_iff_left", "eq_mul_of_mul_inv_eq", "div_mul_div", "nat.bit1_lt_bit0", "nat.mul_mod_mul_right", "div_add_div", "eq_mpr_heq", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "div_two_lt_of_pos", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "add_eq_of_eq_neg_add", "inv_mul_eq_iff_eq_mul", "division_ring.one_div_neg_eq_neg_one_div", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "int.nat_abs_abs", "nat.cond_to_bool_mod_two", "le_of_add_le_add_right", "nat.div_div_eq_div_mul", "coe_sort_ff", "nat.mul_sub_div", "abs_mul_self", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "le_max_right", "bor_eq_true_eq_eq_tt_or_eq_tt", "eq_div_iff_mul_eq", "add_group.add_left_cancel", "tt_bxor", "ordering.ite_eq_lt_distrib", "nat.mod_eq_zero_of_dvd", "add_sub_assoc", "bool.not_ff", "comp.seq_assoc", "add_neg_eq_zero", "list.cons_bind", "group.mul_right_cancel", "nat.add_assoc", "band_eq_false_eq_eq_ff_or_eq_ff", "nat.add_sub_add_left", "div_lt_div_of_mul_sub_mul_div_neg", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "ulift.ext", "function.update_comp", "dlist.to_list_singleton", "forall_or_distrib_right"]}, {"id": "ite", "parentIds": ["ordering.ite_eq_gt_distrib", "option.guard", "tactic.find_if_cond_at", "if_ctx_simp_congr_prop", "tactic.interactive.squeeze_simp", "as_false", "parser.sat", "tactic.strip_prefix", "string.quote", "if_t_t", "nat.div_eq_of_lt", "ite.decidable", "if_ctx_simp_congr", "as_true", "cmp_using_eq_gt", "expr.is_iff", "expr.mk_exists_lst", "tactic.elide.unelide", "to_additive.target_name", "where.trace_namespace", "tactic.cases", "guard", "unused_arguments", "tactic.cc_core", "cmp_using_eq_lt", "tactic.mk_has_sizeof_instance_core", "native.rb_map.add", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.mk_assumption_set", "expr.to_nat", "interaction_monad.orelse'", "where.trace_variables", "tactic.suggest.unfold_head_symbol", "d_array.of_beq_aux_eq_tt", "tactic.rcases_hint", "nat.div_def", "max_self", "transport_multiplicative_to_additive", "restate_axiom", "tactic.interactive.convert", "tactic.get_unused_decl_name", "tactic.interactive.induction", "incorrect_def_lemma", "tactic.interactive.cases_matching", "expr.is_ne", "if_false_left_eq_and", "has_dup", "if_congr", "implies_of_if_pos", "if_ctx_congr_prop", "expr.to_int", "expr.list_local_consts", "max_lt", "tactic.non_dep_prop_hyps", "list.insert", "le_min", "interactive.loc.try_apply", "le_max_left", "if_pos", "expr.is_heq", "smt_tactic.when", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.choose1", "char.to_lower", "lt_min", "tactic.constr_to_prop", "if_true_right_eq_or", "nat.mod_eq_of_lt", "if_ctx_congr", "expr.is_eq", "tactic.apply_auto_param", "lint", "if_simp_congr_prop", "if_true", "tactic.interactive.simp", "environment.is_refl_app", "where.trace_includes", "tactic.suggest.tactic_statement", "tactic.change_with_at", "tactic.unprime", "max", "tactic.lift", "tactic.abstract", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_core_aux", "nat.mk_numeral", "tactic.mk_patterns", "expr.is_false", "nat.zero_mod", "tactic.interactive.library_search", "nat.digit_char", "tactic.intro", "old_conv.find_pattern", "well_founded_tactics.cancel_nat_add_lt", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "max_le", "decidable.has_to_format", "well_founded_tactics.is_psigma_mk", "expr.list_meta_vars", "name.deinternalize_field", "d_array.of_beq_aux_eq_ff", "expr.is_or", "expr.replace_with", "tactic.fold_explicit_args", "min_le_right", "check_unused_arguments", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "environment.get_trusted_decls", "decidable.has_to_string", "print_item_crawl", "bool.cond_to_bool", "if_simp_congr", "tactic.interactive.cases_type", "nat.mod_zero", "tactic.solve_by_elim", "tactic.join_user_simp_lemmas", "tactic.explode_expr", "dif_eq_if", "bool.has_to_format", "set.piecewise", "tactic.suggest.process_declaration", "tactic.rcases", "expr.is_bin_arith_app", "tactic.interactive.constructor_matching", "rsimp.choose", "ordering.ite_eq_eq_distrib", "tactic.injection_with", "tactic.interactive.convert_to", "cmp_compares", "hinst_lemmas.pp", "when", "tactic.interactive.change", "min", "cmp_swap", "guard_true", "if_false", "list_linters", "lint_aux", "tactic.interactive.simp_core", "if_eq_of_eq_false", "if_neg", "tactic.mk_simp_set_core", "monad_except.orelse'", "nat.div_eq_sub_div", "nat.zero_div", "tactic.alias.alias_iff", "conv.interactive.for", "nat.mod_add_div", "tactic.interactive.specialize", "nat.mod_eq_sub_mod", "char.quote_core", "if_true_left_eq_or", "interaction_monad.result.clamp_pos", "incorrect_type_class_argument", "tactic.interactive.clean", "cmp_using", "decidable.has_repr", "lean.parser.parser_orelse", "name_set.filter", "expr.is_not", "tactic.alias.get_alias_target", "cmp_using_eq_eq", "list_items", "smt_tactic.by_contradiction", "tactic.suggest.replace_mvars", "instance_priority", "smt_tactic.by_cases", "instance_derive_handler", "min_self", "native.rb_map.filter", "environment.mfilter", "tactic.local_decls", "tactic.delta_instance", "ite_eq_ff_distrib", "get_checks", "expr.is_eta_expansion_test", "interactive.loc.apply", "guard_false", "if_eq_of_eq", "expr.list_constant", "tactic.interactive.list_cast_of_aux", "where.format_variable", "tactic.interactive.h_generalize", "interactive.param_desc", "if_congr_prop", "if_false_right_eq_and", "ite_eq_tt_distrib", "tactic.explode.entries.add", "saturate_fun", "tactic.rotate_right", "where.get_all_in_namespace", "nat.mod_def", "expr.list_names_with_prefix", "if_eq_of_eq_true", "native.rb_set.filter", "tactic.mk_eq_proof", "min_le_left", "tactic.interactive.suggest", "implies_of_if_neg", "nat.div_zero", "tactic.get_user_simp_lemmas", "derive_struct_ext_lemma", "lint_mathlib", "nat.gcd_def", "ge_or_gt_in_statement", "lint_all", "expr.is_and", "has_inhabited_instance", "list.partition_eq_filter_filter", "tactic.success_if_fail_with_msg", "dup_namespace", "le_max_right", "tactic.apply_opt_param", "expr.of_nat", "ordering.ite_eq_lt_distrib", "expr.contains_constant", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings"]}, {"id": "decidable", "parentIds": ["ordering.ite_eq_gt_distrib", "iff_not_comm", "list.decidable_bex", "int.decidable_lt", "decidable_pred", "if_ctx_simp_congr_prop", "option.decidable_eq_none", "as_false", "binder.decidable_eq", "not_and_distrib'", "punit.decidable_eq", "if_t_t", "imp_or_distrib'", "exists_prop_decidable", "ite.decidable", "if_ctx_simp_congr", "as_true", "list.decidable_ball", "bool.to_bool_not", "decidable.of_not_not", "decidable_of_decidable_of_iff", "decidable_eq_inl_refl", "tactic.suggest.head_symbol_match.decidable_eq", "decidable_of_bool", "not_imp", "guard", "decidable.rec_on_true", "ne.decidable", "or.by_cases", "empty.decidable_eq", "if_false_left_eq_and", "not_iff_not", "dite.decidable", "if_congr", "char.decidable_lt", "implies_of_if_pos", "if_ctx_congr_prop", "list.decidable_mem", "vm_obj_kind.decidable_eq", "dif_pos", "classical.decidable_inhabited", "not_or_of_imp", "implies.decidable", "expr.decidable_rel", "quotient.decidable_eq", "if_pos", "smt_tactic.when", "not.decidable", "not_forall_not", "xor.decidable", "to_bool_false_eq_ff", "if_true_right_eq_or", "d_array.read_write", "not_and_not_right", "if_ctx_congr", "prod_has_decidable_lt", "bool.to_bool_false", "function.decidable_eq_pfun", "to_bool_true_eq_tt", "of_to_bool_ff", "if_simp_congr_prop", "if_true", "decidable_of_iff'", "of_as_true", "option.decidable_exists_mem", "rbnode.color.decidable_eq", "bool.to_bool_true", "bool.of_to_bool_iff", "has_le.le.decidable", "not_iff", "decidable.by_contradiction", "decidable.rec_on_false", "list.decidable_chain", "char.decidable_is_digit", "subtype.decidable_eq", "has_lt.lt.decidable", "bool.ff_eq_to_bool_iff", "decidable.subsingleton", "to_bool_true", "char.decidable_is_punctuation", "decidable_rel", "not_and_distrib", "nat.decidable_lt", "decidable.has_to_format", "not_ball", "dec_em", "char.decidable_is_upper", "not_not", "dif_ctx_congr", "list.decidable_chain'", "to_bool_ff", "not_iff_comm", "not.imp_symm", "by_contradiction", "bool.to_bool_and", "nat.decidable_le", "decidable_of_iff", "coe_decidable_eq", "list.has_decidable_le", "not_exists_not", "fin.decidable_lt", "of_not_imp", "or_iff_not_and_not", "decidable.has_to_string", "to_bool_iff", "bool.cond_to_bool", "imp_iff_not_or", "if_simp_congr", "peirce", "name.lt.decidable_rel", "iff_iff_and_or_not_and_not", "bool.to_bool_coe", "string.has_decidable_eq", "d_array.decidable_eq", "classical.prop_decidable", "dif_eq_if", "assert", "to_bool_ff_iff", "set.piecewise", "tactic.binder_info.has_decidable_eq", "and_iff_not_or_not", "of_to_bool_true", "ite", "ordering.ite_eq_eq_distrib", "imp_or_distrib", "bool.tt_eq_to_bool_iff", "char.decidable_le", "char.decidable_is_lower", "when", "or_iff_not_imp_right", "guard_true", "if_false", "if_eq_of_eq_false", "dif_neg", "bool.decidable_forall_bool", "if_neg", "not_imp_not", "decidable.true", "string.has_decidable_lt", "dif_ctx_simp_congr", "decidable_eq_of_bool_pred", "iff.decidable", "decidable.em", "eq.decidable", "decidable.not_and_iff_or_not", "char.decidable_is_whitespace", "decidable.not_or_iff_and_not", "if_true_left_eq_or", "native.float.decidable_le", "bool.decidable_exists_bool", "decidable.has_repr", "list.has_decidable_lt", "to_bool_congr", "decidable.not_not_iff", "char.decidable_is_alpha", "to_bool_tt", "fin.decidable_le", "decidable_of_decidable_of_eq", "bool.coe_to_bool", "decidable.by_cases", "and.decidable", "ite_eq_ff_distrib", "bool.to_bool_or", "int.decidable_eq", "guard_false", "if_eq_of_eq", "sum.decidable_eq", "list.nodup_decidable", "if_congr_prop", "classical.dec", "if_false_right_eq_and", "d_array.read_write_of_ne", "ite_eq_tt_distrib", "decidable_eq_inr_neg", "forall_prop_decidable", "of_not_not", "native.float.decidable_lt", "if_eq_of_eq_true", "dite", "or_iff_not_imp_left", "decidable.false", "implies_of_if_neg", "not_forall", "not_imp_comm", "or.decidable", "list.decidable_pairwise", "rec_subsingleton", "nat.cond_to_bool_mod_two", "char.decidable_is_alphanum", "decidable.to_bool", "pempty.decidable_eq", "bool.to_bool_eq", "forall_or_distrib_left", "imp_of_not_imp_not", "option.decidable_forall_mem", "ordering.ite_eq_lt_distrib", "int.decidable_le", "forall_or_distrib_right"]}, {"id": "congr_arg", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "char.val_of_nat_eq_of_is_valid", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "bool.bor_inl", "one_add_one_eq_two", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "norm_num.add_comm_four", "id.is_comm_applicative", "nat.eq_zero_or_eq_succ_pred", "int.le.dest", "norm_num.bit0_add_bit1", "imp_or_distrib'", "add_right_eq_self", "tt_band", "bool.to_bool_not", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "div_sub_div", "nat.shiftl'_add", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "option.is_lawful_monad", "add_sub_comm", "mjoin_map_map", "bnot_eq_ff_eq_eq_tt", "classical.forall_or_distrib", "quot.exact", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "int.add_assoc", "list.length_take_le", "except_t.ext", "band_eq_true_eq_eq_tt_and_eq_tt", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "dlist.to_list_concat", "nat.gcd_succ", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "nat.bodd_add", "norm_num.mul_one", "bind_pure", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "nat.gcd_zero_left", "dlist.to_list_cons", "if_false_left_eq_and", "list.length_append", "neg_inj'", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "bor_ff", "mul_right_inj", "state_t.run_map", "option.eq_of_eq_some", "bxor_self", "exists_add_lt_and_pos_of_lt", "nat.bodd_succ", "nat.zero_lt_one_add", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "max_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.le_mul_self", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "list.map_append", "norm_num.add_comm_middle", "option.some_inj", "le_of_neg_le_neg", "nat.shiftr_eq_div_pow", "char.val_of_nat_eq_of_not_is_valid", "functor.comp.comp_map", "nat.binary_rec_eq", "coe_ff", "fin.mod_def", "dlist.of_list_to_list", "function.injective.eq_iff", "le_min", "option.lift_or_get_is_left_id", "le_max_left", "int.nat_abs_add_neg", "option_t.run_map", "nat.mod_two_of_bodd", "eq_add_neg_of_add_eq", "one_dvd", "int.lt_add_succ", "norm_num.add1_zero", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "nat.succ_sub_succ_eq_sub", "div_mul_cancel", "list.length_map", "list.filter_append", "nat.sub_mul_mod", "nat.mul_assoc", "lt_min", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "nat.bitwise_zero_left", "function.injective.of_comp", "nat.add_comm", "norm_num.bit1_add_bit0_helper", "int.neg_succ_of_nat_inj_iff", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "parser.is_lawful_monad", "nat.lt_of_sub_eq_succ", "nat.shiftl'_sub", "norm_num.neg_add_pos_eq_of_eq_add", "add_mul_self_eq", "sum.inl.inj_iff", "add_add_add_comm", "dlist.to_list_append", "reader_t.is_lawful_monad", "norm_num.zero_mul", "is_comm_applicative.commutative_map", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "nat.div_le_of_le_mul", "norm_num.neg_zero_helper", "neg_mul_comm", "funext", "bool.dichotomy", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "fish_pipe", "int.distrib_left", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "mul_eq_one_iff_eq_inv", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.zero_sub", "add_sub_add_right_eq_sub", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "zero_div", "add_left_inj", "nat.lt_add_of_zero_lt_left", "eq_add_of_add_neg_eq", "nat.add_left_cancel", "nat.zero_mod", "list.append_nil", "list.qsort_cons", "sub_sub", "int.le.intro", "exists_and_distrib_right", "ff_bor", "add_eq_zero_iff_eq_neg", "bool.forall_bool", "mjoin_map_pure", "nat.gcd_one_left", "max_le", "nat.bitwise_zero_right", "nat.shiftr_add", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "fin.mul_def", "nat.bitwise_bit", "sub_sub_assoc_swap", "d_array.of_beq_aux_eq_ff", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "norm_num.nonneg_bit0_helper", "sub_sub_self", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "neg_comm_of_comm", "id.is_lawful_monad", "eq_inv_of_eq_inv", "abs_neg", "nat.succ_add", "not_exists_not", "norm_num.add1_bit1_helper", "add_group.add_right_cancel", "min_le_right", "map_seq", "dvd_trans", "norm_num.pos_bit0_helper", "int.mul_pos", "coe_sort_tt", "field.div_mul_div", "one_div_mul_cancel", "mul_eq_of_eq_mul_inv", "mul_right_cancel_iff", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "comp.is_comm_applicative", "state_t.ext", "bool.cond_to_bool", "band_self", "tt_bor", "inv_inj'", "div_eq_mul_one_div", "nat.div_lt_self", "group.mul_left_cancel", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "bor_tt", "nat.mod_zero", "nat.one_add", "nat.bit1_val", "add_self_div_two", "norm_num.bit1_add_bit0", "add_eq_of_eq_add_neg", "comp.pure_seq_eq_map", "int.eq_coe_of_zero_le", "int.mul_assoc", "list.length_map_accumr", "mul_self_sub_mul_self_eq", "nat.bit0_succ_eq", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "nat.div_le_self", "nat.le_of_le_of_sub_le_sub_right", "nat.bodd_bit", "applicative.pure_seq_eq_map'", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "int.lt_iff_le_not_le", "inv_inj", "nat.left_distrib", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "norm_num.sub_nat_pos_helper", "imp_or_distrib", "list.filter_sublist", "int.le_total", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "inv_comm_of_comm", "add_sub", "applicative.ext", "mul_sub_right_distrib", "bxor_tt", "nat.bit1_inj", "norm_num.subst_into_prod", "cmp_compares", "seq_bind_eq", "option.mem_to_list", "function.surjective_comp", "cmp_swap", "guard_true", "dvd_add", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "list.append_assoc", "nat.le_of_sub_eq_zero", "pure_id_seq", "div_eq_one_iff_eq", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "nat.gcd_zero_right", "nat.dvd_of_mod_eq_zero", "dvd_refl", "mjoin_map_mjoin", "add_left_cancel_iff", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "array.read_eq_read'", "exists_eq_right'", "seq_map_assoc", "nat.mod_add_div", "norm_num.neg_mul_neg_helper", "list.nil_bind", "d_array.of_beq_eq_tt", "mul_inv_eq_of_eq_mul", "except_t.is_lawful_monad", "dvd_neg_of_dvd", "option.lift_or_get_is_right_id", "bxor_ff", "two_pos", "d_array.ext'", "bool.bor_inr", "if_true_left_eq_or", "div_one", "eq_sub_of_add_eq'", "int.mul_nonneg", "nat.div2_succ", "d_array.ext", "function.injective_of_left_inverse", "eq_inv_of_mul_eq_one", "add_right_inj", "distrib_three_right", "mul_div_cancel", "cmp_using_eq_eq", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "fish_assoc", "list.length_map\u2082", "eq_add_of_neg_add_eq", "fish_pure", "eq_neg_of_add_eq_zero", "list.length_map_accumr\u2082", "nat.div_mul_le_self", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "classical.iff_iff_not_or_and_or_not", "d_array.of_beq_eq_ff", "min_self", "norm_num.mul_zero", "norm_num.mk_cong", "mul_left_cancel_iff", "mul_sub_left_distrib", "nat.mul_comm", "nat.gcd_rec", "norm_num.neg_add_neg_helper", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.map_map", "norm_num.one_add_bit1_helper", "and.right_comm", "bool.to_bool_or", "reader_t.ext", "guard_false", "nat.bit1_succ_eq", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "int.of_nat_eq_of_nat_iff", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "d_array.read_write_of_ne", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "ite_eq_tt_distrib", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "function.partial_inv_of_injective", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "mul_left_inj", "sub_add", "comp.seq_pure", "nat.div_lt_iff_lt_mul", "list.length_repeat", "and.congr_right_iff", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "nat.zero_add", "min_le_left", "ordered_comm_group.le_of_add_le_add_left", "state_t.is_lawful_monad", "eq_mul_of_mul_inv_eq", "add_right_cancel_iff", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "int.eq_zero_of_nat_abs_eq_zero", "nat.div_zero", "functor.ext", "div_two_lt_of_pos", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "nat.min_succ_succ", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "coe_sort_ff", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "sum.inr.inj_iff", "le_max_right", "bor_eq_true_eq_eq_tt_or_eq_tt", "add_group.add_left_cancel", "nat.div_one", "tt_bxor", "ordering.ite_eq_lt_distrib", "bool.not_ff", "comp.seq_assoc", "list.cons_bind", "group.mul_right_cancel", "band_eq_false_eq_eq_ff_or_eq_ff", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "function.update_comp", "dlist.to_list_singleton", "forall_or_distrib_right"]}, {"id": "if_false", "parentIds": ["ordering.ite_eq_gt_distrib", "if_false_left_eq_and", "if_true_right_eq_or", "bool.cond_to_bool", "ordering.ite_eq_eq_distrib", "cmp_compares", "cmp_swap", "if_true_left_eq_or", "ite_eq_ff_distrib", "guard_false", "if_false_right_eq_and", "ite_eq_tt_distrib", "nat.div_zero", "nat.gcd_def", "list.partition_eq_filter_filter", "ordering.ite_eq_lt_distrib"]}, {"id": "congr", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "char.val_of_nat_eq_of_is_valid", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "bool.bor_inl", "one_add_one_eq_two", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "norm_num.add_comm_four", "id.is_comm_applicative", "nat.eq_zero_or_eq_succ_pred", "int.le.dest", "norm_num.bit0_add_bit1", "imp_or_distrib'", "add_right_eq_self", "tt_band", "bool.to_bool_not", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "div_sub_div", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "option.is_lawful_monad", "add_sub_comm", "mjoin_map_map", "bnot_eq_ff_eq_eq_tt", "classical.forall_or_distrib", "applicative_transformation.preserves_map", "applicative.map_seq_map", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "int.add_assoc", "list.length_take_le", "except_t.ext", "band_eq_true_eq_eq_tt_and_eq_tt", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "dlist.to_list_concat", "nat.gcd_succ", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "nat.bodd_add", "norm_num.mul_one", "bind_pure", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "nat.gcd_zero_left", "dlist.to_list_cons", "if_false_left_eq_and", "list.length_append", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "bor_ff", "state_t.run_map", "bxor_self", "exists_add_lt_and_pos_of_lt", "nat.bodd_succ", "nat.zero_lt_one_add", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "max_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.le_mul_self", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "list.map_append", "norm_num.add_comm_middle", "option.some_inj", "le_of_neg_le_neg", "char.val_of_nat_eq_of_not_is_valid", "functor.comp.comp_map", "nat.binary_rec_eq", "coe_ff", "fin.mod_def", "dlist.of_list_to_list", "le_min", "option.lift_or_get_is_left_id", "le_max_left", "int.nat_abs_add_neg", "option_t.run_map", "nat.mod_two_of_bodd", "eq_add_neg_of_add_eq", "one_dvd", "int.lt_add_succ", "norm_num.add1_zero", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "div_mul_cancel", "list.length_map", "list.filter_append", "nat.sub_mul_mod", "nat.mul_assoc", "lt_min", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "nat.bitwise_zero_left", "norm_num.bit1_add_bit0_helper", "int.neg_succ_of_nat_inj_iff", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "bool.to_bool_false", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "parser.is_lawful_monad", "nat.lt_of_sub_eq_succ", "nat.shiftl'_sub", "norm_num.neg_add_pos_eq_of_eq_add", "add_mul_self_eq", "add_add_add_comm", "dlist.to_list_append", "reader_t.is_lawful_monad", "norm_num.zero_mul", "is_comm_applicative.commutative_map", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "nat.div_le_of_le_mul", "bool.to_bool_true", "norm_num.neg_zero_helper", "neg_mul_comm", "bool.dichotomy", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "fish_pipe", "int.distrib_left", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "mul_eq_one_iff_eq_inv", "congr_arg", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "add_sub_add_right_eq_sub", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "zero_div", "nat.lt_add_of_zero_lt_left", "eq_add_of_add_neg_eq", "nat.add_left_cancel", "nat.zero_mod", "list.append_nil", "list.qsort_cons", "sub_sub", "int.le.intro", "exists_and_distrib_right", "ff_bor", "add_eq_zero_iff_eq_neg", "bool.forall_bool", "mjoin_map_pure", "nat.gcd_one_left", "max_le", "nat.bitwise_zero_right", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "fin.mul_def", "nat.bitwise_bit", "sub_sub_assoc_swap", "d_array.of_beq_aux_eq_ff", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "norm_num.nonneg_bit0_helper", "sub_sub_self", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "id.is_lawful_monad", "eq_inv_of_eq_inv", "abs_neg", "not_exists_not", "norm_num.add1_bit1_helper", "add_group.add_right_cancel", "min_le_right", "map_seq", "dvd_trans", "norm_num.pos_bit0_helper", "int.mul_pos", "coe_sort_tt", "field.div_mul_div", "one_div_mul_cancel", "mul_eq_of_eq_mul_inv", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "comp.is_comm_applicative", "state_t.ext", "bool.cond_to_bool", "band_self", "tt_bor", "div_eq_mul_one_div", "nat.div_lt_self", "group.mul_left_cancel", "bool.to_bool_coe", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "bor_tt", "nat.mod_zero", "nat.one_add", "add_self_div_two", "norm_num.bit1_add_bit0", "add_eq_of_eq_add_neg", "comp.pure_seq_eq_map", "int.eq_coe_of_zero_le", "int.mul_assoc", "mul_self_sub_mul_self_eq", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "nat.div_le_self", "nat.le_of_le_of_sub_le_sub_right", "nat.bodd_bit", "applicative.pure_seq_eq_map'", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "int.lt_iff_le_not_le", "inv_inj", "nat.left_distrib", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "norm_num.sub_nat_pos_helper", "imp_or_distrib", "list.filter_sublist", "int.le_total", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "add_sub", "mul_sub_right_distrib", "bxor_tt", "nat.bit1_inj", "norm_num.subst_into_prod", "cmp_compares", "seq_bind_eq", "option.mem_to_list", "cmp_swap", "guard_true", "dvd_add", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "list.append_assoc", "nat.le_of_sub_eq_zero", "pure_id_seq", "div_eq_one_iff_eq", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "nat.gcd_zero_right", "nat.dvd_of_mod_eq_zero", "dvd_refl", "mjoin_map_mjoin", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "array.read_eq_read'", "exists_eq_right'", "seq_map_assoc", "nat.mod_add_div", "norm_num.neg_mul_neg_helper", "list.nil_bind", "d_array.of_beq_eq_tt", "mul_inv_eq_of_eq_mul", "except_t.is_lawful_monad", "dvd_neg_of_dvd", "option.lift_or_get_is_right_id", "bxor_ff", "two_pos", "bool.bor_inr", "if_true_left_eq_or", "div_one", "eq_sub_of_add_eq'", "int.mul_nonneg", "nat.div2_succ", "eq_inv_of_mul_eq_one", "distrib_three_right", "mul_div_cancel", "cmp_using_eq_eq", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "fish_assoc", "list.length_map\u2082", "eq_add_of_neg_add_eq", "fish_pure", "eq_neg_of_add_eq_zero", "nat.div_mul_le_self", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "classical.iff_iff_not_or_and_or_not", "d_array.of_beq_eq_ff", "min_self", "norm_num.mul_zero", "norm_num.mk_cong", "mul_sub_left_distrib", "nat.mul_comm", "nat.gcd_rec", "norm_num.neg_add_neg_helper", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.map_map", "norm_num.one_add_bit1_helper", "and.right_comm", "bool.to_bool_or", "reader_t.ext", "guard_false", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "d_array.read_write_of_ne", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "ite_eq_tt_distrib", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "sub_add", "comp.seq_pure", "nat.div_lt_iff_lt_mul", "list.length_repeat", "and.congr_right_iff", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "min_le_left", "ordered_comm_group.le_of_add_le_add_left", "state_t.is_lawful_monad", "eq_mul_of_mul_inv_eq", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "functor.ext", "div_two_lt_of_pos", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "coe_sort_ff", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "le_max_right", "bor_eq_true_eq_eq_tt_or_eq_tt", "add_group.add_left_cancel", "nat.div_one", "tt_bxor", "ordering.ite_eq_lt_distrib", "comp.seq_assoc", "list.cons_bind", "group.mul_right_cancel", "band_eq_false_eq_eq_ff_or_eq_ff", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "function.update_comp", "dlist.to_list_singleton", "forall_or_distrib_right"]}, {"id": "if_simp_congr", "parentIds": ["ordering.ite_eq_gt_distrib", "cmp_using_eq_gt", "cmp_using_eq_lt", "d_array.of_beq_aux_eq_tt", "max_self", "if_false_left_eq_and", "max_lt", "le_min", "le_max_left", "lt_min", "if_true_right_eq_or", "nat.mod_eq_of_lt", "nat.zero_mod", "max_le", "d_array.of_beq_aux_eq_ff", "min_le_right", "bool.cond_to_bool", "nat.mod_zero", "ordering.ite_eq_eq_distrib", "cmp_compares", "cmp_swap", "if_true_left_eq_or", "cmp_using_eq_eq", "min_self", "ite_eq_ff_distrib", "if_false_right_eq_and", "ite_eq_tt_distrib", "min_le_left", "nat.div_zero", "nat.gcd_def", "list.partition_eq_filter_filter", "le_max_right", "ordering.ite_eq_lt_distrib"]}, {"id": "iff_true_intro", "parentIds": ["ordering.ite_eq_gt_distrib", "bool.bor_inl", "imp_or_distrib'", "bool.to_bool_not", "ball_true_iff", "list.length_take_le", "max_self", "if_false_left_eq_and", "imp_self", "max_lt", "nat.mul_div_right", "le_min", "le_max_left", "list.filter_append", "nat.sub_mul_mod", "lt_min", "if_true_right_eq_or", "forall_prop_of_false", "not_iff", "string.iterator.zero_lt_length_next_to_string_of_has_next", "iff_self", "bool.forall_bool", "eq_true_intro", "max_le", "bool.to_bool_and", "true_or", "eq_self_iff_true", "min_le_right", "bool.cond_to_bool", "iff_true", "ordering.ite_eq_eq_distrib", "list.filter_sublist", "cmp_compares", "cmp_swap", "or_true", "not_false_iff", "array.read_eq_read'", "bool.bor_inr", "if_true_left_eq_or", "heq_self_iff_true", "prod.lex_def", "min_self", "ite_eq_ff_distrib", "bool.to_bool_or", "imp_true_iff", "array.write_eq_write'", "if_false_right_eq_and", "nat.mod_pow_succ", "ite_eq_tt_distrib", "nat.le_div_iff_mul_le", "and.congr_right_iff", "min_le_left", "forall_true_iff'", "list.partition_eq_filter_filter", "le_max_right", "forall_true_iff", "ordering.ite_eq_lt_distrib"]}, {"id": "eq.trans", "parentIds": ["ordering.ite_eq_gt_distrib", "list.mem_append", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "bool.bor_inl", "int.add_comm", "dlist.to_list_empty", "bnot_eq_true_eq_eq_ff", "norm_num.add_comm_four", "id.is_comm_applicative", "nat.eq_zero_or_eq_succ_pred", "int.le.dest", "norm_num.bit0_add_bit1", "imp_or_distrib'", "add_right_eq_self", "tt_band", "bool.to_bool_not", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "ring.mul_zero", "comp.map_pure", "nat.shiftl_eq_mul_pow", "cmp_using_eq_gt", "option.lift_or_get_comm", "norm_num.mul_bit0", "two_mul", "norm_num.mul_bit0_helper", "option_t.ext", "state_t.run_bind", "option.is_lawful_monad", "add_sub_comm", "mjoin_map_map", "bnot_eq_ff_eq_eq_tt", "classical.forall_or_distrib", "applicative_transformation.preserves_map", "applicative.map_seq_map", "eq_zero_of_zero_dvd", "norm_num.add1_bit1", "eq_ff_eq_not_eq_tt", "add_sub_add_left_eq_sub", "cmp_using_eq_lt", "option.lift_or_get_idem", "functor.add_const.is_lawful_applicative", "mul_right_eq_self", "mul_dvd_mul", "int.add_assoc", "int.le_of_coe_nat_le_coe_nat", "list.length_take_le", "except_t.ext", "band_eq_true_eq_eq_tt_and_eq_tt", "mul_inv_eq", "neg_add_eq_sub", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "dvd_mul_left", "max_self", "eq_zero_of_mul_eq_self_right", "nat.test_bit_bitwise", "dlist.to_list_concat", "nat.gcd_succ", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "nat.bodd_add", "norm_num.mul_one", "bind_pure", "abs_sub_square", "nat.gcd_zero_left", "dlist.to_list_cons", "if_false_left_eq_and", "list.length_append", "dvd_of_mul_left_dvd", "string.iterator.length_next_to_string_next", "bor_ff", "state_t.run_map", "bxor_self", "exists_add_lt_and_pos_of_lt", "nat.bodd_succ", "div_mul_eq_mul_div", "add_neg_eq_of_eq_add", "fin.le_def", "max_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "int.distrib_right", "sum.is_lawful_monad", "nat.mul_div_right", "list.map_append", "norm_num.add_comm_middle", "option.some_inj", "nat.shiftr_eq_div_pow", "functor.comp.comp_map", "coe_ff", "fin.mod_def", "dlist.of_list_to_list", "right_comm", "le_min", "function.injective_of_partial_inv_right", "option.lift_or_get_is_left_id", "le_max_left", "int.nat_abs_add_neg", "option_t.run_map", "nat.mod_two_of_bodd", "eq_add_neg_of_add_eq", "one_dvd", "int.lt_add_succ", "norm_num.add1_zero", "list.length_drop", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "one_div_zero", "div_mul_cancel", "list.length_map", "function.equiv.trans", "list.filter_append", "nat.sub_mul_mod", "nat.mul_assoc", "lt_min", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "if_true_right_eq_or", "d_array.read_write", "div_self", "nat.mod_eq_of_lt", "nat.zero_shiftr", "norm_num.bit1_add_bit0_helper", "int.neg_succ_of_nat_inj_iff", "norm_num.pos_mul_neg_helper", "buffer.read_eq_read'", "bex_imp_distrib", "int.mul_one", "bool.to_bool_false", "int.add_left_neg", "bor_eq_false_eq_eq_ff_and_eq_ff", "parser.is_lawful_monad", "nat.shiftl'_sub", "nat.one_shiftl", "add_mul_self_eq", "add_add_add_comm", "dlist.to_list_append", "reader_t.is_lawful_monad", "norm_num.zero_mul", "is_comm_applicative.commutative_map", "int.sub_nat_nat_eq_coe", "exists_eq_mul_left_of_dvd", "neg_neg_sub_neg", "bool.to_bool_true", "norm_num.neg_zero_helper", "neg_mul_comm", "bool.dichotomy", "nat.bodd_mul", "fish_pipe", "int.distrib_left", "list.map_id", "not_iff", "function.uncurry'_curry", "bor_self", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "add_sub_add_right_eq_sub", "function.injective_of_partial_inv", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "eq_tt_eq_not_eq_ff", "mul_left_eq_self", "except_t.run_map", "zero_div", "eq_add_of_add_neg_eq", "abs_mul", "nat.add_left_cancel", "nat.zero_mod", "list.append_nil", "sub_sub", "int.le.intro", "exists_and_distrib_right", "ff_bor", "nat.bit_decomp", "bool.forall_bool", "prod.mk.inj_iff", "mjoin_map_pure", "nat.gcd_one_left", "max_le", "eq_rec_compose", "list.length_take", "buffer.write_eq_write'", "fin.add_def", "nat.mul_pred_left", "prod.eq_iff_fst_eq_snd_eq", "bind_ext_congr", "fin.mul_def", "sub_sub_assoc_swap", "eq_equivalence", "d_array.of_beq_aux_eq_ff", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "sub_sub_self", "sub_eq_of_eq_add'", "bool.to_bool_and", "neg_dvd_of_dvd", "one_inv_eq", "norm_num.one_add_bit1", "id.is_lawful_monad", "eq_inv_of_eq_inv", "not_exists_not", "norm_num.add1_bit1_helper", "add_group.add_right_cancel", "min_le_right", "map_seq", "dvd_trans", "int.mul_pos", "coe_sort_tt", "field.div_mul_div", "one_div_mul_cancel", "mul_eq_of_eq_mul_inv", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "comp.is_comm_applicative", "state_t.ext", "bool.cond_to_bool", "band_self", "tt_bor", "div_eq_mul_one_div", "nat.div_lt_self", "group.mul_left_cancel", "bool.to_bool_coe", "fin.lt_def", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "bor_tt", "nat.mod_zero", "nat.one_add", "norm_num.bit1_add_bit0", "add_eq_of_eq_add_neg", "comp.pure_seq_eq_map", "int.eq_coe_of_zero_le", "function.left_inverse_of_surjective_of_right_inverse", "int.mul_assoc", "unique_of_exists_unique", "mul_self_sub_mul_self_eq", "functor.const.is_lawful_applicative", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "nat.div_le_self", "nat.bodd_bit", "applicative.pure_seq_eq_map'", "mul_div_assoc", "nat.sub_mul_div", "fin.sub_def", "field.div_mul_right", "int.lt_iff_le_not_le", "quot.eqv_gen_sound", "inv_inj", "nat.left_distrib", "ordering.ite_eq_eq_distrib", "norm_num.bin_zero_add", "imp_or_distrib", "int.le_total", "nat.right_distrib", "list.is_lawful_monad", "map_ext_congr", "add_sub", "applicative.ext", "mul_sub_right_distrib", "bxor_tt", "nat.bit1_inj", "eq_is_equiv", "norm_num.subst_into_prod", "cmp_compares", "seq_bind_eq", "option.mem_to_list", "function.surjective_comp", "cmp_swap", "guard_true", "dvd_add", "eq_mul_inv_of_mul_eq", "neg_inj", "nat.mul_sub_right_distrib", "list.append_assoc", "pure_id_seq", "div_eq_one_iff_eq", "eq_mul_of_inv_mul_eq", "norm_num.bit1_add_bit1", "nat.gcd_zero_right", "nat.dvd_of_mod_eq_zero", "dvd_refl", "mjoin_map_mjoin", "nat.zero_div", "list.append_bind", "sub_add_eq_add_sub", "and.rotate", "array.read_eq_read'", "exists_eq_right'", "seq_map_assoc", "nat.mod_add_div", "norm_num.neg_mul_neg_helper", "list.nil_bind", "mul_inv_eq_of_eq_mul", "except_t.is_lawful_monad", "dvd_neg_of_dvd", "option.lift_or_get_is_right_id", "bxor_ff", "bool.bor_inr", "if_true_left_eq_or", "div_one", "eq_sub_of_add_eq'", "int.mul_nonneg", "nat.div2_succ", "function.injective_of_left_inverse", "eq_inv_of_mul_eq_one", "add_halves", "distrib_three_right", "mul_div_cancel", "cmp_using_eq_eq", "nat.zero_shiftl", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "cond_a_a", "ff_bxor", "fish_assoc", "list.length_map\u2082", "eq_add_of_neg_add_eq", "fish_pure", "eq_neg_of_add_eq_zero", "list.length_map_accumr\u2082", "nat.div_mul_le_self", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "div_neg_eq_neg_div", "classical.iff_iff_not_or_and_or_not", "min_self", "norm_num.mul_zero", "norm_num.mk_cong", "mul_sub_left_distrib", "nat.mul_comm", "nat.gcd_rec", "norm_num.neg_add_neg_helper", "fin.div_def", "ite_eq_ff_distrib", "nat.add_mul_mod_self_left", "list.map_map", "norm_num.one_add_bit1_helper", "and.right_comm", "bool.to_bool_or", "reader_t.ext", "guard_false", "nat.bit1_succ_eq", "band_ff", "norm_num.mul_bit1", "dlist.to_list_of_list", "functor.comp.id_map", "mul_mul_div", "sub_add_eq_sub_sub", "neg_mul_neg", "norm_num.bin_add_zero", "int.mul_comm", "forall_eq'", "array.write_eq_write'", "if_false_right_eq_and", "map_bind", "nat.mod_pow_succ", "d_array.read_write_of_ne", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "ite_eq_tt_distrib", "ff_band", "option.lift_or_get_assoc", "option_t.is_lawful_monad", "abs_sub_abs_le_abs_sub", "function.partial_inv_of_injective", "int.neg_succ_of_nat_lt_zero", "exists_eq_left'", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "sub_add", "comp.seq_pure", "list.length_repeat", "and.congr_right_iff", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "mul_mul_mul_comm", "coe_tt", "min_le_left", "state_t.is_lawful_monad", "eq_mul_of_mul_inv_eq", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "functor.ext", "bnot_bnot", "dvd_zero", "inv_eq_one_div", "division_ring.one_div_neg_eq_neg_one_div", "nat.min_succ_succ", "nat.gcd_def", "band_tt", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "coe_sort_ff", "list.partition_eq_filter_filter", "add_eq_of_eq_sub", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "bool.to_bool_eq", "le_max_right", "bor_eq_true_eq_eq_tt_or_eq_tt", "add_group.add_left_cancel", "nat.div_one", "tt_bxor", "ordering.ite_eq_lt_distrib", "bool.not_ff", "comp.seq_assoc", "list.cons_bind", "group.mul_right_cancel", "band_eq_false_eq_eq_ff_or_eq_ff", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "left_comm", "function.update_comp", "dlist.to_list_singleton", "forall_or_distrib_right"]}, {"id": "partial_order", "parentIds": ["le_iff_lt_or_eq", "decidable.eq_or_lt_of_le", "linear_ordered_semiring", "decidable_linear_ordered_semiring", "lt_of_le_of_ne", "decidable_linear_ordered_cancel_comm_monoid", "linear_ordered_comm_ring", "ordered_cancel_comm_monoid.to_partial_order", "decidable.lt_or_eq_of_le", "decidable_linear_order", "ordered_semiring", "discrete_linear_ordered_field", "decidable_eq_of_decidable_le", "linear_ordered_ring", "decidable.le_iff_lt_or_eq", "eq_of_forall_ge_iff", "linear_order", "linear_order.to_partial_order", "le_antisymm", "partial_order.to_preorder", "eq_iff_le_not_lt", "le_iff_eq_or_lt", "ordered_comm_group", "ordered_comm_group.to_partial_order", "le_antisymm_iff", "ordered_cancel_comm_monoid", "decidable_linear_ordered_comm_ring", "lt_of_le_of_ne'", "lt_or_eq_of_le", "lt_iff_le_and_ne", "eq_or_lt_of_le", "eq_of_forall_le_iff", "linear_ordered_field", "ordered_ring", "decidable_linear_ordered_comm_group"]}, {"id": "preorder.to_has_le", "parentIds": ["partial_order", "abs_add_le_abs_add_abs", "sub_lt_sub_of_lt_of_le", "lt_of_one_div_lt_one_div", "le_mul_of_div_le", "add_lt_add_of_lt_of_le", "max_add_add_left", "le_iff_lt_or_eq", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "add_lt_of_lt_of_nonpos", "le_refl", "decidable.eq_or_lt_of_le", "is_strict_weak_order_of_decidable_linear_order", "add_lt_of_le_of_neg", "nat.pow_le_pow_of_le_left", "le_trans", "le_of_eq", "mul_nonpos_of_nonpos_of_nonneg", "abs_add_three", "add_nonpos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "le_add_of_sub_left_le", "exists_ge_of_linear", "linear_ordered_semiring", "lt_of_not_ge'", "mul_nonneg_of_nonpos_of_nonpos", "abs_sub_le", "le_of_not_ge", "le_add_of_neg_le_sub_right", "mul_le_mul_of_nonneg_right", "list.length_take_le", "zero_le_one", "decidable_linear_ordered_semiring", "lt_add_of_le_of_pos", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "max_self", "neg_le_abs_self", "le_add_of_le_of_nonneg", "one_div_le_of_one_div_le_of_neg", "list.length_le_of_sublist", "one_le_div_of_le", "lt_imp_lt_of_le_imp_le", "sub_le_sub_left", "forall_lt_iff_le", "push_neg.not_le_eq", "sub_left_le_of_le_add", "nonneg_of_mul_nonneg_left", "max_comm", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "le_of_forall_lt'", "one_le_one_div", "lt_iff_not_ge", "le_add_of_nonneg_of_le", "le_or_lt", "not_lt_of_le", "add_le_of_le_neg_add", "max_lt", "nat.le_mul_self", "le_neg_of_le_neg", "ge_trans", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "lt_of_le_of_ne", "max_assoc", "add_lt_of_nonpos_of_lt", "has_le.le.is_total_preorder", "lt_add_of_pos_of_le", "not_le_of_gt", "le_min", "max_eq_right", "le_max_left", "lt_of_not_ge", "decidable_linear_ordered_cancel_comm_monoid", "decidable.not_lt", "eq_or_lt_of_not_lt", "eq_min", "gt_of_ge_of_gt", "push_neg.not_lt_eq", "le_div_of_mul_le", "lt_min", "gt_of_gt_of_ge", "sub_le_of_sub_le", "nat.mod_eq_of_lt", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "lt_of_add_lt_add_left", "decidable.lt_or_le", "lt_iff_le_not_le", "div_mul_le_div_mul_of_div_le_div_pos", "nat.lt_of_sub_eq_succ", "add_neg_of_nonpos_of_neg", "add_le_add_right", "mul_lt_mul", "lt_of_one_div_lt_one_div_of_neg", "lt_add_of_nonneg_of_lt", "lt_trans", "lt_of_mul_lt_mul_right", "min_eq_left", "nat.div_le_of_le_mul", "le_of_eq_or_lt", "linear_ordered_comm_ring", "not_le_of_lt", "max", "mul_self_le_mul_self_iff", "nat.mul_mod_mul_left", "has_le.le.decidable", "le_add_of_neg_le_sub_left", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "decidable.lt_or_eq_of_le", "decidable_linear_order", "pos_of_mul_pos_right", "not_lt_of_ge", "ordered_semiring", "abs_nonneg", "decidable_lt_of_decidable_le", "not_lt_iff_eq_or_lt", "norm_num.nonneg_bit1_helper", "lt_trichotomy", "abs_mul", "neg_le_neg", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "le_of_add_le_add_left", "neg_add_le_right_of_le_add", "min_comm", "add_neg_of_neg_of_nonpos", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "not_lt", "neg_le_sub_left_of_le_add", "decidable.le_imp_le_of_lt_imp_lt", "neg_add_le_left_of_le_add", "max_le", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "decidable_eq_of_decidable_le", "le_not_le_of_lt", "linear_ordered_ring", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "add_le_of_nonpos_of_le", "min_add_add_left", "ge_iff_le", "not_le", "decidable.le_iff_lt_or_eq", "le_of_mul_le_mul_right", "eq_of_forall_ge_iff", "le_of_one_div_le_one_div", "linear_order", "norm_num.nonneg_bit0_helper", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "le_of_not_gt", "le_antisymm", "sub_le_sub_right", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "add_le_add_three", "decidable.le_imp_le_iff_lt_imp_lt", "neg_nonpos_of_nonneg", "le_of_lt_or_eq", "add_pos_of_nonneg_of_pos", "le_of_forall_lt", "neg_of_mul_neg_right", "min_le_right", "sub_lt_of_abs_sub_lt_left", "le_of_lt", "lt_or_ge", "decidable.le_or_lt", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "eq_zero_of_abs_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "neg_le_sub_right_of_le_add", "mul_le_of_div_le_of_neg", "le_implies_le_of_le_of_le", "lt_irrefl", "add_le_add_left", "decidable.lt_trichotomy", "max_eq_left", "gt_of_mul_lt_mul_neg_left", "pos_of_mul_pos_left", "le_add_of_neg_add_le_left", "lt_of_mul_lt_mul_left", "nat.sub_mul_div", "le_imp_le_iff_lt_imp_lt", "div_nonpos_of_nonneg_of_neg", "lt_iff_lt_of_le_iff_le", "le_abs_self", "le_of_forall_le'", "min_assoc", "eq_iff_le_not_lt", "neg_of_mul_neg_left", "abs_of_nonneg", "le_iff_eq_or_lt", "lt_of_le_not_le", "sub_le_of_abs_sub_le_right", "le_of_forall_le", "le_sub_right_of_add_le", "min", "add_nonneg", "eq_zero_of_mul_self_add_mul_self_eq_zero", "ordered_comm_group", "add_lt_add_of_le_of_lt", "nat.le_of_sub_eq_zero", "abs_by_cases", "int.neg_succ_lt_zero", "lt_or_le", "le_add_of_neg_add_le_right", "le_total", "nat.zero_div", "add_le_add", "le_antisymm_iff", "le_of_not_lt", "decidable.le_iff_le_iff_lt_iff_lt", "nonpos_of_neg_nonneg", "two_ge_one", "ordered_ring.mul_le_mul_of_nonneg_left", "one_div_le_one_div_of_le", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "ordered_cancel_comm_monoid", "sub_lt_sub_of_le_of_lt", "div_nonneg_of_nonneg_of_pos", "sub_nonpos_of_le", "decidable.le_of_not_lt", "sub_le_sub", "mul_nonpos_of_nonneg_of_nonpos", "decidable_linear_ordered_comm_ring", "sub_le_self", "lt_of_le_of_ne'", "lt_or_eq_of_le", "lt_iff_le_and_ne", "le_of_sub_nonneg", "mul_self_nonneg", "min_self", "nonpos_of_mul_nonpos_right", "min_eq_right", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "one_div_le_one_div_of_le_of_neg", "le_imp_le_of_lt_imp_lt", "mul_nonneg", "eq_or_lt_of_le", "eq_of_forall_le_iff", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "linear_ordered_field", "abs_abs_sub_abs_le_abs_sub", "div_le_of_le_mul", "abs_sub_abs_le_abs_sub", "nonneg_of_neg_nonpos", "lt_of_lt_of_le", "nat.le_div_iff_mul_le", "lt_iff_lt_of_le_iff_le'", "eq_max", "lt_of_le_of_lt", "int.le_nat_abs", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "neg_nonneg_of_nonpos", "le_of_not_le", "le_iff_le_iff_lt_iff_lt", "mul_lt_mul'", "min_le_left", "ordered_comm_group.le_of_add_le_add_left", "le_or_gt", "ordered_ring", "le_of_sub_nonpos", "le_add_of_nonneg_left", "nat.min_succ_succ", "max_neg_neg", "decidable_linear_ordered_comm_group", "le_of_add_le_add_right", "mul_self_le_mul_self", "le_neg_add_of_add_le", "le_max_right", "forall_lt_iff_le'", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "mul_le_mul", "one_div_le_neg_one", "abs_of_nonpos", "lt_iff_not_ge'", "neg_le_of_neg_le", "mul_le_mul_of_nonpos_right"]}, {"id": "name", "parentIds": ["partial_order", "expr.is_sort", "tactic.rcases.process_constructors", "tactic.interactive.record_lit", "tactic.eval_expr'", "tactic.clear_lst", "interactive.loc.has_reflect", "tactic.simplify", "vm_decl.to_name", "has_sizeof_derive_handler", "name_set.to_list", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "name.has_to_format", "binder.decidable_eq", "environment.is_prefix_of_file", "user_attribute.set_untyped", "expr.local_pp_name", "declaration.is_theorem", "tactic.mk_const", "environment.add_ginductive", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.interactive.format_names", "tactic.instance_cache.get", "get_localized", "tactic.cc_dbg_core", "tactic.delta", "interactive.types.ident_", "tactic.to_simp_lemmas", "expr.is_annotation", "old_conv", "tactic.apply_iff", "auto_param_eq", "tactic.interactive.rsimp", "extensional_attribute", "mk_simp_attr_decl_name", "expr.is_arrow", "tactic.mk_constructor_arg_names", "lean.parser.get_variables", "user_attribute.get_param_untyped", "tactic.copy_attribute", "expr.is_iff", "name_set.mfold", "hinst_lemma.id", "expr.mk_exists_lst", "tactic.rcases_hint.process_constructors", "tactic.injections_with", "options.get_nat", "tactic.elide.unelide", "smt_tactic.definev", "expr.mk_binding", "tactic.mk_mapp", "tactic.open_namespaces", "tactic.is_trace_enabled_for", "tactic.save_const_type_info", "to_additive.target_name", "environment.is_projection", "tactic.rcases.process_constructor", "name_map", "where.trace_namespace", "cc_state.mk_using_hs", "tactic.interactive.field_simp", "tactic.doc_string", "attribute.register", "name.has_append", "tactic.cases", "tactic.existsi", "unused_arguments", "linear_ordered_semiring", "tactic.cc_core", "binder", "tactic.apply_inj_lemma", "mk_definition", "tactic.mk_has_sizeof_instance_core", "expr.macro_def_name", "tactic.get_constructors_for", "tactic.rcases_patt_inverted.inhabited", "tactic.interactive.propagate_tags", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "expr.to_nat", "tactic.instance_cache.append_typeclasses", "tactic.mk_iff_mp_app", "tactic.interactive.loc.get_local_pp_names", "declaration.type", "where.trace_variables", "tactic.mk_brec_on_rec_value", "attribute.get_instances", "where.strip_namespace", "tactic.simplify_top_down", "tactic.suggest.unfold_head_symbol", "decidable_linear_ordered_semiring", "where.mk_flag", "tactic.interactive.guard_tags", "smt_tactic.add_ematch_lhs_lemma_from_decl", "old_conv.failed", "tactic.rcases_hint", "smt_tactic.add_ematch_lemma_from_decl", "simp_attr.pre_smt", "simp_lemmas.rewrite", "tactic.set_basic_attribute", "expr.binding_names", "transport_multiplicative_to_additive", "restate_axiom", "using_smt", "tactic.decl_name", "environment.for_decl_of_imported_module", "conv.lhs", "smt_pre_config.inhabited", "rbmap_of", "name.has_lt", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "expr.local_binding_info", "tactic.interactive.by_contra", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "where.sort_variable_list", "mk_rbtree", "tactic.interactive.min_tac", "tactic.replacer", "tactic.interactive.revert", "expr.is_napp_of", "old_conv.trace", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.interactive.induction", "tactic.interactive.rcases", "environment.inductive_dep_elim", "incorrect_def_lemma", "old_conv.findp", "tactic.symm_apply", "tactic.interactive.unfold_coes", "name_set.of_list", "name.inhabited", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "expr.is_ne", "smt_tactic.interactive.intros", "mk_simple_name", "environment.projection_info.inhabited", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "rbmap.inhabited", "tactic.replace", "tactic.symmetry_hyp", "name_set.has_to_format", "tactic.note", "opt_minus", "old_conv.dsimp", "tactic.transport_with_prefix_fun", "localized_attr", "environment.is_definition", "expr.local_type", "tactic.interactive.split_ifs", "old_conv.istep", "is_lawful_functor", "to_additive.proceed_fields", "tactic.match_app_of", "expr.to_int", "environment.add_inductive", "tactic.interactive.clear_dependent", "old_conv.change", "tactic.interactive.apply_iff_congr_core", "tactic.interactive.rename'_args_parser", "to_additive.value_type", "expr.is_ge", "tactic.left", "tactic.mk_simp_attr", "expr.is_default_local", "tactic.assoc_refl", "rbmap", "vm.call_stack_fn", "tactic.interactive.have_field", "print_decls", "declaration.to_name", "options.set_bool", "environment.is_namespace", "environment.is_inductive", "tactic.dsimp_hyp", "interactive.types.with_ident_list", "ematch_lhs", "smt_tactic.interactive.have", "name_set.contains", "expr.binding_domain", "tactic.mk_dec_eq_instance", "tactic.rcases_patt.name", "vm.get_attribute", "print_localized_commands", "tactic.generalize_proofs", "smt_tactic.when_tracing", "nolint_attr", "register_attribute", "apply_nolint_cmd", "to_additive.parser", "tactic.alias.alias_attr", "tactic.instance_cache.mk_app", "name_set.union", "local_context.mk_local", "functor.const.is_lawful_functor", "tactic.econstructor", "can_lift_attr", "tactic.add_inductive", "expr.binding_body", "tactic.mk_local'", "tactic.interactive.clear'", "options.get_string", "name.append", "decidable_linear_ordered_cancel_comm_monoid", "old_conv.apply_lemmas_core", "tactic.rcases_patt", "tactic.mk_user_fresh_name", "simps_add_projection", "expr.binding_name", "where.collect_implicit_names", "tactic.interactive.lift", "name.get_nth_prefix", "expr.instantiate_locals", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "add_interactive", "expr.is_heq", "local_decl", "old_conv.orelse", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "localized_cmd", "tactic.join_user_simp_lemmas_core", "tactic.choose1", "tactic.assertv_core", "old_conv.to_tactic", "old_conv.conversion", "tactic.extract_def", "tactic.delta_target", "smt_tactic.interactive.add_eqn_lemmas", "old_conv.apply_propext_simp_set", "tactic.interactive.abstract", "simps_tac", "tactic.interactive.apply_field", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "ext_param", "tactic.try_apply_opt_auto_param_for_apply", "tactic.constr_to_prop", "tactic.local_proof", "declaration.value_task", "local_context.get_local_decl", "smt_tactic.pose", "tactic.cc", "interactive.types.without_ident_list", "tactic.interactive.cases_core", "environment.add_namespace", "expr.imp", "name.add_prime", "expr.traverse", "rsimp.config.inhabited", "environment.inductive_num_params", "tactic.ext_simplify_core", "to_additive.value_type.has_reflect", "tactic.choose", "expr.is_constant_of", "expr.is_eta_expansion_of", "expr.is_eq", "tactic.resolve_constant", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "well_founded_tactics.default_dec_tac'", "simp_lemmas.add_congr", "simp_lemmas.add_simp", "options.set_nat", "smt_tactic.interactive.dsimp", "declaration.update_value_task", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.change'", "name.components", "lint", "expr.const_name", "environment.inductive_num_indices", "tactic.interactive.letI", "environment.in_current_file", "tactic.instance_stub", "environment.relation_info", "tactic.interactive.simp", "tactic.in_open_namespaces", "where.get_includes_core", "lean.parser.get_includes", "environment.is_refl_app", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "where.get_namespace_core", "tactic.apply_assumption", "tactic.iff_mp_core", "no_rsimp", "conv.funext", "tactic.suggest.match_head_symbol", "old_conv.match_pattern", "tactic.change_with_at", "where.strip_pi_binders", "tactic.constructor_idx", "tactic.constructor_num_fields", "declaration.is_definition", "tactic.intro1", "linear_ordered_comm_ring", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "old_conv.funext", "rbmap.from_list", "tactic.simp_arg_type.has_reflect", "tactic.interactive.rec.to_tactic_format", "environment.trans_for", "tactic.has_attribute'", "tactic.is_type_app_of", "user_attribute.dflt_cache_cfg", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "tactic.interactive.unfold_aux", "tactic.lift", "simps_add_projections", "expr.mk_delayed_abstraction", "tactic.abstract", "tactic.unsafe.type_context.mk_mvar", "interactive.loc", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "conv.dsimp", "tactic.assert_core", "tactic.interactive.simp_core_aux", "tactic.right", "tactic.def_replacer_cmd", "tactic.mk_patterns", "tactic.mk_replacer\u2082", "tactic.interactive.clear", "tactic.interactive.injection", "expr.is_gt", "smt_tactic.mk_ematch_eqn_lemmas_for_core", "expr.is_false", "name.append_suffix", "expr.is_pi", "decidable_linear_order", "doc_blame_report_defn", "environment.intro_rule", "tactic.fapply", "tactic.assert", "string_to_name", "declaration.to_definition", "ordered_semiring", "tactic.transport_with_prefix_dict", "lean.parser.get_namespace", "tactic.interactive.suffices", "declaration.update_name", "name.replace_prefix", "loc.to_string_aux", "to_additive.map_namespace", "expr.is_mvar", "tactic.get_string_option", "tactic.explode.may_be_proof", "to_additive.value_type.inhabited", "mk_rbmap", "options.fold", "tactic.case_bash", "tactic.elim_gen_prod", "tactic.by_cases", "name.length", "rsimp_attr", "tactic.interactive.library_search", "tactic.add_theorem_by", "tactic.mk_app", "tactic.when_tracing", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.subobject_names", "where.resolve_vars", "tactic.simp_intros_aux", "tactic.interactive.cases_arg_p", "tactic.interactive.rename", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "tactic.get_unused_decl_name_aux", "discrete_linear_ordered_field", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "smt_tactic.add_ematch_eqn_lemmas_for", "name_set.mfilter", "name_set.insert_list", "smt_tactic.interactive.let", "environment.is_ginductive", "expr.reduce_let", "merge_hinst_lemma_attrs", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "tactic.mk_theorem", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.mk_id_eq", "level", "where.trace_opens", "where.find_var", "name.is_private", "tactic.apply_heq_congr_core", "expr.is_lambda", "tactic.mk_constructors_arg_names", "old_conv.lhs", "mk_hinst_lemma_attrs_core", "linear_ordered_ring", "expr.instantiate_univ_params", "name_set.insert", "expr.mk_true", "well_founded_tactics.is_psigma_mk", "environment.structure_fields_full", "name.from_components", "name.deinternalize_field", "smt_tactic.define", "environment.recursor_of", "find_cmd", "declaration.map_value", "tactic.interactive.substs", "tactic.var_names", "tactic.cc_dbg", "tactic.mk_local_pis_whnf", "declaration.update_value", "ematch", "tactic.interactive.assume", "tactic.decl_mk_const", "tactic.interactive.haveI", "library_note_attr", "expr.is_var", "linear_order", "tactic.higher_order_attr", "declaration.is_axiom", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.interactive.compact_decl_aux", "options.get_bool", "tactic.dunfold_target", "smt_tactic.assertv", "tactic.introv", "name.lex_cmp", "environment.get_decl_names", "vm.stack_obj_info", "tactic.suggest.apply_and_solve", "tactic.definev_core", "tactic.mk_local", "simp_attr.functor_norm", "simp_attr.norm", "expr.is_or", "environment.decl_olean", "hinst_lemma.mk_from_decl", "name.to_string", "tactic.revert_and_transform", "name_with_opt", "declaration.value", "tactic.local_def_value", "tactic.simp_arg_type", "name.is_internal", "tactic.comp_val", "tactic.interactive.loc.get_local_uniq_names", "environment.decl_pos", "old_conv.congr_core", "where.get_opens", "level.instantiate", "name_set.erase", "tactic.unsafe.type_context.print_mvars", "apply_nolint_tac", "tactic.interactive.obtain", "expr.is_eta_expansion_aux", "ext_param_type", "where.trace_end", "environment.contains", "interactive.decl_attributes.apply", "tactic.alias.mk_iff_mp_app", "expr.of_int", "tactic.simplify_bottom_up", "tactic.interactive.guard_hyp", "tactic.apply", "name.has_decidable_eq", "old_conv.apply_propext_lemmas_core", "tactic.interactive.generalize", "vm_obj.to_name", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.rcases_patt.inhabited", "environment.is_ginductive'", "print_item_crawl", "declaration.is_constant", "tactic.is_instance", "smt_tactic.execute", "tactic.interactive.transitivity", "tactic.split_ifs", "expr.app_fn", "tactic.ancestor_attr", "tactic.set_nat_option", "tactic.simp_intros", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "derive_handler", "name.lt.decidable_rel", "tactic.define_core", "tactic.interactive.eapply", "interactive.loc.include_goal", "conv.interactive.find", "tactic.interactive.rename'_arg_parser", "tactic.interactive.to_expr'", "get_ext_subject", "smt_tactic.note", "tactic.alias.alias_direct", "tactic.solve_by_elim", "lint_hole_cmd", "environment.projection_info", "expr.is_le", "rsimp.collect_implied_eqs", "to_additive.aux_attr", "tactic.relation_lhs_rhs", "name.has_prefix", "tactic.interactive.simp_intros", "rbtree.from_list", "tactic.dunfold_hyp", "name.append_after", "attribute.fingerprint", "rbtree_of", "tactic.apply_congr_core", "expr.is_let", "where.get_variables_core", "vm.curr_fn", "tactic.interactive.rintro", "simp_lemmas.rewrites", "lean.parser.ident", "tactic.join_user_simp_lemmas", "interactive.inductive_decl", "is_valid_simp_lemma_cnst", "tactic.unset_attribute", "copy_decl_using", "tactic.iff_mpr_core", "tactic.interactive.concat_tags", "smt_config", "tactic.define", "user_attribute.set", "name.head", "smt_config.inhabited", "tactic.by_contradiction", "tactic.interactive.replace", "simp_attr.split_if_reduction", "environment.get", "tactic.find_ancestors", "tactic.interactive.clear_", "environment.refl_for", "tactic.interactive.return_cast", "tactic.has_attribute", "simp_lemmas.erase", "where.resolve_var", "tactic.set_string_option", "environment.is_structure", "tactic.constructor", "smt_tactic.assert", "tactic.match_refl_app", "tactic.suggest.process_declaration", "tactic.interactive.auto_simp_lemma", "tactic.assertv", "tactic.rcases", "expr.is_bin_arith_app", "tactic.fsplit", "expr.abstract_local", "expr.simp", "open_locale_cmd", "tactic.interactive.conv", "expr.dsimp", "tactic.resolve_name", "level.has_param", "simps_parser", "get_linters", "declaration.update_with_fun", "preorder", "environment.is_recursor", "expr.mk_false", "expr.is_aux_decl", "tactic.interactive.intro", "tactic.injection_with", "user_attribute_cache_cfg", "applicative.ext", "tactic.induction", "expr.is_local_constant", "old_conv.apply_simp_set", "binder.inhabited", "tactic.interactive.funext", "get_attribute_cache_dyn", "vm.get_decl", "options.set_string", "tactic.fconstructor", "tactic.rename", "tactic.interactive.change", "environment.get_class_attribute_symbols", "name.last_string", "expr.app_arg", "reflected.subst", "tactic.mk_constructor_fresh_names", "tactic.delta_hyp", "where.is_in_namespace_nonsynthetic", "tactic.interactive.has_to_tactic_format", "list_linters", "ordered_comm_group", "name.map_prefix", "get_hinst_lemmas_for_attr", "declaration.is_auto_generated", "tactic.get_decl", "tactic.interactive.simp_core", "name.has_to_string", "well_founded_tactics.unfold_wf_rel", "declaration.univ_levels", "name.is_prefix_of", "user_attribute", "environment.structure_fields", "structure_instance_info", "tactic.def_replacer", "tactic.injection", "tactic.interactive.conv_rhs", "name.sanitize_name", "to_hinst_lemmas_core", "tactic.mk_simp_set_core", "debugger.attr", "tactic.simp_hyp", "derive_handler_attr", "smt_tactic.intro_lst", "linter.doc_blame", "environment.constructors_of", "expr.is_app", "conv.change", "declaration.get_kind_string", "tactic.cases_core", "loc.to_string", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.ext1", "tactic.mk_local_def", "tactic.interactive.mapply", "get_name_set_for_attr", "tactic.interactive.refine_one", "my_name_to_string", "tactic.prove_goal_async", "tactic.interactive.apply_with", "expr.to_binder", "old_conv.whnf", "environment.for_decl_of_imported_module_name", "options.contains", "tactic.pose", "tactic.funext", "tactic.apply_core", "vm_local_info", "name.lt", "tactic.interactive.fapply", "tactic.get_nat_option", "old_conv.find", "tactic.split", "name.pop_nth_prefix", "name_set.mmap", "tactic.set_bool_option", "tactic.dsimp_target", "name.get_prefix", "where.trace_where", "old_conv.top_down", "old_conv.bind", "tactic.interactive.clean", "expr.is_eta_expansion", "tactic.rcases_patt_inverted", "tactic.simp_all", "cc_config.inhabited", "tactic.mk_fresh_name", "tactic.intro1_aux", "smt_pre_config", "ordered_cancel_comm_monoid", "expr.is_constant", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "tactic.rsimp", "environment.in_current_file'", "conv.interactive.simp", "name_set.filter", "expr.is_not", "interactive.single_inductive_decl.name", "tactic.mk_constructors_fresh_names", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.add_meta_definition", "tactic.get_ancestors", "list_items", "tactic.dunfold", "name.to_string_with_sep", "expr.to_implicit_local_const", "tactic.mk_assoc_instance", "tactic.add_doc_string", "expr.instantiate_local", "tactic.eapplyc", "decidable_linear_ordered_comm_ring", "mk_hinst_lemma_attr_set", "tactic.replace_target", "smt_tactic.by_contradiction", "tactic.mk_replacer", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "tactic.intro_core", "name.update_prefix", "tactic.replacer_core", "instance_priority", "unfolds_to_class", "tactic.interactive.introI", "tactic.interactive.dunfold", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "instance_derive_handler", "name_set.fold", "tactic.inhabited_instance", "rbtree.inhabited", "expr.abstract_locals", "tactic.get_local", "declaration.is_trusted", "declaration", "expr.is_app_of", "pexpr.mk_field_macro", "tactic.interactive.extract_goal", "environment.inductive_type_of", "tactic.get_mathlib_dir", "tactic.simp_arg", "smt_tactic.induction", "tactic.interactive.have", "expr.is_macro", "old_conv.pure", "where.resolve_vars_aux", "tactic.definev", "tactic.interactive.field", "mk_num_name", "is_lawful_monad", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "tactic.add_defn_equations", "tactic.local_decls", "tactic.delta_instance", "smt_tactic.interactive.simp", "hinst_lemma.mk_from_decl_core", "tactic.interactive.injections", "tactic.suggest.head_symbol", "get_checks", "tactic.interactive.clear_except", "expr.is_eta_expansion_test", "auto_param", "expr.apply_replacement_fun", "environment.import_only_until_decl", "tactic.interactive.guard_hyp'", "tactic.mk_inj_eq", "smt_tactic.interactive.change", "tactic.applyc", "smt_tactic.interactive.add_fact", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.triv", "tactic.suggest.decl_data", "tactic.rcases_patt_parse_core", "old_conv.seq", "module_info.module_name", "tactic.decidable_eq_derive_handler", "environment.is_constructor", "where.format_variable", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.mk_id_proof", "tactic.interactive.intros", "tactic.tag", "tactic.funext_lst", "tactic.alias.make_left_right", "linear_ordered_field", "conv.congr", "name.cmp", "where.strip_pi_binders_aux", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "environment.add_defn_eqns", "tactic.funext_core", "saturate_fun", "tactic.interactive.choose", "where.get_all_in_namespace", "mk_hinst_lemma_attr_core", "conv.rhs", "smt_tactic.add_ematch_eqn_lemmas_for_core", "tactic.interactive.source_fields", "interactive.types.using_ident", "environment.import_until_decl", "expr.list_names_with_prefix", "cc_config", "expr.binding_info", "tactic.explode_cmd", "declaration.update_type", "conv.convert", "tactic.find_private_decl", "local_context.get_local", "tactic.interactive.trace_simp_set", "tactic.simp_target", "expr.abstract", "tactic.split_if1", "has_reflect_derive_handler", "tactic.induction'", "where.compile_variable_list", "doc_blame_report_thm", "tactic.mk_eq_proof", "tactic.interactive.introsI", "name.reflect", "tactic.rename'", "tactic.resolve_name'", "mk_str_name", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "tactic.interactive.suggest", "rsimp.config", "tactic.get_unused_name", "interactive.types.location", "tactic.interactive.contrapose", "environment.get_modifiers", "conv.interactive.dsimp", "ordered_ring", "old_conv.fail", "tactic.suggest.library_defs", "environment.symm_for", "tactic.interactive.push_neg", "simp_lemmas.dsimplify", "tactic.get_user_simp_lemmas", "tactic.interactive.conv_lhs", "tactic.get_bool_option", "derive_struct_ext_lemma", "expr.is_lt", "old_conv.map", "lint_mathlib", "tactic.intro_lst", "tactic.reduce_ifs_at", "ge_or_gt_in_statement", "decidable_linear_ordered_comm_group", "lint_all", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "expr.is_and", "has_inhabited_instance", "smt_tactic.interactive.executor", "tactic.interactive.apply", "old_conv.lift_tactic", "tactic.import_private_cmd", "tactic.expanded_field_list", "expr", "tactic.interactive.delta", "name.last", "rbtree", "dup_namespace", "tactic.triv'", "old_conv.mk_match_expr", "tactic.apply_opt_param", "expr.of_nat", "tactic.add_aux_decl", "smt_tactic.add_ematch_lemma_from_decl_core", "is_lawful_applicative", "environment.is_recursive", "name.pop_prefix", "print_name", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.unsafe.type_context.push_local", "user_attribute.get_param", "tactic.get_local_type", "expr.contains_constant", "tactic.mk_simp_set", "expr.local_uniq_name", "tactic.interactive.compact_decl", "tactic.interactive.generalize_proofs", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "expr.to_implicit_binder", "tactic.eapply", "declaration.univ_params", "tactic.interactive.clean_ids", "tactic.get_eqn_lemmas_for", "tactic.note_anon", "tactic.match_fn", "expr.collect_univ_params", "transport_with_dict", "tactic.is_simp_lemma", "old_conv.match_expr", "tactic.generalize"]}, {"id": "preorder", "parentIds": ["partial_order", "preorder.to_has_lt", "le_refl", "le_trans", "le_of_eq", "gt.trans", "linear_ordered_semiring", "decidable_linear_ordered_semiring", "lt_imp_lt_of_le_imp_le", "not_lt_of_le", "ge_trans", "not_le_of_gt", "ne_of_gt", "decidable_linear_ordered_cancel_comm_monoid", "ordering.compares.eq_lt", "gt_of_ge_of_gt", "gt_of_gt_of_ge", "gt_iff_lt", "ordering.compares.eq_gt", "lt.trans", "lt_iff_le_not_le", "lt_trans", "lt_asymm", "le_of_eq_or_lt", "linear_ordered_comm_ring", "not_le_of_lt", "gt_irrefl", "decidable_linear_order", "not_lt_of_ge", "ordered_semiring", "decidable_lt_of_decidable_le", "discrete_linear_ordered_field", "decidable.le_imp_le_of_lt_imp_lt", "le_not_le_of_lt", "linear_ordered_ring", "ge_iff_le", "linear_order", "le_of_lt_or_eq", "partial_order.to_preorder", "le_of_lt", "nat.mod_zero", "le_implies_le_of_le_of_le", "lt_irrefl", "ne_of_lt", "le_of_forall_le'", "lt_of_le_not_le", "le_of_forall_le", "cmp_swap", "ordered_comm_group", "ordered_cancel_comm_monoid", "decidable_linear_ordered_comm_ring", "preorder.to_has_le", "le_imp_le_of_lt_imp_lt", "linear_ordered_field", "lt_of_lt_of_le", "lt_iff_lt_of_le_iff_le'", "lt_of_le_of_lt", "ordered_ring", "nat.div_zero", "ordering.compares.eq_eq", "decidable_linear_ordered_comm_group", "gt_trans"]}, {"id": "and", "parentIds": ["partial_order", "iff_not_comm", "function.bijective_comp", "and.elim_right", "nat.eq_zero_of_add_eq_zero", "char.val_of_nat_eq_of_is_valid", "not_imp_of_and_not", "true_and", "not_and_distrib'", "is_valid_char_range_1", "is_strict_weak_order_of_is_total_preorder", "nat.div_eq_of_lt", "and_imp", "and_or_distrib_left", "or_and_distrib_right", "not_and_of_not_left", "and_not_self_iff", "cmp_using_eq_gt", "exists_prop", "or_and_distrib_left", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "not_imp", "exists_ge_of_linear", "function.left_inverse_surj_inv", "and.imp", "linear_ordered_semiring", "cmp_using_eq_lt", "function.inv_fun_on_eq", "is_valid_char_range_2", "band_eq_true_eq_eq_tt_and_eq_tt", "function.inv_fun_on_neg", "and_iff_left_of_imp", "decidable_linear_ordered_semiring", "d_array.of_beq_aux_eq_tt", "bex_def", "nat.div_def", "function.bijective", "and_eq_of_eq_true_left", "expr.is_napp_of", "dlist.to_list_cons", "and_eq_of_eq_true_right", "if_false_left_eq_and", "not_iff_not", "set.image", "ge_of_forall_ge_sub", "prod.lex.decidable", "and_iff_left", "exists_add_lt_and_pos_of_lt", "and_assoc", "list.map_append", "and_congr", "and.comm", "char.val_of_nat_eq_of_not_is_valid", "and.symm", "tactic.mk_dec_eq_instance", "not_and'", "not_le_of_gt", "not_and_self", "not_and_self_iff", "decidable_linear_ordered_cancel_comm_monoid", "eq_of_incomp", "tactic.interactive.unfold_projs", "nat.find_min", "and.swap", "eq_true_of_and_eq_true_right", "char.to_lower", "and.imp_left", "list.filter_append", "and_true", "nat.div_def_aux", "exists_unique.intro", "not_and_not_right", "nat.mod_eq_of_lt", "list.chain_cons", "prod_has_decidable_lt", "list.choose_x", "exists_unique", "char.of_nat", "lt_iff_le_not_le", "bor_eq_false_eq_eq_ff_and_eq_ff", "function.inv_fun_on", "function.inv_fun_on_pos", "char.is_lower", "lint", "push_neg.not_and_eq", "lt_trans", "exists_of_exists_unique", "or_imp_distrib", "setoid.trans", "and.left_comm", "lt_of_incomp_of_lt", "linear_ordered_comm_ring", "not_le_of_lt", "and_implies", "not_and", "tactic.lift", "list.map_id", "int.add_lt_add_left", "incomp_trans", "decidable_linear_order", "ordered_semiring", "list.decidable_chain", "int.lt_iff_le_and_ne", "and_comm", "nat.zero_mod", "function.injective_prod", "list.append_nil", "and_eq_of_eq_false_right", "discrete_linear_ordered_field", "exists_and_distrib_right", "strict_weak_order.equiv", "bool.forall_bool", "prod.mk.inj_iff", "equivalence", "not_and_distrib", "mk_equivalence", "prod.eq_iff_fst_eq_snd_eq", "le_not_le_of_lt", "linear_ordered_ring", "list.choose", "nat.find", "eq_equivalence", "exists_eq_left", "linear_order", "incomp_iff_eq", "set.inter", "not_iff_comm", "forall_and_distrib", "bool.to_bool_and", "prod.has_lt", "char.is_upper", "and_congr_right", "function.inv_fun_on_mem", "or_iff_not_and_not", "and.elim_left", "prod.lt_def", "le_of_lt", "environment.is_ginductive'", "push_neg.not_implies_eq", "and_eq_of_eq_false_left", "classical.not_and_distrib", "expr.mk_and_lst", "iff_iff_and_or_not_and_not", "exists_eq_right", "exists_unique.elim", "eq_true_of_and_eq_true_left", "nat.lt_iff_le_not_le", "nat.mod_zero", "lt_irrefl", "xor", "prod.ext", "and_or_distrib_right", "and_iff_right_of_imp", "set.sep", "exists_and_distrib_left", "iff_iff_implies_and_implies", "and_iff_right", "and_iff_not_or_not", "int.lt_iff_le_not_le", "char.is_digit", "not_and_of_not_or_not", "strict_weak_order.esymm", "eq_iff_le_not_lt", "preorder", "list.is_lawful_monad", "lt_of_le_not_le", "ordering.or_else_eq_lt", "iff_def", "where.is_in_namespace_nonsynthetic", "setoid.symm", "incomp_trans_of", "ordered_comm_group", "and_eq_of_eq", "declaration.is_auto_generated", "strict_weak_order.erefl", "list.append_assoc", "bool.decidable_forall_bool", "tactic.mk_simp_set_core", "function.involutive.bijective", "nat.div_eq_sub_div", "nat.zero_div", "nat.mod_def_aux", "and.rotate", "exists_eq_right'", "nat.mod_add_div", "le_antisymm_iff", "prod.ext_iff", "decidable.not_and_iff_or_not", "ball_and_distrib", "and_self", "nat.mod_eq_sub_mod", "is_valid_char", "band_coe_iff", "sum.forall", "decidable.not_or_iff_and_not", "and_not_self", "ordered_cancel_comm_monoid", "function.bijective_id", "cmp_using_eq_eq", "list_items", "decidable_linear_ordered_comm_ring", "nat.find_spec", "prod.lex_def", "list.pairwise_cons", "instance_priority", "and.assoc", "lt_iff_le_and_ne", "instance_derive_handler", "classical.iff_iff_not_or_and_or_not", "and.imp_right", "and.decidable", "iff_congr", "iff_def'", "list.ball_cons", "list.map_map", "and.right_comm", "push_neg.not_or_eq", "set.is_lawful_functor", "dlist.to_list_of_list", "not_or_distrib", "interactive.param_desc", "if_false_right_eq_and", "linear_ordered_field", "tactic.suggest", "and.elim", "lt_of_lt_of_incomp", "nonempty_prod", "nonempty_pprod", "nat.mod_def", "strict_weak_order.not_lt_of_equiv'", "lt_of_lt_of_le", "exists_eq_left'", "lt_iff_lt_of_le_iff_le'", "lt_of_le_of_lt", "tactic.find_private_decl", "and.congr_right_iff", "tactic.mk_eq_proof", "imp_and_distrib", "and_false", "ordered_ring", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.div_zero", "strict_weak_order.not_lt_of_equiv", "function.bijective_iff_has_inverse", "is_incomp_trans", "lint_mathlib", "list.decidable_pairwise", "decidable_linear_ordered_comm_group", "lint_all", "tactic.ids_to_simp_arg_list", "false_and", "nat.find_x", "setoid.refl", "not_and_of_not_right", "dlist.to_list_singleton", "exists_unique_congr"]}, {"id": "auto_param", "parentIds": ["partial_order", "auto_param_eq", "linear_ordered_semiring", "decidable_linear_ordered_semiring", "rbmap_of", "mk_rbtree", "rbmap.inhabited", "is_lawful_functor", "rbmap", "functor.const.is_lawful_functor", "decidable_linear_ordered_cancel_comm_monoid", "linear_ordered_comm_ring", "rbmap.from_list", "decidable_linear_order", "ordered_semiring", "mk_rbmap", "discrete_linear_ordered_field", "linear_ordered_ring", "linear_order", "rbtree.from_list", "rbtree_of", "preorder", "applicative.ext", "ordered_comm_group", "user_attribute", "ordered_cancel_comm_monoid", "decidable_linear_ordered_comm_ring", "rbtree.inhabited", "is_lawful_monad", "linear_ordered_field", "ordered_ring", "decidable_linear_ordered_comm_group", "rbtree", "is_lawful_applicative"]}, {"id": "iff", "parentIds": ["partial_order", "list.mem_append", "iff_not_comm", "iff.refl", "neg_eq_iff_neg_eq", "if_ctx_simp_congr_prop", "not_exists", "add_left_eq_self", "dvd_neg_iff_dvd", "list.not_mem_nil", "sub_eq_sub_iff_sub_eq_sub", "true_and", "not_and_distrib'", "classical.not_exists_not", "bool.coe_bool_iff", "le_iff_lt_or_eq", "eq_add_neg_iff_add_eq", "is_strict_weak_order_of_is_total_preorder", "imp_or_distrib'", "and_imp", "if_ctx_simp_congr", "add_right_eq_self", "imp_congr_ctx", "and_or_distrib_left", "or_and_distrib_right", "decidable_of_decidable_of_iff", "and_not_self_iff", "cmp_using_eq_gt", "forall_prop_of_true", "proof_irrel_heq", "is_symm_op_of_is_symm", "eqv_lt_iff_eq", "iff.symm", "nonempty_sum", "nonempty_sigma", "exists_prop", "or_and_distrib_left", "eq_inv_iff_mul_eq_one", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "ball_true_iff", "decidable_of_bool", "not_imp", "classical.forall_or_distrib", "push_neg.not_eq", "linear_ordered_semiring", "not_exists_of_forall_not", "mul_right_eq_self", "eq_mul_inv_iff_mul_eq", "propext", "not_imp_eq_of_eq_false_right", "and_iff_left_of_imp", "decidable_linear_ordered_semiring", "function.update_eq_self", "bex_def", "nonempty_ulift", "max_self", "bex_congr", "nat.sub_sub_self", "list.nil_subset", "not_of_iff_false", "list.mem_append_left", "eq.congr_left", "mul_eq_one_iff_inv_eq", "mul_eq_of_eq_div", "nat.add_le_add_iff_le_right", "true_iff_false", "forall_lt_iff_le", "incorrect_def_lemma", "iff.rfl", "dvd_add_iff_right", "or.assoc", "prod.forall", "imp_eq_of_eq_false_right", "not_iff_not", "neg_inj'", "if_congr", "mul_right_inj", "option.eq_of_eq_some", "imp_eq_of_eq_false_left", "int.coe_nat_le_coe_nat_iff", "and_iff_left", "and_assoc", "lt_iff_not_ge", "imp_self", "if_ctx_congr_prop", "max_lt", "classical.or_iff_not_imp_left", "tactic.mk_iff", "nat.mul_div_right", "option.some_inj", "and_congr", "and.comm", "imp_congr_right", "not_and'", "forall_const", "function.injective.eq_iff", "le_min", "function.injective_of_partial_inv_right", "add_neg_eq_iff_eq_add", "not_and_self", "le_max_left", "ball_congr", "not_and_self_iff", "iff_true_right", "not_non_contradictory_iff_absurd", "iff_false_right", "decidable_linear_ordered_cancel_comm_monoid", "iff_false_intro", "decidable.not_lt", "true_iff", "sub_eq_iff_eq_add", "ordering.compares.eq_lt", "or_iff_right_of_imp", "not_forall_not", "iff_true_intro", "nat.sub_eq_iff_eq_add", "iff_iff_eq", "div_mul_cancel", "forall_iff_forall_surj", "list.filter_append", "and_true", "lt_min", "int.sign_eq_neg_one_iff_neg", "bool.bxor_iff_ne", "imp_false", "d_array.read_write", "div_self", "not_and_not_right", "nat.mod_eq_of_lt", "if_ctx_congr", "gt_iff_lt", "mul_self_lt_mul_self_iff", "false_iff", "list.chain_cons", "int.neg_succ_of_nat_inj_iff", "int.lt_of_coe_nat_lt_coe_nat", "nat.mul_self_le_mul_self_iff", "bex_imp_distrib", "ordering.compares.eq_gt", "decidable.lt_or_le", "eq_inv_iff_eq_inv", "not_true_iff", "lt_iff_le_not_le", "eq.congr", "mul_self_iff_eq_one", "inv_eq_iff_inv_eq", "bor_coe_iff", "nonempty_psigma", "to_bool_true_eq_tt", "imp_iff_right", "ne_iff_lt_or_gt", "iff_eq_true_of_eq", "of_to_bool_ff", "sum.inl.inj_iff", "eq_neg_iff_eq_neg", "if_simp_congr_prop", "bex_or_distrib", "int.coe_nat_lt_coe_nat_iff", "list.mem_nil_iff", "decidable_of_iff'", "list.mem_cons_iff", "imp_eq_true_of_eq", "false_iff_true", "or_imp_distrib", "not_not_not_iff", "false_implies_iff", "false_or", "forall_prop_of_false", "option.is_none_iff_eq_none", "exists_or_distrib", "add_eq_zero_iff_neg_eq", "and.left_comm", "linear_ordered_comm_ring", "eq_inv_mul_iff_mul_eq", "mul_self_le_mul_self_iff", "add_self_iff_eq_zero", "add_div_eq_mul_add_div", "not_and", "ne_comm", "list.mem_append_right", "bool.of_to_bool_iff", "iff_of_true", "int.add_lt_add_left", "not_iff", "mul_eq_one_iff_eq_inv", "nat.mul_self_lt_mul_self_iff", "neg_add_eq_iff_eq_add", "classical.not_ball", "eq_comm", "function.injective_of_partial_inv", "inv_ne_one", "mul_one_div_cancel", "decidable_linear_order", "mul_left_eq_self", "int.sign_eq_one_iff_pos", "add_left_inj", "ordered_semiring", "iff_self", "not_lt_iff_eq_or_lt", "eq_iff_eq_cancel_right", "int.lt_iff_le_and_ne", "or_iff_left_of_imp", "and_comm", "nat.zero_mod", "bool.ff_eq_to_bool_iff", "function.is_partial_inv", "mul_inv_eq_iff_eq_mul", "true_implies_iff", "classical.not_forall", "imp_congr", "to_bool_true", "discrete_linear_ordered_field", "classical.skolem", "exists_and_distrib_right", "not_lt", "add_eq_zero_iff_eq_neg", "iff_subst", "bool.forall_bool", "prod.mk.inj_iff", "eq_div_of_mul_eq", "sub_eq_zero", "not_and_distrib", "max_le", "not_ball", "prod.eq_iff_fst_eq_snd_eq", "le_not_le_of_lt", "or.left_comm", "linear_ordered_ring", "sum.lex_inl_inl", "sub_ne_zero", "eq_iff_eq_of_sub_eq_sub", "eq_iff_eq_cancel_left", "nat.dvd_add_iff_right", "or.comm", "ge_iff_le", "forall_2_true_iff", "not_le", "nat.dvd_mod_iff", "forall_eq", "nat.dvd_sub", "bool_iff_false", "decidable.le_iff_lt_or_eq", "nonempty_Prop", "exists_eq_left", "eq_of_forall_ge_iff", "function.surjective_iff_has_right_inverse", "not_not", "linear_order", "incomp_iff_eq", "dif_ctx_congr", "to_bool_ff", "not_iff_comm", "implies_true_iff", "forall_and_distrib", "iff.trans", "one_inv_eq", "iff_of_eq", "decidable_of_iff", "true_or", "neg_dvd_iff_dvd", "classical.or_iff_not_imp_right", "mul_eq_zero_iff_eq_zero_or_eq_zero", "ne_self_iff_false", "eq_self_iff_true", "not_exists_not", "decidable.le_imp_le_iff_lt_imp_lt", "and_congr_right", "min_le_right", "or_iff_not_and_not", "push_neg.classical.implies_iff_not_or", "forall_congr", "imp.swap", "not_true", "one_div_mul_cancel", "not_congr", "imp_eq_of_eq_true_left", "classical.forall_or_distrib_left", "mul_right_cancel_iff", "to_bool_iff", "classical.not_and_distrib", "eq_of_inv_eq_inv", "imp_iff_not_or", "if_simp_congr", "or_false", "inv_eq_one", "inv_inj'", "nat.div_lt_self", "iff_iff_and_or_not_and_not", "exists_eq_right", "nat.lt_iff_le_not_le", "classical.forall_or_distrib_right", "int.coe_nat_lt_coe_nat_of_lt", "nat.mod_zero", "add_self_div_two", "eq_neg_iff_add_eq_zero", "list.tfae", "iff.to_eq", "list.bex_cons", "nat.div_eq_of_lt_le", "iff_true", "int.coe_nat_eq_coe_nat_iff", "prod.ext", "nat.dvd_iff_mod_eq_zero", "and_or_distrib_right", "nonempty_subtype", "and_iff_right_of_imp", "sum.lex_inr_inr", "nat.sub_add_comm", "exists_and_distrib_left", "iff_false_left", "iff_iff_implies_and_implies", "bool.exists_bool", "imp_not_comm", "function.injective_iff_has_left_inverse", "to_bool_ff_iff", "le_imp_le_iff_lt_imp_lt", "and_iff_right", "and_iff_not_or_not", "int.lt_iff_le_not_le", "exists_prop_of_true", "lt_iff_lt_of_le_iff_le", "of_to_bool_true", "neq_of_not_iff", "int.sign_eq_zero_iff_zero", "eq_iff_le_not_lt", "imp_or_distrib", "preorder", "list.filter_sublist", "eq_iff_iff", "bool.tt_eq_to_bool_iff", "mul_inv_eq_one", "le_iff_eq_or_lt", "lt_of_le_not_le", "ordering.or_else_eq_lt", "iff_def", "or_iff_not_imp_right", "option.mem_to_list", "eq_of_neg_eq_neg", "eq_true", "classical.imp_iff_not_or", "ordered_comm_group", "of_iff_true", "not_iff_self", "iff_eq_eq", "div_eq_one_iff_eq", "or_true", "sum.exists", "iff_true_left", "not_false_iff", "iff_eq_of_eq_true_left", "not_imp_not", "iff.elim_left", "neg_eq_iff_add_eq_zero", "function.cantor_surjective", "nat.sub_le_sub_right_iff", "not_iff_not_of_iff", "add_left_cancel_iff", "bool_eq_false", "neg_eq_zero", "dif_ctx_simp_congr", "and.rotate", "classical.nonempty_pi", "array.read_eq_read'", "exists_eq_right'", "iff.decidable", "neg_ne_zero", "le_antisymm_iff", "prod.ext_iff", "nonempty.congr", "decidable.not_and_iff_or_not", "eq_sub_iff_add_eq", "ball_and_distrib", "and_self", "le_of_not_lt", "decidable.le_iff_le_iff_lt_iff_lt", "band_coe_iff", "sum.forall", "decidable.not_or_iff_and_not", "function.is_partial_inv_left", "iff_eq_of_eq_true_right", "mul_self_eq_mul_self_iff", "and_not_self", "to_bool_congr", "imp_eq_of_eq_true_right", "ordered_cancel_comm_monoid", "iff.comm", "add_right_inj", "nonempty_plift", "mul_div_cancel", "eq_of_div_eq_one", "heq_self_iff_true", "decidable.not_not_iff", "eq.congr_right", "or_assoc", "decidable_linear_ordered_comm_ring", "exists_swap", "decidable.ne_iff_lt_or_gt", "nat.div_mul_le_self", "prod.lex_def", "option.mem_def", "list.pairwise_cons", "and.assoc", "lt_iff_le_and_ne", "nat.sub_eq_zero_iff_le", "heq_iff_eq", "classical.iff_iff_not_or_and_or_not", "bool.coe_to_bool", "exists_true_iff_nonempty", "forall_3_true_iff", "min_self", "mul_left_cancel_iff", "iff_congr", "iff_def'", "list.ball_cons", "sub_left_inj", "and.right_comm", "or_congr", "nonempty.exists", "set.is_lawful_functor", "imp_true_iff", "eq_of_forall_le_iff", "mul_mul_div", "int.of_nat_eq_of_nat_iff", "exists_imp_distrib", "sub_eq_zero_iff_eq", "not_or_distrib", "forall_eq'", "if_congr_prop", "array.write_eq_write'", "classical.not_imp_not", "eq_neg_add_iff_add_eq", "linear_ordered_field", "or_comm", "d_array.read_write_of_ne", "forall_swap", "int.lt_iff_add_one_le", "nonempty_psum", "iff_of_false", "not_nonempty_iff_imp_false", "nonempty_prod", "eq_false", "sub_right_inj", "iff.elim_right", "nonempty_pprod", "dvd_add_iff_left", "function.partial_inv_of_injective", "exists_eq_left'", "inv_eq_iff_mul_eq_one", "nat.le_div_iff_mul_le", "mul_left_inj", "lt_iff_lt_of_le_iff_le'", "iff.elim", "iff_false", "nat.div_lt_iff_lt_mul", "forall_pempty", "sub_eq_iff_eq_add'", "nat.add_le_to_le_sub", "and.congr_right_iff", "le_iff_le_iff_lt_iff_lt", "eq_sub_iff_add_eq'", "or_iff_not_imp_left", "imp_and_distrib", "and_false", "min_le_left", "nat.dvd_add_iff_left", "eq.to_iff", "function.cantor_injective", "classical.not_not", "add_right_cancel_iff", "ordered_ring", "not_forall", "mul_self_eq_one_iff", "exists_pempty", "function.funext_iff", "bxor_coe_iff", "not_imp_comm", "function.bijective_iff_has_inverse", "forall_true_iff'", "iff_not_self", "inv_mul_eq_iff_eq_mul", "ordering.compares.eq_eq", "decidable_linear_ordered_comm_group", "function.involutive_iff_iter_2_eq_id", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "nonempty.forall", "false_and", "list.partition_eq_filter_filter", "or_self", "bool.to_bool_eq", "sum.inr.inj_iff", "forall_or_distrib_left", "le_max_right", "prod.exists", "eq_div_iff_mul_eq", "false_of_true_iff_false", "forall_true_iff", "forall_lt_iff_le'", "not_bex", "add_neg_eq_zero", "exists_const", "lt_iff_not_ge'", "exists_congr", "function.update_comp", "exists_unique_congr", "forall_or_distrib_right"]}, {"id": "has_lt", "parentIds": ["partial_order", "decidable.lt_or_gt_of_ne", "int.lt_of_le_sub_one", "lt_add_of_sub_right_lt", "nat.le_total", "int.add_one_le_of_lt", "int.decidable_lt", "native.rb_map.scale", "sub_lt_sub_of_lt_of_le", "char.val_of_nat_eq_of_is_valid", "preorder.to_has_lt", "lt_of_one_div_lt_one_div", "native.rb_map.of_list", "add_lt_add_of_lt_of_le", "int.lt_of_add_one_le", "nat.lt_add_left", "parser.sat", "le_iff_lt_or_eq", "nat.mod_lt", "is_valid_char_range_1", "div_le_div_of_le_of_pos", "add_lt_of_lt_of_nonpos", "nat.div_eq_of_lt", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "nat.lt_le_antisymm", "decidable.eq_or_lt_of_le", "is_strict_weak_order_of_decidable_linear_order", "add_lt_of_le_of_neg", "one_div_pos_of_pos", "sub_right_lt_of_lt_add", "nat.lt.step", "int.lt.intro", "int.le_of_lt_add_one", "nat.one_lt_bit0", "div_pos_of_neg_of_neg", "nat.succ_lt_succ", "div_lt_of_mul_lt_of_pos", "lt_or_gt_of_ne", "mul_lt_mul_of_pos_left", "int.has_lt", "tactic.existsi", "expr.dedup_size", "array.push_back_idx", "linear_ordered_semiring", "abs_pos_of_ne_zero", "lt_of_not_ge'", "neg_add_lt_of_lt_add", "add_midpoint", "is_valid_char_range_2", "decidable_linear_ordered_semiring", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "lt_add_of_le_of_pos", "min_eq_left_of_lt", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "nat.div_def", "nat.not_lt_zero", "name.has_lt", "not_lt_of_gt", "unsigned.has_lt", "one_div_le_of_one_div_le_of_neg", "ordered_comm_group.lt_of_add_lt_add_left", "mul_zero_lt_mul_inv_of_neg", "lt_imp_lt_of_le_imp_le", "nat.zero_lt_one", "forall_lt_iff_le", "push_neg.not_le_eq", "nonneg_of_mul_nonneg_left", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "nat.pow_lt_pow_of_lt_right", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "char.decidable_lt", "le_of_forall_lt'", "exists_add_lt_and_pos_of_lt", "int.lt.elim", "one_le_one_div", "nat.zero_lt_one_add", "lt_iff_not_ge", "fin.le_def", "le_or_lt", "nat.lt_trichotomy", "not_lt_of_le", "nat.bit1_lt", "list.lt", "max_lt", "nat.lt_irrefl", "nat.lt_add_of_pos_left", "fin.has_lt", "nat.mod_one", "nat.strong_induction_on", "char.val_of_nat_eq_of_not_is_valid", "lt_of_le_of_ne", "add_lt_of_nonpos_of_lt", "one_div_lt_neg_one", "nat.pred_lt_pred", "nat.lt_ge_by_cases", "fin.mod_def", "one_lt_div_of_lt", "lt_add_of_pos_of_le", "int.lt_succ", "int.nat_abs_add_neg", "lt_of_not_ge", "lt_of_add_lt_add_right", "decidable_linear_ordered_cancel_comm_monoid", "add_lt_of_neg_of_lt", "decidable.not_lt", "nat.lt_wf", "div_neg_of_pos_of_neg", "nat.find_min", "div_lt_of_mul_gt_of_neg", "eq_or_lt_of_not_lt", "ordering.compares.eq_lt", "int.lt_add_succ", "int.nat_abs_add_nonneg", "push_neg.not_lt_eq", "le_div_of_mul_le", "decidable.lt_by_cases", "nat.zero_lt_succ", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "lt_min", "lt_add_of_neg_add_lt_left", "int.sign_eq_neg_one_iff_neg", "neg_lt_neg", "nat.mod_eq_of_lt", "gt_iff_lt", "mul_self_lt_mul_self_iff", "int.lt_of_coe_nat_lt_coe_nat", "mul_zero_lt_mul_inv_of_pos", "prod_has_decidable_lt", "buffer.read_eq_read'", "mul_lt_mul_of_neg_right", "lt_of_add_lt_add_left", "decidable.lt_or_le", "lt.trans", "one_div_lt_one_div_of_lt_of_neg", "char.of_nat", "lt_iff_le_not_le", "sub_lt_of_abs_sub_lt_right", "nat.lt_of_sub_eq_succ", "add_neg_of_nonpos_of_neg", "mul_lt_mul", "ne_iff_lt_or_gt", "lt_of_one_div_lt_one_div_of_neg", "lt_add_of_nonneg_of_lt", "int.coe_nat_lt_coe_nat_iff", "lt_trans", "lt_of_mul_lt_mul_right", "nat.le_lt_antisymm", "mul_pos", "native.rb_map.map", "lt_asymm", "le_of_eq_or_lt", "nat.lt_add_of_pos_right", "linear_ordered_comm_ring", "tactic.unprime", "mul_sub_mul_div_mul_neg", "fin.eq_of_veq", "not_le_of_lt", "nat.sub_pos_of_lt", "int.of_nat_nat_abs_eq_of_nonneg", "array.write'", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "tactic.lift", "int.lt_irrefl", "int.add_lt_add_left", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "nat.nat.lt_asymm", "lt_add_of_neg_lt_sub_left", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.gcd.induction", "decidable.lt_or_eq_of_le", "nat.lt_by_cases", "array.pop_back_idx", "decidable_linear_order", "add_lt_add", "pos_of_mul_pos_right", "not_lt_of_ge", "int.sign_eq_one_iff_pos", "nat.lt_add_of_zero_lt_left", "ordered_semiring", "decidable_lt_of_decidable_le", "not_lt_iff_eq_or_lt", "nat.has_lt", "lt_add_of_pos_left", "buffer.lt_aux_2", "lt_trichotomy", "ordering.compares", "lt_of_one_lt_div", "int.lt_iff_le_and_ne", "mul_le_of_le_div", "nat.zero_mod", "le_of_one_div_le_one_div_of_neg", "unsigned.of_nat'", "has_lt.lt.decidable", "nat.succ_pos", "int.zero_lt_one", "add_neg_of_neg_of_nonpos", "nat.sub_lt_of_pos_le", "discrete_linear_ordered_field", "not_lt", "measure", "abs_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "gt", "decidable.le_imp_le_of_lt_imp_lt", "int.le_sub_one_of_lt", "nat.decidable_lt", "one_div_neg_of_neg", "fin.veq_of_eq", "lt_of_sub_pos", "buffer.write_eq_write'", "fin.add_def", "le_not_le_of_lt", "linear_ordered_ring", "is_strict_total_order_of_decidable_linear_order", "fin.mul_def", "mul_neg_of_neg_of_pos", "fin", "mul_pos_of_neg_of_neg", "int.eq_neg_succ_of_lt_zero", "add_neg", "neg_of_neg_pos", "nat.find", "not_le", "int.ne_of_lt", "decidable.le_iff_lt_or_eq", "list.nth_le", "fin.lt", "le_of_mul_le_mul_right", "d_array.of_beq_aux_eq_ff", "eq_zero_of_neg_eq", "sub_lt_self", "le_of_one_div_le_one_div", "linear_order", "list.lt_eq_not_ge", "nat.lt_succ_of_lt", "mul_lt_of_gt_div_of_neg", "nat.case_strong_induction_on", "nonneg_of_mul_nonneg_right", "native.rb_map.for", "le_of_not_gt", "list.of_fn_nth_val", "prod.has_lt", "nat.mul_lt_mul_of_pos_left", "list.has_decidable_le", "le_of_mul_le_mul_left", "nat.sub_one_sub_lt", "array.ext'", "decidable.le_imp_le_iff_lt_imp_lt", "array.read'", "le_of_lt_or_eq", "fin.decidable_lt", "add_pos_of_nonneg_of_pos", "le_of_forall_lt", "neg_of_mul_neg_right", "nat.add_lt_add_right", "sub_lt_of_abs_sub_lt_left", "div_lt_div_of_lt_of_neg", "buffer.lt_aux_3", "norm_num.pos_bit0_helper", "int.mul_pos", "int.eq_succ_of_zero_lt", "prod.lt_def", "native.rb_map.mfilter", "le_of_lt", "lt_or_ge", "lt_mul_of_gt_one_right", "decidable.le_or_lt", "div_nonpos_of_nonpos_of_pos", "nat.mul_lt_mul_of_pos_right", "nonpos_of_mul_nonpos_left", "sub_lt_sub_left", "mul_self_lt_mul_self", "div_pos_of_pos_of_pos", "nat.div_lt_self", "char.has_lt", "mul_le_of_div_le_of_neg", "nat.lt_iff_le_not_le", "fin.lt_def", "int.coe_nat_lt_coe_nat_of_lt", "nat.mod_zero", "native.rb_map.inhabited", "div_lt_div_of_lt_of_pos", "lt_irrefl", "nat.bit0_lt", "decidable.lt_trichotomy", "lt_add_of_neg_add_lt", "gt_of_mul_lt_mul_neg_left", "nat.div_eq_of_lt_le", "pos_of_mul_pos_left", "lt_add_of_neg_add_lt_right", "buffer.append_array", "lt_of_mul_lt_mul_left", "nat.eq_or_lt_of_le", "ne_of_lt", "nat.one_pos", "sub_left_lt_of_lt_add", "neg_pos_of_neg", "zero_gt_neg_one", "native.rb_lmap.of_list", "one_div_lt_one_div_of_lt", "nat.pos_pow_of_pos", "add_pos", "native.rb_map.mmap", "fin.sub_def", "nat.pred_lt", "le_imp_le_iff_lt_imp_lt", "add_lt_of_lt_sub_right", "int.lt_iff_le_not_le", "div_nonpos_of_nonneg_of_neg", "abs_pos_of_neg", "lt_iff_lt_of_le_iff_le", "rsimp.choose", "eq_iff_le_not_lt", "preorder", "nat.strong_rec_on", "lt_add_of_neg_lt_sub_right", "neg_of_mul_neg_left", "nat.lt_of_le_and_ne", "level.dedup_size", "int.lt_of_sub_one_le", "nat.zero_lt_bit1", "le_iff_eq_or_lt", "lt_of_le_not_le", "nat.eq_or_lt_of_not_lt", "lt_neg_of_lt_neg", "cmp_compares", "int.pos_of_sign_eq_one", "native.rb_map.set_of_list", "nat.le_of_lt_succ", "nat.lt_of_add_lt_add_left", "nat.div2_bit", "lt_add_of_pos_of_lt", "cmp_swap", "nat.bit0_lt_bit1", "neg_lt_of_neg_lt", "ordered_comm_group", "add_lt_add_of_le_of_lt", "nat.lt_of_succ_lt", "list.qsort.F", "list.has_le", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "int.neg_succ_lt_zero", "int.neg_of_sign_eq_neg_one", "nat.lt_succ_of_le", "lt_or_le", "nat.mul_self_lt_mul_self", "expr.has_lt", "buffer.lt_aux_1", "add_lt_add_right", "nat.div_eq_sub_div", "nat.pow_lt_pow_of_lt_left", "nat.lt_of_le_of_lt", "string.has_decidable_lt", "sub_lt_of_sub_lt", "nat.zero_div", "lt_sub_right_of_add_lt", "nat.mod_def_aux", "ordered_ring.mul_lt_mul_of_pos_right", "array.read_eq_read'", "div_lt_div_of_pos_of_lt_of_pos", "int.sub_one_le_of_lt", "nat.mod_add_div", "list.has_lt", "le_of_not_lt", "where.binder_less_important", "nat.mod_eq_sub_mod", "decidable.le_iff_le_iff_lt_iff_lt", "is_valid_char", "neg_add_lt_left_of_lt_add", "two_pos", "d_array.ext'", "lt_of_neg_lt_neg", "interaction_monad.result.clamp_pos", "native.rb_set.inhabited", "sub_pos_of_lt", "string.has_lt", "one_div_le_one_div_of_le", "native.mk_rb_set", "list.has_decidable_lt", "dist_bdd_within_interval", "pos_of_neg_neg", "ordered_cancel_comm_monoid", "sub_lt_sub_of_le_of_lt", "pos_of_one_div_pos", "char.lt", "div_nonneg_of_nonneg_of_pos", "lt_add_of_pos_right", "native.rb_lmap.inhabited", "decidable.le_of_not_lt", "measure_wf", "cmp", "char.zero_lt_d800", "lt_add_of_lt_of_pos", "decidable_linear_ordered_comm_ring", "nat.find_spec", "decidable.ne_iff_lt_or_gt", "lt_of_sub_neg", "lt_of_le_of_ne'", "lt_or_eq_of_le", "instance_priority", "int.lt_add_one_of_le", "lt_iff_le_and_ne", "instance_derive_handler", "int.sign_eq_neg_one_of_neg", "d_array.of_beq_eq_ff", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "nonpos_of_mul_nonpos_right", "nat.mod_two_eq_zero_or_one", "native.rb_map.filter", "int.lt.dest", "add_pos_of_pos_of_nonneg", "fin.div_def", "nat.sub_lt", "add_lt_add_left", "abs_lt_of_lt_of_neg_lt", "one_div_le_one_div_of_le_of_neg", "nat.lt_of_succ_le", "le_imp_le_of_lt_imp_lt", "unsigned.reflect", "eq_or_lt_of_le", "neg_of_one_div_neg", "native.float.has_lt", "nat.lt_add_right", "min_eq_right_of_lt", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "int.sign_eq_one_of_pos", "nat.succ_le_of_lt", "mul_lt_mul_of_pos_right", "array.write_eq_write'", "nat.mod_pow_succ", "nat.zero_pow", "linear_ordered_field", "nat.add_lt_add_left", "lt_add_of_sub_left_lt", "tactic.suggest", "int.lt_iff_add_one_le", "tactic.interactive.case", "zero_lt_one", "nat.mod_def", "lt_of_lt_of_le", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "nat.lt_of_lt_of_le", "nat.le_div_iff_mul_le", "sub_lt_sub", "native.float.decidable_lt", "lt_iff_lt_of_le_iff_le'", "lt_of_le_of_lt", "nat.div_lt_iff_lt_mul", "nat.lt_succ_self", "add_lt_of_lt_of_neg", "int.le_of_lt", "max_eq_right_of_lt", "le_iff_le_iff_lt_iff_lt", "native.mk_rb_map", "nat.lt_of_succ_lt_succ", "list.length_remove_nth", "nat.sub_lt_succ", "ordered_ring.mul_lt_mul_of_pos_left", "mul_lt_mul'", "div_neg_of_neg_of_pos", "neg_lt_sub_right_of_lt_add", "nat.bit1_lt_bit0", "ordered_ring", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.div_zero", "list.le", "div_two_lt_of_pos", "list.le_eq_not_gt", "decidable_linear_ordered_comm_group", "nat.mul_sub_div", "nat.zero_lt_bit0", "one_lt_one_div", "nat.find_x", "sub_neg_of_lt", "nat.lt.base", "nat.lt_trans", "forall_lt_iff_le'", "max_eq_left_of_lt", "neg_neg_of_pos", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "nat.le_of_lt", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg", "lt_iff_not_ge'", "lt_sub_left_of_add_lt", "nat.le_antisymm"]}, {"id": "has_le", "parentIds": ["partial_order", "int.lt_of_le_sub_one", "abs_add_le_abs_add_abs", "nat.le_total", "int.add_one_le_of_lt", "sub_lt_sub_of_lt_of_le", "le_mul_of_div_le", "add_lt_add_of_lt_of_le", "int.lt_of_add_one_le", "max_add_add_left", "le_iff_lt_or_eq", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "d_array.iterate_aux", "nat.mod_lt", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "add_lt_of_lt_of_nonpos", "int.le.dest", "nat.div_eq_of_lt", "le_refl", "nat.lt_le_antisymm", "decidable.eq_or_lt_of_le", "add_lt_of_le_of_neg", "nat.pow_le_pow_of_le_left", "unsigned.has_le", "le_trans", "le_of_eq", "int.le_of_lt_add_one", "mul_nonpos_of_nonpos_of_nonneg", "abs_add_three", "add_nonpos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "le_add_of_sub_left_le", "nat.not_succ_le_zero", "exists_ge_of_linear", "array.take", "linear_ordered_semiring", "lt_of_not_ge'", "mul_nonneg_of_nonpos_of_nonpos", "abs_sub_le", "le_of_not_ge", "le_add_of_neg_le_sub_right", "mul_le_mul_of_nonneg_right", "int.neg_ne_of_pos", "int.le_of_coe_nat_le_coe_nat", "list.length_take_le", "nat.le_of_succ_le_succ", "nat.le_add_left", "zero_le_one", "decidable_linear_ordered_semiring", "d_array.of_beq_aux_eq_tt", "lt_add_of_le_of_pos", "div_nonneg_of_nonpos_of_neg", "nat.div_def", "nat.sub_eq_zero_of_le", "int.le.dest_sub", "max_self", "buffer.take", "nat.pred_le", "nat.sub_sub_self", "neg_le_abs_self", "le_add_of_le_of_nonneg", "nat.sub_le_sub_left", "one_div_le_of_one_div_le_of_neg", "list.length_le_of_sublist", "nat.shiftl_sub", "one_le_div_of_le", "lt_imp_lt_of_le_imp_le", "sub_le_sub_left", "nat.add_le_add_iff_le_right", "forall_lt_iff_le", "push_neg.not_le_eq", "sub_left_le_of_le_add", "nonneg_of_mul_nonneg_left", "max_comm", "nat.zero_le", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "le_of_forall_lt'", "int.coe_nat_le_coe_nat_iff", "one_le_one_div", "fin.le_def", "le_add_of_nonneg_of_le", "le_or_lt", "not_lt_of_le", "add_le_of_le_neg_add", "max_lt", "nat.find_min'", "nat.le_mul_self", "nat.le_succ", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "lt_of_le_of_ne", "max_assoc", "fin.has_le", "add_lt_of_nonpos_of_lt", "has_le.le.is_total_preorder", "lt_add_of_pos_of_le", "not_le_of_gt", "le_min", "max_eq_right", "le_max_left", "lt_of_not_ge", "decidable_linear_ordered_cancel_comm_monoid", "decidable.not_lt", "nat.le_trans", "char.has_le", "eq_min", "nat.sub_eq_iff_eq_add", "nat.le_of_eq", "push_neg.not_lt_eq", "char.to_lower", "le_div_of_mul_le", "nat.sub_mul_mod", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "lt_min", "sub_le_of_sub_le", "nat.mod_eq_of_lt", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "nat.mul_self_le_mul_self_iff", "lt_of_add_lt_add_left", "decidable.lt_or_le", "nat.one_le_bit0", "lt_iff_le_not_le", "div_mul_le_div_mul_of_div_le_div_pos", "int.of_nat_nat_abs_of_nonpos", "add_neg_of_nonpos_of_neg", "add_le_add_right", "char.is_lower", "nat.shiftl'_sub", "mul_lt_mul", "nat.one_le_bit1", "lt_add_of_nonneg_of_lt", "buffer.drop", "int.coe_nat_lt_coe_nat_iff", "nat.mul_le_mul_left", "lt_trans", "lt_of_mul_lt_mul_right", "nat.le_lt_antisymm", "nat.add_sub_assoc", "int.of_nat_nonneg", "int.of_nat_sub", "min_eq_left", "nat.div_le_of_le_mul", "le_of_eq_or_lt", "linear_ordered_comm_ring", "not_le_of_lt", "max", "mul_self_le_mul_self_iff", "nat.mul_mod_mul_left", "has_le.le.decidable", "int.add_lt_add_left", "le_add_of_neg_le_sub_left", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "nat.add_le_add_right", "decidable.lt_or_eq_of_le", "int.le_antisymm", "decidable_linear_order", "pos_of_mul_pos_right", "ordered_semiring", "abs_nonneg", "decidable_lt_of_decidable_le", "not_lt_iff_eq_or_lt", "nat.pred_le_pred", "lt_trichotomy", "int.lt_iff_le_and_ne", "char.decidable_is_digit", "abs_mul", "neg_le_neg", "mul_le_of_le_div", "ge", "nat.zero_mod", "le_of_one_div_le_one_div_of_neg", "le_of_add_le_add_left", "neg_add_le_right_of_le_add", "min_comm", "int.has_le", "add_neg_of_neg_of_nonpos", "nat.sub_lt_of_pos_le", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "int.le.intro", "not_lt", "neg_le_sub_left_of_le_add", "char.le", "nat.le_of_add_le_add_right", "decidable.le_imp_le_of_lt_imp_lt", "neg_add_le_left_of_le_add", "nat.eq_zero_of_le_zero", "int.le_sub_one_of_lt", "max_le", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "buffer.take_right", "nat.le_of_succ_le", "decidable_eq_of_decidable_le", "int.le_trans", "le_not_le_of_lt", "linear_ordered_ring", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "add_le_of_nonpos_of_le", "min_add_add_left", "ge_iff_le", "not_le", "nat.dvd_sub", "decidable.le_iff_lt_or_eq", "le_of_mul_le_mul_right", "d_array.of_beq_aux_eq_ff", "eq_of_forall_ge_iff", "char.decidable_is_upper", "le_of_one_div_le_one_div", "linear_order", "list.lt_eq_not_ge", "norm_num.nonneg_bit0_helper", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "nat.case_strong_induction_on", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "array.take_right", "nat.le.intro", "nat.decidable_le", "le_of_not_gt", "le_antisymm", "sub_le_sub_right", "char.is_upper", "le_add_of_neg_add_le", "nat.mul_lt_mul_of_pos_left", "le_add_of_sub_right_le", "list.has_decidable_le", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "add_le_add_three", "decidable.le_imp_le_iff_lt_imp_lt", "neg_nonpos_of_nonneg", "le_of_lt_or_eq", "nat.mul_le_mul_right", "add_pos_of_nonneg_of_pos", "le_of_forall_lt", "neg_of_mul_neg_right", "min_le_right", "sub_lt_of_abs_sub_lt_left", "nat.le_add_right", "le_of_lt", "list.of_fn_aux", "decidable.le_or_lt", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "eq_zero_of_abs_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "neg_le_sub_right_of_le_add", "mul_le_of_div_le_of_neg", "nat.lt_iff_le_not_le", "nat.has_le", "nat.mod_zero", "nat.mul_self_le_mul_self", "le_implies_le_of_le_of_le", "nat.le_succ_of_pred_le", "lt_irrefl", "add_le_add_left", "decidable.lt_trichotomy", "max_eq_left", "gt_of_mul_lt_mul_neg_left", "array.drop", "int.eq_coe_of_zero_le", "nat.div_eq_of_lt_le", "int.add_le_add_left", "pos_of_mul_pos_left", "nat.le.dest", "le_add_of_neg_add_le_left", "lt_of_mul_lt_mul_left", "int.coe_nat_sub", "nat.eq_or_lt_of_le", "int.eq_nat_abs_of_zero_le", "nat.sub_add_comm", "nat.div_le_self", "nat.le_of_le_of_sub_le_sub_right", "nat.sub_mul_div", "le_imp_le_iff_lt_imp_lt", "int.lt_iff_le_not_le", "div_nonpos_of_nonneg_of_neg", "lt_iff_lt_of_le_iff_le", "char.is_digit", "le_abs_self", "nat.le_succ_of_le", "le_of_forall_le'", "int.coe_nat_le_coe_nat_of_le", "min_assoc", "eq_iff_le_not_lt", "preorder", "int.le_total", "native.float.has_le", "neg_of_mul_neg_left", "nat.lt_of_le_and_ne", "int.lt_of_sub_one_le", "abs_of_nonneg", "char.decidable_le", "char.decidable_is_lower", "le_iff_eq_or_lt", "lt_of_le_not_le", "sub_le_of_abs_sub_le_right", "le_of_forall_le", "nat.le_of_lt_succ", "le_sub_right_of_add_le", "min", "add_nonneg", "eq_zero_of_mul_self_add_mul_self_eq_zero", "nat.lt_of_add_lt_add_left", "nat.not_succ_le_self", "nat.bit0_lt_bit1", "ordered_comm_group", "add_lt_add_of_le_of_lt", "nat.add_le_add_left", "nat.le_of_sub_eq_zero", "list.has_le", "abs_by_cases", "nat.lt_succ_of_le", "lt_or_le", "nat.div_eq_sub_div", "le_add_of_neg_add_le_right", "nat.sub_le_sub_right_iff", "nat.lt_of_le_of_lt", "le_total", "int.le_refl", "nat.zero_div", "nat.mod_def_aux", "add_le_add", "nat.succ_le_succ", "int.sub_one_le_of_lt", "nat.mod_add_div", "le_antisymm_iff", "int.exists_eq_neg_of_nat", "le_of_not_lt", "nat.mod_eq_sub_mod", "decidable.le_iff_le_iff_lt_iff_lt", "nonpos_of_neg_nonneg", "ordered_ring.mul_le_mul_of_nonneg_left", "char.quote_core", "native.float.decidable_le", "int.mul_nonneg", "one_div_le_one_div_of_le", "int.le.elim", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "ordered_cancel_comm_monoid", "sub_lt_sub_of_le_of_lt", "d_array.rev_iterate_aux", "nat.le_refl", "nat.sub_le", "div_nonneg_of_nonneg_of_pos", "sub_nonpos_of_le", "decidable.le_of_not_lt", "sub_le_sub", "mul_nonpos_of_nonneg_of_nonpos", "nat.le_of_add_le_add_left", "decidable_linear_ordered_comm_ring", "sub_le_self", "nat.sub_le_sub_right", "nat.div_mul_le_self", "lt_of_le_of_ne'", "lt_or_eq_of_le", "int.lt_add_one_of_le", "fin.decidable_le", "lt_iff_le_and_ne", "int.le.intro_sub", "nat.sub_eq_zero_iff_le", "le_of_sub_nonneg", "preorder.to_has_le", "nat.le_of_dvd", "mul_self_nonneg", "min_self", "nonpos_of_mul_nonpos_right", "min_eq_right", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "one_div_le_one_div_of_le_of_neg", "nat.lt_of_succ_le", "le_imp_le_of_lt_imp_lt", "mul_nonneg", "eq_or_lt_of_le", "eq_of_forall_le_iff", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "nat.succ_le_of_lt", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "nat.can_lift", "linear_ordered_field", "nat.add_lt_add_left", "abs_abs_sub_abs_le_abs_sub", "int.lt_iff_add_one_le", "div_le_of_le_mul", "abs_sub_abs_le_abs_sub", "nat.mod_def", "nonneg_of_neg_nonpos", "lt_of_lt_of_le", "nat.add_sub_of_le", "nat.lt_of_lt_of_le", "nat.le_div_iff_mul_le", "lt_iff_lt_of_le_iff_le'", "eq_max", "lt_of_le_of_lt", "int.le_nat_abs", "le_of_one_le_div", "neg_nonneg_of_nonpos", "le_of_not_le", "nat.add_le_to_le_sub", "int.le_of_lt", "le_iff_le_iff_lt_iff_lt", "mul_lt_mul'", "min_le_left", "ordered_comm_group.le_of_add_le_add_left", "le_or_gt", "nat.bit1_lt_bit0", "ordered_ring", "array.slice", "le_of_sub_nonpos", "nat.div_zero", "list.le_eq_not_gt", "le_add_of_nonneg_left", "nat.min_succ_succ", "max_neg_neg", "decidable_linear_ordered_comm_group", "le_of_add_le_add_right", "nat.div_div_eq_div_mul", "int.lt", "nat.mul_sub_div", "d_array.beq_aux", "mul_self_le_mul_self", "nat.find_x", "le_neg_add_of_add_le", "le_max_right", "forall_lt_iff_le'", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "int.coe_zero_le", "nat.le_of_lt", "mul_le_mul", "fin.le", "int.decidable_le", "one_div_le_neg_one", "abs_of_nonpos", "lt_iff_not_ge'", "neg_le_of_neg_le", "nat.le_antisymm", "mul_le_mul_of_nonpos_right"]}, {"id": "has_coe_t_aux", "parentIds": ["coe_base_aux", "coe_fn_coe_trans", "coe_sort_coe_trans", "coe_sort_trans", "coe_fn_trans", "coe_trans_aux"]}, {"id": "list.mem_append", "parentIds": ["list.mem_append_eq", "list.mem_append_left", "list.mem_append_right"]}, {"id": "list.cons_append", "parentIds": ["list.mem_append", "list.length_append", "list.map_append", "list.filter_append", "list.append_nil", "list.is_lawful_monad", "list.append_assoc", "list.append_bind"]}, {"id": "list.nil_append", "parentIds": ["list.mem_append", "list.length_append", "list.map_append", "list.append_nil", "list.is_lawful_monad", "list.append_assoc"]}, {"id": "list", "parentIds": ["list.mem_append", "expr.is_sort", "list.decidable_bex", "tactic.interactive.record_lit", "tactic.eval_expr'", "list.enum", "tactic.clear_lst", "lean.parser.sep_by", "smt_tactic.interactive.assume", "interactive.loc.has_reflect", "tactic.simplify", "tactic.find_if_cond_at", "has_sizeof_derive_handler", "name_set.to_list", "tactic.get_subsingleton_info", "format.join", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "tactic.replace_at", "list.permutations_aux2", "native.rb_map.of_list", "tactic.library_search_hole_cmd", "list.prod", "bin_tree.to_list", "list.not_mem_nil", "expr.local_pp_name", "declaration.is_theorem", "tactic.mk_const", "list.ball_nil", "environment.add_ginductive", "tactic.first", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.interactive.format_names", "tactic.instance_cache.get", "get_localized", "smt_tactic.solve1", "dlist.to_list_empty", "tactic.delta", "tactic.to_simp_lemmas", "list.join", "list.not_bex_nil", "tactic.focus1", "array.has_to_format", "print_content", "tactic.rintro_hint", "string.quote_aux", "array.to_list", "pexpr.get_uninst_pis", "tactic.revertible_local_context", "tactic.apply_iff", "tactic.mllist.m_of_list", "infer_type_cmd", "extensional_attribute", "list.decidable_ball", "tactic.rewrite_core", "list.subset_cons_of_subset", "expr.is_arrow", "tactic.mk_constructor_arg_names", "vm_obj.fields", "lean.parser.get_variables", "rbmap.to_list", "print_decls_sorted", "list.union", "smt_tactic.add_lemmas_from_facts_core", "lean.parser.many", "string.over_list", "expr.is_iff", "well_founded_tactics.clear_internals", "tactic.explode.entries.inhabited", "param_info.to_format", "tactic.find_same_type", "expr.mk_exists_lst", "interactive.types.opt_pexpr_list", "tactic.rcases_hint.process_constructors", "tactic.injections_with", "tactic.elide.unelide", "expr.get_app_args_aux", "expr.mk_binding", "list.mem_append_eq", "tactic.mk_mapp", "tactic.open_namespaces", "tactic.build_list_expr_for_apply", "tactic.interactive.recover", "tactic.explode.args", "list.length_cons", "tactic.focus", "parser.one_of'", "smt_tactic.set_goals", "tactic.find_assumption", "cc_state.mk_using_hs", "tactic.interactive.field_simp", "tactic.cases", "tactic.existsi", "unused_arguments", "list.map_accumr\u2082", "tactic.local_context", "tactic.cc_core", "tactic.back_lemmas_find", "tactic.apply_inj_lemma", "mk_definition", "tactic.mk_has_sizeof_instance_core", "print_arguments", "tactic.get_constructors_for", "tactic.interactive.propagate_tags", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "expr.to_nat", "cc_state.roots", "tactic.mk_psigma", "tactic.instance_cache.append_typeclasses", "list.length_take_le", "expr.mk_or_lst", "list.split_on_p_aux", "tactic.interactive.loc.get_local_pp_names", "list.eq_or_mem_of_mem_cons", "declaration.type", "wf_tacs", "smt_tactic.add_lemmas_from_facts", "where.trace_variables", "list.reverse", "attribute.get_instances", "tactic.suggest.unfold_head_symbol", "tactic.interactive.guard_tags", "tactic.back_chaining_using_hs", "simp_attr.pre_smt", "hole_command", "list.repeat", "expr.binding_names", "tactic.cleanup", "smt_tactic.seq", "transport_multiplicative_to_additive", "tactic.seq_focus", "restate_axiom", "tactic.interactive.convert", "using_smt", "conv.interactive.conv", "rbmap_of", "dlist.to_list_concat", "to_additive.tokens_dict", "list.concat", "list.nil_subset", "string_imp", "list.length_le_of_sublist", "string.get_rest", "list.mem_append_left", "tactic.apply_list_expr", "tactic.get_pi_binders", "expr.local_binding_info", "list.head", "tactic.interactive.get_rule_eqn_lemmas", "list.has_subset", "list.has_sizeof", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "where.sort_variable_list", "list.inits", "list.ilast", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "tactic.by_elim_opt", "native.rb_lmap.find", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.explode.append_dep", "list.all", "tactic.interactive.induction", "incorrect_def_lemma", "tactic.symm_apply", "parser.many'", "tactic.revert_kdependencies", "old_conv.first", "tactic.interactive.unfold_coes", "name_set.of_list", "tactic.interactive.dsimp", "list.cons_subset_cons", "dlist.to_list_cons", "tactic.interactive.cases_matching", "list.is_prefix_of", "expr.is_ne", "list.intersperse", "smt_tactic.interactive.intros", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "list.length_append", "has_dup", "string.iterator.length_next_to_string_next", "list.transpose_aux", "old_conv.dsimp", "string.empty", "list.repr_aux", "tactic.transport_with_prefix_fun", "list.is_prefix", "tactic.interactive.apply_assumption", "list.filter", "monad.filter", "tactic.elim_gen_sum", "list.drop_while", "localized_attr", "environment.is_definition", "expr.local_type", "list.func.neg", "tactic.interactive.split_ifs", "tactic.pis", "to_additive.proceed_fields", "list.lt", "tactic.match_app_of", "expr.to_int", "expr.list_local_consts", "environment.add_inductive", "list.update_nth", "tactic.interactive.clear_dependent", "list.sigma", "tactic.non_dep_prop_hyps", "use_cmd", "tactic.interactive.rename'_args_parser", "expr.mk_op_lst", "list.func.sub", "list.of_fn", "list.insert", "list.map_append", "tactic.left", "tactic.mk_simp_attr", "list.decidable_mem", "expr.is_default_local", "tactic.assoc_refl", "array.has_to_tactic_format", "print_decls", "declaration.to_name", "nat.to_digits", "list.zip_with", "tactic.dsimp_hyp", "interactive.types.with_ident_list", "list.range_core", "ematch_lhs", "smt_tactic.swap", "interactive.types.pexpr_list", "tactic.mk_pattern", "expr.binding_domain", "tactic.match_subexpr", "tactic.mk_dec_eq_instance", "vm.get_attribute", "array.has_repr", "print_localized_commands", "list.band", "tactic.suggest_scripts", "tactic.generalize_proofs", "dlist.of_list_to_list", "rbtree.has_repr", "nolint_attr", "apply_nolint_cmd", "interactive.loc.try_apply", "char.is_whitespace", "list.alternative", "parser.sep_by1", "tactic.alias.alias_attr", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "tactic.econstructor", "tactic.unsafe.type_context.list_mvars", "can_lift_attr", "tactic.add_inductive", "tactic.match_hypothesis", "list.range'", "tactic.explode.head'", "tactic.terminal_goal", "list.sublists_aux\u2081", "expr.binding_body", "tactic.interactive.clear'", "list.func.set", "tactic.back_lemmas_add_extra", "list.scanr_aux", "simps_add_projection", "list.find", "expr.binding_name", "where.collect_implicit_names", "list.chain'", "tactic.interactive.lift", "tactic.mk_mvar_list", "expr.instantiate_locals", "tactic.mllist.force", "list.intercalate", "tactic.interactive.unfold1", "list.split_at", "tactic.interactive.unfold_projs", "list.reflect", "occurrences_to_format", "add_interactive", "tactic.ext_parse", "list.func.equiv", "list.mpartition", "expr.is_heq", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "localized_cmd", "expr.get_app_fn_args_aux", "tactic.join_user_simp_lemmas_core", "tactic.mk_local_pisn", "list.filter_cons_of_neg", "list.length_drop", "tactic.choose1", "parser.many", "list.ne_nil_of_length_eq_succ", "tactic.extract_def", "tactic.delta_target", "list.subset.trans", "smt_tactic.interactive.add_eqn_lemmas", "list.erasep", "list.length_map", "list.is_infix", "list.to_string", "simps_tac", "list.filter_append", "tactic.rewrite", "tactic.i_to_expr_for_apply", "tactic.try_apply_opt_auto_param_for_apply", "rbmap.has_repr", "list.filter_nil", "tactic.constr_to_prop", "tactic.rintro_parse", "tactic.local_proof", "declaration.value_task", "tactic.cc", "interactive.types.without_ident_list", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.solve_aux", "list.chain_cons", "monad.foldl", "list.has_sdiff", "expr.traverse", "list.repr", "list.modify_nth", "expr.lambdas", "list.any_of", "list.choose_x", "tactic.propositional_goal", "tactic.choose", "expr.is_constant_of", "tactic.match_expr", "dlist.lazy_of_list", "smt_state.has_append", "expr.is_eta_expansion_of", "list.subset_cons", "tactic.get_goal", "expr.is_eq", "list.rotate", "tactic.resolve_constant", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "smt_tactic.interactive.dsimp", "declaration.update_value_task", "well_founded_tactics.default", "tactic.apply_auto_param", "environment.decl_filter_map", "tactic.change_core", "string.map_tokens", "list.append", "tactic.interactive.change'", "name.components", "lint", "expr.const_name", "dlist.to_list_append", "monad.sequence'", "list.mmap_filter", "list.extractp", "tactic.match_assoc_pattern'", "tactic.intros_dep", "tactic.instance_stub", "list.mem_nil_iff", "expr.get_app_fn_args", "list.mem_cons_iff", "tactic.interactive.simp", "tactic.in_open_namespaces", "where.get_includes_core", "list.pairwise", "lean.parser.get_includes", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.apply_assumption", "no_rsimp", "tactic.kdependencies", "tactic.rintro", "conv.funext", "old_conv.match_pattern", "list.split_on", "where.strip_pi_binders", "expr.get_pis", "tactic.match_target_subexpr", "tactic.constructor_idx", "string.iterator.next_to_string_mk_iterator", "tactic.clear_aux_decl", "declaration.is_definition", "where.collect_by_aux", "list.unzip", "mk_hinst_lemma_attr_from_simp_attr", "old_conv.funext", "tactic.interactive.refine_struct", "rbmap.from_list", "parser.many1", "tactic.interactive.rec.to_tactic_format", "user_attribute.dflt_cache_cfg", "tactic.dependent_pose_core", "list.mem_append_right", "list.remove_all", "list.rotate'", "string.split_on", "tactic.interactive.guard_hyp_nums", "tactic.lift", "list.cons_append", "simps_add_projections", "list.permutations", "expr.mk_delayed_abstraction", "tactic.abstract", "interactive.loc", "list.map_id", "tactic.interactive.squeeze_simpa", "tactic.ematch_all_core", "conv.dsimp", "string.iterator.extract_core", "tactic.successes", "tactic.interactive.simp_core_aux", "list.sublists", "tactic.right", "tactic.frozen_local_instances", "buffer.has_to_tactic_format", "string.iterator.zero_lt_length_next_to_string_of_has_next", "tactic.mk_patterns", "cc_state.eqc_of", "tactic.generalizes", "list.mmap_accuml", "tactic.interactive.clear", "smt_tactic.focus1", "tactic.interactive.injection", "expr.is_false", "list.map_cons", "list.indexes_of", "expr.is_pi", "print_decls_sorted_mathlib", "list.is_suffix", "doc_blame_report_defn", "smt_tactic.get_facts", "list.empty", "tactic.interactive.existsi", "list.mem_cons_self", "tactic.fapply", "tactic.apply_at_aux", "tactic.rewrite_hyp", "list.nodup", "declaration.to_definition", "local_context.to_list", "cc_state.eqc_of_core", "tactic.transport_with_prefix_dict", "string.str_ne_str_right", "list.decidable_chain", "string.to_list", "list.indexes_values", "declaration.update_name", "to_additive.map_namespace", "list.revzip", "expr.is_mvar", "print_all_content", "string.intercalate", "tactic.explode.may_be_proof", "char.is_punctuation", "mzip_with'", "tactic.mllist.squash", "list.has_dec_eq", "list.map_accumr", "list.append_nil", "tactic.case_bash", "tactic.elim_gen_prod", "tactic.by_cases", "rsimp_attr", "show_goal_cmd", "list.take", "tactic.add_theorem_by", "tactic.mk_app", "list.map_with_index", "list.traversable", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.subobject_names", "list.qsort_cons", "where.resolve_vars", "tactic.simp_intros_aux", "tactic.interactive.cases_arg_p", "list.map\u2082", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "char.decidable_is_punctuation", "tactic.interactive.mk_paragraph_aux", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "dlist.join", "name_set.insert_list", "expr.reduce_let", "merge_hinst_lemma_attrs", "well_founded_tactics.cancel_nat_add_lt", "native.rb_lmap.contains", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.mk_theorem", "old_conv.interactive.find", "tactic.interactive.simp_rw", "list.has_to_format", "declaration.instantiate_value_univ_params", "tactic.mk_id_eq", "tactic.eqn_stub", "string.split", "where.trace_opens", "tactic.get_pi_binders_aux", "list.find_indexes_aux", "where.find_var", "interactive.types.pexpr_list_or_texpr", "expr.is_lambda", "tactic.mk_constructors_arg_names", "tactic.merge_list", "list.sublists'", "simps_attr", "list.length", "list.subset_append_left", "list.length_take", "mk_hinst_lemma_attrs_core", "smt_tactic.all_goals", "expr.mk_app", "smt_state", "rbtree.to_list", "smt_tactic.interactive.add_lemma", "buffer.append_list", "list.mfirst", "string.empty_ne_str", "list.enum_from", "expr.instantiate_univ_params", "expr.mk_true", "tactic.enum_assoc_subexpr", "well_founded_tactics.is_psigma_mk", "expr.list_meta_vars", "environment.structure_fields_full", "name.from_components", "find_cmd", "declaration.map_value", "tactic.interactive.substs", "tactic.var_names", "tactic.cc_dbg", "tactic.mk_local_pis_whnf", "declaration.update_value", "ematch", "smt_tactic.slift_aux", "list.choose", "tactic.interactive.assume", "tactic.any_hyp", "control_laws_tac", "tactic.decl_mk_const", "check_unused_arguments_aux", "list.has_emptyc", "tactic.interactive.collect_struct'", "list.nth_le", "tactic.iterate1", "list.mfilter", "tactic.back_chaining", "library_note_attr", "tactic.olean_doc_strings", "native.rb_map.values", "smt_tactic.get_refuted_facts", "expr.is_var", "tactic.mk_local_pis", "tactic.mllist.concat", "list.lt_eq_not_ge", "buffer.has_repr", "list.decidable_chain'", "declaration.is_axiom", "tactic.list_constructors_hole", "tactic.interactive.compact_decl_aux", "tactic.dunfold_target", "tactic.introv", "environment.get_decl_names", "tactic.suggest.apply_and_solve", "tactic.mk_local", "simp_attr.functor_norm", "simp_attr.norm", "expr.is_or", "tactic.fill_args", "tactic.revert_and_transform", "parser.one_of", "declaration.value", "list.partition", "tactic.local_def_value", "tactic.mllist.of_list", "tactic.mllist.fixl_with", "param_info", "tactic.use", "tactic.comp_val", "expr.instantiate_lambdas_or_apps", "tactic.interactive.loc.get_local_uniq_names", "cc_state.roots_core", "old_conv.congr_core", "list.ilast'", "where.get_opens", "level.instantiate", "list.reverse_core", "native.rb_map.keys", "tactic.unsafe.type_context.print_mvars", "list.func.pointwise", "apply_nolint_tac", "tactic.interactive.rw_rules_t.has_reflect", "tactic.interactive.obtain", "parser.many_char1", "expr.is_eta_expansion_aux", "list.has_decidable_le", "list.find_indexes", "list.sublists_aux", "list.range", "expr.of_int", "list.forall\u2082", "tactic.match_target", "list.mmap_accumr", "tactic.ematch_core", "tactic.get_spec_subsingleton_info", "tactic.apply", "tactic.contradiction", "check_unused_arguments", "old_conv.apply_propext_lemmas_core", "monad.sequence", "tactic.interactive.use", "native.rb_map.mfilter", "tactic.mk_has_reflect_instance", "tactic.iterate'", "environment.get_trusted_decls", "list.mem_cons_eq", "list.subset_append_right", "list.qsort", "print_item_crawl", "tactic.all_goals", "list.scanr", "declaration.is_constant", "list.nil_append", "smt_tactic.execute", "parser.sep_by", "tactic.split_ifs", "expr.app_fn", "list.of_fn_aux", "tactic.ancestor_attr", "tactic.simp_intros", "tactic.interactive.cases_type", "list.nth", "tactic.alias.alias_cmd", "list.length_tail", "list.bin_tree_to_list", "add_succ_defeq_succ_add_hint", "interactive.loc.get_locals", "tactic.interactive.eapply", "interactive.loc.include_goal", "conv.interactive.find", "expr.mk_and_lst", "tactic.interactive.to_expr'", "tactic.interactive.ext", "tactic.alias.alias_direct", "list.transpose", "dlist.empty", "tactic.solve_by_elim", "lint_hole_cmd", "string.has_decidable_eq", "tactic.interactive.show", "tactic.ematch_all", "rsimp.collect_implied_eqs", "list.tfae", "tactic.relation_lhs_rhs", "list.sum", "tactic.interactive.simp_intros", "rbtree.from_list", "list.map_with_index_core", "list.split_on_p", "tactic.dunfold_hyp", "rbtree_of", "list.has_repr", "list.bex_cons", "tactic.apply_congr_core", "expr.is_let", "where.get_variables_core", "monad.mapm", "list.reduce_option", "tactic.interactive.rintro", "list.length_map_accumr", "list.to_string_aux", "tactic.explode.pad_right", "tactic.unsafe.type_context.to_tmp_mvars", "simp_lemmas.rewrites", "buffer.to_list", "tactic.join_user_simp_lemmas", "interactive.inductive_decl", "list.tail", "list.bor", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "list.as_string", "list.monad", "fold_over_with_cond", "interactive.parse_binders", "smt_config.inhabited", "tactic.goals", "tactic.by_contradiction", "list.last", "dlist.singleton", "simp_attr.split_if_reduction", "tactic.intros", "expr.app_of_list", "tactic.find_ancestors", "tactic.interactive.clear_", "expr.get_app_args", "list.is_suffix_of", "tactic.interactive.return_cast", "tactic.explode.has_to_tactic_format", "list.count", "parser.decorate_errors", "native.rb_lmap.of_list", "dlist.to_list", "simp_lemmas.erase", "where.resolve_var", "environment.is_structure", "list.sublist", "tactic.constructor", "native.rb_map.mmap", "list.sections", "list.scanl", "fun_info_to_format", "tactic.interactive.auto_simp_lemma", "tactic.andthen_seq_focus", "list.for_each", "list.zip", "list.countp", "tactic.fsplit", "list.init", "tactic.interactive.constructor_matching", "tactic.assoc_rewrite", "expr.simp", "open_locale_cmd", "tactic.assoc_rewrite_hyp", "tactic.rewrite_target", "list.to_format", "list.has_append", "expr.dsimp", "list.head'", "simps_parser", "get_linters", "list.filter_sublist", "smt_tactic.get_goals", "tactic.subsingleton_goal", "tactic.revert", "tactic.mk_assoc", "expr.mk_false", "expr.is_aux_decl", "tactic.ematch", "list.is_lawful_monad", "tactic.injection_with", "user_attribute_cache_cfg", "tactic.induction", "expr.is_local_constant", "list.after", "tactic.interactive.funext", "tactic.lambdas", "get_attribute_cache_dyn", "unification_hint.inhabited", "native.rb_map.set_of_list", "tactic.fconstructor", "tactic.interactive.exacts", "tactic.interactive.change", "tactic.collect_ctx_simps", "expr.app_arg", "reflected.subst", "tactic.match_stub", "list.lookmap", "option.mem_to_list", "tactic.mk_constructor_fresh_names", "tactic.interactive.refine_recursively", "tactic.delta_hyp", "buffer.has_to_format", "list.inth", "list_linters", "tactic.fold_explicit_args_aux", "lint_aux", "native.rb_lmap.insert", "declaration.is_auto_generated", "list.map_last", "tactic.interactive.list_cast_of", "list.indexes_values_aux", "tactic.interactive.simp_core", "list.qsort.F", "list.append_assoc", "well_founded_tactics.unfold_wf_rel", "tactic.any_hyp_aux", "declaration.univ_levels", "string.str_ne_str_left", "list.has_le", "environment.structure_fields", "structure_instance_info", "list.has_union", "list.ret", "tactic.def_replacer", "tactic.injection", "list.permutations_aux", "list.disjoint", "interactive.parse_binders_core", "tactic.interactive.match_target", "to_hinst_lemmas_core", "tactic.mk_simp_set_core", "fun_info.inhabited", "debugger.attr", "tactic.back_chaining_using", "list.inter", "tactic.simp_hyp", "tactic.explode.format_aux", "derive_handler_attr", "smt_tactic.intro_lst", "smt_tactic.interactive.eblast_using", "environment.constructors_of", "native.rb_lmap.erase", "expr.is_app", "tactic.repeat", "conv.change", "declaration.get_kind_string", "list.filter_cons_of_pos", "tactic.solve1", "list.append_bind", "tactic.mllist.take", "list.mmap", "tactic.cases_core", "list.has_mem", "loc.to_string", "tactic.alias.alias_iff", "conv.interactive.for", "string.iterator_imp", "list.mfoldl", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.ext1", "list.sublists'_aux", "list.decidable_eq", "list.has_to_tactic_format", "tactic.interactive.mapply", "list.nil_bind", "list.has_lt", "list.remove_nth", "tactic.mk_meta_pis", "tactic.interactive.refine_one", "tactic.explode.entry", "list.modify_nth_tail", "tactic.interactive.swap", "list.mem_cons_of_mem", "tactic.prove_goal_async", "char.decidable_is_whitespace", "tactic.interactive.apply_with", "expr.to_binder", "list.take'", "tactic.match_pattern", "tactic.funext", "tactic.apply_core", "expr.pis", "tactic.interactive.fapply", "tactic.swap", "tactic.split", "fold_over_with_cond_sorted", "tactic.solve_by_elim_aux", "tactic.dsimp_target", "tactic.interactive.casesm", "impossible_instance", "fun_info", "parser.many_char", "incorrect_type_class_argument", "tactic.interactive.clean", "string.has_lt", "expr.is_eta_expansion", "expr.drop_pis", "tactic.apply_rules", "list.pw_filter", "tactic.simp_all", "cc_config.inhabited", "where.inflate", "list.has_decidable_lt", "list.subset_of_cons_subset", "tactic.intro1_aux", "simp_lemmas.append", "list.func.get", "expr.is_constant", "tactic.decode_simp_arg_list", "environment.in_current_file'", "conv.interactive.simp", "list.map_singleton", "expr.is_not", "tactic.pattern", "tactic.mk_constructors_fresh_names", "list.span", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.list_Sigma", "tactic.add_meta_definition", "tactic.get_ancestors", "list_items", "tactic.dunfold", "tactic.assumption", "list.length_map\u2082", "list.product", "expr.to_implicit_local_const", "tactic.mk_assoc_instance", "tactic.chain_eq_trans", "tactic.interactive.rw_rules", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "list.iota", "monad.mapm'", "smt_tactic.by_contradiction", "list.length_map_accumr\u2082", "list.bag_inter", "list.take_while", "list.subset.refl", "list.index_of", "tactic.mk_num_meta_univs", "environment.get_decls", "tactic.try_lst", "vm_decl.args_info", "list.pairwise_cons", "tactic.replacer_core", "instance_priority", "mzip_with", "tactic.interactive.dunfold", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "instance_derive_handler", "tactic.interactive.mk_paragraph", "tactic.inhabited_instance", "tactic.simp_arg_list", "expr.abstract_locals", "declaration.is_trusted", "declaration", "param_info.inhabited", "tactic.set_goals", "list.erase", "tactic.interactive.extract_goal", "expr.instantiate_lambdas", "expr.instantiate_vars", "native.rb_lmap", "tactic.seq", "list.find_index", "smt_tactic.induction", "expr.is_macro", "where.resolve_vars_aux", "environment.mfilter", "list.has_insert", "tactic.interactive.field", "tactic.interactive.erase_simp_args", "tactic.add_defn_equations", "tactic.delta_instance", "list.inhabited", "nat.digit_succ", "list.ball_cons", "smt_tactic.interactive.simp", "list.map_map", "tactic.interactive.injections", "get_checks", "tactic.interactive.clear_except", "list.last'", "list.map_head", "list.partition_map", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "tactic.flatten", "string_imp.inhabited", "interactive.loc.apply", "list.drop", "list.qsort_nil", "option.to_list", "tactic.mk_inj_eq", "smt_tactic.interactive.change", "tactic.applyc", "tactic.explode.entries", "smt_tactic.interactive.ematch_using", "format.intercalate", "dlist.to_list_of_list", "tactic.unify_prefix", "string.join", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.interactive.apply_rules", "tactic.revert_lst", "list.get_rest", "occurrences", "tactic.decidable_eq_derive_handler", "where.format_variable", "list.nodup_decidable", "tactic.interactive.h_generalize", "interactive.param_desc", "nat.bits", "tactic.mk_id_proof", "tactic.interactive.intros", "tactic.tag", "tactic.funext_lst", "tactic.alias.make_left_right", "well_founded_tactics", "conv.congr", "where.strip_pi_binders_aux", "list.foldl", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "list.foldr", "environment.add_defn_eqns", "list.erase_dup", "list.mem", "list.func.add", "tactic.explode.entries.add", "tactic.funext_core", "tactic.injections_and_clear", "saturate_fun", "tactic.interactive.choose", "where.get_all_in_namespace", "dangerous_instance", "mk_hinst_lemma_attr_core", "tactic.interactive.source_fields", "lift_list", "local_context.to_format", "expr.list_names_with_prefix", "array.rev_list", "parser.decorate_error", "cc_config", "list.modify_head", "expr.binding_info", "list.diff", "declaration.update_type", "conv.convert", "tactic.find_private_decl", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "expr.pi_binders", "expr.abstract", "list.length_repeat", "has_reflect_derive_handler", "tactic.mllist.fixl", "tactic.induction'", "tactic.interactive.rw_rules_t", "tactic.any_goals", "list.subset", "list.filter_map", "where.compile_variable_list", "doc_blame_report_thm", "tactic.mk_eq_proof", "tactic.interactive.introsI", "tactic.rename'", "tactic.resolve_name'", "interactive.single_inductive_decl", "native.rb_set.to_list", "list.length_remove_nth", "tactic.solve", "tactic.replacer_attr", "tactic.subst", "tactic.interactive.suggest", "tactic.list_Pi", "list.is_nil", "interactive.types.location", "smt_tactic.interactive.add_lhs_lemma", "tactic.has_to_tactic_format", "tactic.get_goals", "interactive.types.list_of", "conv.interactive.dsimp", "list.mfoldr", "list.any", "list.traverse", "tactic.suggest.library_defs", "expr.pi_binders_aux", "list.insert_nth", "tactic.interactive.push_neg", "simp_lemmas.dsimplify", "tactic.intros1", "list.map", "list.le", "list.le_eq_not_gt", "derive_struct_ext_lemma", "environment.decl_map", "where.collect_by", "lint_mathlib", "list.decidable_pairwise", "tactic.intro_lst", "tactic.reduce_ifs_at", "tactic.num_goals", "tactic.clear_aux_decl_aux", "ge_or_gt_in_statement", "lint_all", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "list.chain", "tactic.interactive.collect_struct", "expr.is_and", "declaration.instantiate_type_univ_params", "has_inhabited_instance", "smt_tactic.interactive.executor", "tactic.interactive.apply", "list.partition_eq_filter_filter", "dedup", "tactic.expanded_field_list", "expr", "tactic.interactive.delta", "tactic.metavariables", "list.has_to_string", "dup_namespace", "tactic.valid_types", "old_conv.mk_match_expr", "native.rb_map.to_list", "list.to_buffer", "tactic.apply_opt_param", "expr.of_nat", "conv.discharge_eq_lhs", "string.iterator_imp.inhabited", "list.mmap'", "list.has_inter", "tactic.get_pi_binders_dep_aux", "congr_lemma", "dlist.of_list", "dlist", "list.tails", "smt_tactic.num_goals", "tactic.pexpr_to_pattern", "tactic.mk_simp_set", "tactic.get_pi_binders_dep", "list.to_array", "expr.local_uniq_name", "tactic.interactive.compact_decl", "tactic.interactive.generalize_proofs", "list.cons_bind", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "expr.to_implicit_binder", "tactic.eapply", "declaration.univ_params", "tactic.apply_at", "tactic.interactive.clean_ids", "tactic.get_eqn_lemmas_for", "derive_attr", "list.eq_nil_of_length_eq_zero", "where.select_for_which", "dlist.to_list_singleton", "tactic.match_fn", "unification_hint", "expr.collect_univ_params", "list.bind", "old_conv.match_expr"]}, {"id": "iff_self", "parentIds": ["list.mem_append", "imp_or_distrib'", "classical.forall_or_distrib", "option.some_inj", "bex_imp_distrib", "iff_eq_true_of_eq", "not_iff", "exists_and_distrib_right", "prod.eq_iff_fst_eq_snd_eq", "not_exists_not", "imp_or_distrib", "option.mem_to_list", "and.rotate", "exists_eq_right'", "and.right_comm", "forall_eq'", "exists_eq_left'", "nat.le_div_iff_mul_le", "bool.to_bool_eq", "forall_or_distrib_right"]}, {"id": "list.has_append", "parentIds": ["list.mem_append", "tactic.interactive.squeeze_simp", "tactic.focus1", "list.mem_append_eq", "tactic.mk_has_sizeof_instance_core", "tactic.mk_assumption_set", "smt_tactic.seq", "tactic.seq_focus", "tactic.interactive.convert", "dlist.to_list_concat", "list.mem_append_left", "dlist.to_list_cons", "list.length_append", "list.is_prefix", "tactic.elim_gen_sum", "list.map_append", "dlist.of_list_to_list", "interactive.loc.try_apply", "list.is_infix", "list.filter_append", "dlist.lazy_of_list", "smt_state.has_append", "dlist.to_list_append", "tactic.interactive.refine_struct", "tactic.interactive.rec.to_tactic_format", "list.mem_append_right", "list.cons_append", "tactic.interactive.squeeze_simpa", "smt_tactic.focus1", "list.is_suffix", "string.str_ne_str_right", "list.append_nil", "list.qsort_cons", "tactic.mk_dec_eq_instance_core", "list.subset_append_left", "string.empty_ne_str", "ematch", "smt_tactic.slift_aux", "list.subset_append_right", "list.nil_append", "list.is_lawful_monad", "list.append_assoc", "string.str_ne_str_left", "list.append_bind", "tactic.interactive.refine_one", "tactic.get_ancestors", "mk_hinst_lemma_attr_set", "tactic.interactive.extract_goal", "tactic.seq", "dlist.to_list_of_list", "where.format_variable", "tactic.alias.make_left_right", "conv.congr", "tactic.mk_eq_proof", "derive_struct_ext_lemma", "dlist.of_list", "dlist", "list.cons_bind", "tactic.module_doc_strings", "tactic.apply_at"]}, {"id": "has_append", "parentIds": ["list.mem_append", "declaration.modifiers.has_to_string", "tactic.interactive.squeeze_simp", "string.quote", "tactic.focus1", "option_to_tactic_format", "print_decls_sorted", "param_info.to_format", "list.mem_append_eq", "to_additive.target_name", "where.trace_namespace", "name.has_append", "unused_arguments", "sigma.has_to_format", "tactic.cc_core", "tactic.mk_has_sizeof_instance_core", "print_arguments", "tactic.mk_assumption_set", "where.trace_variables", "where.mk_flag", "smt_tactic.seq", "sum_has_to_format", "tactic.seq_focus", "tactic.interactive.convert", "dlist.to_list_concat", "list.mem_append_left", "tactic.mk_simp_attribute_cmd", "tactic.clear'", "tactic.interactive.rcases", "restate_axiom_cmd", "dlist.to_list_cons", "list.length_append", "name_set.has_to_format", "list.is_prefix", "tactic.elim_gen_sum", "native.rb_map.has_to_tactic_format", "to_additive.proceed_fields", "list.map_append", "tactic.assoc_refl", "print_decls", "ematch_lhs", "native.has_to_string", "dlist.of_list_to_list", "rbtree.has_repr", "interactive.loc.try_apply", "tactic.terminal_goal", "tactic.mk_user_fresh_name", "simps_add_projection", "occurrences_to_format", "localized_cmd", "old_conv.conversion", "list.is_infix", "parser.mk_error_msg", "simps_tac", "list.filter_append", "native.has_to_format", "interaction_monad.result_to_string", "rbmap.has_repr", "name.add_prime", "dlist.lazy_of_list", "smt_state.has_append", "dlist.to_list_append", "tactic.instance_stub", "where.trace_includes", "tactic.suggest.tactic_statement", "format.indent", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "tactic.interactive.refine_struct", "tactic.interactive.rec.to_tactic_format", "list.mem_append_right", "tactic.interactive.guard_hyp_nums", "tactic.lift", "list.cons_append", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "smt_tactic.focus1", "print_decls_sorted_mathlib", "list.is_suffix", "string.str_ne_str_right", "list.append_nil", "rsimp_attr", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.subobject_names", "list.qsort_cons", "tactic.decorate_ex", "tactic.mk_dec_eq_instance_core", "buffer.has_append", "tactic.eqn_stub", "where.trace_opens", "list.subset_append_left", "format.has_append", "string.empty_ne_str", "environment.structure_fields_full", "ematch", "smt_tactic.slift_aux", "tactic.list_constructors_hole", "exceptional.to_string", "tactic.local_def_value", "tactic.use", "native.rb_set.has_to_format", "tactic.interactive.obtain", "where.trace_end", "list.subset_append_right", "print_item_crawl", "list.nil_append", "tactic.alias.alias_cmd", "binder.to_string", "prod.has_to_format", "tactic.interactive.simp_intros", "tactic.interactive.rintro", "option.has_to_format", "list.to_format", "list.has_append", "get_linters", "list.is_lawful_monad", "dlist.has_append", "char_to_hex", "hinst_lemmas.pp", "tactic.match_stub", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "list.append_assoc", "string.str_ne_str_left", "tactic.def_replacer", "string.has_append", "binder.has_to_tactic_format", "list.append_bind", "tactic.interactive.simpa", "tactic.ext1", "tactic.interactive.refine_one", "my_name_to_string", "char.quote_core", "impossible_instance", "incorrect_type_class_argument", "tactic.get_ancestors", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "format.bracket", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "tactic.seq", "tactic.delta_instance", "dlist.to_list_of_list", "string.join", "where.format_variable", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.alias.make_left_right", "conv.congr", "tactic.get_lift_prf", "tactic.interactive.case", "tactic.has_append", "dangerous_instance", "mk_hinst_lemma_attr_core", "tactic.mk_eq_proof", "tactic.replacer_attr", "equiv_type_constr", "pos.has_to_format", "tactic.has_to_tactic_format", "format.dcbrace", "derive_struct_ext_lemma", "tactic.ids_to_simp_arg_list", "char.has_repr", "tactic.import_private_cmd", "tactic.success_if_fail_with_msg", "dup_namespace", "dlist.of_list", "dlist", "list.cons_bind", "tactic.module_doc_strings", "tactic.apply_at"]}, {"id": "false_or", "parentIds": ["list.mem_append", "imp_or_distrib'", "if_true_right_eq_or", "bool.dichotomy", "or_eq_of_eq_false_left", "if_true_left_eq_or", "bool.to_bool_or", "bor_eq_true_eq_eq_tt_or_eq_tt", "band_eq_false_eq_eq_ff_or_eq_ff"]}, {"id": "has_mem", "parentIds": ["list.mem_append", "list.decidable_bex", "list.not_mem_nil", "list.ball_nil", "list.not_bex_nil", "ne_of_mem_of_not_mem", "list.decidable_ball", "list.subset_cons_of_subset", "list.mem_append_eq", "function.inv_fun_on_eq", "tactic.mk_assumption_set", "list.eq_or_mem_of_mem_cons", "array.read_mem", "function.inv_fun_on_neg", "function.inv_fun_eq", "list.nil_subset", "list.mem_append_left", "list.cons_subset_cons", "set.image", "set.subset", "list.insert", "list.decidable_mem", "set.sUnion", "set.compl", "function.injective_of_partial_inv_right", "char.is_whitespace", "list.subset.trans", "list.choose_x", "function.inv_fun_on_eq'", "list.subset_cons", "function.inv_fun_on", "function.inv_fun_on_pos", "option.has_mem", "list.mem_nil_iff", "list.mem_cons_iff", "list.pairwise", "option.decidable_exists_mem", "list.mem_append_right", "list.remove_all", "list.mem_cons_self", "rbmap.has_mem", "char.is_punctuation", "tactic.subobject_names", "list.choose", "set.has_mem", "set.inter", "parser.one_of", "function.inv_fun_neg", "function.inv_fun_on_mem", "check_unused_arguments", "list.mem_cons_eq", "buffer.has_mem", "list.tfae", "list.bex_cons", "set.sep", "set.piecewise", "rbtree.has_mem", "set.diff", "option.mem_to_list", "declaration.is_auto_generated", "list.disjoint", "tactic.mk_simp_set_core", "list.inter", "list.has_mem", "conv.interactive.for", "tactic.interactive.refine_one", "list.mem_cons_of_mem", "tactic.interactive.clean", "list.subset_of_cons_subset", "environment.in_current_file'", "list_items", "set.union", "list.subset.refl", "option.mem_def", "list.pairwise_cons", "list.ball_cons", "set.is_lawful_functor", "array.has_mem", "tactic.interactive.source_fields", "set.insert", "list.subset", "list.decidable_pairwise", "ge_or_gt_in_statement", "has_inhabited_instance", "option.decidable_forall_mem"]}, {"id": "or", "parentIds": ["list.mem_append", "decidable.lt_or_gt_of_ne", "nat.le_total", "is_total", "tactic.replace_at", "bool.bor_inl", "not_and_distrib'", "eq_zero_or_eq_zero_of_mul_eq_zero", "le_iff_lt_or_eq", "not_not_em", "is_valid_char_range_1", "nat.eq_zero_or_eq_succ_pred", "imp_or_distrib'", "list.subset_cons_of_subset", "decidable.eq_or_lt_of_le", "and_or_distrib_left", "or_and_distrib_right", "expr.mk_exists_lst", "classical.or_not", "list.mem_append_eq", "nonempty_sum", "or_and_distrib_left", "lt_or_gt_of_ne", "exists_ge_of_linear", "classical.forall_or_distrib", "linear_ordered_semiring", "tactic.mk_assumption_set", "is_valid_char_range_2", "expr.mk_or_lst", "list.eq_or_mem_of_mem_cons", "or_of_or_of_imp_right", "or.by_cases", "decidable_linear_ordered_semiring", "nat.lt_or_ge", "int.nat_abs_eq", "list.mem_append_left", "incorrect_def_lemma", "list.cons_subset_cons", "or.assoc", "tactic.interactive.solve_by_elim", "prod.lex.decidable", "le_or_lt", "nat.lt_trichotomy", "classical.or_iff_not_imp_left", "integral_domain", "or.imp_right", "or_of_or_of_imp_of_imp", "nat.eq_zero_or_pos", "not_or_of_imp", "lt_of_not_ge", "decidable_linear_ordered_cancel_comm_monoid", "nat.mod_two_of_bodd", "eq_of_incomp", "eq_or_lt_of_not_lt", "or_iff_right_of_imp", "no_zero_divisors", "or.imp", "if_true_right_eq_or", "int.eq_coe_or_neg", "decidable.lt_or_le", "list.subset_cons", "bor_coe_iff", "ne_iff_lt_or_gt", "bex_or_distrib", "push_neg.not_and_eq", "list.mem_cons_iff", "or_imp_distrib", "false_or", "exists_or_distrib", "le_of_eq_or_lt", "linear_ordered_comm_ring", "or.neg_resolve_left", "bool.dichotomy", "list.mem_append_right", "tactic.interactive.simp_core_aux", "decidable.lt_or_eq_of_le", "nat.eq_zero_of_mul_eq_zero", "decidable_linear_order", "list.mem_cons_self", "not_lt_iff_eq_or_lt", "lt_trichotomy", "or.elim3", "or_iff_left_of_imp", "tactic.intro", "or.swap", "discrete_linear_ordered_field", "trichotomous_of", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "not_and_distrib", "eq_false_of_or_eq_false_right", "or.resolve_right", "dec_em", "or.left_comm", "linear_ordered_ring", "or.comm", "classical.prop_complete", "non_contradictory_em", "decidable.le_iff_lt_or_eq", "d_array.of_beq_aux_eq_ff", "eq_zero_of_neg_eq", "linear_order", "or.intro_left", "or_eq_of_eq_true_right", "true_or", "classical.or_iff_not_imp_right", "le_of_not_gt", "prod.has_lt", "char.is_alpha", "mul_eq_zero_iff_eq_zero_or_eq_zero", "le_of_lt_or_eq", "or_iff_not_and_not", "push_neg.classical.implies_iff_not_or", "not_or", "prod.lt_def", "list.mem_cons_eq", "classical.forall_or_distrib_left", "lt_or_ge", "classical.not_and_distrib", "imp_iff_not_or", "decidable.le_or_lt", "or_false", "or_eq_of_eq_false_left", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "iff_iff_and_or_not_and_not", "classical.forall_or_distrib_right", "decidable.lt_trichotomy", "list.bex_cons", "xor", "nat.eq_or_lt_of_le", "and_or_distrib_right", "bool.exists_bool", "nat.sub_mul_div", "and_iff_not_or_not", "tactic.suggest.process_declaration", "not_and_of_not_or_not", "char.is_alphanum", "imp_or_distrib", "int.le_total", "or.neg_resolve_right", "le_iff_eq_or_lt", "nat.eq_or_lt_of_not_lt", "or_eq_of_eq_false_right", "ordering.or_else_eq_lt", "or_iff_not_imp_right", "option.mem_to_list", "classical.imp_iff_not_or", "declaration.is_auto_generated", "or_eq_of_eq", "classical.eq_false_or_eq_true", "lt_or_le", "or_true", "sum.exists", "le_total", "nat.mod_add_div", "decidable.em", "forall_or_of_or_forall", "decidable.not_and_iff_or_not", "list.mem_cons_of_mem", "is_valid_char", "decidable.not_or_iff_and_not", "bool.bor_inr", "char.quote_core", "if_true_left_eq_or", "classical.eq_true_or_eq_false", "bool.decidable_exists_bool", "mul_self_eq_mul_self_iff", "dist_bdd_within_interval", "tactic.alias.get_alias_target", "or.imp_left", "or_assoc", "total_of", "decidable_linear_ordered_comm_ring", "decidable.ne_iff_lt_or_gt", "set.union", "prod.lex_def", "lt_or_eq_of_le", "instance_priority", "classical.iff_iff_not_or_and_or_not", "or.elim", "nat.mod_two_eq_zero_or_one", "bool.to_bool_or", "or_congr", "push_neg.not_or_eq", "eq_or_lt_of_le", "or.intro_right", "not_or_distrib", "eq_false_of_or_eq_false_left", "nat.mod_pow_succ", "tactic.alias.make_left_right", "linear_ordered_field", "or_comm", "tactic.suggest", "nonempty_psum", "set.insert", "nat.le_div_iff_mul_le", "or.symm", "classical.em", "or_iff_not_imp_left", "le_or_gt", "or_eq_of_eq_true_left", "mul_self_eq_one_iff", "pos_and_pos_or_neg_and_neg_of_mul_pos", "trichotomous", "or.resolve_left", "or.decidable", "decidable_linear_ordered_comm_group", "nat.cond_to_bool_mod_two", "is_trichotomous", "nat.div_div_eq_div_mul", "has_inhabited_instance", "or_self", "dup_namespace", "forall_or_distrib_left", "bor_eq_true_eq_eq_tt_or_eq_tt", "total", "or_of_or_of_imp_left", "band_eq_false_eq_eq_ff_or_eq_ff", "forall_or_distrib_right"]}, {"id": "or_assoc", "parentIds": ["list.mem_append"]}, {"id": "list.has_mem", "parentIds": ["list.mem_append", "list.decidable_bex", "list.not_mem_nil", "list.ball_nil", "list.not_bex_nil", "list.decidable_ball", "list.subset_cons_of_subset", "list.mem_append_eq", "tactic.mk_assumption_set", "list.eq_or_mem_of_mem_cons", "list.nil_subset", "list.mem_append_left", "list.cons_subset_cons", "list.insert", "list.decidable_mem", "char.is_whitespace", "list.subset.trans", "list.choose_x", "list.subset_cons", "list.mem_nil_iff", "list.mem_cons_iff", "list.pairwise", "list.mem_append_right", "list.remove_all", "list.mem_cons_self", "char.is_punctuation", "tactic.subobject_names", "list.choose", "parser.one_of", "check_unused_arguments", "list.mem_cons_eq", "list.tfae", "list.bex_cons", "option.mem_to_list", "declaration.is_auto_generated", "list.disjoint", "tactic.mk_simp_set_core", "list.inter", "conv.interactive.for", "tactic.interactive.refine_one", "list.mem_cons_of_mem", "tactic.interactive.clean", "list.subset_of_cons_subset", "environment.in_current_file'", "list_items", "list.subset.refl", "list.pairwise_cons", "list.ball_cons", "tactic.interactive.source_fields", "list.subset", "list.decidable_pairwise", "ge_or_gt_in_statement", "has_inhabited_instance"]}, {"id": "list.mem_cons_iff", "parentIds": ["list.mem_append", "list.bex_cons", "option.mem_to_list"]}, {"id": "list.not_mem_nil", "parentIds": ["list.mem_append", "option.mem_to_list"]}, {"id": "rbmap.mem", "parentIds": ["rbmap.has_mem"]}, {"id": "rbmap", "parentIds": ["rbmap.mem", "rbmap.fold", "rbmap.to_list", "rbmap.min", "rbmap_of", "rbmap.inhabited", "rbmap.rev_fold", "rbmap.has_repr", "rbmap.contains", "rbmap.from_list", "rbmap.has_mem", "mk_rbmap", "rbmap.find", "rbmap.max", "rbmap.find_entry", "rbmap.insert", "rbmap.empty"]}, {"id": "rbmap_lt", "parentIds": ["rbmap.mem", "rbmap.fold", "rbmap.to_list", "rbmap.min", "rbmap", "rbmap.rev_fold", "mk_rbmap", "rbmap.max", "rbmap.find_entry", "rbmap.insert", "rbmap.rbmap_lt_dec", "rbmap.empty"]}, {"id": "prod", "parentIds": ["rbmap.mem", "prod.has_to_tactic_format", "tactic.rcases.process_constructors", "tactic.interactive.record_lit", "list.enum", "tactic.simplify", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "tactic.replace_at", "list.permutations_aux2", "native.rb_map.of_list", "tactic.library_search_hole_cmd", "rbmap.fold", "environment.add_ginductive", "tactic.interactive.cases", "tactic.instance_cache.get", "smt_tactic.solve1", "tactic.delta", "expr.is_annotation", "id.is_comm_applicative", "tactic.rintro_hint", "tactic.flat_assoc", "pexpr.get_uninst_pis", "tactic.apply_iff", "prod.decidable_eq", "infer_type_cmd", "extensional_attribute", "tactic.rewrite_core", "tactic.mk_constructor_arg_names", "lean.parser.get_variables", "nat.bodd", "rbmap.to_list", "print_decls_sorted", "expr.is_iff", "tactic.rcases_hint.process_constructors", "state_t.run_bind", "smt_tactic.set_goals", "prod.id_prod", "tactic.rcases.process_constructor", "prod.has_reflect", "tactic.cases", "state_t.monad_map", "tactic.existsi", "expr.dedup_size", "unused_arguments", "list.map_accumr\u2082", "function.uncurry_curry", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "smt_tactic.trace_state", "print_arguments", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "tactic.instance_cache.append_typeclasses", "tactic.dsimplify", "prod.mk.eta", "rbmap.min", "where.trace_variables", "tactic.simplify_top_down", "where.mk_flag", "tactic.rcases_hint", "hole_command", "simp_lemmas.rewrite", "smt_tactic.seq", "transport_multiplicative_to_additive", "nat.bodd_div2", "restate_axiom", "using_smt", "conv.lhs", "tactic.match_or", "rbmap_of", "to_additive.tokens_dict", "prod.rprod_wf", "tactic.get_pi_binders", "tactic.interactive.by_cases", "where.sort_variable_list", "tactic.interactive.min_tac", "tactic.get_library_notes", "nat.div2", "tactic.interactive.induction", "tactic.interactive.rcases", "lean.parser.with_input", "tactic.symm_apply", "state_t.bind", "tactic.interactive.dsimp", "prod.forall", "expr.is_ne", "tactic.interactive.rename'", "has_dup", "rsimp.rsimplify_goal", "lean.parser.emit_command_here", "name_set.has_to_format", "state_t.run_map", "prod.lex.decidable", "nat.bodd_succ", "tactic.elim_gen_sum", "localized_attr", "native.rb_map.has_to_tactic_format", "environment.add_inductive", "push_neg.normalize_negations", "use_cmd", "tactic.interactive.rename'_args_parser", "expr.is_ge", "tactic.left", "smt_tactic.write", "tactic.assoc_refl", "rbmap", "prod.map_snd'", "print_decls", "tactic.mllist.empty", "tactic.mllist.head", "smt_tactic.swap", "native.has_to_string", "tactic.generalize_proofs", "state_t", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "local_context.mk_local", "prod.map_fst'", "rbmap_lt", "tactic.econstructor", "can_lift_attr", "tactic.add_inductive", "tactic.match_hypothesis", "state_t.run_monad_map", "old_conv.apply_lemmas_core", "list.scanr_aux", "where.collect_implicit_names", "rbmap.rev_fold", "expr.instantiate_locals", "tactic.mllist.enum_from", "list.split_at", "list.mpartition", "expr.is_heq", "where.get_def_variables", "prod.rprod", "tactic.interactive.generalize_hyp", "localized_cmd", "expr.get_app_fn_args_aux", "tactic.mk_eq_simp_ext", "tactic.mk_local_pisn", "tactic.choose1", "is_comm_applicative", "old_conv.to_tactic", "old_conv.conversion", "tactic.extract_def", "state_t.put", "binder_info.brackets", "expr.mfoldl", "tactic.norm_num", "tactic.mllist.enum", "native.has_to_format", "tactic.rewrite", "tactic.try_apply_opt_auto_param_for_apply", "state_t.run_adapt", "rbmap.has_repr", "tactic.constr_to_prop", "tactic.local_proof", "monad_state_adapter_trans", "tactic.match_assoc_pattern", "tactic.solve_aux", "prod_has_decidable_lt", "tactic.dsimplify_core", "tactic.ext_simplify_core", "lift_pair\u2081", "tactic.match_eq", "tactic.match_expr", "expr.is_eta_expansion_of", "expr.is_eq", "tactic.interactive.set", "lint", "tactic.assoc_root", "list.extractp", "tactic.match_assoc_pattern'", "is_comm_applicative.commutative_map", "tactic.instance_stub", "expr.get_app_fn_args", "environment.relation_info", "where.get_includes_core", "lean.parser.get_includes", "environment.is_refl_app", "where.trace_includes", "state_t.monad_except", "tactic.mk_iff_of_inductive_prop", "where.get_namespace_core", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.rintro", "rbmap.contains", "conv.funext", "old_conv.match_pattern", "where.strip_pi_binders", "expr.get_pis", "monad_state_adapter", "tactic.constructor_idx", "where.collect_by_aux", "list.unzip", "old_conv.funext", "native.float.frexp", "tactic.interactive.refine_struct", "rbmap.from_list", "tactic.dependent_pose_core", "state_t.adapt", "tactic.interactive.obtain_parse", "tactic.lift", "function.uncurry_bicompr", "tactic.interactive.squeeze_simpa", "prod.swap_swap", "tactic.ematch_all_core", "function.uncurry'_curry", "tactic.interactive.simp_core_aux", "tactic.rcases_hint_core", "tactic.right", "prod.map_fst", "tactic.mk_patterns", "list.mmap_accuml", "tactic.mk_replacer\u2082", "smt_tactic.focus1", "tactic.interactive.injection", "expr.is_gt", "vm.call_stack_var_range", "prod.lex", "print_decls_sorted_mathlib", "tactic.fapply", "tactic.apply_at_aux", "state_t.run_monad_lift", "tactic.rewrite_hyp", "lean.parser.get_namespace", "state_t.run_get", "tactic.match_heq", "lift_pair", "list.indexes_values", "list.revzip", "mk_rbmap", "function.injective_prod", "list.map_accumr", "tactic.elim_gen_prod", "tactic.by_cases", "show_goal_cmd", "tactic.add_theorem_by", "tactic.mk_inhabited_instance", "tactic.simp_bottom_up", "prod.inhabited", "tactic.subobject_names", "list.qsort_cons", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "state_t.lift", "prod.mk.inj_iff", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "old_conv.interactive.find", "tactic.eqn_stub", "tactic.ac_refl", "tactic.get_pi_binders_aux", "where.find_var", "tactic.apply_heq_congr_core", "simps_attr", "smt_tactic.all_goals", "prod.eq_iff_fst_eq_snd_eq", "prod.has_sizeof", "prod.swap_swap_eq", "list.enum_from", "expr.instantiate_univ_params", "well_founded_tactics.is_psigma_mk", "rbmap.max", "tactic.mk_local_pis_whnf", "smt_tactic.slift_aux", "tactic.decl_mk_const", "tactic.interactive.collect_struct'", "tactic.iterate1", "tactic.rcases_hint.continue", "tactic.olean_doc_strings", "tactic.mk_local_pis", "smt_tactic.save_info", "tactic.match_ne", "rsimp.rsimplify_at", "tactic.list_constructors_hole", "tactic.interactive.compact_decl_aux", "prod.fst_swap", "vm.stack_obj_info", "tactic.suggest.apply_and_solve", "expr.is_or", "tactic.fill_args", "tactic.apply_eq_congr_core", "name_with_opt", "list.partition", "tactic.local_def_value", "tactic.mllist.fixl_with", "tactic.comp_val", "prod.lex_wf", "level.instantiate", "prod.has_lt", "native.rb_set.has_to_format", "tactic.interactive.obtain", "smt_tactic.try", "rbmap.find_entry", "expr.is_eta_expansion_aux", "tactic.mllist", "tactic.mllist.uncons", "tactic.simplify_bottom_up", "list.mmap_accumr", "tactic.ematch_core", "tactic.apply", "old_conv.apply_propext_lemmas_core", "prod.map", "prod.lt_def", "tactic.interactive.generalize", "tactic.interactive.use", "native.rb_map.mfilter", "tactic.mk_has_reflect_instance", "tactic.find_local", "comp.is_comm_applicative", "tactic.interactive.transitivity", "state_t.ext", "tactic.match_and", "tactic.alias.alias_cmd", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.rename'_arg_parser", "prod.swap_left_inverse", "binder.to_string", "prod.has_to_format", "smt_tactic.istep", "lint_hole_cmd", "expr.is_le", "tactic.ematch_all", "tactic.relation_lhs_rhs", "tactic.interactive.simp_intros", "prod.has_to_string", "prod.lex_accessible", "tactic.apply_congr_core", "where.get_variables_core", "list.length_map_accumr", "tactic.unsafe.type_context.to_tmp_mvars", "simp_lemmas.rewrites", "tactic.unfold_projs", "prod.ext", "tactic.interactive.concat_tags", "fold_over_with_cond", "prod.map_snd", "tactic.by_contradiction", "tactic.rcases.continue", "tactic.interactive.return_cast", "conv.replace_lhs", "tactic.match_iff", "native.rb_lmap.of_list", "tactic.mllist.monad_lift", "tactic.constructor", "tactic.match_refl_app", "native.rb_map.mmap", "function.uncurry_def", "tactic.rcases", "expr.is_bin_arith_app", "list.zip", "tactic.fsplit", "tactic.assoc_rewrite", "expr.simp", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "expr.dsimp", "simps_parser", "prod.snd_swap", "smt_tactic.get_goals", "level.dedup_size", "tactic.ematch", "tactic.injection_with", "tactic.induction", "function.uncurry", "state_t.run_put", "tactic.fconstructor", "lift_pair\u2082", "tactic.simp_bottom_up'", "native.float.mantissa", "tactic.match_stub", "tactic.mk_constructor_fresh_names", "tactic.interactive.refine_recursively", "prod.has_well_founded", "state_t.orelse", "lint_aux", "tactic.interactive.list_cast_of", "list.indexes_values_aux", "tactic.interactive.simp_core", "tactic.injection", "list.permutations_aux", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "tactic.simp_hyp", "state_t.monad_state", "conv.change", "state_t.modify", "tactic.cases_core", "conv.interactive.for", "prod.has_repr", "tactic.ext1", "rbmap.insert", "tactic.interactive.mapply", "prod.ext_iff", "smt_tactic.read", "tactic.mk_meta_pis", "tactic.interactive.refine_one", "tactic.interactive.apply_with", "tactic.match_pattern", "tactic.apply_core", "rbmap.to_value", "tactic.interactive.fapply", "old_conv.find", "tactic.split", "name.pop_nth_prefix", "fold_over_with_cond_sorted", "state_t.monad_run", "where.trace_where", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "incorrect_type_class_argument", "nat.div2_succ", "tactic.simp_all", "where.inflate", "rsimp.rsimplify", "prod.swap_prod_mk", "tactic.decode_simp_arg_list", "conv.interactive.simp", "state_t.pure", "list.span", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.get_ancestors", "list.product", "tactic.mk_assoc_instance", "tactic.eapplyc", "prod.swap", "smt_tactic.by_contradiction", "list.length_map_accumr\u2082", "old_conv.bottom_up", "native.float.modf", "prod.lex_def", "push_neg.push_neg_at_hyp", "function.uncurry'_bicompr", "instance_priority", "prod.map_def", "where.fetch_potential_variable_names", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "lean.version", "function.uncurry'", "rbmap.rbmap_lt_dec", "smt_tactic.induction", "tactic.interactive.field", "tactic.interactive.erase_simp_args", "tactic.add_defn_equations", "tactic.delta_instance", "list.partition_map", "expr.is_eta_expansion_test", "tactic.flatten", "tactic.applyc", "tactic.interactive.list_cast_of_aux", "where.format_variable", "tactic.interactive.h_generalize", "tactic.alias.make_left_right", "conv.congr", "where.strip_pi_binders_aux", "tactic.interactive.case", "environment.add_defn_eqns", "rbmap.empty", "nonempty_prod", "dangerous_instance", "conv.rhs", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "state_t.failure", "conv.convert", "tactic.interactive.trace_simp_set", "tactic.simp_target", "expr.pi_binders", "tactic.mllist.fixl", "tactic.induction'", "where.compile_variable_list", "tactic.mk_eq_proof", "tactic.rename'", "tactic.mk_replacer\u2081", "tactic.subst", "state_t.is_lawful_monad", "function.curry", "tactic.interactive.contrapose", "prod.swap_right_inverse", "conv.interactive.dsimp", "expr.pi_binders_aux", "tactic.intros1", "derive_struct_ext_lemma", "prod.rprod_sub_lex", "expr.is_lt", "where.collect_by", "lint_mathlib", "lint_all", "tactic.assoc_rewrite_target", "tactic.interactive.collect_struct", "expr.is_and", "expr.dedup_size_aux", "has_inhabited_instance", "state_t.run_pure", "tactic.interactive.apply", "list.partition_eq_filter_filter", "tactic.expanded_field_list", "state_t.get", "old_conv.mk_match_expr", "native.rb_map.to_list", "prod.exists", "expr.lift", "tactic.get_pi_binders_dep_aux", "tactic.interactive.old_conv", "tactic.suggest.apply_declaration", "tactic.pexpr_to_pattern", "smt_tactic.preprocess", "tactic.mk_simp_set", "tactic.get_pi_binders_dep", "tactic.interactive.compact_decl", "tactic.module_doc_strings", "tactic.eapply", "tactic.apply_at", "where.select_for_which", "tactic.match_fn", "old_conv.match_expr"]}, {"id": "rbnode", "parentIds": ["rbmap.mem", "rbnode.balance1_node", "mk_rbtree", "rbnode.mem", "rbtree.mem", "rbtree.depth", "rbnode.max", "rbnode.balance2_node", "rbnode.inhabited", "rbnode.find", "rbtree.mem_exact", "rbnode.well_formed", "rbmap.find_entry", "rbnode.min", "rbnode.rev_fold", "rbnode.balance2", "rbnode.depth", "rbnode.balance1", "rbnode.mk_insert_result", "rbnode.insert", "rbnode.ins", "rbnode.mem_exact", "rbnode.fold", "rbnode.get_color", "rbtree"]}, {"id": "subtype", "parentIds": ["rbmap.mem", "subtype.has_to_string", "mk_rbtree", "rbtree.mem", "subtype.has_to_format", "rbtree.depth", "nat.find_min", "list.choose_x", "subtype.exists_of_subtype", "subtype.decidable_eq", "function.restrict_eq", "classical.epsilon_spec_aux", "list.choose", "nat.find", "subtype.inhabited", "classical.strong_indefinite_description", "subtype.has_sizeof", "rbtree.mem_exact", "rbmap.find_entry", "subtype.eta", "function.restrict", "nonempty_subtype", "subtype.eq", "coe_subtype", "classical.some_spec", "classical.epsilon", "subtype.has_repr", "classical.indefinite_description", "subtype.tag_irrelevant", "nat.find_spec", "classical.subtype_of_exists", "classical.some", "rbtree", "nat.find_x"]}, {"id": "rbnode.well_formed", "parentIds": ["rbmap.mem", "mk_rbtree", "rbtree.mem", "rbtree.depth", "rbtree.mem_exact", "rbmap.find_entry", "rbtree"]}, {"id": "eq_ff_of_not_eq_tt", "parentIds": []}, {"id": "eq_ff_eq_not_eq_tt", "parentIds": ["eq_ff_of_not_eq_tt"]}, {"id": "bool", "parentIds": ["eq_ff_of_not_eq_tt", "expr.is_sort", "tactic.eval_expr'", "tactic.mk_congr_arg", "tactic.unsafe_change", "reflected.has_to_tactic_format", "declaration.modifiers.has_to_string", "smt_tactic.interactive.assume", "tactic.simplify", "tactic.find_if_cond_at", "has_sizeof_derive_handler", "tactic.interactive.constructor", "tactic.get_subsingleton_info", "option.decidable_eq_none", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "expr.has_var_idx", "tactic.replace_at", "binder.decidable_eq", "bool.bor_inl", "environment.is_prefix_of_file", "user_attribute.set_untyped", "expr.local_pp_name", "declaration.is_theorem", "tactic.mk_const", "environment.add_ginductive", "bool.bxor_comm", "expr.is_sorry", "tactic.mk_eq_refl", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "bool.coe_bool_iff", "tactic.instance_cache.get", "smt_tactic.solve1", "tactic.cc_dbg_core", "tactic.delta", "string.quote", "bnot_eq_true_eq_eq_ff", "expr.is_annotation", "level.occurs", "tactic.i_to_expr_strict", "tactic.focus1", "print_content", "tactic.rintro_hint", "local_context.is_subset", "tactic.flat_assoc", "tactic.change", "old_conv", "tactic.interactive.with_cases", "tactic.revertible_local_context", "nat.bitwise_zero", "tactic.apply_iff", "infer_type_cmd", "tactic.apply_cfg.inhabited", "nat.bit_zero", "linter.incorrect_type_class_argument", "extensional_attribute", "tactic.interactive.rw_rule.has_reflect", "tactic.rewrite_core", "tactic.get_expl_arity", "expr.is_arrow", "lean.parser.get_variables", "tactic.admit", "nat.bodd", "tt_band", "nat.test_bit", "bool.to_bool_not", "tactic.explode.core", "user_attribute.get_param_untyped", "smt_tactic.add_lemmas_from_facts_core", "tactic.unify", "tactic.copy_attribute", "expr.is_iff", "well_founded_tactics.clear_internals", "tactic.explode.entries.inhabited", "param_info.to_format", "level.lt", "tactic.find_same_type", "nat.shiftl'_add", "expr.mk_exists_lst", "bnot", "tactic.rcases_hint.process_constructors", "tactic.mk_congr_fun", "nat.lxor_bit", "tactic.injections_with", "tactic.elide.unelide", "expr.get_app_args_aux", "smt_tactic.definev", "expr.mk_binding", "tactic.mk_mapp", "nat.test_bit_ldiff", "tactic.build_list_expr_for_apply", "tactic.target", "tactic.interactive.recover", "tactic.explode.args", "tactic.is_trace_enabled_for", "tactic.save_const_type_info", "smt_tactic.interactive.destruct", "tactic.focus", "smt_tactic.set_goals", "decidable_of_bool", "bnot_eq_ff_eq_eq_tt", "tactic.find_assumption", "tactic.mk_assoc_pattern'", "cc_state.mk_using_hs", "tactic.interactive.field_simp", "attribute.register", "tactic.cases", "tactic.existsi", "expr.dedup_size", "unused_arguments", "tactic.simp_config", "format.when", "tactic.local_context", "tactic.cc_core", "eq_ff_eq_not_eq_tt", "ematch_state.internalize", "binder", "tactic.mk_comp", "tactic.back_lemmas_find", "tactic.apply_inj_lemma", "mk_definition", "tactic.interactive.from", "tactic.mk_has_sizeof_instance_core", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "vm.pp_expr", "smt_tactic.ematch_core", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "expr.to_nat", "cc_state.roots", "tactic.mk_psigma", "tactic.instance_cache.append_typeclasses", "tactic.mk_iff_mp_app", "tactic.dsimplify", "int.bit", "d_array.beq", "expr.mk_or_lst", "tactic.interactive.loc.get_local_pp_names", "declaration.type", "wf_tacs", "interaction_monad.orelse'", "smt_tactic.add_lemmas_from_facts", "expr.has_to_string", "where.trace_variables", "interactive.types.only_flag", "cc_state.mt", "tactic.mk_brec_on_rec_value", "band_eq_true_eq_eq_tt_and_eq_tt", "tactic.simplify_top_down", "linter.unused_arguments", "d_array.of_beq_aux_eq_tt", "smt_tactic.add_ematch_lhs_lemma_from_decl", "old_conv.failed", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "smt_tactic.add_ematch_lemma_from_decl", "simp_attr.pre_smt", "native.float.is_nan", "simp_lemmas.rewrite", "expr.has_decidable_eq", "tactic.set_basic_attribute", "expr.binding_names", "tactic.cleanup", "tactic.is_prop", "tactic.kdepends_on", "smt_tactic.seq", "transport_multiplicative_to_additive", "nat.bodd_div2", "nat.test_bit_bitwise", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "using_smt", "smt_tactic.interactive.guard_target", "tactic.explode.entries.size", "tactic.enable_tags", "conv.interactive.conv", "conv.lhs", "smt_pre_config.inhabited", "tactic.match_or", "level.lex_lt", "tactic.mk_higher_order_type", "nat.bodd_add_div2", "tactic.simp_all_entry", "bool.band_comm", "tactic.get_unused_decl_name", "is_dec_eq", "tactic.apply_list_expr", "tactic.is_in_mathlib", "nat.bodd_add", "tactic.get_pi_binders", "expr.local_binding_info", "expr.inhabited", "tactic.interactive.get_rule_eqn_lemmas", "tactic.rcases_patt.format", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "where.sort_variable_list", "nat.shiftl_sub", "exceptional.to_bool", "tt_eq_ff_eq_false", "tactic.interactive.min_tac", "tactic.clear'", "tactic.replacer", "native.float.is_normal", "native.float.sign", "tactic.interactive.revert", "tactic.by_elim_opt", "expr.is_napp_of", "old_conv.trace", "tactic.get_library_notes", "nat.div2", "tactic.interactive.unfold", "tactic.explode.append_dep", "list.all", "tactic.interactive.induction", "tactic.interactive.rcases", "environment.inductive_dep_elim", "incorrect_def_lemma", "old_conv.findp", "tactic.symm_apply", "tactic.revert_kdependencies", "tactic.interactive.unfold_coes", "tactic.interactive.dsimp", "mk_nat_val_le_proof", "pexpr.of_expr", "tactic.interactive.cases_matching", "list.is_prefix_of", "expr.is_ne", "nat.test_bit_lor", "environment.projection_info.inhabited", "tactic.interactive.rename'", "expr.hash", "succeeds", "expr.pi_arity_aux", "environment.unfold_all_macros", "tactic.interactive.solve_by_elim", "expr_set", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "bor_ff", "tactic.symmetry_hyp", "expr.get_depth", "tactic.unfold_proj_config.inhabited", "name_set.has_to_format", "tactic.note", "old_conv.dsimp", "list.repr_aux", "tactic.transport_with_prefix_fun", "tactic.interactive.apply_assumption", "tactic.is_assigned", "expr.reduce_lets", "monad.filter", "tactic.unsafe.type_context.get_fun_info", "bxor_self", "nat.bodd_succ", "cc_state.proof_for", "rbtree.empty", "old_conv_result", "tactic.elim_gen_sum", "localized_attr", "environment.is_definition", "native.rb_map.has_to_tactic_format", "expr.local_type", "old_conv.istep", "tactic.save_type_info", "tactic.pis", "nat.ldiff_bit", "tactic.mk_eq_mp", "bool.decidable_eq", "tactic.dunfold_head", "tactic.match_app_of", "expr.to_int", "expr.list_local_consts", "environment.add_inductive", "tactic.interactive.clear_dependent", "cc_state.add", "push_neg.normalize_negations", "tactic.elide.replace", "old_conv.change", "tactic.interactive.apply_iff_congr_core", "tactic.non_dep_prop_hyps", "tactic.mk_iff", "use_cmd", "tactic.rcases_patt_inverted.format_list", "expr.mk_op_lst", "expr.is_ge", "interaction_monad.fail", "tactic.left", "tactic.mk_simp_attr", "is_dec_refl", "expr.is_default_local", "tactic.assoc_refl", "tactic.interactive.have_field", "declaration.to_name", "options.set_bool", "environment.is_namespace", "environment.is_inductive", "tactic.mllist.empty", "tactic.head_zeta", "tactic.dsimp_hyp", "user_attribute.parse_reflect", "ematch_lhs", "smt_tactic.swap", "smt_tactic.interactive.have", "name_set.contains", "tactic.mk_pattern", "expr.binding_domain", "nat.binary_rec_eq", "tactic.match_subexpr", "native.has_to_string", "coe_ff", "tactic.mk_dec_eq_instance", "list.band", "tactic.generalize_proofs", "tactic.interactive.refine", "tactic_format_expr", "smt_tactic.when_tracing", "nolint_attr", "pexpr", "nat.lor_bit", "tactic.mk_instance", "interactive.loc.try_apply", "user_attribute.dflt_parser", "to_additive.parser", "tactic.alias.alias_attr", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "local_context.mk_local", "tactic.result", "tactic.econstructor", "tactic.unsafe.type_context.whnf", "string.iterator.has_next", "tactic.unsafe.type_context.list_mvars", "can_lift_attr", "tactic.add_inductive", "tactic.match_hypothesis", "tactic.terminal_goal", "expr.binding_body", "tactic.mk_local'", "tactic.interactive.clear'", "int.mk_numeral", "old_conv.apply_lemmas_core", "native.rb_set.mfilter", "expr.subst", "nat.mod_two_of_bodd", "tactic.back_lemmas_add_extra", "simps_add_projection", "expr.binding_name", "expr.decidable_rel", "tactic.interactive.lift", "tactic.trace_macro", "tactic.unsafe.type_context.fold_mvars", "tactic.exact", "native.float.is_infinite", "tactic.mk_mvar_list", "expr.instantiate_locals", "vm.eof", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "nat.binary_rec_zero", "option.is_none", "list.mpartition", "expr.is_heq", "local_decl", "old_conv.orelse", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "localized_cmd", "expr.get_app_fn_args_aux", "tactic.mk_eq_simp_ext", "tactic.mk_local_pisn", "tactic.choose1", "expr.has_local_in", "tactic.assertv_core", "old_conv.to_tactic", "conv.update_lhs", "tactic.delta_config", "old_conv.conversion", "tactic.extract_def", "linter.impossible_instance", "bool.has_reflect", "tactic.delta_target", "tactic.whnf", "expr.mfoldl", "conv.interactive.guard_lhs", "expr.occurs", "tactic.norm_num", "tactic.interactive.abstract", "simps_tac", "tactic.interactive.apply_field", "native.has_to_format", "tactic.rewrite", "expr.instantiate_var", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "tactic.try_apply_opt_auto_param_for_apply", "coe_sort_bool", "tactic.back_lemmas_insert_core", "smt_tactic.classical", "ff_eq_tt_eq_false", "to_bool_false_eq_ff", "bool.bxor_iff_ne", "nat.bodd_one", "tactic.constr_to_prop", "int.nat_bitwise", "tactic.local_proof", "declaration.value_task", "nat.bitwise_zero_left", "nat.bitwise", "smt_tactic.pose", "tactic.cc", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "simp_lemmas.add", "expr.imp", "expr.get_app_fn", "push_neg.whnf_reducible", "tactic.solve_aux", "smt_tactic.add_ematch_lemma_core", "expr.extract_opt_auto_param", "mk_int_val_ne_proof", "expr.traverse", "expr.lambdas", "tactic.dsimplify_core", "tactic.ext_simplify_core", "tactic.try_for", "nat.bit", "environment.unfold_untrusted_macros", "expr.replace", "expr.has_meta_var", "tactic.suggest.message", "bool.inhabited", "bool.to_bool_false", "tactic.propositional_goal", "tactic.choose", "expr.is_constant_of", "tactic.match_eq", "tactic.success_if_fail", "tactic.match_expr", "mk_expr_set", "tactic.save_info", "expr.is_eta_expansion_of", "cc_state.refutation_for", "bor_eq_false_eq_eq_ff_and_eq_ff", "tactic.get_goal", "expr.is_eq", "tactic.resolve_constant", "tactic.interactive.set", "well_founded_tactics.default_dec_tac'", "tactic.subst_core", "bor_coe_iff", "expr.has_to_format", "mk_nat_val_ne_proof", "smt_tactic.interactive.dsimp", "declaration.update_value_task", "well_founded_tactics.default", "nat.shiftl'_sub", "tactic.apply_auto_param", "tactic.change_core", "to_bool_true_eq_tt", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "expr.const_name", "of_to_bool_ff", "tactic.returnopt", "tactic.assoc_root", "tactic.interactive.letI", "old_conv.trace_lhs", "cc_state.pp_eqc", "tactic.mk_congr_lemma_simp", "environment.in_current_file", "tactic.match_assoc_pattern'", "reflected.has_to_format", "tactic.intros_dep", "tactic.instance_stub", "tactic.mk_specialized_congr_lemma", "expr.get_app_fn_args", "cc_state.is_cg_root", "tactic.interactive.simp", "tactic.in_open_namespaces", "where.get_includes_core", "tactic.interactive.type_check", "lean.parser.get_includes", "environment.is_refl_app", "where.trace_includes", "smt_tactic.proof_for", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.find_if_cond", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.iff_mp_core", "no_rsimp", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.rintro", "tactic.instance_cache", "rbmap.contains", "conv.funext", "tactic.suggest.match_head_symbol", "old_conv.match_pattern", "tactic.change_with_at", "where.strip_pi_binders", "expr.get_pis", "tactic.match_target_subexpr", "tactic.constructor_idx", "tactic.constructor_num_fields", "mk_fin_val_ne_proof", "tactic.clear_aux_decl", "option.is_none_iff_eq_none", "declaration.is_definition", "tactic.intro1", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "bool.to_bool_true", "old_conv.funext", "tactic.interactive.refine_struct", "tactic.simp_arg_type.has_reflect", "tactic.interactive.elide", "cc_state.eqc_size", "tactic.interactive.rec.to_tactic_format", "tactic.has_attribute'", "tactic.is_type_app_of", "user_attribute.dflt_cache_cfg", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "int.bitwise", "tactic.simp_config.inhabited", "bool.dichotomy", "smt_tactic.add_ematch_lhs_lemma", "nat.bodd_mul", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "bool.of_to_bool_iff", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.simp_intros_config", "simps_add_projections", "expr.mk_delayed_abstraction", "tactic.abstract", "bool.coe_sort_ff", "tactic.unsafe.type_context.mk_mvar", "option.rhoare", "nat.bodd_zero", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.whnf_no_delta", "tactic.interactive.try_for", "tactic.ematch_all_core", "conv.dsimp", "bor_self", "linter.dup_namespace", "tactic.assert_core", "tactic.interactive.simp_core_aux", "tactic.rcases_hint_core", "tactic.right", "nat.mk_numeral", "tactic.frozen_local_instances", "tactic.fail_if_success", "string.iterator.zero_lt_length_next_to_string_of_has_next", "monad.whenb", "tactic.def_replacer_cmd", "tactic.mk_patterns", "expr.to_string", "cc_state.eqc_of", "tactic.generalizes", "tactic.mk_replacer\u2082", "conv.interactive.trace_lhs", "smt_tactic.focus1", "tactic.alias.get_lambda_body", "tactic.interactive.injection", "expr.is_gt", "conv.whnf", "expr.is_false", "expr.is_pi", "expr.mk_sorry", "tactic.interactive.exact", "doc_blame_report_defn", "smt_tactic.get_facts", "list.empty", "environment.intro_rule", "eq_tt_eq_not_eq_ff", "tactic.interactive.existsi", "tactic.fapply", "tactic.assert", "tactic.apply_at_aux", "tactic.unsafe.type_context.assign", "tactic.rewrite_hyp", "declaration.to_definition", "local_context.to_list", "cc_state.eqc_of_core", "tactic.match_heq", "list.indexes_values", "tactic.interactive.suffices", "bool.band_elim_left", "declaration.update_name", "to_additive.map_namespace", "smt_tactic.ematch", "expr.is_mvar", "print_all_content", "tactic.explode.may_be_proof", "expr.lower_vars", "conv.interactive.rw", "tactic.case_bash", "declaration.in_current_file", "tactic.rewrite_cfg", "tactic.rewrite_cfg.inhabited", "tactic.elim_gen_prod", "tactic.by_cases", "smt_tactic.to_expr", "rsimp_attr", "native.rb_set.contains", "tactic.interactive.library_search", "bool.ff_eq_to_bool_iff", "tactic.add_theorem_by", "bool.eq_tt_of_bnot_eq_ff", "tactic.mk_app", "tactic.when_tracing", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "expr.pos", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "list.qsort_cons", "where.resolve_vars", "bool.coe_sort_tt", "string.is_empty", "tactic.simp_intros_aux", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "to_bool_true", "cc_state.root", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "pexpr.is_placeholder", "name_set.mfilter", "tactic.mk_has_sizeof_instance", "ff_bor", "smt_tactic.interactive.let", "environment.is_ginductive", "expr.reduce_let", "merge_hinst_lemma_attrs", "well_founded_tactics.cancel_nat_add_lt", "interaction_monad.mk_exception", "native.rb_lmap.contains", "expr.erase_annotations", "bool.forall_bool", "tactic.unsafe.type_context.get_assignment", "option.eq_some_of_is_some", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "tactic.mk_theorem", "old_conv.interactive.find", "tactic.interactive.simp_rw", "declaration.instantiate_value_univ_params", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.ac_refl", "string.split", "nat.bit_cases_on", "where.trace_opens", "tactic.rcases_patt.has_to_format", "tactic.get_pi_binders_aux", "where.find_var", "tactic.set_main_tag", "tactic.to_expr_strict", "name.is_private", "bool.eq_tt_of_ne_ff", "tactic.apply_heq_congr_core", "nat.bitwise_swap", "expr.is_lambda", "nat.bitwise_zero_right", "simps_attr", "mk_nat_val_lt_proof", "old_conv.lhs", "nat.size", "tactic.unsafe.type_context.is_stuck", "mk_hinst_lemma_attrs_core", "smt_tactic.all_goals", "expr.mk_app", "tactic.match_not", "smt_tactic.interactive.add_lemma", "conv.interactive.change", "expr.instantiate_univ_params", "expr.mk_true", "tactic.unsafe.type_context.is_declared", "tactic.interactive.exactI", "tactic.enum_assoc_subexpr", "reflected.has_to_pexpr", "well_founded_tactics.is_psigma_mk", "expr.list_meta_vars", "nat.bitwise_bit", "smt_tactic.define", "find_cmd", "declaration.map_value", "tactic.interactive.substs", "tactic.var_names", "tactic.cc_dbg", "tactic.mk_local_pis_whnf", "declaration.update_value", "rsimp.explicit_size", "ematch", "tactic.assoc_refl'", "smt_tactic.slift_aux", "tactic.interactive.assume", "tactic.explode.entries.find", "tactic.any_hyp", "control_laws_tac", "expr.mk_var", "tactic.decl_mk_const", "smt_tactic.add_ematch_lemma", "check_unused_arguments_aux", "bool_iff_false", "tactic.interactive.collect_struct'", "list.mfilter", "tactic.rcases_hint.continue", "tactic.back_chaining", "tactic.apply_under_pis", "d_array.of_beq_aux_eq_ff", "tactic.interactive.haveI", "library_note_attr", "string.is_suffix_of", "smt_tactic.get_refuted_facts", "expr.is_var", "tactic.mk_local_pis", "bool.eq_ff_of_bnot_eq_tt", "tactic.interactive.rw_rule", "tactic.match_ne", "rsimp.rsimplify_at", "nat.bitwise_bit_aux", "declaration.is_axiom", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.interactive.compact_decl_aux", "options.get_bool", "tactic.dunfold_target", "smt_tactic.assertv", "tactic.introv", "to_bool_ff", "vm.stack_obj_info", "nat.shiftl", "expr.lift_vars", "tactic.suggest.apply_and_solve", "tactic.definev_core", "tactic.mk_local", "simp_attr.functor_norm", "tactic.mk_mvar", "simp_attr.norm", "expr.is_or", "hinst_lemma.mk_from_decl", "tactic.fill_args", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "tactic.eval_expr", "expr.replace_with", "bool.to_bool_and", "declaration.value", "tactic.local_def_value", "param_info", "tactic.use", "name.is_internal", "tactic.comp_val", "coe_decidable_eq", "expr.instantiate_lambdas_or_apps", "tactic.interactive.loc.get_local_uniq_names", "mnot", "cc_state.roots_core", "bool.cond_ff", "old_conv.congr_core", "bxor", "tactic.unsafe.type_context.print_mvars", "native.rb_set.has_to_format", "apply_nolint_tac", "tactic.interactive.obtain", "expr.size", "tactic.unsafe.type_context.unify", "expr.is_eta_expansion_aux", "nat.test_bit_lxor", "subsingleton_info_to_format", "expr.is_num_eq", "environment.contains", "interactive.decl_modifiers", "tactic.fold_explicit_args", "tactic.alias.mk_iff_mp_app", "expr.of_int", "bool.eq_ff_of_ne_tt", "tactic.simplify_bottom_up", "reflected", "tactic.interactive.guard_hyp", "linter.ge_or_gt", "tactic.is_class", "tactic.match_target", "tactic.ematch_core", "tactic.get_spec_subsingleton_info", "expr.copy_pos_info", "tactic.apply", "linter.has_inhabited_instance", "tactic.contradiction", "tactic.get_main_tag", "old_conv.apply_propext_lemmas_core", "expr.mfold", "expr.reflect", "tactic.instantiate_mvars", "tactic.interactive.erw", "monad.cond", "coe_sort_tt", "tactic.interactive.generalize", "tactic.delta_config.inhabited", "tactic.interactive.use", "native.rb_map.mfilter", "tactic.mk_has_reflect_instance", "is_valid_simp_lemma", "nat.land_bit", "environment.get_trusted_decls", "environment.is_ginductive'", "bool.has_to_string", "subsingleton_info.inhabited", "bool.bor_assoc", "list.qsort", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "bool.cond_tt", "to_bool_iff", "declaration.is_constant", "tactic.is_instance", "tactic.unsafe.type_context.is_regular_mvar", "smt_tactic.execute", "expr.pi_arity", "tactic.interactive.transitivity", "bool.cond_to_bool", "tactic.split_ifs", "band_self", "expr.app_fn", "tactic.ancestor_attr", "tactic.simp_intros", "linter.doc_blame_thm", "tactic.match_and", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.unsafe.type_context.infer", "interactive.loc.get_locals", "derive_handler", "tt_bor", "tactic.define_core", "tactic.interactive.eapply", "interactive.loc.include_goal", "conv.interactive.find", "expr.mk_and_lst", "binder.to_string", "tactic.interactive.to_expr'", "tactic.dsimp_config.inhabited", "cc_state.inconsistent", "get_ext_subject", "rsimp.to_repr_map", "bool.to_bool_coe", "smt_tactic.note", "tactic.interactive.ext", "tactic.alias.alias_direct", "bor_tt", "tactic.interactive.unelide", "subsingleton_info", "tactic.solve_by_elim", "string.iterator.has_prev", "lint_hole_cmd", "expr.has_to_tactic_format", "environment.projection_info", "expr.is_le", "tactic.interactive.show", "lean.is_release", "d_array.decidable_eq", "tactic.ematch_all", "rsimp.collect_implied_eqs", "tactic.relation_lhs_rhs", "name.has_prefix", "tactic.interactive.simp_intros", "tactic.head_beta", "tactic.dunfold_hyp", "tactic.pformat_macro", "tactic.interactive.erewrite", "tactic.apply_congr_core", "native.rb_map.empty", "expr.is_let", "where.get_variables_core", "tactic.interactive.rintro", "tactic.no_mvars_in_target", "list.to_string_aux", "bool.bnot_false", "tactic.unsafe.type_context.to_tmp_mvars", "tactic.iff_mpr", "simp_lemmas.rewrites", "expr.to_pos_nat", "tactic.join_user_simp_lemmas", "tactic.interactive.guard_target'", "interactive.inductive_decl", "tactic.explode_expr", "is_valid_simp_lemma_cnst", "tactic.unfold_projs", "tactic.head_eta", "list.bor", "cc_state.in_singlenton_eqc", "tactic.iff_mpr_core", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "tactic.dsimp_config", "linter", "tactic.define", "user_attribute.set", "smt_config.inhabited", "tactic.mk_specialized_congr_lemma_simp", "tactic.unsafe.type_context.is_tmp_mvar", "expr.has_coe", "tactic.goals", "tactic.unsafe.type_context.in_tmp_mode", "tactic.by_contradiction", "expr.has_local_constant", "tactic.interactive.replace", "tactic.interactive.find", "reflected_value.expr", "tactic.interactive.subst", "simp_attr.split_if_reduction", "tactic.get_arity", "tactic.intros", "expr.app_of_list", "tactic.rcases.continue", "tactic.find_ancestors", "tactic.interactive.clear_", "expr.get_app_args", "list.is_suffix_of", "tactic.interactive.return_cast", "cc_state.mfold_eqc", "conv.replace_lhs", "tactic.match_iff", "expr.has_to_pexpr", "tactic.destruct", "rsimp.repr_map", "nat.bodd_bit", "bool.exists_bool", "where.resolve_var", "bool.has_to_format", "bool.bxor_bnot_bnot", "environment.is_structure", "tactic_state.to_format", "tactic.constructor", "smt_tactic.assert", "tactic.match_refl_app", "to_bool_ff_iff", "cc_state.pp_core", "tactic.head_eta_expand", "option.get", "tactic.suggest.process_declaration", "tactic.assertv", "tactic.revert_kdeps", "tactic.type_check", "tactic.get_pi_arity", "tactic.rcases", "expr.is_bin_arith_app", "tactic.fsplit", "cc_state.fold_eqc_core", "tactic.interactive.constructor_matching", "of_to_bool_true", "expr.get_weight", "tactic.enum_assoc_subexpr'", "expr.abstract_local", "tactic.assoc_rewrite", "expr.simp", "expr.is_numeral", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "tactic.interactive.conv", "expr.dsimp", "level.has_param", "tactic.interactive.guard_expr_strict", "simps_parser", "get_linters", "smt_tactic.get_goals", "tactic.subsingleton_goal", "tactic.revert", "native.float.has_le", "bool.tt_eq_to_bool_iff", "tactic.mk_assoc", "environment.is_recursor", "level.dedup_size", "expr.mk_false", "expr.is_aux_decl", "expr.has_var", "tactic.ematch", "tactic.interactive.intro", "tactic.injection_with", "tactic.interactive.convert_to", "expr.alpha_eqv", "tactic.set_tag", "nat.test_bit_succ", "tactic.induction", "expr.is_local_constant", "tactic.unfold_proj", "binder.inhabited", "bxor_tt", "tactic.unsafe.type_context.is_assigned", "smt_tactic.interactive.apply", "nat.ldiff", "tactic.lambdas", "get_attribute_cache_dyn", "tactic.fconstructor", "hinst_lemmas.pp", "tactic.rename", "tactic.interactive.exacts", "string.is_prefix_of", "tactic.interactive.change", "tactic.collect_ctx_simps", "tactic.simp_bottom_up'", "bool.default_bool", "expr.app_arg", "reflected.subst", "tactic.match_stub", "tactic.mk_constructor_fresh_names", "nat.div2_bit", "tactic.interactive.refine_recursively", "tactic.delta_hyp", "where.is_in_namespace_nonsynthetic", "tactic.interactive.has_to_tactic_format", "tactic.i_to_expr_no_subgoals", "list_linters", "eq_tt_of_not_eq_ff", "tactic.fold_explicit_args_aux", "lint_aux", "tactic_state.format_expr", "declaration.is_auto_generated", "tactic.interactive.list_cast_of", "list.indexes_values_aux", "tactic.interactive.simp_core", "list.qsort.F", "well_founded_tactics.unfold_wf_rel", "tactic.any_hyp_aux", "tactic.unsafe.type_context.instantiate_mvars", "cc_state.has_to_tactic_format", "name.is_prefix_of", "bor", "user_attribute", "tactic.def_replacer", "tactic.injection", "tactic.interactive.conv_rhs", "occurrences.contains", "conv.interactive.erw", "tactic.is_def_eq", "bool.decidable_forall_bool", "lean.parser.reflectable.expr", "tactic.interactive.match_target", "tactic.mk_eq_mpr", "tactic.zeta", "binder.has_to_tactic_format", "to_hinst_lemmas_core", "tactic.mk_simp_set_core", "tactic.apply_cfg", "tactic.whnf_ginductive", "expr.has_lt", "debugger.attr", "monad_except.orelse'", "tactic.back_chaining_using", "tactic.simp_hyp", "nat.bit_val", "derive_handler_attr", "tactic.back_lemmas_insert", "linter.doc_blame", "smt_tactic.interactive.eblast_using", "expr.is_app", "tactic.repeat", "conv.change", "tactic.mk_eq_trans", "declaration.get_kind_string", "bool_eq_false", "tactic.solve1", "band", "tactic.unsafe.type_context.get_context", "tactic.cases_core", "tactic.get_tag", "decidable_eq_of_bool_pred", "nat.shiftl_add", "tactic.alias.alias_iff", "conv.interactive.for", "nat.test_bit_zero", "bool.ff_ne_tt", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "int.bodd", "tactic.mk_local_def", "tactic.interactive.mapply", "cc_state.is_not_eqv", "tactic.interactive.specialize", "tactic.get_assignment", "tactic.mk_meta_pis", "tactic.interactive.refine_one", "tactic.explode.entry", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "tactic.kabstract", "tactic.interactive.apply_with", "where.binder_less_important", "d_array.of_beq_eq_tt", "expr.to_binder", "old_conv.whnf", "options.contains", "tactic.pose", "tactic.match_pattern", "tactic.dunfold_config.inhabited", "tactic.funext", "tactic.apply_core", "bool.band_intro", "tactic.mk_congr", "vm_local_info", "nat.test_bit_land", "name_set.empty", "expr.pis", "tactic.interactive.fapply", "band_coe_iff", "tactic.swap", "expr.bind_lambda", "old_conv.find", "tactic.split", "bxor_ff", "tactic.instantiate_mvars_in_target", "except.to_bool", "conv.interactive.rewrite", "tactic.solve_by_elim_aux", "bool.bor_inr", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.dsimp_target", "native.float.decidable_le", "tactic.interactive.casesm", "cc_state.next", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "monad.unlessb", "int.test_bit", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "tactic.mk_meta_var", "expr.is_eta_expansion", "bool.bnot_true", "expr.drop_pis", "tactic.unfold_projs_target", "nat.div2_succ", "tactic.apply_rules", "bool.decidable_exists_bool", "tactic.simp_all", "cc_config.inhabited", "tactic.rexact", "rsimp.rsimplify", "tactic.unsafe.type_context.tmp_get_assignment", "tactic.intro1_aux", "smt_pre_config", "simp_lemmas.append", "expr.to_raw_fmt", "expr.has_coe_to_fun", "to_bool_congr", "expr.is_constant", "tactic.decode_simp_arg_list", "environment.in_current_file'", "conv.interactive.simp", "tactic.iff_mp", "cond", "name_set.filter", "option.is_some", "tactic.interactive.guard_expr_eq'", "expr.is_not", "mwhen", "expr.ith_arg", "interactive.single_inductive_decl.name", "tactic.pattern", "tactic.alias.get_alias_target", "where.is_variable_name", "nat.binary_rec", "cc_state.proof_for_false", "lean.parser.reflect", "tactic.add_meta_definition", "cond_a_a", "list_items", "ff_bxor", "expr.get_nat_value", "tactic.dunfold", "tactic.assumption", "tactic.is_proof", "expr.to_implicit_local_const", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "tactic.infer_type", "tactic.chain_eq_trans", "expr.instantiate_local", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "pexpr.is_choice_macro", "native.rb_map.contains", "tactic.replace_target", "smt_tactic.by_contradiction", "native.float.le", "tactic.mk_replacer", "tactic.interactive.guard_target", "to_bool_tt", "bool.band_assoc", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "bool.bxor_left_comm", "tactic.intro_core", "tactic.trace_algebra_info", "bool.band_left_comm", "tactic.suggest.replace_mvars", "expr.ith_arg_aux", "tactic.replacer_core", "instance_priority", "bool.has_repr", "unfolds_to_class", "expr.expr.lt_prop", "tactic.clear", "tactic.interactive.dunfold", "tactic.interactive.rw", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "instance_derive_handler", "smt_tactic.interactive.from", "tactic.inhabited_instance", "expr.fold", "bool.coe_to_bool", "d_array.of_beq_eq_ff", "expr.abstract_locals", "tactic.get_local", "declaration.is_trusted", "bool.bor_left_comm", "declaration", "expr.is_app_of", "param_info.inhabited", "tactic.set_goals", "tactic.get_fun_info", "tactic.interactive.extract_goal", "expr.instantiate_lambdas", "tactic.unsafe.type_context.is_def_eq", "rsimp.is_value_like", "expr.instantiate_vars", "tactic.seq", "tactic.unsafe.type_context.tmp_is_assigned", "smt_tactic.induction", "tactic.interactive.have", "expr.is_macro", "old_conv.pure", "where.resolve_vars_aux", "environment.mfilter", "tactic.definev", "tactic.interactive.field", "bool.bxor_bnot_right", "bool.band_elim_right", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "level.eqv", "tactic.add_defn_equations", "expr_map", "tactic.local_decls", "tactic.delta_instance", "ite_eq_ff_distrib", "smt_tactic.interactive.simp", "mk_char_val_ne_proof", "hinst_lemma.mk_from_decl_core", "bool.to_bool_or", "tactic.mk_hcongr_lemma", "tactic.suggest.head_symbol", "get_checks", "tactic.interactive.clear_except", "expr.is_eta_expansion_test", "format.is_nil", "expr.apply_replacement_fun", "native.float.lt", "tactic.flatten", "expr.instantiate_nth_var", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "mcond", "cc_state.internalize", "list.qsort_nil", "expr.pi_codomain", "environment.is_constructor_app", "smt_tactic.interactive.change", "native.float.has_lt", "tactic.applyc", "band_ff", "expr.list_constant", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "tactic.unify_prefix", "conv.save_info", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.interactive.apply_rules", "tactic.triv", "tactic.interactive.destruct", "tactic.revert_lst", "bool.to_string_python", "old_conv.seq", "tactic.decidable_eq_derive_handler", "environment.is_constructor", "where.format_variable", "tactic.interactive.h_generalize", "interactive.param_desc", "nat.bits", "tactic.mk_id_proof", "tactic.interactive.intros", "tactic.funext_lst", "linter.def_lemma", "tactic.interactive.ac_change", "tactic.alias.make_left_right", "well_founded_tactics", "expr.is_internal_cnstr", "conv.congr", "expr.lt", "where.strip_pi_binders_aux", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "option.eq_none_of_is_none", "environment.add_defn_eqns", "tactic.unfold_config.inhabited", "rbmap.empty", "ite_eq_tt_distrib", "tactic.explode.entries.add", "tactic.funext_core", "tactic.injections_and_clear", "ff_band", "guardb", "saturate_fun", "expr.get_free_var_range", "smt_tactic.destruct", "tactic.interactive.choose", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "conv.rhs", "tactic.interactive.source_fields", "local_context.to_format", "local_context.fold", "expr.list_names_with_prefix", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "native.float.decidable_lt", "cc_config", "expr.binding_info", "declaration.update_type", "conv.convert", "tactic.find_private_decl", "local_context.get_local", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "expr.pi_binders", "expr.abstract", "tactic.split_if1", "declaration.modifiers", "has_reflect_derive_handler", "tactic.induction'", "native.rb_set.filter", "tactic.any_goals", "where.compile_variable_list", "doc_blame_report_thm", "bool.bor_comm", "tactic.rcases_core", "tactic.mk_eq_proof", "expr.get_pi_app_fn", "tactic.rename'", "expr.has_local", "tactic.resolve_name'", "interactive.single_inductive_decl", "tactic.mk_replacer\u2081", "tactic.replacer_attr", "equiv_type_constr", "coe_tt", "tactic.subst", "tactic.simp_intros_config.inhabited", "smt_config.set_classical", "tactic.mk_eq_symm", "tactic.interactive.suggest", "rbtree.contains", "tactic.unsafe.type_context.level.tmp_is_assigned", "list.is_nil", "smt_tactic.interactive.add_lhs_lemma", "tactic.has_to_tactic_format", "expr.lambda_body", "linter.instance_priority", "tactic.get_goals", "environment.get_modifiers", "conv.interactive.dsimp", "tactic.to_expr", "list.any", "old_conv.fail", "expr.pi_binders_aux", "tactic.interactive.push_neg", "bool.bxor_bnot_left", "coe_bool_to_Prop", "simp_lemmas.dsimplify", "expr.bind_pi", "smt_tactic.interactive.guard_expr_eq", "bxor_coe_iff", "nat.shiftl'_tt_eq_mul_pow", "tactic.interactive.conv_lhs", "tactic.intros1", "tactic.get_bool_option", "tactic.backward_chaining_core", "derive_struct_ext_lemma", "expr.is_lt", "bnot_bnot", "cc_state.is_eqv", "smt_tactic.refutation_for", "tactic.mk_instance_cache", "old_conv.map", "tactic.interactive.rewrite", "lint_mathlib", "tactic.intro_lst", "tactic.reduce_ifs_at", "tactic.num_goals", "tactic.clear_aux_decl_aux", "ge_or_gt_in_statement", "band_tt", "lint_all", "reducibility_hints", "nat.cond_to_bool_mod_two", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "coe_sort_ff", "tactic.interactive.collect_struct", "expr.is_and", "old_conv.interactive.change", "expr.dedup_size_aux", "declaration.instantiate_type_univ_params", "d_array.beq_aux", "decidable.to_bool", "has_inhabited_instance", "smt_tactic.interactive.executor", "tactic.interactive.apply", "old_conv.lift_tactic", "nat.shiftl'", "dedup", "tactic.import_private_cmd", "expr", "tactic.interactive.delta", "tactic.metavariables", "simp_lemmas.drewrite", "mk_string_val_ne_proof", "tactic.success_if_fail_with_msg", "dup_namespace", "tactic.triv'", "tactic.valid_types", "old_conv.mk_match_expr", "bool.to_bool_eq", "tactic.congr_core", "tactic.unfold_projs_hyp", "hinst_lemma.mk_core", "tactic.unsafe.type_context.mk_tmp_mvar", "tactic.apply_opt_param", "tactic.i_to_expr", "native.rb_set.empty", "level.nonzero", "expr.of_nat", "conv.discharge_eq_lhs", "bor_eq_true_eq_eq_tt_or_eq_tt", "vm_obj.to_expr", "tactic.add_aux_decl", "native.float.is_finite", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "linter.dangerous_instance", "expr.lift", "tactic.fail_macro", "environment.is_recursive", "cc_state.eqv_proof", "tt_bxor", "tactic.get_pi_binders_dep_aux", "rsimp.mk_repr_map", "cc_state.fold_eqc", "congr_lemma", "tactic_state.has_to_format", "tactic.mk_sorry", "smt_tactic.interactive.fapply", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "bool.has_sizeof", "tactic.suggest.apply_declaration", "tactic.pexpr_to_pattern", "expr.lex_lt", "tactic.unsafe.type_context.push_local", "smt_tactic.preprocess", "user_attribute.get_param", "smt_state.classical", "tactic.get_local_type", "tactic.perm_ac", "expr.contains_constant", "tactic.mk_simp_set", "tactic.get_pi_binders_dep", "reflected.to_expr", "bool.not_ff", "expr.local_uniq_name", "tactic.interactive.compact_decl", "well_founded_tactics.check_target_is_value_lt", "tactic.tags_enabled", "tactic.module_doc_strings", "expr.to_implicit_binder", "tactic.get_spec_prefix_size", "tactic.eapply", "declaration.univ_params", "band_eq_false_eq_eq_ff_or_eq_ff", "tactic.apply_at", "tactic.get_eqn_lemmas_for", "expr.get_app_num_args", "bool.bxor_assoc", "tactic.note_anon", "tactic.match_fn", "tactic.mk_congr_lemma", "nat.bodd_two", "expr.collect_univ_params", "transport_with_dict", "tactic.get_expl_pi_arity", "tactic.is_simp_lemma", "old_conv.match_expr", "tactic.generalize"]}, {"id": "eq.mp", "parentIds": ["eq_ff_of_not_eq_tt", "false_of_a_eq_not_a", "lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "nat.mod_lt", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "nat.add_right_cancel", "sub_right_lt_of_lt_add", "mul_nonpos_of_nonpos_of_nonneg", "option_t.ext", "le_add_of_sub_left_le", "mul_nonneg_of_nonpos_of_nonpos", "neg_add_lt_of_lt_add", "int.neg_ne_of_pos", "except_t.ext", "function.inv_fun_on_neg", "d_array.of_beq_aux_eq_tt", "nat.div_def", "eq_zero_of_mul_eq_self_right", "nat.eq_of_mul_eq_mul_right", "eq_of_sub_eq_zero", "one_div_le_of_one_div_le_of_neg", "ordered_comm_group.lt_of_add_lt_add_left", "sub_left_le_of_le_add", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "add_le_of_le_neg_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.le_mul_self", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "nat.binary_rec_eq", "one_div_lt_neg_one", "div_two_sub_self", "heq_of_eq_mp", "int.sub_nat_nat_elim", "nat.mod_two_of_bodd", "nat.sub_mul_mod", "lt_add_of_neg_add_lt_left", "nat.bit0_inj", "neg_lt_neg", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_lt_mul_of_neg_right", "eq_true_of_not_eq_false", "mul_self_iff_eq_one", "nat.lt_of_sub_eq_succ", "function.inv_fun_on_pos", "norm_num.neg_add_pos_eq_of_eq_add", "mul_pos", "nat.add_sub_cancel", "add_self_iff_eq_zero", "int.add_lt_add_left", "not_iff", "mul_eq_one_iff_eq_inv", "nat.pos_of_dvd_of_pos", "nat.mul_div_cancel'", "nat.lt_add_of_zero_lt_left", "lt_add_of_pos_left", "int.lt_iff_le_and_ne", "neg_le_neg", "nat.add_left_cancel", "neg_add_le_right_of_le_add", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "dvd.intro_left", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "eq_false_of_or_eq_false_right", "lt_of_sub_pos", "sub_right_le_of_le_add", "mul_neg_of_neg_of_pos", "le_sub_left_of_add_le", "ne_zero_of_one_div_ne_zero", "mul_pos_of_neg_of_neg", "nat.dvd_mod_iff", "int.ne_of_lt", "d_array.of_beq_aux_eq_ff", "mul_right_inv", "mul_le_mul_of_nonpos_left", "neg_comm_of_comm", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "neg_nonpos_of_nonneg", "add_group.add_right_cancel", "sub_lt_of_abs_sub_lt_left", "nat.dvd_of_mul_dvd_mul_right", "int.eq_succ_of_zero_lt", "lt_mul_of_gt_one_right", "ordered_ring.mul_le_mul_of_nonneg_right", "nat.div_lt_self", "group.mul_left_cancel", "lt_add_of_neg_add_lt", "list.bex_cons", "int.eq_coe_of_zero_le", "nat.div_eq_of_lt_le", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "sub_left_lt_of_lt_add", "add_right_neg", "neg_pos_of_neg", "zero_gt_neg_one", "nat.le_of_le_of_sub_le_sub_right", "nat.sub_mul_div", "add_lt_of_lt_sub_right", "dvd_of_neg_dvd", "int.lt_iff_le_not_le", "division_ring.mul_ne_zero", "inv_comm_of_comm", "nat.test_bit_succ", "nat.bit1_inj", "lt_neg_of_lt_neg", "le_sub_right_of_add_le", "nat.lt_of_add_lt_add_left", "eq_tt_of_not_eq_ff", "neg_lt_of_neg_lt", "nat.le_of_sub_eq_zero", "mul_neg_of_pos_of_neg", "le_add_of_neg_add_le_right", "nat.dvd_of_mod_eq_zero", "lt_sub_right_of_add_lt", "ordered_ring.mul_lt_mul_of_pos_right", "sub_self_div_two", "ordered_ring.mul_le_mul_of_nonneg_left", "eq_zero_of_mul_eq_self_left", "nat.dvd_of_mul_dvd_mul_left", "sub_pos_of_lt", "sub_nonpos_of_le", "lt_add_of_pos_right", "mul_nonpos_of_nonneg_of_nonpos", "nat.le_of_add_le_add_left", "nat.div_self", "lt_of_sub_neg", "norm_num.bit1_add_bit1_helper", "le_of_sub_nonneg", "nat.le_of_dvd", "neg_lt_sub_left_of_lt_add", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "mul_nonneg", "eq_false_of_or_eq_false_left", "nat.mod_pow_succ", "lt_add_of_sub_left_lt", "dvd_add_iff_left", "function.partial_inv_of_injective", "nat.mod_def", "lt_neg_add_of_add_lt", "norm_num.nonzero_of_div_helper", "neg_nonneg_of_nonpos", "and.congr_right_iff", "ordered_ring.mul_lt_mul_of_pos_left", "ordered_comm_group.le_of_add_le_add_left", "dvd_of_dvd_neg", "mul_self_eq_one_iff", "pos_and_pos_or_neg_and_neg_of_mul_pos", "le_of_sub_nonpos", "le_add_of_nonneg_left", "nat.mul_sub_div", "one_lt_one_div", "sub_neg_of_lt", "le_neg_add_of_add_le", "add_group.add_left_cancel", "nat.div_one", "neg_neg_of_pos", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "group.mul_right_cancel", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel", "nat.eq_zero_of_add_eq_zero_right", "lt_sub_left_of_add_lt", "neg_le_of_neg_le", "mul_le_mul_of_nonpos_right"]}, {"id": "expr.is_sort", "parentIds": []}, {"id": "macro_def", "parentIds": ["expr.is_sort", "expr.local_pp_name", "tactic.delta", "expr.is_arrow", "expr.is_iff", "expr.mk_exists_lst", "tactic.elide.unelide", "expr.mk_binding", "tactic.apply_inj_lemma", "expr.macro_def_name", "expr.to_nat", "tactic.instance_cache.append_typeclasses", "expr.local_binding_info", "tactic.interactive.get_rule_eqn_lemmas", "tactic.interactive.induction", "incorrect_def_lemma", "expr.is_ne", "expr.local_type", "expr.to_int", "expr.is_default_local", "expr.binding_domain", "tactic.mk_dec_eq_instance", "expr.binding_body", "expr.binding_name", "expr.is_heq", "tactic.choose1", "tactic.i_to_expr_for_apply", "tactic.constr_to_prop", "expr.traverse", "expr.is_constant_of", "expr.is_eq", "tactic.resolve_constant", "tactic.apply_auto_param", "tactic.change_core", "expr.const_name", "tactic.mk_iff_of_inductive_prop", "conv.funext", "old_conv.funext", "expr.is_false", "expr.is_pi", "expr.is_mvar", "tactic.explode.may_be_proof", "tactic.explode", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "expr.reduce_let", "well_founded_tactics.cancel_nat_add_lt", "expr.is_lambda", "well_founded_tactics.is_psigma_mk", "tactic.mk_local_pis_whnf", "expr.is_var", "expr.is_or", "tactic.revert_and_transform", "tactic.local_def_value", "old_conv.congr_core", "tactic.unsafe.type_context.print_mvars", "tactic.interactive.use", "expr.app_fn", "tactic.interactive.to_expr'", "tactic.relation_lhs_rhs", "expr.is_let", "expr.is_aux_decl", "expr.is_local_constant", "expr.app_arg", "reflected.subst", "expr.is_app", "tactic.interactive.simpa", "expr.to_binder", "tactic.interactive.clean", "expr.is_constant", "expr.is_not", "expr.to_implicit_local_const", "expr.is_macro", "tactic.interactive.erase_simp_args", "tactic.delta_instance", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "tactic.interactive.list_cast_of_aux", "interactive.param_desc", "expr.list_names_with_prefix", "expr.binding_info", "expr.abstract", "expr.is_and", "has_inhabited_instance", "expr", "tactic.apply_opt_param", "expr.local_uniq_name", "well_founded_tactics.check_target_is_value_lt", "expr.to_implicit_binder", "tactic.match_fn"]}, {"id": "level", "parentIds": ["expr.is_sort", "expr.local_pp_name", "tactic.mk_const", "tactic.exfalso", "tactic.delta", "tactic.unsafe.type_context.level.instantiate_mvars", "level.occurs", "expr.is_arrow", "expr.is_iff", "level.lt", "expr.mk_exists_lst", "tactic.elide.unelide", "expr.mk_binding", "expr.dedup_size", "unused_arguments", "vm_obj.to_level", "tactic.cc_core", "tactic.apply_inj_lemma", "expr.to_nat", "tactic.instance_cache.append_typeclasses", "level.lex_lt", "expr.local_binding_info", "expr.inhabited", "tactic.interactive.get_rule_eqn_lemmas", "tactic.interactive.induction", "incorrect_def_lemma", "expr.is_ne", "expr.local_type", "expr.to_int", "expr.is_default_local", "smt_tactic.interactive.have", "tactic.mk_pattern", "expr.binding_domain", "tactic.mk_dec_eq_instance", "tactic.instance_cache.mk_app", "expr.binding_body", "expr.binding_name", "expr.is_heq", "tactic.choose1", "simps_tac", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "tactic.constr_to_prop", "expr.traverse", "expr.is_constant_of", "tactic.match_expr", "expr.is_eta_expansion_of", "expr.is_eq", "tactic.resolve_constant", "tactic.interactive.set", "tactic.unsafe.type_context.level.tmp_get_assignment", "tactic.apply_auto_param", "tactic.change_core", "expr.const_name", "tactic.mk_iff_of_inductive_prop", "tactic.instance_cache", "conv.funext", "old_conv.match_pattern", "old_conv.funext", "copy_decl_updating_type", "level.has_to_format", "expr.is_false", "expr.is_pi", "expr.is_mvar", "tactic.explode.may_be_proof", "tactic.unsafe.type_context.level.mk_tmp_mvar", "tactic.add_theorem_by", "tactic.explode", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "old_conv.find_pattern", "smt_tactic.interactive.let", "expr.reduce_let", "well_founded_tactics.cancel_nat_add_lt", "old_conv.interactive.find", "declaration.instantiate_value_univ_params", "level.of_nat", "expr.is_lambda", "level.to_format", "expr.instantiate_univ_params", "expr.mk_true", "well_founded_tactics.is_psigma_mk", "level.size", "tactic.mk_local_pis_whnf", "level.dedup_size_aux", "tactic.decl_mk_const", "expr.is_var", "tactic.mk_local", "tactic.mk_mvar", "expr.is_or", "tactic.revert_and_transform", "tactic.local_def_value", "tactic.comp_val", "level.to_string", "old_conv.congr_core", "level.instantiate", "tactic.unsafe.type_context.print_mvars", "level.fold", "tactic.interactive.use", "expr.app_fn", "conv.interactive.find", "tactic.interactive.to_expr'", "tactic.alias.alias_direct", "level.has_decidable_eq", "tactic.relation_lhs_rhs", "expr.is_let", "tactic.unsafe.type_context.to_tmp_mvars", "tactic.interactive.return_cast", "level.has_param", "level.dedup_size", "expr.mk_false", "expr.is_aux_decl", "level.has_to_string", "expr.is_local_constant", "get_attribute_cache_dyn", "tactic.interactive.change", "expr.app_arg", "reflected.subst", "level.normalize", "declaration.univ_levels", "expr.is_app", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.prove_goal_async", "expr.to_binder", "tactic.match_pattern", "tactic.unsafe.type_context.level.assign", "tactic.interactive.clean", "expr.is_constant", "expr.is_not", "tactic.pattern", "expr.to_implicit_local_const", "smt_tactic.by_contradiction", "tactic.mk_num_meta_univs", "smt_tactic.by_cases", "instance_derive_handler", "tactic.interactive.have", "expr.is_macro", "level.inhabited", "tactic.interactive.erase_simp_args", "level.eqv", "tactic.delta_instance", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "tactic.interactive.list_cast_of_aux", "tactic.get_univ_assignment", "interactive.param_desc", "tactic.mk_id_proof", "saturate_fun", "expr.list_names_with_prefix", "expr.binding_info", "expr.abstract", "tactic.has_to_tactic_format", "derive_struct_ext_lemma", "tactic.mk_instance_cache", "tactic.ids_to_simp_arg_list", "expr.is_and", "expr.dedup_size_aux", "declaration.instantiate_type_univ_params", "has_inhabited_instance", "expr", "old_conv.mk_match_expr", "tactic.apply_opt_param", "level.nonzero", "expr.lift", "tactic.mk_sorry", "tactic.pexpr_to_pattern", "expr.local_uniq_name", "well_founded_tactics.check_target_is_value_lt", "expr.to_implicit_binder", "tactic.mk_meta_univ", "tactic.match_fn", "old_conv.match_expr"]}, {"id": "nat", "parentIds": ["expr.is_sort", "unsigned_sz", "tactic.rcases.process_constructors", "nat.le_total", "list.enum", "nat.has_mod", "int.neg_succ_of_nat_coe'", "tactic.get_subsingleton_info", "nat.eq_zero_of_add_eq_zero", "nat.pred_zero", "char.val_of_nat_eq_of_is_valid", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "expr.has_var_idx", "nat.zero_ne_one_class", "tactic.library_search_hole_cmd", "int.of_nat_ge_zero", "fin.of_nat_zero", "nat.lt_add_left", "user_attribute.set_untyped", "parser.sat", "expr.local_pp_name", "tactic.mk_const", "array.reverse", "parser.eof", "nat.sub_succ", "tactic.interactive.cases", "int.add_comm", "tactic.delta", "d_array.iterate_aux", "nat.pos_of_ne_zero", "nat.mod_lt", "is_valid_char_range_1", "nat.eq_zero_or_eq_succ_pred", "string.popn_back", "int.le.dest", "array.has_to_format", "tactic.rintro_hint", "simp.default_max_steps", "nat.div_eq_of_lt", "nat.semiring", "name_set.size", "array.to_list", "nat.bitwise_zero", "nat.one_ne_zero", "fin.has_one", "smt_tactic.iterate_exactly", "nat.bit_zero", "char.decidable_eq", "nat.lt_le_antisymm", "tactic.interactive.rsimp", "int.nat_abs_of_nat", "tactic.get_expl_arity", "expr.is_arrow", "tactic.mk_constructor_arg_names", "lean.parser.get_variables", "nat.bodd", "nat.test_bit", "tactic.explode.core", "nat.pow_le_pow_of_le_left", "nat.add_right_cancel", "nat.lt.step", "tactic.copy_attribute", "nat.shiftl_eq_mul_pow", "expr.is_iff", "param_info.to_format", "int.coe_nat_add_out", "int.neg_of_nat", "nat.shiftl'_add", "nat.add_mul_mod_self_right", "int.lt.intro", "expr.mk_exists_lst", "nat.has_pow", "tactic.rcases_hint.process_constructors", "nat.lxor_bit", "d_array.read", "tactic.injections_with", "options.get_nat", "int.nat_abs_bit1_nonneg_step", "tactic.elide.unelide", "nat.one_lt_bit0", "nat.succ_lt_succ", "expr.mk_binding", "tactic.rotate", "nat.mod", "nat.test_bit_ldiff", "scope_trace", "nat.add_one_ne_zero", "tactic.explode.args", "vm.stack_obj", "list.length_cons", "nat.mul_one", "nat.mul_div_mul", "tactic.rcases.process_constructor", "nat.lcm", "nat.not_succ_le_zero", "nat.succ_eq_add_one", "nat.eq_zero_of_add_eq_zero_left", "attribute.register", "try_for", "tactic.cases", "parser.pure", "tactic.existsi", "nat.succ_sub_sub_succ", "expr.dedup_size", "unused_arguments", "array.push_back_idx", "tactic.simp_config", "unsigned.has_zero", "array.take", "sigma.has_to_format", "pos.inhabited", "nat.sub", "char.of_nat_eq_of_not_is_valid", "vm_obj.fn_idx", "tactic.apply_inj_lemma", "mk_definition", "tactic.mk_has_sizeof_instance_core", "print_arguments", "int.add_assoc", "nat.mul_div_assoc", "fin.vne_of_ne", "array.decidable_eq", "int.le_of_coe_nat_le_coe_nat", "expr.to_nat", "tactic.instance_cache.append_typeclasses", "tactic.mk_iff_mp_app", "list.length_take_le", "is_valid_char_range_2", "d_array.beq", "d_array.nil", "nat.le_of_succ_le_succ", "cc_state.mt", "tactic.mk_brec_on_rec_value", "array.read_mem", "nat.le_add_left", "nat.lt_or_ge", "where.mk_flag", "d_array.of_beq_aux_eq_tt", "int.nat_abs_mul_self", "tactic.rcases_hint", "fin.mod", "simp_attr.pre_smt", "nat.div_def", "tactic.set_basic_attribute", "list.repeat", "nat.sub_eq_zero_of_le", "int.le.dest_sub", "native.rb_set.size", "vm.pc", "array", "nat.bodd_div2", "nat_add_zero", "sum_has_to_format", "nat.test_bit_bitwise", "nat.eq_of_mul_eq_mul_right", "buffer.take", "tactic.interactive.convert", "nat.pred_le", "using_smt", "unsigned.of_nat", "environment.for_decl_of_imported_module", "nat.not_lt_zero", "tactic.explode.entries.size", "nat.sub_sub_self", "smt_pre_config.inhabited", "int.nat_abs_eq", "nat.add_div_left", "nat.gcd_succ", "nat.bodd_add_div2", "nat.sub_le_sub_left", "list.length_le_of_sublist", "int.ne_of_nat_ne_nonneg_case", "nat.succ_mul_succ_eq", "tactic.get_unused_decl_name", "nat.add_mul_div_right", "nat.bodd_add", "expr.local_binding_info", "tactic.interactive.get_rule_eqn_lemmas", "parser.foldl", "nat.shiftl_sub", "tactic.clear'", "tactic.interactive.revert", "tactic.by_elim_opt", "nat.gcd_zero_left", "expr.is_napp_of", "fin.succ", "nat.add_le_add_iff_le_right", "nat.div2", "tactic.explode.append_dep", "nat.zero_lt_one", "sizeof", "tactic.interactive.induction", "int.neg_of_nat_zero", "tactic.interactive.rcases", "incorrect_def_lemma", "rbtree.default_lt", "fin.sub", "tactic.revert_kdependencies", "tactic.interactive.dsimp", "expr.is_ne", "nat.test_bit_lor", "environment.projection_info.inhabited", "expr.hash", "fin.has_sub", "expr.pi_arity_aux", "tactic.interactive.solve_by_elim", "nat.zero_le", "list.length_append", "nat.bit0_val", "string.iterator.length_next_to_string_next", "nat.pow_lt_pow_of_lt_right", "expr.get_depth", "name_set.has_to_format", "smt_tactic.intron", "tactic.unsafe.type_context.get_fun_info", "int.coe_nat_le_coe_nat_iff", "int.lt.elim", "nat.bodd_succ", "int.add_zero", "tactic.elim_gen_sum", "nat.zero_lt_one_add", "localized_attr", "native.rb_map.has_to_tactic_format", "expr.local_type", "fin.le_def", "nat.add_right_comm", "nat.lt_trichotomy", "old_conv.istep", "nat.ldiff_bit", "buffer.to_array", "to_additive.proceed_fields", "nat.bit1_lt", "native.float.has_one", "nat.has_mul", "expr.to_int", "expr.list_local_consts", "environment.add_inductive", "list.update_nth", "tactic.elide.replace", "tactic.interactive.rotate", "to_additive.guess_name", "string.iterator.prevn", "nat.find_min'", "nat.le_mul_self", "nat.lt_irrefl", "array.read_write_of_ne", "nat.le_succ", "vm.pp_stack_obj", "nat.lt_add_of_pos_left", "std.priority.default", "tactic.iterate_range", "nat.mul_div_right", "list.of_fn", "where.trace_nl", "nat.add_comm_monoid", "tactic.mk_simp_attr", "d_array.map\u2082", "fin.has_lt", "nat.shiftr_eq_div_pow", "expr.is_default_local", "nat.mod_one", "array.has_to_tactic_format", "vm.call_stack_fn", "nat.strong_induction_on", "char.val_of_nat_eq_of_not_is_valid", "nat.to_digits", "native.float.specification.emax", "fin.has_le", "list.range_core", "ematch_lhs", "interactive.types.pexpr_list", "expr.binding_domain", "nat.binary_rec_eq", "native.float.of_nat", "string.iterator.nextn", "nat.eq_zero_or_pos", "tactic.mk_dec_eq_instance", "nat.pred_lt_pred", "int.of_nat_inj", "vm.bp", "nat.lt_ge_by_cases", "fin.mod_def", "nat.nat_zero_eq_zero", "array.has_repr", "tactic.suggest_scripts", "nolint_attr", "nat.lor_bit", "char.is_whitespace", "int.of_nat_zero", "tactic.alias.alias_attr", "int.nat_abs_add_neg", "ematch_config", "tactic.library_search", "rbtree.depth", "can_lift_attr", "tactic.add_inductive", "list.range'", "int.sub_nat_nat_elim", "expr.binding_body", "int.mk_numeral", "nat.mod_two_of_bodd", "list.func.set", "simps_add_projection", "array.read", "expr.binding_name", "parser.orelse", "nat.lt_wf", "nat.le_trans", "name.get_nth_prefix", "tactic.mk_mvar_list", "int.nat_abs_pos_of_ne_zero", "tactic.mllist.enum_from", "list.split_at", "unsigned.has_to_string", "nat.find_min", "occurrences_to_format", "nat.binary_rec_zero", "list.func.equiv", "expr.is_heq", "local_decl", "int.lt_add_succ", "tactic.revert_all", "tactic.interactive.generalize_hyp", "localized_cmd", "tactic.mk_local_pisn", "list.length_drop", "nat.add_mul_div_left", "tactic.choose1", "int.nat_abs_add_nonneg", "tactic.delta_config", "nat.repr", "list.ne_nil_of_length_eq_succ", "old_conv.conversion", "tactic.extract_def", "nat.add_self_ne_one", "nat.sub_eq_iff_eq_add", "nat.succ_sub_succ_eq_sub", "parser.bind", "nat.le_of_eq", "vm_obj.to_nat", "list.length_map", "char.to_lower", "nat.succ_inj", "parser.mk_error_msg", "interactive.types.tac_rbp", "nat.zero_lt_succ", "tactic.mllist.enum", "nat.sub_eq_sub_min", "d_array.rev_iterate", "native.has_to_format", "nat.sub_mul_mod", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "tactic.i_to_expr_for_apply", "nat.mul_assoc", "nat.sub_induction", "nat.comm_semigroup", "nat.zero_mul", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "parser.foldr", "nat.bodd_one", "tactic.constr_to_prop", "tactic.ext", "int.nat_bitwise", "tactic.rintro_parse", "d_array.read_write", "nat.mod_eq_of_lt", "nat.bitwise_zero_left", "nat.zero_shiftr", "nat.bitwise", "nat.add_comm", "tactic.interactive.convert_to_core", "nat.ordered_semiring", "array.write", "string.hash", "int.neg_succ_of_nat_inj_iff", "int.lt_of_coe_nat_lt_coe_nat", "expr.traverse", "rsimp.config.inhabited", "list.modify_nth", "environment.inductive_num_params", "tactic.try_for", "nat.add_succ", "nat.bit", "nat.mul_self_le_mul_self_iff", "expr.replace", "buffer.read_eq_read'", "int.mul_one", "nat.has_zero", "expr.is_constant_of", "parser.foldl_core", "int.eq_coe_or_neg", "nat.one_le_bit0", "char.of_nat", "int.add_left_neg", "nat.has_to_string", "unsigned.has_repr", "int.nat_abs_bit0_step", "expr.is_eq", "list.rotate", "tactic.resolve_constant", "tactic.unsafe.type_context.level.tmp_get_assignment", "unsigned.to_nat", "nat.lt_of_sub_eq_succ", "int.of_nat_nat_abs_of_nonpos", "options.set_nat", "nat.comm_semiring", "char.is_lower", "string.popn", "nat.shiftl'_sub", "tactic.apply_auto_param", "tactic.change_core", "nat.one_shiftl", "expr.const_name", "environment.inductive_num_indices", "nat.one_le_bit1", "tactic.interactive.letI", "buffer.drop", "int.coe_nat_lt_coe_nat_iff", "tactic.mk_congr_lemma_simp", "nat.mul_le_mul_left", "nat.linear_order", "environment.relation_info", "lean.parser.get_includes", "nat.le_lt_antisymm", "environment.is_refl_app", "int.coe_nat_mul_out", "tactic.mk_iff_of_inductive_prop", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "tactic.has_opt_auto_param", "where.get_namespace_core", "tactic.iff_mp_core", "no_rsimp", "int.of_nat_nonneg", "nat.add_sub_cancel", "tactic.sleep", "nat.mul_zero", "format.indent", "conv.funext", "tactic.change_with_at", "fin.mul", "int.of_nat_sub", "int.coe_nat_zero", "tactic.constructor_idx", "nat.div_le_of_le_mul", "tactic.constructor_num_fields", "nat.lt_add_of_pos_right", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "old_conv.funext", "fin.eq_of_veq", "nat.sub_pos_of_lt", "tactic.interactive.elide", "int.of_nat_nat_abs_eq_of_nonneg", "cc_state.eqc_size", "array.write'", "tactic.has_attribute'", "tactic.classical", "nat.mul_mod_mul_left", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "array.read_write", "list.rotate'", "vm_decl.arity", "int.distrib_left", "tactic.interactive.guard_hyp_nums", "tactic.lift", "fin.has_add", "tactic.abstract", "tactic.interactive.iterate", "int.lt_irrefl", "tactic.interactive.rintros", "nat.div2_zero", "nat.bodd_zero", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "nat.mul_self_lt_mul_self_iff", "nat.coprime", "nat.mod_le", "tactic.interactive.simp_core_aux", "tactic.rcases_hint_core", "nat.nat.lt_asymm", "nat.mk_numeral", "nat.add_le_add_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.gcd.induction", "nat.has_add", "nat.zero_sub", "int.of_nat_mul", "tactic.mk_patterns", "nat.div_mul_cancel", "nat.eq_zero_of_mul_eq_zero", "nat.pos_of_dvd_of_pos", "tactic.istep", "tactic.mk_replacer\u2082", "nat.lt_by_cases", "array.pop_back_idx", "nat.div_eq_of_eq_mul_right", "expr.is_false", "vm.call_stack_var_range", "list.indexes_of", "expr.is_pi", "int.coe_nat_add_one_out", "nat.mul_div_cancel'", "int.le_antisymm", "print_decls_sorted_mathlib", "nat.succ_sub_succ", "lean.parser.small_nat", "pos_line", "nat.lt_add_of_zero_lt_left", "lean.parser.get_namespace", "list.indexes_values", "nat.has_lt", "nat.div", "buffer.lt_aux_2", "nat.pred_le_pred", "nat.sub_self", "std.prec.arrow", "vm_decl.idx", "fin.ne_of_vne", "int.lt_iff_le_and_ne", "char.decidable_is_digit", "to_additive.map_namespace", "nat.one_ne_bit1", "expr.is_mvar", "nat.add_left_cancel", "tactic.explode.may_be_proof", "char.is_punctuation", "expr.lower_vars", "tactic.rcases_parse_depth", "nat.zero_mod", "unsigned.of_nat'", "tactic.iterate_exactly", "tactic.elim_gen_prod", "name.length", "parser.fail", "tactic.unsafe.type_context.level.mk_tmp_mvar", "rsimp_attr", "char.veq_of_eq", "nat.succ_pos", "list.take", "nat.digit_char", "list.map_with_index", "tactic.mk_inhabited_instance", "tactic.explode", "std.prec.max", "list.qsort_cons", "tactic.unsafe.type_context.tmp_mode", "tactic.decorate_ex", "string.is_empty", "nat.sub_lt_of_pos_le", "vm.call_stack_size", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "char.decidable_is_punctuation", "tactic.get_unused_decl_name_aux", "tactic.interactive.mk_paragraph_aux", "char", "tactic.has_opt_auto_param_for_apply", "nat.add_mod_right", "int.le.intro", "nat.add_sub_add_right", "measure", "char.le", "expr.reduce_let", "nat.bit_decomp", "buffer.reverse", "nat.le_of_add_le_add_right", "nat.add_sub_cancel_left", "well_founded_tactics.cancel_nat_add_lt", "nat.bit1_ne_bit0", "int", "linter_attr", "tactic.mk_dec_eq_instance_core", "nat.gcd_one_left", "nat.eq_zero_of_le_zero", "nat.bit_cases_on", "nat.decidable_lt", "nat.semigroup", "nat.add_monoid", "list.find_indexes_aux", "fin.veq_of_eq", "level.of_nat", "tactic.apply_heq_congr_core", "nat.bitwise_swap", "expr.is_lambda", "nat.has_sizeof", "tactic.mk_constructors_arg_names", "nat.bitwise_zero_right", "buffer.take_right", "int.coe_nat_add", "nat.le_of_succ_le", "nat.shiftr_add", "char.ne_of_vne", "list.length", "options.size", "string.backn", "nat.less_than_or_equal", "nat.pow_succ", "nat.size", "int.le_trans", "int.zero", "list.length_take", "buffer.write_eq_write'", "int.coe_nat_eq", "fin.add_def", "nat.mul_pred_left", "nat.lor", "list.enum_from", "int.has_coe", "fin.mul_def", "well_founded_tactics.is_psigma_mk", "expr.list_meta_vars", "name.deinternalize_field", "level.size", "nat.bitwise_bit", "find_cmd", "fin", "nat.zero_ne_bit1", "nat.dvd_add_iff_right", "tactic.mllist.range", "int.nat_abs_neg", "tactic.mk_local_pis_whnf", "rsimp.explicit_size", "ematch", "parser.fix_core", "int.eq_neg_succ_of_lt_zero", "std.prec.max_plus", "nat.mul", "level.dedup_size_aux", "expr.mk_var", "nat.find", "nat.dvd_mod_iff", "check_unused_arguments_aux", "nat.dvd_sub", "nat.le", "list.nth_le", "fin.lt", "tactic.rcases_hint.continue", "tactic.apply_under_pis", "d_array.of_beq_aux_eq_ff", "tactic.interactive.haveI", "native.float.specification.radix", "library_note_attr", "char.decidable_is_upper", "environment.fingerprint", "nat.inhabited", "expr.is_var", "nat.decidable_eq", "nat.bitwise_bit_aux", "nat.lt_succ_of_lt", "d_array.write", "int.nat_abs_bit0", "vm.stack_obj_info", "nat.eq_one_of_dvd_one", "nat.shiftl", "nat.iterate", "expr.lift_vars", "tactic.suggest.apply_and_solve", "int.abs_eq_nat_abs", "simp_attr.functor_norm", "simp_attr.norm", "nat.case_strong_induction_on", "int.coe_nat_one", "expr.is_or", "int.mul_zero", "fin.of_nat", "array.take_right", "tactic.revert_and_transform", "expr.replace_with", "nat.le.intro", "tactic.local_def_value", "param_info", "nat.decidable_le", "tactic.comp_val", "char.to_nat", "int.sub_nat_nat", "list.of_fn_nth_val", "old_conv.congr_core", "nat.sub_self_add", "nat.land", "char.is_upper", "tactic.unsafe.type_context.print_mvars", "native.rb_set.has_to_format", "apply_nolint_tac", "int.sign_mul_abs", "nat.discriminate", "cc_state.gmt", "expr.size", "nat.test_bit_lxor", "nat.mul_lt_mul_of_pos_left", "fin.has_repr", "nat.sub_one_sub_lt", "array.mem", "list.find_indexes", "array.ext'", "nat.succ_add", "array.read'", "list.range", "tactic.fold_explicit_args", "tactic.alias.mk_iff_mp_app", "expr.of_int", "fin.decidable_lt", "nat.mul_le_mul_right", "nat.add_lt_add_right", "int.nat_abs_of_nat_core", "nat.distrib", "nat.le_add_right", "check_unused_arguments", "expr.mfold", "nat.dvd_of_mul_dvd_mul_right", "buffer.lt_aux_3", "d_array.map", "hex_digit_repr", "int.mul_pos", "nat.zero_min", "int.eq_succ_of_zero_lt", "tactic.interactive.generalize", "tactic.interactive.use", "nat.add_zero", "tactic.mk_has_reflect_instance", "nat.land_bit", "tactic.intron", "nat.succ_ne_zero", "int.one", "buffer.read'", "list.qsort", "print_item_crawl", "unsigned.has_one", "d_array.iterate", "buffer.write'", "smt_tactic.execute", "expr.pi_arity", "native.float.has_zero", "expr.app_fn", "list.of_fn_aux", "nat.mul_mod_left", "nat.add_div_right", "tactic.ancestor_attr", "tactic.set_nat_option", "list.nth", "list.length_tail", "nat.mul_lt_mul_of_pos_right", "add_succ_defeq_succ_add_hint", "nat.div_lt_self", "nat.mul_mod_right", "prod.has_to_format", "tactic.interactive.to_expr'", "has_sizeof", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "nat.lt_iff_le_not_le", "char.vne_of_ne", "fin.lt_def", "int.coe_nat_lt_coe_nat_of_lt", "tactic.interactive.ext", "tactic.alias.alias_direct", "nat.has_le", "nat.mul_succ", "nat.div2_val", "smt_tactic.istep", "string.iterator.remove", "nat.mod_zero", "nat.one_add", "nat.mul_self_le_mul_self", "nat.bit1_val", "char.inhabited", "tactic.solve_by_elim", "int.coe_nat_succ", "nat.le_succ_of_pred_le", "nat.bit0_lt", "nat.mul_div_left", "int.coe_nat_inj", "nat.lt", "environment.projection_info", "lean.is_release", "d_array.decidable_eq", "rsimp.collect_implied_eqs", "tactic.relation_lhs_rhs", "list.map_with_index_core", "array.drop", "name.append_after", "attribute.fingerprint", "int.eq_coe_of_zero_le", "nat.div_eq_of_lt_le", "expr.is_let", "int.mul_assoc", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "list.length_map_accumr", "int.coe_nat_eq_coe_nat_iff", "int.nat_abs_bit1_nonneg", "option.has_to_format", "tactic.explode.pad_right", "int.add_le_add_left", "nat.le.dest", "expr.to_pos_nat", "rbnode.depth", "tactic.explode_expr", "nat.one_succ_zero", "tactic.iff_mpr_core", "int.of_nat_eq_coe", "buffer.append_array", "tactic.dsimp_config", "user_attribute.set", "interactive.parse_binders", "smt_config.inhabited", "nat.has_div", "nat.bit0_succ_eq", "nat.dvd_iff_mod_eq_zero", "int.coe_nat_sub", "nat.mul_sub_left_distrib", "nat.eq_or_lt_of_le", "nat.mul_pred_right", "tactic.interactive.replace", "nat.gcd", "nat.one_pos", "int.neg_neg_of_nat_succ", "simp_attr.split_if_reduction", "int.eq_nat_abs_of_zero_le", "tactic.get_arity", "nat.bit0_ne_one", "tactic.interactive.clear_", "int.nat_mod", "nat.monoid", "tactic.has_attribute", "nat.sub_add_comm", "tactic.explode.has_to_tactic_format", "list.count", "parser.decorate_errors", "nat.has_one", "nat.succ_sub", "nat.div_le_self", "nat.le_of_le_of_sub_le_sub_right", "nat.bodd_bit", "nat.pos_pow_of_pos", "where.resolve_var", "nat.sub_mul_div", "nat.bit0_ne_bit1", "fin.sub_def", "nat.pred_lt", "nat.exists_eq_succ_of_ne_zero", "fun_info_to_format", "parser.run", "char.of_nat_ne_of_ne", "tactic.revert_kdeps", "tactic.get_pi_arity", "tactic.rcases", "int.neg_succ_of_nat_coe", "expr.is_bin_arith_app", "nat.sub.right_comm", "list.countp", "nat.left_distrib", "char.is_digit", "int.neg_succ_of_nat_eq", "expr.get_weight", "nat.mod_self", "nat.shiftl_succ", "nat.le_succ_of_le", "rsimp.choose", "int.coe_nat_le_coe_nat_of_le", "list.to_format", "nat.lxor", "norm_num.sub_nat_pos_helper", "int.sign_mul_nat_abs", "tactic.iterate", "nat.strong_rec_on", "tactic.revert", "nat.add_mod_left", "nat.lt_of_le_and_ne", "nat.right_distrib", "level.dedup_size", "expr.is_aux_decl", "tactic.injection_with", "tactic.interactive.convert_to", "nat.test_bit_succ", "expr.is_local_constant", "nat.zero_lt_bit1", "char.decidable_is_lower", "nat.one_ne_bit0", "nat.bit1_inj", "nat.ldiff", "tactic.interactive.congr'", "nat.eq_or_lt_of_not_lt", "char_to_hex", "int.pos_of_sign_eq_one", "tactic.fail_if_no_goals", "nat.le_of_lt_succ", "parser.remaining", "tactic.rename", "fin.div", "tactic.interactive.change", "expr.app_arg", "reflected.subst", "nat.zero_ne_one", "smt_tactic.iterate_at_most", "nat.sub_sub", "nat.lt_of_add_lt_add_left", "tactic.mk_constructor_fresh_names", "nat.div2_bit", "list.inth", "nat.prio", "nat.not_succ_le_self", "nat.bit0_lt_bit1", "vm.stack_size", "lint_aux", "mk_buffer", "nat.sub_zero", "nat.mul_sub_right_distrib", "tactic.interactive.list_cast_of", "list.indexes_values_aux", "nat.sub_add_min_cancel", "nat.lt_of_succ_lt", "nat.add_le_add_left", "list.qsort.F", "nat.le_of_sub_eq_zero", "user_attribute", "fin.has_mod", "array.map\u2082", "where.binder_priority", "nat.succ_ne_self", "char.eq_of_veq", "nat.add_one", "int.neg_succ_lt_zero", "tactic.def_replacer", "int.neg_of_sign_eq_neg_one", "nat.lt_succ_of_le", "occurrences.contains", "nat.mul_self_sub_mul_self_eq", "interactive.parse_binders_core", "smt_tactic.iterate", "nat.mul_self_lt_mul_self", "fun_info.inhabited", "array.pop_back", "nat.zero_ne_bit0", "debugger.attr", "buffer.lt_aux_1", "nat.gcd_zero_right", "nat.decidable_linear_ordered_semiring", "nat.bit_val", "nat.div_eq_sub_div", "std.priority.max", "derive_handler_attr", "tactic.iterate_at_most_on_all_goals", "nat.pow_lt_pow_of_lt_left", "nat.sub_le_sub_right_iff", "unsigned.has_to_format", "nat.lt_of_le_of_lt", "nat.dvd_of_mod_eq_zero", "expr.is_app", "nat.add", "int.le_refl", "nat.zero_div", "parser.fix", "nat.mod_def_aux", "tactic.mllist.take", "tactic.iterate_at_most", "mk_array", "nat.bit1_eq_succ_bit0", "nat.add_comm_semigroup", "nat.shiftl_add", "array.read_eq_read'", "tactic.alias.alias_iff", "conv.interactive.for", "nat.succ_le_succ", "tactic.rotate_left", "nat.test_bit_zero", "nat.mod_add_div", "tactic.interactive.simpa", "tactic.back_chaining_core", "int.exists_eq_neg_of_nat", "native.rb_map.size", "d_array.foreach", "list.remove_nth", "tactic.explode.entry", "list.modify_nth_tail", "tactic.interactive.swap", "tactic.prove_goal_async", "char.decidable_is_whitespace", "where.binder_less_important", "d_array.of_beq_eq_tt", "fin.has_mul", "expr.to_binder", "nat.two_step_induction", "list.take'", "nat.mod_eq_sub_mod", "nat.mul_div_cancel_left", "parser.failure", "nat.has_to_format", "nat.test_bit_land", "lean.parser.pexpr", "nat.repeat", "is_valid_char", "tactic.get_nat_option", "d_array", "name.pop_nth_prefix", "array.foreach", "parse_result", "tactic.solve_by_elim_aux", "d_array.ext'", "char.quote_core", "nat.dvd_of_mul_dvd_mul_left", "where.trace_where", "impossible_instance", "int.nat_abs_of_nonneg", "interaction_monad.result.clamp_pos", "fun_info", "int.test_bit", "incorrect_type_class_argument", "tactic.interactive.clean", "int.nat_abs_one", "environment.trust_lvl", "int.mul_nonneg", "int.to_nat_sub", "nat.div2_succ", "tactic.select", "tactic.apply_rules", "int.le.elim", "native.nat_map", "parser.foldr_core", "environment.inhabited", "int.of_nat_one", "d_array.ext", "nat.bit1_ne_zero", "tactic.unsafe.type_context.tmp_get_assignment", "nat.min_zero", "smt_pre_config", "int.neg_succ_of_nat_inj", "list.func.get", "pos", "fin.decidable_eq", "int.nat_abs_of_neg_succ_of_nat", "expr.is_constant", "tactic.new_aux_decl_name", "tactic.rsimp", "int.of_nat_add", "d_array.rev_iterate_aux", "char.lt", "expr.is_not", "expr.ith_arg", "tactic.pattern", "tactic.mk_constructors_fresh_names", "array.push_back", "nat.le_refl", "tactic.alias.get_alias_target", "where.is_variable_name", "nat.binary_rec", "format.of_nat", "nat.sub_le", "nat.zero_shiftl", "nat.pred", "nat.succ_mul", "array.rev_foldl", "list_items", "expr.get_nat_value", "measure_wf", "list.length_map\u2082", "expr.to_implicit_local_const", "nat.le_of_add_le_add_left", "int.sign_of_succ", "char.zero_lt_d800", "tactic.interactive.rw_rules", "int.nat_abs", "nat.find_spec", "mk_hinst_lemma_attr_set", "list.iota", "nat.div_self", "fin.add", "nat.sub_le_sub_right", "nat_to_format", "list.length_map_accumr\u2082", "tactic.mk_replacer", "nat.div_mul_le_self", "tactic.rsimp_at", "list.index_of", "tactic.suggest.replace_mvars", "tactic.mk_num_meta_univs", "nat.bit1_ne_one", "format.nest", "expr.ith_arg_aux", "nat.shiftl_zero", "instance_priority", "fin.decidable_le", "int.of_nat_succ", "buffer", "vm_obj.cidx", "tactic.interactive.dunfold", "int.le.intro_sub", "nat.sub_eq_zero_iff_le", "ematch_config.inhabited", "parser", "nat.pow_zero", "instance_derive_handler", "array.iterate", "tactic.interactive.mk_paragraph", "tactic.inhabited_instance", "int.sign_eq_neg_one_of_neg", "expr.fold", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "param_info.inhabited", "int.to_nat", "tactic.get_fun_info", "tactic.interactive.extract_goal", "lean.version", "nat.add_semigroup", "native.float.of_nat_coe", "conv.istep", "tactic.get_mathlib_dir", "list.find_index", "tactic.unsafe.type_context.tmp_is_assigned", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "expr.is_macro", "nat.mul_comm", "int.lt.dest", "fin.has_div", "nat.gcd_rec", "int.neg_of_nat_of_succ", "tactic.interactive.field", "mk_num_name", "tactic.interactive.erase_simp_args", "fin.div_def", "fin.pred", "nat.sub_lt", "nat.eq_of_mul_eq_mul_left", "tactic.delta_instance", "nat.add_mul_mod_self_left", "nat.digit_succ", "nat.lt_of_succ_le", "nat.pred_inj", "int.coe_succ_pos", "tactic.mk_hcongr_lemma", "int.decidable_eq", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "unsigned.reflect", "nat.div2_two", "nat.pow", "expr.instantiate_nth_var", "list.drop", "list.qsort_nil", "tactic.mk_inj_eq", "nat.bit1_succ_eq", "nat.lt_add_right", "expr.list_constant", "array.map", "smt_tactic.interactive.add_fact", "environment.from_imported_module", "buffer.size", "int.of_nat_eq_of_nat_iff", "tactic.interactive.list_cast_of_aux", "tactic.interactive.apply_rules", "tactic.revert_lst", "int.sign_eq_one_of_pos", "array.has_mem", "tactic.suggest.decl_data", "nat.succ_le_of_lt", "occurrences", "int.mul_comm", "nat.sub_one", "where.format_variable", "array.ext", "tactic.interactive.h_generalize", "interactive.param_desc", "nat.bits", "nat.bit1_ne", "nat.add_left_comm", "array.write_eq_write'", "nat.mod_pow_succ", "tactic.interactive.ac_change", "tactic.alias.make_left_right", "nat.zero_pow", "nat.can_lift", "nat.add_lt_add_left", "nat.has_sub", "conv.congr", "d_array.read_write_of_ne", "tactic.suggest", "string.length", "environment.mk_std", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.suggest.application", "array.rev_iterate", "nat.one_mul", "nat.succ_sub_one", "saturate_fun", "expr.get_free_var_range", "tactic.rotate_right", "dangerous_instance", "mk_hinst_lemma_attr_core", "nat.mod_def", "nat.bit0_ne_zero", "nat.add_sub_of_le", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "expr.list_names_with_prefix", "fin.val_zero", "nat.lt_of_lt_of_le", "nat.le_div_iff_mul_le", "array.rev_list", "d_array.foldl", "expr.binding_info", "conv.convert", "int.le_nat_abs", "nat.div_lt_iff_lt_mul", "nat.decidable_dvd", "expr.abstract", "list.length_repeat", "nat.lt_succ_self", "nat.add_le_to_le_sub", "int.le_of_lt", "int.gcd", "nat.lt_of_succ_lt_succ", "tactic.rename'", "list.length_remove_nth", "nat.sub_lt_succ", "tactic.mk_replacer\u2081", "fin.elim0", "tactic.replacer_attr", "nat.zero_add", "tactic.interactive.suggest", "nat.bit0_ne", "tactic.unsafe.type_context.level.tmp_is_assigned", "nat.sub_add_cancel", "pos.has_to_format", "rsimp.config", "nat.dvd_add_iff_left", "pos.has_reflect", "tactic.get_unused_name", "nat.decidable_linear_ordered_cancel_comm_monoid", "tactic.has_to_tactic_format", "nat.pred_succ", "fin.has_to_string", "environment.get_modifiers", "nat.bit1_lt_bit0", "array.nil", "array.to_buffer", "nat.mul_mod_mul_right", "list.insert_nth", "array.slice", "tactic.interactive.push_neg", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "int.eq_zero_of_nat_abs_eq_zero", "nat.div_zero", "format.dcbrace", "nat.has_repr", "tactic.backward_chaining_core", "tactic.exact_dec_trivial", "nat.shiftr", "int.coe_nat_mul", "native.float.specification.precision", "int.zero_ne_one", "lint_mathlib", "nat.min_succ_succ", "nat.gcd_def", "tactic.done", "tactic.num_goals", "int.nat_abs_abs", "reducibility_hints", "nat.cond_to_bool_mod_two", "function.involutive_iff_iter_2_eq_id", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "expr.is_and", "expr.dedup_size_aux", "d_array.beq_aux", "has_inhabited_instance", "smt_tactic.interactive.executor", "nat.shiftl'", "dedup", "expr", "string.to_nat", "tactic.interactive.delta", "nat.zero_lt_bit0", "nat.find_x", "dup_namespace", "array.foldl", "tactic.unsafe.type_context.mk_tmp_mvar", "tactic.apply_opt_param", "nat.div2_one", "expr.of_nat", "nat.div_one", "nat.lt.base", "nat.lt_trans", "name.pop_prefix", "tactic.get_pi_binders_dep_aux", "native.float.has_nat_pow", "fin.has_zero", "int.coe_zero_le", "smt_tactic.num_goals", "nat.succ_pred_eq_of_pos", "nat.le_of_lt", "expr.contains_constant", "nat.mod_eq_zero_of_dvd", "tactic.get_pi_binders_dep", "expr.local_uniq_name", "fin.le", "nat.dvd_antisymm", "nat.reflect", "well_founded_tactics.check_target_is_value_lt", "expr.to_implicit_binder", "int.nat_abs_zero", "tactic.get_spec_prefix_size", "nat.add_assoc", "nat.add_sub_add_left", "nat.mul_div_cancel", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "expr.get_app_num_args", "nat.comm_monoid", "list.eq_nil_of_length_eq_zero", "tactic.note_anon", "nat.le_antisymm", "tactic.match_fn", "tactic.mk_congr_lemma", "nat.bodd_two", "tactic.get_expl_pi_arity"]}, {"id": "binder_info", "parentIds": ["expr.is_sort", "binder.decidable_eq", "expr.local_pp_name", "tactic.delta", "expr.is_arrow", "lean.parser.get_variables", "expr.is_iff", "expr.mk_exists_lst", "tactic.elide.unelide", "expr.mk_binding", "binder", "tactic.apply_inj_lemma", "expr.to_nat", "tactic.instance_cache.append_typeclasses", "where.trace_variables", "expr.local_binding_info", "tactic.interactive.get_rule_eqn_lemmas", "where.sort_variable_list", "tactic.interactive.induction", "incorrect_def_lemma", "expr.is_ne", "expr.local_type", "expr.to_int", "expr.is_default_local", "expr.binding_domain", "tactic.mk_dec_eq_instance", "binder_info.inhabited", "local_context.mk_local", "expr.binding_body", "tactic.mk_local'", "expr.binding_name", "expr.is_heq", "local_decl", "where.get_def_variables", "tactic.choose1", "binder_info.brackets", "tactic.i_to_expr_for_apply", "tactic.constr_to_prop", "expr.imp", "expr.traverse", "expr.is_constant_of", "expr.is_eq", "tactic.resolve_constant", "tactic.apply_auto_param", "tactic.change_core", "expr.const_name", "where.get_includes_core", "lean.parser.get_includes", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "conv.funext", "where.strip_pi_binders", "old_conv.funext", "expr.is_false", "expr.is_pi", "binder_info.has_reflect", "expr.is_mvar", "tactic.explode.may_be_proof", "tactic.explode", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "expr.reduce_let", "well_founded_tactics.cancel_nat_add_lt", "where.find_var", "expr.is_lambda", "well_founded_tactics.is_psigma_mk", "tactic.mk_local_pis_whnf", "expr.is_var", "tactic.interactive.compact_decl_aux", "tactic.mk_local", "expr.is_or", "tactic.revert_and_transform", "tactic.local_def_value", "old_conv.congr_core", "tactic.unsafe.type_context.print_mvars", "tactic.interactive.use", "expr.app_fn", "tactic.interactive.to_expr'", "tactic.relation_lhs_rhs", "expr.is_let", "where.get_variables_core", "binder_info.has_repr", "tactic.binder_info.has_decidable_eq", "expr.is_aux_decl", "expr.is_local_constant", "binder.inhabited", "expr.app_arg", "reflected.subst", "where.binder_priority", "expr.is_app", "tactic.interactive.simpa", "tactic.mk_local_def", "where.binder_less_important", "expr.to_binder", "impossible_instance", "incorrect_type_class_argument", "tactic.interactive.clean", "expr.is_constant", "expr.is_not", "where.is_variable_name", "expr.to_implicit_local_const", "instance_priority", "where.fetch_potential_variable_names", "instance_derive_handler", "tactic.interactive.extract_goal", "expr.is_macro", "tactic.interactive.erase_simp_args", "tactic.delta_instance", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "tactic.interactive.list_cast_of_aux", "where.format_variable", "interactive.param_desc", "where.strip_pi_binders_aux", "dangerous_instance", "expr.list_names_with_prefix", "expr.binding_info", "expr.abstract", "has_reflect_derive_handler", "where.compile_variable_list", "expr.is_and", "has_inhabited_instance", "expr", "tactic.apply_opt_param", "tactic.unsafe.type_context.push_local", "expr.local_uniq_name", "tactic.interactive.compact_decl", "well_founded_tactics.check_target_is_value_lt", "expr.to_implicit_binder", "tactic.match_fn"]}, {"id": "expr", "parentIds": ["expr.is_sort", "tactic.eval_expr'", "tactic.mk_congr_arg", "tactic.unsafe_change", "reflected.has_to_tactic_format", "tactic.simplify", "tactic.find_if_cond_at", "has_sizeof_derive_handler", "tactic.get_subsingleton_info", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "expr.has_var_idx", "tactic.replace_at", "binder.decidable_eq", "user_attribute.set_untyped", "expr.local_pp_name", "declaration.is_theorem", "tactic.mk_const", "environment.add_ginductive", "expr.is_sorry", "tactic.mk_eq_refl", "tactic.exfalso", "tactic.interactive.cases", "tactic.instance_cache.get", "smt_tactic.solve1", "tactic.delta", "expr.is_annotation", "tactic.i_to_expr_strict", "tactic.focus1", "tactic.rintro_hint", "tactic.flat_assoc", "tactic.change", "old_conv", "tactic.revertible_local_context", "tactic.apply_iff", "infer_type_cmd", "tactic.interactive.rw_rule.has_reflect", "tactic.rewrite_core", "tactic.get_expl_arity", "expr.is_arrow", "lean.parser.get_variables", "tactic.admit", "tactic.explode.core", "user_attribute.get_param_untyped", "smt_tactic.add_lemmas_from_facts_core", "tactic.unify", "expr.is_iff", "well_founded_tactics.clear_internals", "tactic.explode.entries.inhabited", "tactic.find_same_type", "expr.mk_exists_lst", "tactic.rcases_hint.process_constructors", "tactic.mk_congr_fun", "tactic.injections_with", "tactic.elide.unelide", "expr.get_app_args_aux", "smt_tactic.definev", "expr.mk_binding", "tactic.mk_mapp", "tactic.build_list_expr_for_apply", "tactic.target", "tactic.interactive.recover", "tactic.explode.args", "tactic.save_const_type_info", "smt_tactic.interactive.destruct", "tactic.focus", "smt_tactic.set_goals", "tactic.find_assumption", "tactic.mk_assoc_pattern'", "tactic.cases", "tactic.existsi", "expr.dedup_size", "unused_arguments", "tactic.local_context", "tactic.cc_core", "ematch_state.internalize", "binder", "tactic.mk_comp", "tactic.back_lemmas_find", "tactic.apply_inj_lemma", "mk_definition", "tactic.mk_has_sizeof_instance_core", "tactic.get_constructors_for", "tactic.apply_instance", "vm.pp_expr", "smt_tactic.ematch_core", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "expr.to_nat", "cc_state.roots", "tactic.mk_psigma", "tactic.instance_cache.append_typeclasses", "tactic.mk_iff_mp_app", "tactic.dsimplify", "expr.mk_or_lst", "tactic.interactive.loc.get_local_pp_names", "declaration.type", "wf_tacs", "smt_tactic.add_lemmas_from_facts", "expr.has_to_string", "where.trace_variables", "cc_state.mt", "tactic.mk_brec_on_rec_value", "tactic.simplify_top_down", "old_conv.failed", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "simp_lemmas.rewrite", "expr.has_decidable_eq", "expr.binding_names", "tactic.cleanup", "tactic.is_prop", "tactic.kdepends_on", "smt_tactic.seq", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "tactic.explode.entries.size", "conv.interactive.conv", "conv.lhs", "tactic.match_or", "tactic.mk_higher_order_type", "tactic.simp_all_entry", "tactic.apply_list_expr", "tactic.get_pi_binders", "expr.local_binding_info", "expr.inhabited", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "where.sort_variable_list", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "tactic.by_elim_opt", "expr.is_napp_of", "old_conv.trace", "tactic.get_library_notes", "tactic.explode.append_dep", "tactic.interactive.induction", "incorrect_def_lemma", "old_conv.findp", "tactic.symm_apply", "tactic.revert_kdependencies", "tactic.interactive.dsimp", "mk_nat_val_le_proof", "pexpr.of_expr", "tactic.interactive.cases_matching", "expr.is_ne", "expr.hash", "expr.pi_arity_aux", "environment.unfold_all_macros", "tactic.interactive.solve_by_elim", "expr_set", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "tactic.symmetry_hyp", "expr.get_depth", "tactic.note", "old_conv.dsimp", "tactic.interactive.apply_assumption", "tactic.is_assigned", "expr.reduce_lets", "tactic.unsafe.type_context.get_fun_info", "cc_state.proof_for", "old_conv_result", "tactic.elim_gen_sum", "localized_attr", "environment.is_definition", "expr.local_type", "old_conv.istep", "tactic.save_type_info", "tactic.pis", "tactic.mk_eq_mp", "tactic.dunfold_head", "tactic.match_app_of", "expr.to_int", "expr.list_local_consts", "environment.add_inductive", "tactic.interactive.clear_dependent", "cc_state.add", "push_neg.normalize_negations", "tactic.elide.replace", "old_conv.change", "tactic.non_dep_prop_hyps", "tactic.mk_iff", "use_cmd", "expr.mk_op_lst", "expr.is_ge", "interaction_monad.fail", "tactic.left", "tactic.mk_simp_attr", "expr.is_default_local", "tactic.assoc_refl", "tactic.interactive.have_field", "declaration.to_name", "tactic.head_zeta", "tactic.dsimp_hyp", "user_attribute.parse_reflect", "smt_tactic.swap", "smt_tactic.interactive.have", "tactic.mk_pattern", "expr.binding_domain", "tactic.match_subexpr", "tactic.mk_dec_eq_instance", "tactic.generalize_proofs", "tactic_format_expr", "pexpr", "tactic.mk_instance", "interactive.loc.try_apply", "user_attribute.dflt_parser", "to_additive.parser", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "local_context.mk_local", "tactic.result", "tactic.econstructor", "tactic.unsafe.type_context.whnf", "tactic.unsafe.type_context.list_mvars", "can_lift_attr", "tactic.add_inductive", "tactic.match_hypothesis", "tactic.terminal_goal", "expr.binding_body", "tactic.mk_local'", "tactic.interactive.clear'", "int.mk_numeral", "old_conv.apply_lemmas_core", "expr.subst", "tactic.back_lemmas_add_extra", "simps_add_projection", "expr.binding_name", "expr.decidable_rel", "tactic.unsafe.type_context.fold_mvars", "tactic.exact", "tactic.mk_mvar_list", "expr.instantiate_locals", "tactic.interactive.unfold_projs", "expr.is_heq", "local_decl", "old_conv.orelse", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "localized_cmd", "expr.get_app_fn_args_aux", "tactic.mk_eq_simp_ext", "tactic.mk_local_pisn", "tactic.choose1", "expr.has_local_in", "tactic.assertv_core", "old_conv.to_tactic", "conv.update_lhs", "old_conv.conversion", "tactic.extract_def", "tactic.delta_target", "tactic.whnf", "expr.mfoldl", "conv.interactive.guard_lhs", "expr.occurs", "tactic.norm_num", "simps_tac", "tactic.rewrite", "expr.instantiate_var", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "tactic.try_apply_opt_auto_param_for_apply", "tactic.back_lemmas_insert_core", "tactic.constr_to_prop", "tactic.local_proof", "declaration.value_task", "smt_tactic.pose", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "simp_lemmas.add", "expr.imp", "expr.get_app_fn", "push_neg.whnf_reducible", "tactic.solve_aux", "smt_tactic.add_ematch_lemma_core", "expr.extract_opt_auto_param", "mk_int_val_ne_proof", "expr.traverse", "expr.lambdas", "tactic.dsimplify_core", "tactic.ext_simplify_core", "tactic.try_for", "environment.unfold_untrusted_macros", "expr.replace", "expr.has_meta_var", "tactic.suggest.message", "tactic.propositional_goal", "tactic.choose", "expr.is_constant_of", "tactic.match_eq", "tactic.success_if_fail", "tactic.match_expr", "mk_expr_set", "expr.is_eta_expansion_of", "cc_state.refutation_for", "tactic.get_goal", "expr.is_eq", "tactic.resolve_constant", "tactic.interactive.set", "tactic.subst_core", "expr.has_to_format", "mk_nat_val_ne_proof", "declaration.update_value_task", "well_founded_tactics.default", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.congr_core'", "tactic.interactive.change'", "expr.const_name", "tactic.returnopt", "tactic.assoc_root", "old_conv.trace_lhs", "cc_state.pp_eqc", "tactic.mk_congr_lemma_simp", "tactic.match_assoc_pattern'", "reflected.has_to_format", "tactic.intros_dep", "tactic.instance_stub", "tactic.mk_specialized_congr_lemma", "expr.get_app_fn_args", "cc_state.is_cg_root", "where.get_includes_core", "tactic.interactive.type_check", "lean.parser.get_includes", "environment.is_refl_app", "where.trace_includes", "smt_tactic.proof_for", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.find_if_cond", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.iff_mp_core", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.rintro", "tactic.instance_cache", "conv.funext", "tactic.suggest.match_head_symbol", "old_conv.match_pattern", "tactic.change_with_at", "where.strip_pi_binders", "expr.get_pis", "tactic.match_target_subexpr", "tactic.constructor_idx", "tactic.constructor_num_fields", "mk_fin_val_ne_proof", "tactic.clear_aux_decl", "declaration.is_definition", "tactic.intro1", "mk_hinst_lemma_attr_from_simp_attr", "old_conv.funext", "tactic.interactive.refine_struct", "tactic.simp_arg_type.has_reflect", "tactic.interactive.elide", "cc_state.eqc_size", "tactic.interactive.rec.to_tactic_format", "tactic.is_type_app_of", "user_attribute.dflt_cache_cfg", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "smt_tactic.add_ematch_lhs_lemma", "tactic.interactive.unfold_aux", "tactic.interactive.guard_hyp_nums", "tactic.lift", "simps_add_projections", "expr.mk_delayed_abstraction", "tactic.abstract", "tactic.unsafe.type_context.mk_mvar", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.whnf_no_delta", "tactic.interactive.try_for", "tactic.ematch_all_core", "conv.dsimp", "tactic.assert_core", "tactic.interactive.simp_core_aux", "tactic.rcases_hint_core", "tactic.right", "nat.mk_numeral", "tactic.frozen_local_instances", "tactic.fail_if_success", "tactic.def_replacer_cmd", "tactic.mk_patterns", "expr.to_string", "cc_state.eqc_of", "tactic.generalizes", "tactic.mk_replacer\u2082", "conv.interactive.trace_lhs", "smt_tactic.focus1", "tactic.alias.get_lambda_body", "tactic.interactive.injection", "expr.is_gt", "conv.whnf", "expr.is_false", "expr.is_pi", "expr.mk_sorry", "tactic.interactive.exact", "doc_blame_report_defn", "smt_tactic.get_facts", "environment.intro_rule", "tactic.fapply", "tactic.assert", "tactic.apply_at_aux", "tactic.unsafe.type_context.assign", "tactic.rewrite_hyp", "declaration.to_definition", "local_context.to_list", "cc_state.eqc_of_core", "tactic.match_heq", "declaration.update_name", "to_additive.map_namespace", "smt_tactic.ematch", "expr.is_mvar", "tactic.explode.may_be_proof", "expr.lower_vars", "tactic.case_bash", "tactic.elim_gen_prod", "tactic.by_cases", "smt_tactic.to_expr", "tactic.add_theorem_by", "tactic.mk_app", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "expr.pos", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "where.resolve_vars", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "cc_state.root", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "smt_tactic.interactive.let", "expr.reduce_let", "well_founded_tactics.cancel_nat_add_lt", "interaction_monad.mk_exception", "expr.erase_annotations", "tactic.unsafe.type_context.get_assignment", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "tactic.mk_theorem", "old_conv.interactive.find", "declaration.instantiate_value_univ_params", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.ac_refl", "tactic.get_pi_binders_aux", "where.find_var", "tactic.set_main_tag", "tactic.to_expr_strict", "tactic.apply_heq_congr_core", "expr.is_lambda", "mk_nat_val_lt_proof", "old_conv.lhs", "tactic.unsafe.type_context.is_stuck", "smt_tactic.all_goals", "expr.mk_app", "tactic.match_not", "conv.interactive.change", "expr.instantiate_univ_params", "expr.mk_true", "tactic.unsafe.type_context.is_declared", "tactic.enum_assoc_subexpr", "reflected.has_to_pexpr", "well_founded_tactics.is_psigma_mk", "expr.list_meta_vars", "smt_tactic.define", "find_cmd", "declaration.map_value", "tactic.interactive.substs", "tactic.var_names", "tactic.mk_local_pis_whnf", "declaration.update_value", "rsimp.explicit_size", "tactic.assoc_refl'", "smt_tactic.slift_aux", "tactic.explode.entries.find", "tactic.any_hyp", "control_laws_tac", "expr.mk_var", "tactic.decl_mk_const", "smt_tactic.add_ematch_lemma", "check_unused_arguments_aux", "tactic.interactive.collect_struct'", "tactic.rcases_hint.continue", "tactic.back_chaining", "tactic.apply_under_pis", "smt_tactic.get_refuted_facts", "expr.is_var", "tactic.mk_local_pis", "tactic.match_ne", "rsimp.rsimplify_at", "declaration.is_axiom", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.interactive.compact_decl_aux", "tactic.dunfold_target", "smt_tactic.assertv", "tactic.introv", "vm.stack_obj_info", "expr.lift_vars", "tactic.suggest.apply_and_solve", "tactic.definev_core", "tactic.mk_local", "tactic.mk_mvar", "expr.is_or", "tactic.fill_args", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "tactic.eval_expr", "expr.replace_with", "declaration.value", "tactic.local_def_value", "tactic.comp_val", "expr.instantiate_lambdas_or_apps", "tactic.interactive.loc.get_local_uniq_names", "cc_state.roots_core", "old_conv.congr_core", "tactic.unsafe.type_context.print_mvars", "tactic.interactive.obtain", "expr.size", "tactic.unsafe.type_context.unify", "expr.is_eta_expansion_aux", "expr.is_num_eq", "tactic.fold_explicit_args", "tactic.alias.mk_iff_mp_app", "expr.of_int", "tactic.simplify_bottom_up", "reflected", "tactic.interactive.guard_hyp", "tactic.is_class", "tactic.match_target", "tactic.ematch_core", "tactic.get_spec_subsingleton_info", "expr.copy_pos_info", "tactic.apply", "tactic.contradiction", "tactic.get_main_tag", "old_conv.apply_propext_lemmas_core", "expr.mfold", "expr.reflect", "tactic.instantiate_mvars", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "is_valid_simp_lemma", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "declaration.is_constant", "tactic.unsafe.type_context.is_regular_mvar", "expr.pi_arity", "tactic.interactive.transitivity", "tactic.split_ifs", "expr.app_fn", "tactic.match_and", "tactic.unsafe.type_context.infer", "interactive.loc.get_locals", "tactic.define_core", "tactic.interactive.eapply", "conv.interactive.find", "expr.mk_and_lst", "tactic.interactive.to_expr'", "get_ext_subject", "rsimp.to_repr_map", "smt_tactic.note", "tactic.alias.alias_direct", "tactic.interactive.unelide", "expr.has_to_tactic_format", "expr.is_le", "tactic.interactive.show", "tactic.ematch_all", "tactic.relation_lhs_rhs", "tactic.head_beta", "tactic.dunfold_hyp", "tactic.apply_congr_core", "expr.is_let", "where.get_variables_core", "tactic.no_mvars_in_target", "tactic.unsafe.type_context.to_tmp_mvars", "tactic.iff_mpr", "simp_lemmas.rewrites", "expr.to_pos_nat", "tactic.interactive.guard_target'", "interactive.inductive_decl", "tactic.explode_expr", "tactic.unfold_projs", "tactic.head_eta", "cc_state.in_singlenton_eqc", "tactic.iff_mpr_core", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "tactic.define", "user_attribute.set", "tactic.mk_specialized_congr_lemma_simp", "tactic.unsafe.type_context.is_tmp_mvar", "expr.has_coe", "tactic.goals", "tactic.by_contradiction", "expr.has_local_constant", "tactic.interactive.replace", "reflected_value.expr", "tactic.interactive.subst", "tactic.get_arity", "tactic.intros", "expr.app_of_list", "tactic.rcases.continue", "tactic.find_ancestors", "tactic.interactive.clear_", "expr.get_app_args", "tactic.interactive.return_cast", "cc_state.mfold_eqc", "conv.replace_lhs", "tactic.match_iff", "expr.has_to_pexpr", "tactic.destruct", "rsimp.repr_map", "where.resolve_var", "tactic.constructor", "smt_tactic.assert", "tactic.match_refl_app", "tactic.head_eta_expand", "tactic.assertv", "tactic.revert_kdeps", "tactic.type_check", "tactic.get_pi_arity", "tactic.rcases", "expr.is_bin_arith_app", "tactic.fsplit", "cc_state.fold_eqc_core", "expr.get_weight", "tactic.enum_assoc_subexpr'", "expr.abstract_local", "tactic.assoc_rewrite", "expr.simp", "expr.is_numeral", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "expr.dsimp", "tactic.interactive.guard_expr_strict", "get_linters", "smt_tactic.get_goals", "tactic.subsingleton_goal", "tactic.revert", "tactic.mk_assoc", "expr.mk_false", "expr.is_aux_decl", "expr.has_var", "tactic.ematch", "tactic.interactive.intro", "tactic.injection_with", "expr.alpha_eqv", "tactic.set_tag", "tactic.induction", "expr.is_local_constant", "tactic.unfold_proj", "binder.inhabited", "tactic.unsafe.type_context.is_assigned", "tactic.lambdas", "get_attribute_cache_dyn", "tactic.fconstructor", "tactic.rename", "tactic.interactive.change", "tactic.collect_ctx_simps", "tactic.simp_bottom_up'", "expr.app_arg", "reflected.subst", "tactic.match_stub", "tactic.mk_constructor_fresh_names", "tactic.interactive.refine_recursively", "tactic.delta_hyp", "tactic.interactive.has_to_tactic_format", "tactic.i_to_expr_no_subgoals", "list_linters", "tactic.fold_explicit_args_aux", "tactic_state.format_expr", "tactic.interactive.list_cast_of", "tactic.interactive.simp_core", "tactic.any_hyp_aux", "tactic.unsafe.type_context.instantiate_mvars", "tactic.def_replacer", "tactic.injection", "tactic.is_def_eq", "lean.parser.reflectable.expr", "tactic.interactive.match_target", "tactic.mk_eq_mpr", "tactic.zeta", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "tactic.whnf_ginductive", "expr.has_lt", "tactic.back_chaining_using", "tactic.simp_hyp", "tactic.back_lemmas_insert", "expr.is_app", "tactic.repeat", "conv.change", "tactic.mk_eq_trans", "declaration.get_kind_string", "tactic.solve1", "tactic.unsafe.type_context.get_context", "tactic.cases_core", "tactic.get_tag", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.ext1", "tactic.mk_local_def", "tactic.interactive.mapply", "cc_state.is_not_eqv", "tactic.interactive.specialize", "tactic.get_assignment", "tactic.mk_meta_pis", "tactic.interactive.refine_one", "tactic.explode.entry", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "tactic.kabstract", "tactic.interactive.apply_with", "expr.to_binder", "old_conv.whnf", "tactic.pose", "tactic.match_pattern", "tactic.apply_core", "tactic.mk_congr", "vm_local_info", "expr.pis", "tactic.interactive.fapply", "tactic.swap", "expr.bind_lambda", "old_conv.find", "tactic.split", "tactic.instantiate_mvars_in_target", "tactic.solve_by_elim_aux", "tactic.interactive.guard_expr_eq", "tactic.dsimp_target", "cc_state.next", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "tactic.mk_meta_var", "expr.is_eta_expansion", "expr.drop_pis", "tactic.unfold_projs_target", "tactic.apply_rules", "tactic.simp_all", "tactic.rexact", "rsimp.rsimplify", "tactic.unsafe.type_context.tmp_get_assignment", "tactic.intro1_aux", "simp_lemmas.append", "expr.to_raw_fmt", "expr.has_coe_to_fun", "expr.is_constant", "conv.interactive.simp", "tactic.iff_mp", "tactic.interactive.guard_expr_eq'", "expr.is_not", "expr.ith_arg", "tactic.pattern", "tactic.alias.get_alias_target", "where.is_variable_name", "cc_state.proof_for_false", "lean.parser.reflect", "tactic.add_meta_definition", "list_items", "expr.get_nat_value", "tactic.dunfold", "tactic.assumption", "tactic.is_proof", "expr.to_implicit_local_const", "tactic.mk_assoc_instance", "tactic.infer_type", "tactic.chain_eq_trans", "expr.instantiate_local", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "tactic.replace_target", "smt_tactic.by_contradiction", "tactic.mk_replacer", "tactic.interactive.guard_target", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "tactic.intro_core", "tactic.trace_algebra_info", "tactic.suggest.replace_mvars", "expr.ith_arg_aux", "tactic.replacer_core", "instance_priority", "expr.expr.lt_prop", "tactic.clear", "tactic.interactive.dunfold", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "instance_derive_handler", "tactic.inhabited_instance", "expr.fold", "expr.abstract_locals", "tactic.get_local", "declaration.is_trusted", "declaration", "expr.is_app_of", "tactic.set_goals", "tactic.get_fun_info", "tactic.interactive.extract_goal", "expr.instantiate_lambdas", "tactic.unsafe.type_context.is_def_eq", "rsimp.is_value_like", "expr.instantiate_vars", "tactic.seq", "smt_tactic.induction", "tactic.interactive.have", "expr.is_macro", "old_conv.pure", "where.resolve_vars_aux", "tactic.definev", "tactic.interactive.field", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "tactic.add_defn_equations", "expr_map", "tactic.delta_instance", "mk_char_val_ne_proof", "tactic.mk_hcongr_lemma", "tactic.suggest.head_symbol", "tactic.interactive.clear_except", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "tactic.flatten", "expr.instantiate_nth_var", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "cc_state.internalize", "expr.pi_codomain", "environment.is_constructor_app", "tactic.applyc", "expr.list_constant", "smt_tactic.interactive.add_fact", "tactic.unify_prefix", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.triv", "tactic.interactive.destruct", "tactic.revert_lst", "old_conv.seq", "tactic.decidable_eq_derive_handler", "where.format_variable", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.mk_id_proof", "tactic.interactive.intros", "well_founded_tactics", "expr.is_internal_cnstr", "conv.congr", "expr.lt", "where.strip_pi_binders_aux", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "environment.add_defn_eqns", "tactic.explode.entries.add", "tactic.injections_and_clear", "saturate_fun", "expr.get_free_var_range", "smt_tactic.destruct", "tactic.interactive.choose", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "conv.rhs", "tactic.interactive.source_fields", "local_context.to_format", "local_context.fold", "expr.list_names_with_prefix", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "expr.binding_info", "declaration.update_type", "conv.convert", "local_context.get_local", "order_laws_tac", "tactic.simp_target", "expr.pi_binders", "expr.abstract", "tactic.split_if1", "has_reflect_derive_handler", "tactic.induction'", "tactic.any_goals", "where.compile_variable_list", "doc_blame_report_thm", "tactic.rcases_core", "tactic.mk_eq_proof", "expr.get_pi_app_fn", "tactic.rename'", "expr.has_local", "tactic.resolve_name'", "interactive.single_inductive_decl", "tactic.mk_replacer\u2081", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "tactic.mk_eq_symm", "tactic.has_to_tactic_format", "expr.lambda_body", "tactic.get_goals", "tactic.to_expr", "old_conv.fail", "expr.pi_binders_aux", "tactic.interactive.push_neg", "simp_lemmas.dsimplify", "expr.bind_pi", "smt_tactic.interactive.guard_expr_eq", "tactic.intros1", "derive_struct_ext_lemma", "expr.is_lt", "cc_state.is_eqv", "smt_tactic.refutation_for", "tactic.mk_instance_cache", "old_conv.map", "tactic.intro_lst", "tactic.reduce_ifs_at", "tactic.num_goals", "tactic.clear_aux_decl_aux", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "tactic.interactive.collect_struct", "expr.is_and", "expr.dedup_size_aux", "declaration.instantiate_type_univ_params", "has_inhabited_instance", "tactic.interactive.apply", "old_conv.lift_tactic", "dedup", "tactic.import_private_cmd", "tactic.interactive.delta", "tactic.metavariables", "simp_lemmas.drewrite", "mk_string_val_ne_proof", "tactic.success_if_fail_with_msg", "tactic.triv'", "tactic.valid_types", "old_conv.mk_match_expr", "tactic.congr_core", "tactic.unfold_projs_hyp", "hinst_lemma.mk_core", "tactic.unsafe.type_context.mk_tmp_mvar", "tactic.apply_opt_param", "tactic.i_to_expr", "expr.of_nat", "conv.discharge_eq_lhs", "vm_obj.to_expr", "tactic.add_aux_decl", "expr.lift", "cc_state.eqv_proof", "tactic.get_pi_binders_dep_aux", "rsimp.mk_repr_map", "cc_state.fold_eqc", "congr_lemma", "tactic.mk_sorry", "tactic.interactive.old_conv", "tactic.suggest.apply_declaration", "tactic.pexpr_to_pattern", "expr.lex_lt", "tactic.unsafe.type_context.push_local", "smt_tactic.preprocess", "user_attribute.get_param", "tactic.get_local_type", "tactic.perm_ac", "expr.contains_constant", "tactic.get_pi_binders_dep", "reflected.to_expr", "expr.local_uniq_name", "tactic.interactive.compact_decl", "well_founded_tactics.check_target_is_value_lt", "expr.to_implicit_binder", "tactic.get_spec_prefix_size", "tactic.eapply", "declaration.univ_params", "tactic.apply_at", "expr.get_app_num_args", "tactic.note_anon", "tactic.match_fn", "tactic.mk_congr_lemma", "expr.collect_univ_params", "tactic.get_expl_pi_arity", "old_conv.match_expr", "tactic.generalize"]}, {"id": "environment", "parentIds": ["tactic.unsafe.type_context.get_env", "environment.is_prefix_of_file", "tactic.mk_const", "environment.add_ginductive", "tactic.delta", "print_content", "environment.mfold", "environment.is_projection", "tactic.mk_has_sizeof_instance_core", "tactic.get_constructors_for", "tactic.get_env", "transport_multiplicative_to_additive", "restate_axiom", "environment.for_decl_of_imported_module", "environment.fold", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "tactic.interactive.induction", "environment.inductive_dep_elim", "environment.unfold_all_macros", "tactic.symmetry_hyp", "environment.is_definition", "to_additive.proceed_fields", "environment.add_inductive", "environment.is_namespace", "environment.is_inductive", "tactic.mk_dec_eq_instance", "tactic_state.env", "tactic.add_inductive", "environment.from_imported_module_name", "localized_cmd", "simps_tac", "tactic.constr_to_prop", "environment.add_namespace", "environment.import_only", "environment.inductive_num_params", "environment.unfold_untrusted_macros", "environment.has_repr", "lean.parser.set_env", "environment.decl_filter_map", "lint", "environment.inductive_num_indices", "environment.in_current_file", "tactic.instance_stub", "environment.relation_info", "tactic.in_open_namespaces", "environment.is_refl_app", "tactic.updateex_env", "tactic.mk_iff_of_inductive_prop", "tactic.constructor_num_fields", "environment.trans_for", "simps_add_projections", "environment.import_dependencies", "copy_decl_updating_type", "tactic.mk_patterns", "print_all_content", "declaration.in_current_file", "tactic.mk_inhabited_instance", "tactic.subobject_names", "tactic.get_unused_decl_name_aux", "environment.is_ginductive", "tactic.mk_dec_eq_instance_core", "tactic.mk_constructors_arg_names", "environment.structure_fields_full", "environment.recursor_of", "find_cmd", "environment.fingerprint", "tactic.list_constructors_hole", "environment.get_decl_names", "environment.decl_olean", "environment.decl_pos", "environment.contains", "tactic.mk_has_reflect_instance", "tactic.set_env_core", "environment.get_trusted_decls", "environment.is_ginductive'", "print_item_crawl", "tactic.alias.alias_direct", "tactic.relation_lhs_rhs", "copy_decl_using", "environment.get", "environment.refl_for", "environment.is_structure", "tactic.match_refl_app", "tactic.set_env", "environment.is_recursor", "tactic.injection_with", "environment.get_class_attribute_symbols", "list_linters", "declaration.is_auto_generated", "environment.structure_fields", "lean.parser_state.env", "environment.constructors_of", "vm.get_env", "tactic.alias.alias_iff", "tactic.prove_goal_async", "environment.for_decl_of_imported_module_name", "environment.add", "fold_over_with_cond_sorted", "expr.is_eta_expansion", "environment.trust_lvl", "environment.inhabited", "tactic.new_aux_decl_name", "environment.in_current_file'", "tactic.mk_constructors_fresh_names", "environment.get_decls", "instance_derive_handler", "environment.inductive_type_of", "tactic.get_mathlib_dir", "environment.mfilter", "tactic.is_prop_decl", "tactic.add_defn_equations", "tactic.local_decls", "tactic.delta_instance", "environment.import_only_until_decl", "environment.is_constructor_app", "environment.from_imported_module", "environment.is_constructor", "vm_obj.to_environment", "environment.mk_std", "tactic.interactive.case", "environment.add_defn_eqns", "environment.import'", "where.get_all_in_namespace", "environment.import_until_decl", "tactic.find_private_decl", "environment.get_modifiers", "tactic.suggest.library_defs", "environment.symm_for", "derive_struct_ext_lemma", "environment.decl_map", "lint_mathlib", "lint_all", "tactic.ids_to_simp_arg_list", "environment.is_recursive", "print_name", "tactic.module_doc_strings"]}, {"id": "is_cond_left_inv", "parentIds": []}, {"id": "out_param", "parentIds": ["is_cond_left_inv", "ne_of_mem_of_not_mem", "has_andthen", "is_cond_right_inv", "monoid_to_is_left_id", "is_symm_op", "monad_reader", "monad_reader_adapter", "add_monoid_to_is_right_id", "option_t.monad_run", "is_right_id", "reader_t.monad_except", "has_sep", "is_left_null", "monad_state", "state_t.monad_except", "monad_state_adapter", "add_monoid_to_is_left_id", "is_left_id", "has_insert", "is_left_inv", "is_right_inv", "monad_except", "except_t.monad_run", "except_t.monad_except", "state_t.monad_run", "monad_except_adapter", "is_right_null", "monoid_to_is_right_id", "is_right_distrib", "is_left_distrib", "reader_t.monad_run", "has_mem", "monad_run"]}, {"id": "unsigned_sz", "parentIds": ["unsigned.has_mod", "unsigned.has_le", "unsigned", "unsigned.decidable_eq", "unsigned.has_lt", "unsigned.has_to_string", "localized_cmd", "unsigned.has_mul", "string.hash", "unsigned.has_repr", "unsigned.to_nat", "unsigned.of_nat'", "unsigned.has_div", "unsigned.has_add", "unsigned.reflect", "unsigned.has_sub"]}, {"id": "has_one", "parentIds": ["unsigned_sz", "int.lt_of_le_sub_one", "int.add_one_le_of_lt", "int.decidable_lt", "int.neg_succ_of_nat_coe'", "comm_semiring", "char.val_of_nat_eq_of_is_valid", "lt_of_one_div_lt_one_div", "nat.zero_ne_one_class", "tactic.library_search_hole_cmd", "list.prod", "int.lt_of_add_one_le", "div_zero", "parser.sat", "one_add_one_eq_two", "is_valid_char_range_1", "div_le_div_of_le_of_pos", "nat.eq_zero_or_eq_succ_pred", "simp.default_max_steps", "nat.div_eq_of_lt", "norm_num.bit0_add_bit1", "nat.one_ne_zero", "fin.has_one", "tactic.interactive.rsimp", "one_div_pos_of_pos", "mul_self_sub_one_eq", "discrete_field", "nat.shiftl_eq_mul_pow", "div_sub_div", "tactic.injections_with", "int.le_of_lt_add_one", "nat.one_lt_bit0", "div_pos_of_neg_of_neg", "two_mul", "nat.add_one_ne_zero", "eq_inv_iff_mul_eq_one", "list.length_cons", "div_lt_of_mul_lt_of_pos", "nat.mul_one", "nat.succ_eq_add_one", "tactic.existsi", "unused_arguments", "array.push_back_idx", "unsigned.has_zero", "sigma.has_to_format", "linear_ordered_semiring", "monoid_to_is_left_id", "norm_num.add1_bit1", "mk_definition", "mul_right_eq_self", "print_arguments", "add_midpoint", "norm_num.bit1_add_one_helper", "is_valid_char_range_2", "mul_inv_rev", "norm_num.bit1_add_one", "zero_le_one", "mul_inv_eq", "decidable_linear_ordered_semiring", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "nat.div_def", "norm_num.mul_bit1_helper", "two_ne_zero", "eq_zero_of_mul_eq_self_right", "sum_has_to_format", "using_smt", "unsigned.of_nat", "environment.for_decl_of_imported_module", "smt_pre_config.inhabited", "nat.bodd_add_div2", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "nat.succ_mul_succ_eq", "tactic.get_unused_decl_name", "abs_one_div", "mul_eq_one_iff_inv_eq", "one_inv", "norm_num.mul_one", "parser.foldl", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "nat.zero_lt_one", "tactic.interactive.induction", "rbtree.default_lt", "tactic.interactive.solve_by_elim", "list.length_append", "lt_div_of_mul_lt", "nat.bit0_val", "string.iterator.length_next_to_string_next", "comm_group", "nat.pow_lt_pow_of_lt_right", "int.zero_ne_one_class", "one_div_mul_one_div'", "name_set.has_to_format", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "one_div_eq_inv", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_div_eq_div_mul", "tactic.elim_gen_sum", "nat.zero_lt_one_add", "native.rb_map.has_to_tactic_format", "native.float.has_one", "inv_ne_zero", "mul_one", "tactic.interactive.rotate", "to_additive.guess_name", "int.one_pos", "nat.le_mul_self", "integral_domain", "std.priority.default", "nat.shiftr_eq_div_pow", "semiring", "one_div_mul_one_div", "nat.mod_one", "char.val_of_nat_eq_of_not_is_valid", "one_div_lt_neg_one", "tactic.mk_dec_eq_instance", "div_two_sub_self", "one_lt_div_of_lt", "char.is_whitespace", "int.lt_succ", "int.sub_nat_nat_elim", "int.mk_numeral", "nat.mod_two_of_bodd", "one_dvd", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "one_mul", "int.lt_add_succ", "norm_num.add1_zero", "int.sign_one", "localized_cmd", "nat.repr", "old_conv.conversion", "tactic.extract_def", "nat.add_self_ne_one", "one_div_zero", "div_mul_cancel", "list.length_map", "char.to_lower", "parser.mk_error_msg", "le_div_of_mul_le", "interactive.types.tac_rbp", "native.has_to_format", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "int.sign_eq_neg_one_iff_neg", "nat.bit0_inj", "parser.foldr", "nat.bodd_one", "div_self", "nat.zero_shiftr", "nat.add_comm", "tactic.interactive.convert_to_core", "norm_num.bit1_add_bit0_helper", "le_mul_of_ge_one_right", "string.hash", "mul_zero_lt_mul_inv_of_pos", "rsimp.config.inhabited", "int.mul_one", "nat.one_le_bit0", "one_div_lt_one_div_of_lt_of_neg", "char.of_nat", "div_helper", "mul_self_iff_eq_one", "div_mul_le_div_mul_of_div_le_div_pos", "char.is_lower", "nat.shiftl'_sub", "nat.one_shiftl", "two_gt_one", "nat.one_le_bit1", "add_mul_self_eq", "lt_of_one_div_lt_one_div_of_neg", "ring", "int.coe_nat_lt_coe_nat_iff", "div_mul_left", "environment.is_refl_app", "int.sub_nat_nat_eq_coe", "tactic.has_opt_auto_param", "functor.const.applicative", "division_ring", "tactic.constructor_idx", "linear_ordered_comm_ring", "tactic.unprime", "division_ring.one_div_one_div", "tactic.lift", "one_div_one", "int.bit1_pos", "mul_eq_one_iff_eq_inv", "nat.coprime", "nat.mk_numeral", "string.iterator.zero_lt_length_next_to_string_of_has_next", "array.pop_back_idx", "int.coe_nat_add_one_out", "inv_ne_one", "mul_one_div_cancel", "norm_num.bit0_add_bit1_helper", "mul_left_eq_self", "int.eq_one_of_mul_eq_self_left", "int.sign_eq_one_iff_pos", "ordered_semiring", "buffer.lt_aux_2", "std.prec.arrow", "lt_of_one_lt_div", "char.decidable_is_digit", "nat.one_ne_bit1", "char.is_punctuation", "tactic.rcases_parse_depth", "le_of_one_div_le_one_div_of_neg", "int.zero_lt_one", "nat.digit_char", "std.prec.max", "monoid.to_has_one", "tactic.decorate_ex", "char.decidable_is_punctuation", "discrete_linear_ordered_field", "tactic.has_opt_auto_param_for_apply", "nat.bit_decomp", "well_founded_tactics.cancel_nat_add_lt", "int.one_nonneg", "nat.gcd_one_left", "mul_inv_cancel_left", "int.le_sub_one_of_lt", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "comm_ring", "tactic.mk_constructors_arg_names", "int.one_mul", "list.length_take", "linear_ordered_ring", "int.has_one", "name.deinternalize_field", "tactic.mllist.range", "ne_zero_of_one_div_ne_zero", "std.prec.max_plus", "one_div_ne_zero", "d_array.of_beq_aux_eq_ff", "char.decidable_is_upper", "mul_right_inv", "field.div_mul_left", "le_of_one_div_le_one_div", "field.div_mul_eq_mul_div_comm", "nat.eq_one_of_dvd_one", "tactic.suggest.apply_and_solve", "mul_inv_self", "le_of_mul_le_of_ge_one", "nat.case_strong_induction_on", "int.coe_nat_one", "one_inv_eq", "norm_num.one_add_bit1", "tactic.comp_val", "comm_monoid", "char.is_upper", "native.rb_set.has_to_format", "inv_mul_cancel_left", "nat.sub_one_sub_lt", "div_mul_le_div_mul_of_div_le_div_pos'", "norm_num.add1_bit1_helper", "int.sign_neg_one", "expr.of_int", "group", "mul_inv_cancel", "check_unused_arguments", "div_lt_div_of_lt_of_neg", "buffer.lt_aux_3", "int.eq_succ_of_zero_lt", "tactic.interactive.generalize", "division_ring.one_div_div", "one_div_mul_cancel", "int.one", "neg_eq_neg_one_mul", "unsigned.has_one", "smt_tactic.execute", "lt_mul_of_gt_one_right", "nat.add_div_right", "div_nonpos_of_nonpos_of_pos", "list.length_tail", "inv_eq_one", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_mul_one_div", "nat.div_lt_self", "div_mul_right", "prod.has_to_format", "zero_ne_one_class", "tactic.interactive.ext", "nat.div2_val", "nat.one_add", "nat.bit1_val", "char.inhabited", "add_self_div_two", "tactic.solve_by_elim", "div_lt_div_of_lt_of_pos", "int.coe_nat_succ", "norm_num.bit1_add_bit0", "lean.is_release", "rsimp.collect_implied_eqs", "one_div_neg_one_eq_neg_one", "one_div_neg_eq_neg_one_div", "int.nat_abs_bit1_nonneg", "option.has_to_format", "tactic.explode.pad_right", "div_mul_eq_div_mul_one_div", "nat.one_succ_zero", "smt_config.inhabited", "tactic.interactive.replace", "functor.const.is_lawful_applicative", "nat.one_pos", "nat.bit0_ne_one", "tactic.interactive.clear_", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "zero_gt_neg_one", "nat.has_one", "nat.div_le_self", "bit1_zero", "nat.bodd_bit", "one_div_lt_one_div_of_lt", "nat.sub_mul_div", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "int.neg_succ_of_nat_coe", "expr.is_bin_arith_app", "char.is_digit", "int.neg_succ_of_nat_eq", "division_ring.mul_ne_zero", "nat.shiftl_succ", "rsimp.choose", "list.to_format", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "tactic.iterate", "mul_inv_eq_one", "int.lt_of_sub_one_le", "tactic.injection_with", "tactic.interactive.convert_to", "nat.test_bit_succ", "char.decidable_is_lower", "nat.one_ne_bit0", "char_to_hex", "int.pos_of_sign_eq_one", "tactic.rename", "nat.zero_ne_one", "nat.div2_bit", "nat.prio", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "one_div_div", "nat.le_of_sub_eq_zero", "where.binder_priority", "nat.succ_ne_self", "nat.add_one", "int.neg_of_sign_eq_neg_one", "smt_tactic.iterate", "div_eq_one_iff_eq", "mul_div_mul_left", "monoid", "array.pop_back", "norm_num.bit1_add_bit1", "inv_mul_self", "nat.bit_val", "nat.div_eq_sub_div", "std.priority.max", "norm_num.one_add_one", "dvd_refl", "nat.zero_div", "parser.fix", "one_ne_zero", "conv.interactive.for", "div_lt_div_of_pos_of_lt_of_pos", "int.sub_one_le_of_lt", "nat.mod_add_div", "tactic.back_chaining_core", "field", "one_div_one_div", "tactic.interactive.swap", "char.decidable_is_whitespace", "sub_self_div_two", "mul_inv_eq_of_eq_mul", "nat.two_step_induction", "is_valid_char", "two_ge_one", "two_pos", "eq_zero_of_mul_eq_self_left", "char.quote_core", "where.trace_where", "div_one", "int.nat_abs_one", "inv_eq_of_mul_eq_one", "one_div_le_one_div_of_le", "int.to_nat_sub", "int.of_nat_one", "eq_inv_of_mul_eq_one", "tactic.new_aux_decl_name", "tactic.rsimp", "add_halves", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "expr.ith_arg", "mul_div_cancel", "eq_of_div_eq_one", "array.push_back", "inv_mul_cancel", "tactic.alias.get_alias_target", "div_nonneg_of_nonneg_of_pos", "nat.zero_shiftl", "list.length_map\u2082", "int.sign_of_succ", "char.zero_lt_d800", "division_ring.eq_of_one_div_eq_one_div", "decidable_linear_ordered_comm_ring", "division_ring.inv_inv", "nat.div_self", "neg_div", "int.eq_one_of_mul_eq_self_right", "tactic.rsimp_at", "eq_of_one_div_eq_one_div", "norm_num.bit1_add_bit1_helper", "nat.bit1_ne_one", "instance_priority", "int.lt_add_one_of_le", "int.of_nat_succ", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "ematch_config.inhabited", "nat.pow_zero", "tactic.inhabited_instance", "int.sign_eq_neg_one_of_neg", "nat.le_of_dvd", "mul_left_inv", "eq_one_div_of_mul_eq_one_left", "tactic.interactive.extract_goal", "lean.version", "tactic.get_mathlib_dir", "eq_one_div_of_mul_eq_one", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "int.lt.dest", "one_div_add_one_div", "tactic.interactive.field", "zero_ne_one", "nat.sub_lt", "one_div_le_one_div_of_le_of_neg", "norm_num.one_add_bit1_helper", "nat.div2_two", "monoid_to_is_right_id", "tactic.mk_inj_eq", "neg_of_one_div_neg", "bit1", "norm_num.mul_bit1", "environment.from_imported_module", "mul_mul_div", "tactic.interactive.apply_rules", "int.sign_eq_one_of_pos", "nat.sub_one", "tactic.alias.make_left_right", "linear_ordered_field", "norm_num.add1_one", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "int.lt_iff_add_one_le", "tactic.interactive.case", "mul_inv_cancel_right", "nat.one_mul", "zero_lt_one", "nat.succ_sub_one", "saturate_fun", "div_le_of_le_mul", "nat.bit0_ne_zero", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "eq_zero_of_one_div_eq_zero", "inv_eq_iff_mul_eq_one", "nat.le_div_iff_mul_le", "norm_num.bit0_add_one", "division_ring.one_div_mul_one_div", "le_of_one_le_div", "list.length_repeat", "list.length_remove_nth", "tactic.interactive.suggest", "div_neg_of_neg_of_pos", "ordered_ring", "mul_self_eq_one_iff", "tactic.interactive.push_neg", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "four_pos", "format.dcbrace", "div_two_lt_of_pos", "tactic.exact_dec_trivial", "inv_eq_one_div", "division_ring.one_div_neg_eq_neg_one_div", "int.zero_ne_one", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "function.involutive_iff_iter_2_eq_id", "int.lt", "smt_tactic.interactive.executor", "one_lt_one_div", "nat.find_x", "dup_namespace", "norm_num.add1_bit0", "nat.div2_one", "nat.div_one", "name.pop_prefix", "group.mul_right_cancel", "one_div_le_neg_one", "inv_mul_cancel_right", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "norm_num.add1", "zero_ne_one_class.to_has_one", "nat.bodd_two"]}, {"id": "nat.has_add", "parentIds": ["unsigned_sz", "nat.eq_zero_of_add_eq_zero", "char.val_of_nat_eq_of_is_valid", "tactic.library_search_hole_cmd", "nat.lt_add_left", "parser.sat", "int.add_comm", "is_valid_char_range_1", "simp.default_max_steps", "nat.div_eq_of_lt", "tactic.interactive.rsimp", "nat.add_right_cancel", "nat.shiftl_eq_mul_pow", "nat.shiftl'_add", "nat.add_mul_mod_self_right", "tactic.injections_with", "int.nat_abs_bit1_nonneg_step", "nat.one_lt_bit0", "nat.add_one_ne_zero", "list.length_cons", "nat.succ_eq_add_one", "nat.eq_zero_of_add_eq_zero_left", "tactic.existsi", "nat.succ_sub_sub_succ", "unused_arguments", "array.push_back_idx", "unsigned.has_zero", "print_arguments", "int.add_assoc", "int.le_of_coe_nat_le_coe_nat", "is_valid_char_range_2", "nat.le_add_left", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "nat.div_def", "nat.sub_eq_zero_of_le", "nat_add_zero", "sum_has_to_format", "using_smt", "unsigned.of_nat", "environment.for_decl_of_imported_module", "nat.sub_sub_self", "smt_pre_config.inhabited", "nat.add_div_left", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "tactic.get_unused_decl_name", "nat.add_mul_div_right", "nat.bodd_add", "parser.foldl", "nat.add_le_add_iff_le_right", "rbtree.default_lt", "tactic.interactive.solve_by_elim", "list.length_append", "nat.bit0_val", "string.iterator.length_next_to_string_next", "tactic.elim_gen_sum", "nat.zero_lt_one_add", "nat.add_right_comm", "nat.bit1_lt", "to_additive.guess_name", "nat.le_mul_self", "nat.lt_add_of_pos_left", "std.priority.default", "nat.mul_div_right", "nat.shiftr_eq_div_pow", "char.val_of_nat_eq_of_not_is_valid", "tactic.mk_dec_eq_instance", "char.is_whitespace", "int.nat_abs_add_neg", "int.sub_nat_nat_elim", "int.mk_numeral", "nat.mod_two_of_bodd", "localized_cmd", "nat.add_mul_div_left", "int.nat_abs_add_nonneg", "nat.repr", "old_conv.conversion", "nat.add_self_ne_one", "nat.sub_eq_iff_eq_add", "list.length_map", "char.to_lower", "parser.mk_error_msg", "interactive.types.tac_rbp", "nat.sub_mul_mod", "nat.div_def_aux", "nat.mul_assoc", "nat.zero_mul", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "parser.foldr", "nat.zero_shiftr", "nat.add_comm", "tactic.interactive.convert_to_core", "string.hash", "rsimp.config.inhabited", "nat.add_succ", "nat.bit", "nat.one_le_bit0", "char.of_nat", "int.nat_abs_bit0_step", "char.is_lower", "nat.shiftl'_sub", "nat.one_shiftl", "nat.one_le_bit1", "nat.mul_le_mul_left", "environment.is_refl_app", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "tactic.has_opt_auto_param", "nat.add_sub_cancel", "nat.div_le_of_le_mul", "nat.lt_add_of_pos_right", "tactic.unprime", "nat.sub_pos_of_lt", "nat.bodd_mul", "int.distrib_left", "tactic.lift", "nat.add_le_add_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.eq_zero_of_mul_eq_zero", "array.pop_back_idx", "nat.mul_div_cancel'", "int.le_antisymm", "nat.lt_add_of_zero_lt_left", "std.prec.arrow", "char.decidable_is_digit", "nat.one_ne_bit1", "nat.add_left_cancel", "char.is_punctuation", "tactic.rcases_parse_depth", "nat.digit_char", "std.prec.max", "tactic.decorate_ex", "char.decidable_is_punctuation", "tactic.has_opt_auto_param_for_apply", "nat.add_mod_right", "nat.add_sub_add_right", "nat.bit_decomp", "nat.le_of_add_le_add_right", "nat.add_sub_cancel_left", "well_founded_tactics.cancel_nat_add_lt", "nat.bit1_ne_bit0", "int.coe_nat_add", "nat.shiftr_add", "int.le_trans", "list.length_take", "fin.add_def", "nat.mul_pred_left", "name.deinternalize_field", "nat.zero_ne_bit1", "nat.dvd_add_iff_right", "tactic.mllist.range", "std.prec.max_plus", "nat.dvd_mod_iff", "nat.dvd_sub", "d_array.of_beq_aux_eq_ff", "char.decidable_is_upper", "int.nat_abs_bit0", "tactic.suggest.apply_and_solve", "nat.case_strong_induction_on", "nat.le.intro", "nat.sub_self_add", "char.is_upper", "nat.mul_lt_mul_of_pos_left", "nat.sub_one_sub_lt", "nat.succ_add", "expr.of_int", "nat.add_lt_add_right", "nat.le_add_right", "buffer.lt_aux_3", "int.mul_pos", "int.eq_succ_of_zero_lt", "nat.add_zero", "unsigned.has_one", "smt_tactic.execute", "nat.add_div_right", "add_succ_defeq_succ_add_hint", "nat.mul_mod_right", "nat.mul_succ", "nat.div2_val", "nat.one_add", "nat.bit1_val", "char.inhabited", "tactic.solve_by_elim", "nat.bit0_lt", "rsimp.collect_implied_eqs", "int.nat_abs_bit1_nonneg", "option.has_to_format", "tactic.explode.pad_right", "nat.le.dest", "smt_config.inhabited", "nat.bit0_succ_eq", "tactic.interactive.replace", "nat.bit0_ne_one", "tactic.interactive.clear_", "nat.sub_add_comm", "nat.succ_sub", "nat.bodd_bit", "nat.sub_mul_div", "nat.bit0_ne_bit1", "int.neg_succ_of_nat_coe", "expr.is_bin_arith_app", "nat.sub.right_comm", "nat.left_distrib", "char.is_digit", "nat.shiftl_succ", "int.coe_nat_le_coe_nat_of_le", "norm_num.sub_nat_pos_helper", "int.sign_mul_nat_abs", "tactic.iterate", "nat.add_mod_left", "nat.right_distrib", "tactic.interactive.convert_to", "nat.test_bit_succ", "nat.zero_lt_bit1", "char.decidable_is_lower", "nat.one_ne_bit0", "nat.bit1_inj", "char_to_hex", "int.pos_of_sign_eq_one", "nat.sub_sub", "nat.lt_of_add_lt_add_left", "nat.div2_bit", "nat.prio", "nat.bit0_lt_bit1", "nat.mul_sub_right_distrib", "nat.sub_add_min_cancel", "nat.add_le_add_left", "nat.le_of_sub_eq_zero", "where.binder_priority", "nat.succ_ne_self", "nat.add_one", "int.neg_of_sign_eq_neg_one", "nat.mul_self_sub_mul_self_eq", "smt_tactic.iterate", "array.pop_back", "nat.zero_ne_bit0", "buffer.lt_aux_1", "nat.bit_val", "nat.div_eq_sub_div", "std.priority.max", "nat.dvd_of_mod_eq_zero", "nat.zero_div", "parser.fix", "nat.bit1_eq_succ_bit0", "nat.shiftl_add", "conv.interactive.for", "nat.mod_add_div", "tactic.back_chaining_core", "tactic.interactive.swap", "char.decidable_is_whitespace", "is_valid_char", "char.quote_core", "where.trace_where", "int.to_nat_sub", "nat.bit1_ne_zero", "tactic.rsimp", "int.of_nat_add", "array.push_back", "tactic.alias.get_alias_target", "nat.zero_shiftl", "nat.succ_mul", "list.length_map\u2082", "nat.le_of_add_le_add_left", "char.zero_lt_d800", "nat.div_self", "tactic.rsimp_at", "nat.bit1_ne_one", "instance_priority", "ematch_config.inhabited", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "lean.version", "tactic.get_mathlib_dir", "nat.mod_two_eq_zero_or_one", "nat.mul_comm", "nat.sub_lt", "nat.add_mul_mod_self_left", "nat.div2_two", "tactic.mk_inj_eq", "nat.bit1_succ_eq", "nat.lt_add_right", "environment.from_imported_module", "tactic.interactive.apply_rules", "nat.bit1_ne", "nat.add_left_comm", "nat.mod_pow_succ", "tactic.alias.make_left_right", "nat.add_lt_add_left", "tactic.interactive.case", "nat.bit0_ne_zero", "nat.add_sub_of_le", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "nat.le_div_iff_mul_le", "list.length_repeat", "nat.add_le_to_le_sub", "list.length_remove_nth", "nat.zero_add", "tactic.interactive.suggest", "nat.bit0_ne", "nat.sub_add_cancel", "nat.dvd_add_iff_left", "nat.bit1_lt_bit0", "tactic.interactive.push_neg", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "tactic.exact_dec_trivial", "nat.cond_to_bool_mod_two", "function.involutive_iff_iter_2_eq_id", "smt_tactic.interactive.executor", "nat.zero_lt_bit0", "nat.find_x", "dup_namespace", "nat.div_one", "nat.add_assoc", "nat.add_sub_add_left", "nat.mul_div_cancel", "nat.eq_zero_of_add_eq_zero_right", "nat.bodd_two"]}, {"id": "nat.has_one", "parentIds": ["unsigned_sz", "char.val_of_nat_eq_of_is_valid", "nat.zero_ne_one_class", "tactic.library_search_hole_cmd", "parser.sat", "is_valid_char_range_1", "simp.default_max_steps", "nat.div_eq_of_lt", "nat.one_ne_zero", "fin.has_one", "tactic.interactive.rsimp", "nat.shiftl_eq_mul_pow", "tactic.injections_with", "int.nat_abs_bit1_nonneg_step", "nat.one_lt_bit0", "nat.add_one_ne_zero", "list.length_cons", "nat.mul_one", "nat.succ_eq_add_one", "tactic.existsi", "unused_arguments", "array.push_back_idx", "unsigned.has_zero", "sigma.has_to_format", "mk_definition", "print_arguments", "is_valid_char_range_2", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "nat.div_def", "sum_has_to_format", "using_smt", "unsigned.of_nat", "environment.for_decl_of_imported_module", "smt_pre_config.inhabited", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "tactic.get_unused_decl_name", "parser.foldl", "nat.zero_lt_one", "tactic.interactive.induction", "rbtree.default_lt", "tactic.interactive.solve_by_elim", "list.length_append", "nat.bit0_val", "string.iterator.length_next_to_string_next", "nat.pow_lt_pow_of_lt_right", "name_set.has_to_format", "tactic.elim_gen_sum", "nat.zero_lt_one_add", "native.rb_map.has_to_tactic_format", "nat.bit1_lt", "native.float.has_one", "tactic.interactive.rotate", "to_additive.guess_name", "nat.le_mul_self", "std.priority.default", "nat.shiftr_eq_div_pow", "nat.mod_one", "char.val_of_nat_eq_of_not_is_valid", "tactic.mk_dec_eq_instance", "char.is_whitespace", "int.sub_nat_nat_elim", "int.mk_numeral", "nat.mod_two_of_bodd", "localized_cmd", "nat.repr", "old_conv.conversion", "tactic.extract_def", "nat.add_self_ne_one", "list.length_map", "char.to_lower", "parser.mk_error_msg", "interactive.types.tac_rbp", "native.has_to_format", "nat.div_def_aux", "nat.bit0_inj", "parser.foldr", "nat.bodd_one", "nat.zero_shiftr", "nat.add_comm", "tactic.interactive.convert_to_core", "string.hash", "rsimp.config.inhabited", "nat.bit", "int.mul_one", "nat.one_le_bit0", "char.of_nat", "char.is_lower", "nat.shiftl'_sub", "nat.one_shiftl", "nat.one_le_bit1", "environment.is_refl_app", "int.sub_nat_nat_eq_coe", "tactic.has_opt_auto_param", "tactic.constructor_idx", "tactic.unprime", "tactic.lift", "nat.coprime", "string.iterator.zero_lt_length_next_to_string_of_has_next", "array.pop_back_idx", "buffer.lt_aux_2", "std.prec.arrow", "char.decidable_is_digit", "nat.one_ne_bit1", "char.is_punctuation", "tactic.rcases_parse_depth", "nat.digit_char", "std.prec.max", "tactic.decorate_ex", "char.decidable_is_punctuation", "tactic.has_opt_auto_param_for_apply", "nat.bit_decomp", "well_founded_tactics.cancel_nat_add_lt", "nat.bit1_ne_bit0", "nat.gcd_one_left", "tactic.mk_constructors_arg_names", "list.length_take", "name.deinternalize_field", "nat.zero_ne_bit1", "tactic.mllist.range", "std.prec.max_plus", "d_array.of_beq_aux_eq_ff", "char.decidable_is_upper", "nat.eq_one_of_dvd_one", "tactic.suggest.apply_and_solve", "nat.case_strong_induction_on", "int.coe_nat_one", "tactic.comp_val", "char.is_upper", "native.rb_set.has_to_format", "nat.sub_one_sub_lt", "expr.of_int", "check_unused_arguments", "buffer.lt_aux_3", "int.eq_succ_of_zero_lt", "tactic.interactive.generalize", "int.one", "unsigned.has_one", "smt_tactic.execute", "nat.add_div_right", "list.length_tail", "nat.div_lt_self", "prod.has_to_format", "tactic.interactive.ext", "nat.div2_val", "nat.one_add", "nat.bit1_val", "char.inhabited", "tactic.solve_by_elim", "lean.is_release", "rsimp.collect_implied_eqs", "int.nat_abs_bit1_nonneg", "option.has_to_format", "tactic.explode.pad_right", "nat.one_succ_zero", "smt_config.inhabited", "tactic.interactive.replace", "nat.one_pos", "nat.bit0_ne_one", "tactic.interactive.clear_", "nat.div_le_self", "nat.bodd_bit", "nat.sub_mul_div", "nat.bit0_ne_bit1", "int.neg_succ_of_nat_coe", "expr.is_bin_arith_app", "char.is_digit", "nat.shiftl_succ", "rsimp.choose", "list.to_format", "int.sign_mul_nat_abs", "tactic.iterate", "tactic.injection_with", "tactic.interactive.convert_to", "nat.test_bit_succ", "nat.zero_lt_bit1", "char.decidable_is_lower", "nat.one_ne_bit0", "nat.bit1_inj", "char_to_hex", "int.pos_of_sign_eq_one", "tactic.rename", "nat.zero_ne_one", "nat.div2_bit", "nat.prio", "nat.bit0_lt_bit1", "nat.le_of_sub_eq_zero", "where.binder_priority", "nat.succ_ne_self", "nat.add_one", "int.neg_of_sign_eq_neg_one", "smt_tactic.iterate", "array.pop_back", "nat.bit_val", "nat.div_eq_sub_div", "std.priority.max", "nat.zero_div", "parser.fix", "nat.bit1_eq_succ_bit0", "conv.interactive.for", "nat.mod_add_div", "tactic.back_chaining_core", "tactic.interactive.swap", "char.decidable_is_whitespace", "nat.two_step_induction", "is_valid_char", "char.quote_core", "where.trace_where", "int.nat_abs_one", "int.to_nat_sub", "int.of_nat_one", "nat.bit1_ne_zero", "tactic.new_aux_decl_name", "tactic.rsimp", "expr.ith_arg", "array.push_back", "tactic.alias.get_alias_target", "nat.zero_shiftl", "list.length_map\u2082", "char.zero_lt_d800", "nat.div_self", "tactic.rsimp_at", "nat.bit1_ne_one", "instance_priority", "ematch_config.inhabited", "nat.pow_zero", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "lean.version", "tactic.get_mathlib_dir", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "tactic.interactive.field", "nat.sub_lt", "nat.div2_two", "tactic.mk_inj_eq", "nat.bit1_succ_eq", "environment.from_imported_module", "tactic.interactive.apply_rules", "nat.sub_one", "nat.bit1_ne", "tactic.alias.make_left_right", "tactic.interactive.case", "nat.one_mul", "nat.succ_sub_one", "nat.bit0_ne_zero", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "nat.le_div_iff_mul_le", "list.length_repeat", "list.length_remove_nth", "tactic.interactive.suggest", "nat.bit1_lt_bit0", "tactic.interactive.push_neg", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "format.dcbrace", "tactic.exact_dec_trivial", "int.zero_ne_one", "nat.cond_to_bool_mod_two", "function.involutive_iff_iter_2_eq_id", "smt_tactic.interactive.executor", "nat.find_x", "dup_namespace", "nat.div2_one", "nat.div_one", "name.pop_prefix", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "nat.bodd_two"]}, {"id": "bit1", "parentIds": ["unsigned_sz", "char.val_of_nat_eq_of_is_valid", "tactic.library_search_hole_cmd", "is_valid_char_range_1", "simp.default_max_steps", "norm_num.bit0_add_bit1", "tactic.injections_with", "int.nat_abs_bit1_nonneg_step", "unsigned.has_zero", "norm_num.add1_bit1", "norm_num.bit1_add_one_helper", "int.bit", "is_valid_char_range_2", "norm_num.bit1_add_one", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "sum_has_to_format", "using_smt", "unsigned.of_nat", "environment.for_decl_of_imported_module", "smt_pre_config.inhabited", "rbtree.default_lt", "tactic.interactive.solve_by_elim", "nat.bit1_lt", "to_additive.guess_name", "std.priority.default", "char.val_of_nat_eq_of_not_is_valid", "tactic.mk_dec_eq_instance", "char.is_whitespace", "nat.repr", "char.to_lower", "parser.mk_error_msg", "norm_num.bit1_add_bit0_helper", "string.hash", "nat.bit", "char.of_nat", "char.is_lower", "nat.one_le_bit1", "tactic.unprime", "int.bit1_pos", "nat.mk_numeral", "norm_num.bit0_add_bit1_helper", "norm_num.nonneg_bit1_helper", "std.prec.arrow", "char.decidable_is_digit", "nat.one_ne_bit1", "char.is_punctuation", "tactic.rcases_parse_depth", "nat.digit_char", "int.bit1_nonneg", "char.decidable_is_punctuation", "well_founded_tactics.cancel_nat_add_lt", "nat.bit1_ne_bit0", "name.deinternalize_field", "nat.zero_ne_bit1", "std.prec.max_plus", "char.decidable_is_upper", "tactic.suggest.apply_and_solve", "norm_num.one_add_bit1", "char.is_upper", "norm_num.add1_bit1_helper", "unsigned.has_one", "smt_tactic.execute", "nat.bit1_val", "char.inhabited", "tactic.solve_by_elim", "norm_num.bit1_add_bit0", "rsimp.collect_implied_eqs", "int.nat_abs_bit1_nonneg", "option.has_to_format", "smt_config.inhabited", "tactic.interactive.clear_", "bit1_zero", "nat.bit0_ne_bit1", "char.is_digit", "tactic.iterate", "tactic.interactive.convert_to", "nat.zero_lt_bit1", "char.decidable_is_lower", "nat.bit1_inj", "nat.prio", "nat.bit0_lt_bit1", "where.binder_priority", "smt_tactic.iterate", "norm_num.bit1_add_bit1", "std.priority.max", "nat.bit1_eq_succ_bit0", "char.decidable_is_whitespace", "is_valid_char", "char.quote_core", "where.trace_where", "nat.bit1_ne_zero", "char.zero_lt_d800", "norm_num.bit1_add_bit1_helper", "nat.bit1_ne_one", "instance_priority", "ematch_config.inhabited", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "lean.version", "tactic.get_mathlib_dir", "norm_num.one_add_bit1_helper", "tactic.mk_inj_eq", "nat.bit1_succ_eq", "norm_num.mul_bit1", "environment.from_imported_module", "tactic.interactive.apply_rules", "nat.bit1_ne", "tactic.alias.make_left_right", "nat.one_lt_bit1", "norm_num.bit0_add_one", "tactic.interactive.suggest", "nat.bit1_lt_bit0", "tactic.interactive.push_neg", "nat.shiftl'_tt_eq_mul_pow", "tactic.exact_dec_trivial", "norm_num.one_add_bit0", "smt_tactic.interactive.executor", "norm_num.add1_bit0"]}, {"id": "decidable.lt_or_gt_of_ne", "parentIds": ["decidable.ne_iff_lt_or_gt"]}, {"id": "or.resolve_left", "parentIds": ["decidable.lt_or_gt_of_ne", "nat.pos_of_ne_zero", "is_strict_weak_order_of_is_total_preorder", "le_of_not_ge", "int.nat_abs_pos_of_ne_zero", "nat.div_eq_of_lt_le", "nat.exists_eq_succ_of_ne_zero", "nat.eq_or_lt_of_not_lt", "cmp_compares", "eq_of_mul_eq_mul_left", "le_of_not_le", "or_iff_not_imp_left", "nat.mul_sub_div", "forall_or_distrib_left"]}, {"id": "partial_order.to_preorder", "parentIds": ["decidable.lt_or_gt_of_ne", "lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "sub_lt_sub_of_lt_of_le", "lt_of_one_div_lt_one_div", "le_mul_of_div_le", "add_lt_add_of_lt_of_le", "nat.lt_add_left", "max_add_add_left", "le_iff_lt_or_eq", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "add_lt_of_lt_of_nonpos", "nat.div_eq_of_lt", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "decidable.eq_or_lt_of_le", "is_strict_weak_order_of_decidable_linear_order", "add_lt_of_le_of_neg", "one_div_pos_of_pos", "nat.pow_le_pow_of_le_left", "sub_right_lt_of_lt_add", "div_pos_of_neg_of_neg", "mul_nonpos_of_nonpos_of_nonneg", "abs_add_three", "add_nonpos", "div_lt_of_mul_lt_of_pos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "le_add_of_sub_left_le", "abs_of_pos", "lt_or_gt_of_ne", "exists_ge_of_linear", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "abs_pos_of_ne_zero", "lt_of_not_ge'", "mul_nonneg_of_nonpos_of_nonpos", "abs_sub_le", "le_of_not_ge", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "mul_le_mul_of_nonneg_right", "int.neg_ne_of_pos", "add_midpoint", "list.length_take_le", "zero_le_one", "decidable_linear_ordered_semiring", "d_array.of_beq_aux_eq_tt", "lt_add_of_le_of_pos", "min_eq_left_of_lt", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "max_self", "neg_le_abs_self", "le_add_of_le_of_nonneg", "nat.sub_le_sub_left", "not_lt_of_gt", "one_div_le_of_one_div_le_of_neg", "list.length_le_of_sublist", "ordered_comm_group.lt_of_add_lt_add_left", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_imp_lt_of_le_imp_le", "sub_le_sub_left", "forall_lt_iff_le", "push_neg.not_le_eq", "sub_left_le_of_le_add", "nonneg_of_mul_nonneg_left", "int.zero_nonneg", "max_comm", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "nat.pow_lt_pow_of_lt_right", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "le_of_forall_lt'", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "lt_iff_not_ge", "le_add_of_nonneg_of_le", "le_or_lt", "add_le_of_le_neg_add", "max_lt", "nat.find_min'", "nat.le_mul_self", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "lt_of_le_of_ne", "max_assoc", "add_lt_of_nonpos_of_lt", "one_div_lt_neg_one", "has_le.le.is_total_preorder", "one_lt_div_of_lt", "lt_add_of_pos_of_le", "le_min", "max_eq_right", "le_max_left", "lt_of_not_ge", "lt_of_add_lt_add_right", "decidable_linear_ordered_cancel_comm_monoid", "add_lt_of_neg_of_lt", "decidable.not_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "eq_or_lt_of_not_lt", "int.nat_abs_add_nonneg", "eq_min", "push_neg.not_lt_eq", "le_div_of_mul_le", "decidable.lt_by_cases", "nat.pow_le_pow_of_le_right", "lt_min", "lt_add_of_neg_add_lt_left", "sub_le_of_sub_le", "neg_lt_neg", "nat.mod_eq_of_lt", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "nat.mul_self_le_mul_self_iff", "mul_lt_mul_of_neg_right", "lt_of_add_lt_add_left", "decidable.lt_or_le", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "sub_lt_of_abs_sub_lt_right", "nat.lt_of_sub_eq_succ", "add_neg_of_nonpos_of_neg", "add_le_add_right", "mul_lt_mul", "ne_iff_lt_or_gt", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "lt_add_of_nonneg_of_lt", "lt_of_mul_lt_mul_right", "mul_pos", "min_eq_left", "nat.div_le_of_le_mul", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "nat.sub_pos_of_lt", "int.of_nat_nat_abs_eq_of_nonneg", "max", "mul_self_le_mul_self_iff", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "has_le.le.decidable", "le_add_of_neg_le_sub_left", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "lt_add_of_neg_lt_sub_left", "decidable.lt_or_eq_of_le", "nat.pos_of_dvd_of_pos", "decidable_linear_order", "add_lt_add", "pos_of_mul_pos_right", "ordered_semiring", "abs_nonneg", "not_lt_iff_eq_or_lt", "norm_num.nonneg_bit1_helper", "lt_add_of_pos_left", "lt_trichotomy", "lt_of_one_lt_div", "abs_mul", "neg_le_neg", "mul_le_of_le_div", "nat.zero_mod", "le_of_one_div_le_one_div_of_neg", "has_lt.lt.decidable", "le_of_add_le_add_left", "neg_add_le_right_of_le_add", "min_comm", "add_neg_of_neg_of_nonpos", "nat.sub_lt_of_pos_le", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "not_lt", "neg_le_sub_left_of_le_add", "abs_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "decidable.le_imp_le_of_lt_imp_lt", "neg_add_le_left_of_le_add", "max_le", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "lt_of_sub_pos", "decidable_eq_of_decidable_le", "linear_ordered_ring", "is_strict_total_order_of_decidable_linear_order", "sub_right_le_of_le_add", "mul_neg_of_neg_of_pos", "le_sub_left_of_add_le", "add_le_of_nonpos_of_le", "min_add_add_left", "mul_pos_of_neg_of_neg", "int.eq_neg_succ_of_lt_zero", "add_neg", "neg_of_neg_pos", "not_le", "decidable.le_iff_lt_or_eq", "le_of_mul_le_mul_right", "d_array.of_beq_aux_eq_ff", "eq_zero_of_neg_eq", "eq_of_forall_ge_iff", "sub_lt_self", "le_of_one_div_le_one_div", "linear_order", "mul_lt_of_gt_div_of_neg", "norm_num.nonneg_bit0_helper", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "le_of_not_gt", "le_antisymm", "sub_le_sub_right", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "le_of_mul_le_mul_left", "nat.sub_one_sub_lt", "div_mul_le_div_mul_of_div_le_div_pos'", "add_le_add_three", "decidable.le_imp_le_iff_lt_imp_lt", "neg_nonpos_of_nonneg", "add_pos_of_nonneg_of_pos", "le_of_forall_lt", "neg_of_mul_neg_right", "min_le_right", "sub_lt_of_abs_sub_lt_left", "div_lt_div_of_lt_of_neg", "buffer.lt_aux_3", "norm_num.pos_bit0_helper", "lt_or_ge", "lt_mul_of_gt_one_right", "decidable.le_or_lt", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "sub_lt_sub_left", "mul_self_lt_mul_self", "div_pos_of_pos_of_pos", "eq_zero_of_abs_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "nat.div_lt_self", "abs_zero", "neg_le_sub_right_of_le_add", "mul_le_of_div_le_of_neg", "nat.mod_zero", "add_self_div_two", "norm_num.nonzero_of_pos_helper", "div_lt_div_of_lt_of_pos", "add_le_add_left", "decidable.lt_trichotomy", "max_eq_left", "lt_add_of_neg_add_lt", "gt_of_mul_lt_mul_neg_left", "nat.div_eq_of_lt_le", "pos_of_mul_pos_left", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "lt_of_mul_lt_mul_left", "sub_left_lt_of_lt_add", "neg_pos_of_neg", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "nat.sub_mul_div", "add_pos", "le_imp_le_iff_lt_imp_lt", "add_lt_of_lt_sub_right", "div_nonpos_of_nonneg_of_neg", "abs_pos_of_neg", "lt_iff_lt_of_le_iff_le", "nat.mod_self", "le_abs_self", "min_assoc", "eq_iff_le_not_lt", "nat.strong_rec_on", "lt_add_of_neg_lt_sub_right", "neg_of_mul_neg_left", "abs_of_nonneg", "le_iff_eq_or_lt", "sub_le_of_abs_sub_le_right", "lt_neg_of_lt_neg", "cmp_compares", "le_sub_right_of_add_le", "min", "add_nonneg", "eq_zero_of_mul_self_add_mul_self_eq_zero", "lt_add_of_pos_of_lt", "neg_lt_of_neg_lt", "ordered_comm_group", "add_lt_add_of_le_of_lt", "nat.le_of_sub_eq_zero", "abs_by_cases", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "int.neg_succ_lt_zero", "lt_or_le", "nat.mul_self_lt_mul_self", "buffer.lt_aux_1", "add_lt_add_right", "le_add_of_neg_add_le_right", "nat.pow_lt_pow_of_lt_left", "le_total", "sub_lt_of_sub_lt", "nat.zero_div", "lt_sub_right_of_add_lt", "ordered_ring.mul_lt_mul_of_pos_right", "add_le_add", "div_lt_div_of_pos_of_lt_of_pos", "nat.mod_add_div", "le_antisymm_iff", "le_of_not_lt", "d_array.of_beq_eq_tt", "abs_pos_of_pos", "decidable.le_iff_le_iff_lt_iff_lt", "nonpos_of_neg_nonneg", "two_ge_one", "ordered_ring.mul_le_mul_of_nonneg_left", "neg_add_lt_left_of_lt_add", "two_pos", "lt_of_neg_lt_neg", "sub_pos_of_lt", "one_div_le_one_div_of_le", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "pos_of_neg_neg", "ordered_cancel_comm_monoid", "sub_lt_sub_of_le_of_lt", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "sub_nonpos_of_le", "lt_add_of_pos_right", "decidable.le_of_not_lt", "sub_le_sub", "mul_nonpos_of_nonneg_of_nonpos", "lt_add_of_lt_of_pos", "decidable_linear_ordered_comm_ring", "sub_le_self", "decidable.ne_iff_lt_or_gt", "lt_of_sub_neg", "nat.div_mul_le_self", "lt_of_le_of_ne'", "lt_or_eq_of_le", "lt_iff_le_and_ne", "le_of_sub_nonneg", "nat.le_of_dvd", "mul_self_nonneg", "d_array.of_beq_eq_ff", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "min_self", "nonpos_of_mul_nonpos_right", "min_eq_right", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "abs_lt_of_lt_of_neg_lt", "nat.eq_of_mul_eq_mul_left", "one_div_le_one_div_of_le_of_neg", "nat.pred_inj", "le_imp_le_of_lt_imp_lt", "mul_nonneg", "eq_or_lt_of_le", "neg_of_one_div_neg", "nat.lt_add_right", "min_eq_right_of_lt", "eq_of_forall_le_iff", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "mul_lt_mul_of_pos_right", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "linear_ordered_field", "lt_add_of_sub_left_lt", "abs_abs_sub_abs_le_abs_sub", "zero_lt_one", "div_le_of_le_mul", "abs_sub_abs_le_abs_sub", "nonneg_of_neg_nonpos", "lt_neg_add_of_add_lt", "nat.le_div_iff_mul_le", "sub_lt_sub", "eq_max", "int.le_nat_abs", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "neg_nonneg_of_nonpos", "le_of_not_le", "add_lt_of_lt_of_neg", "max_eq_right_of_lt", "le_iff_le_iff_lt_iff_lt", "list.length_remove_nth", "ordered_ring.mul_lt_mul_of_pos_left", "mul_lt_mul'", "min_le_left", "ordered_comm_group.le_of_add_le_add_left", "div_neg_of_neg_of_pos", "neg_lt_sub_right_of_lt_add", "le_or_gt", "ordered_ring", "pos_and_pos_or_neg_and_neg_of_mul_pos", "le_of_sub_nonpos", "nat.div_zero", "four_pos", "div_two_lt_of_pos", "le_add_of_nonneg_left", "nat.min_succ_succ", "max_neg_neg", "decidable_linear_ordered_comm_group", "le_of_add_le_add_right", "nat.div_div_eq_div_mul", "mul_self_le_mul_self", "one_lt_one_div", "sub_neg_of_lt", "le_neg_add_of_add_le", "le_max_right", "forall_lt_iff_le'", "max_eq_left_of_lt", "neg_neg_of_pos", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "nat.succ_pred_eq_of_pos", "mul_le_mul", "one_div_le_neg_one", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "lt_iff_not_ge'", "lt_sub_left_of_add_lt", "neg_le_of_neg_le", "mul_le_mul_of_nonpos_right"]}, {"id": "decidable_linear_order.to_linear_order", "parentIds": ["decidable.lt_or_gt_of_ne", "abs_add_le_abs_add_abs", "max_add_add_left", "is_strict_weak_order_of_decidable_linear_order", "abs_pos_of_ne_zero", "list.length_take_le", "min_eq_left_of_lt", "max_self", "max_comm", "max_lt", "max_assoc", "has_le.le.is_total_preorder", "le_min", "max_eq_right", "le_max_left", "decidable.not_lt", "eq_or_lt_of_not_lt", "eq_min", "decidable.lt_by_cases", "nat.sub_eq_sub_min", "lt_min", "decidable.lt_or_le", "min_eq_left", "max", "abs_nonneg", "min_comm", "decidable.le_imp_le_of_lt_imp_lt", "max_le", "is_strict_total_order_of_decidable_linear_order", "min_add_add_left", "eq_zero_of_neg_eq", "decidable.le_imp_le_iff_lt_imp_lt", "min_le_right", "decidable.le_or_lt", "decidable.lt_trichotomy", "max_eq_left", "le_abs_self", "min_assoc", "cmp_compares", "min", "abs_by_cases", "decidable.le_iff_le_iff_lt_iff_lt", "dist_bdd_within_interval", "decidable.le_of_not_lt", "decidable.ne_iff_lt_or_gt", "min_self", "min_eq_right", "min_eq_right_of_lt", "eq_max", "max_eq_right_of_lt", "min_le_left", "nat.min_succ_succ", "max_neg_neg", "decidable_linear_ordered_comm_group", "le_max_right", "max_eq_left_of_lt"]}, {"id": "linear_order.to_partial_order", "parentIds": ["decidable.lt_or_gt_of_ne", "abs_add_le_abs_add_abs", "lt_of_one_div_lt_one_div", "max_add_add_left", "is_strict_weak_order_of_decidable_linear_order", "lt_or_gt_of_ne", "exists_ge_of_linear", "abs_pos_of_ne_zero", "lt_of_not_ge'", "le_of_not_ge", "list.length_take_le", "decidable_linear_ordered_semiring", "min_eq_left_of_lt", "max_self", "not_lt_of_gt", "one_div_le_of_one_div_le_of_neg", "lt_imp_lt_of_le_imp_le", "forall_lt_iff_le", "push_neg.not_le_eq", "nonneg_of_mul_nonneg_left", "max_comm", "ge_of_forall_ge_sub", "le_of_forall_lt'", "lt_iff_not_ge", "le_or_lt", "max_lt", "nat.find_min'", "max_assoc", "has_le.le.is_total_preorder", "le_min", "max_eq_right", "le_max_left", "lt_of_not_ge", "decidable_linear_ordered_cancel_comm_monoid", "decidable.not_lt", "eq_or_lt_of_not_lt", "eq_min", "push_neg.not_lt_eq", "decidable.lt_by_cases", "lt_min", "mul_self_lt_mul_self_iff", "decidable.lt_or_le", "nat.lt_of_sub_eq_succ", "ne_iff_lt_or_gt", "lt_of_one_div_lt_one_div_of_neg", "lt_of_mul_lt_mul_right", "min_eq_left", "max", "nat.mul_mod_mul_left", "has_le.le.decidable", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "decidable_linear_order", "pos_of_mul_pos_right", "abs_nonneg", "not_lt_iff_eq_or_lt", "lt_trichotomy", "abs_mul", "le_of_one_div_le_one_div_of_neg", "has_lt.lt.decidable", "min_comm", "discrete_linear_ordered_field", "not_lt", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "decidable.le_imp_le_of_lt_imp_lt", "nat.eq_zero_of_le_zero", "max_le", "is_strict_total_order_of_decidable_linear_order", "min_add_add_left", "not_le", "le_of_mul_le_mul_right", "eq_zero_of_neg_eq", "le_of_one_div_le_one_div", "nonneg_of_mul_nonneg_right", "le_of_not_gt", "le_of_mul_le_mul_left", "decidable.le_imp_le_iff_lt_imp_lt", "le_of_forall_lt", "neg_of_mul_neg_right", "min_le_right", "lt_or_ge", "decidable.le_or_lt", "nonpos_of_mul_nonpos_left", "decidable.lt_trichotomy", "max_eq_left", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "le_imp_le_iff_lt_imp_lt", "lt_iff_lt_of_le_iff_le", "le_abs_self", "min_assoc", "neg_of_mul_neg_left", "cmp_compares", "min", "abs_by_cases", "int.neg_succ_lt_zero", "lt_or_le", "le_total", "le_of_not_lt", "decidable.le_iff_le_iff_lt_iff_lt", "decidable.le_of_not_lt", "decidable_linear_ordered_comm_ring", "decidable.ne_iff_lt_or_gt", "mul_self_nonneg", "min_self", "nonpos_of_mul_nonpos_right", "min_eq_right", "le_imp_le_of_lt_imp_lt", "min_eq_right_of_lt", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "nat.le_div_iff_mul_le", "eq_max", "int.le_nat_abs", "nat.div_lt_iff_lt_mul", "le_of_not_le", "max_eq_right_of_lt", "le_iff_le_iff_lt_iff_lt", "min_le_left", "le_or_gt", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.min_succ_succ", "max_neg_neg", "decidable_linear_ordered_comm_group", "le_max_right", "forall_lt_iff_le'", "max_eq_left_of_lt", "lt_iff_not_ge'"]}, {"id": "ne", "parentIds": ["decidable.lt_or_gt_of_ne", "ne_zero_of_mul_ne_zero_left", "nat.pos_of_ne_zero", "mul_sub_mul_div_mul_nonpos", "ne_of_eq_of_ne", "ne_of_mem_of_not_mem", "nat.one_ne_zero", "discrete_field", "div_sub_div", "expr.mk_exists_lst", "nat.one_lt_bit0", "nat.add_one_ne_zero", "to_additive.target_name", "mul_ne_zero_comm", "lt_or_gt_of_ne", "unused_arguments", "array.push_back_idx", "push_neg.not_eq", "abs_pos_of_ne_zero", "int.neg_ne_of_pos", "fin.vne_of_ne", "int.zero_ne_neg_of_ne", "ne.decidable", "mul_inv_eq", "function.update_eq_self", "two_ne_zero", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "field.one_div_mul_one_div", "int.ne_of_nat_ne_nonneg_case", "mul_eq_of_eq_div", "tactic.clear'", "one_le_div_of_le", "sum.elim_injective", "ne_false_of_self", "one_div_mul_one_div'", "int.neg_ne_zero_of_ne", "field.div_mul_eq_div_mul_one_div", "ne_true_of_not", "inv_ne_zero", "mul_div_mul_left'", "is_distinct", "integral_domain", "array.read_write_of_ne", "div_le_div_of_mul_sub_mul_div_nonpos", "lt_of_le_of_ne", "nat.pred_lt_pred", "one_lt_div_of_lt", "sub_ne_zero_of_ne", "ne_of_gt", "int.nat_abs_pos_of_ne_zero", "eq_of_mul_eq_mul_of_nonzero_right", "false_ne_true", "string.str_ne_empty", "list.ne_nil_of_length_eq_succ", "nat.add_self_ne_one", "div_mul_cancel", "mul_ne_zero", "mul_div_cancel_left", "bool.bxor_iff_ne", "false_of_ne", "div_self", "ne_zero_of_mul_ne_zero_right", "nat.one_le_bit0", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "ne_iff_lt_or_gt", "div_mul_left", "division_ring", "linear_ordered_comm_ring", "tactic.unprime", "mul_sub_mul_div_mul_neg", "division_ring.one_div_one_div", "add_div_eq_mul_add_div", "int.ne_neg_of_ne", "ne_comm", "tactic.lift", "tactic.abstract", "int.add_lt_add_left", "inv_ne_one", "mul_one_div_cancel", "int.eq_one_of_mul_eq_self_left", "list.nodup", "string.str_ne_str_right", "fin.ne_of_vne", "lt_of_one_lt_div", "field.div_div_div_div_eq", "int.lt_iff_le_and_ne", "nat.one_ne_bit1", "norm_num.div_add_helper", "discrete_linear_ordered_field", "nat.bit1_ne_bit0", "eq_div_of_mul_eq", "ne_of_ne_of_eq", "bool.eq_tt_of_ne_ff", "char.ne_of_vne", "ne.symm", "string.empty_ne_str", "linear_ordered_ring", "sub_ne_zero", "nat.zero_ne_bit1", "ne_zero_of_one_div_ne_zero", "one_div_ne_zero", "int.ne_of_lt", "ne.irrefl", "d_array.of_beq_aux_eq_ff", "field.div_mul_left", "field.div_mul_eq_mul_div_comm", "one_inv_eq", "bool.eq_ff_of_ne_tt", "mul_inv_cancel", "norm_num.add_div_helper", "field.div_mul_div", "function.injective.ne", "division_ring.one_div_div", "one_div_mul_cancel", "nat.succ_ne_zero", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "norm_num.nonzero_of_neg_helper", "div_mul_right", "mul_inv'", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "char.vne_of_ne", "zero_ne_one_class", "norm_num.nonzero_of_pos_helper", "lean.is_release", "norm_num.div_mul_helper", "one_div_neg_eq_neg_one_div", "ne_zero_of_abs_ne_zero", "abs_div", "function.update_noteq", "sum.inl_ne_inr", "ne_of_lt", "list.last", "nat.bit0_ne_one", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "nat.bit0_ne_bit1", "nat.pred_lt", "nat.exists_eq_succ_of_ne_zero", "field.div_mul_right", "ne.intro", "char.of_nat_ne_of_ne", "int.lt_iff_le_not_le", "division_ring.mul_ne_zero", "neq_of_not_iff", "eq_of_mul_eq_mul_of_nonzero_left", "nat.lt_of_le_and_ne", "nat.one_ne_bit0", "division_ring.neg_div_neg_eq", "nat.zero_ne_one", "ne.def", "mul_eq_mul_of_div_eq_div", "one_div_div", "string.str_ne_str_left", "nat.succ_ne_self", "div_eq_one_iff_eq", "mul_div_mul_left", "nat.zero_ne_bit0", "mul_div_mul_right'", "one_ne_zero", "neg_ne_zero", "eq_of_mul_eq_mul_left", "field", "one_div_one_div", "mul_div_cancel'", "mul_div_mul_right", "eq_zero_of_mul_eq_self_left", "impossible_instance", "nat.bit1_ne_zero", "lean.parser.parser_orelse", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "neg_div_neg_eq", "mul_div_cancel", "eq_of_div_eq_one", "inv_mul_cancel", "division_ring.eq_of_one_div_eq_one_div", "decidable_linear_ordered_comm_ring", "division_ring.inv_inv", "decidable.ne_iff_lt_or_gt", "div_mul_eq_mul_div_comm", "int.eq_one_of_mul_eq_self_right", "eq_of_one_div_eq_one_div", "lt_of_le_of_ne'", "nat.bit1_ne_one", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "lt_iff_le_and_ne", "div_neg_eq_neg_div", "d_array.of_beq_eq_ff", "int.ne_neg_of_pos", "eq_one_div_of_mul_eq_one_left", "ne.elim", "eq_one_div_of_mul_eq_one", "one_div_add_one_div", "zero_ne_one", "fin.pred", "sum.inr_ne_inl", "neg_of_one_div_neg", "mul_mul_div", "list.nodup_decidable", "tactic.interactive.h_generalize", "nat.bit1_ne", "tactic.alias.make_left_right", "norm_num.div_helper", "linear_ordered_field", "d_array.read_write_of_ne", "field.div_div_eq_div_mul", "tactic.interactive.case", "list.erase_dup", "decidable_eq_inr_neg", "dangerous_instance", "nat.bit0_ne_zero", "nat.one_lt_bit1", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "conv.convert", "le_of_one_le_div", "classical.em", "norm_num.mul_div_helper", "nat.bit0_ne", "div_mul_div", "ordered_ring", "div_add_div", "derive_struct_ext_lemma", "division_ring.one_div_neg_eq_neg_one_div", "int.zero_ne_one", "tactic.done", "nat.zero_lt_bit0", "dup_namespace", "eq_div_iff_mul_eq", "div_lt_div_of_mul_sub_mul_div_neg", "function.update_comp"]}, {"id": "preorder.to_has_lt", "parentIds": ["decidable.lt_or_gt_of_ne", "lt_add_of_sub_right_lt", "sub_lt_sub_of_lt_of_le", "lt_of_one_div_lt_one_div", "le_mul_of_div_le", "add_lt_add_of_lt_of_le", "le_iff_lt_or_eq", "div_le_div_of_le_of_pos", "add_lt_of_lt_of_nonpos", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "decidable.eq_or_lt_of_le", "is_strict_weak_order_of_decidable_linear_order", "add_lt_of_le_of_neg", "one_div_pos_of_pos", "sub_right_lt_of_lt_add", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "abs_of_pos", "lt_or_gt_of_ne", "mul_lt_mul_of_pos_left", "gt.trans", "linear_ordered_semiring", "abs_pos_of_ne_zero", "lt_of_not_ge'", "neg_add_lt_of_lt_add", "add_midpoint", "decidable_linear_ordered_semiring", "d_array.of_beq_aux_eq_tt", "lt_add_of_le_of_pos", "min_eq_left_of_lt", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "not_lt_of_gt", "one_div_le_of_one_div_le_of_neg", "ordered_comm_group.lt_of_add_lt_add_left", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_imp_lt_of_le_imp_le", "forall_lt_iff_le", "push_neg.not_le_eq", "nonneg_of_mul_nonneg_left", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "nat.pow_lt_pow_of_lt_right", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "le_of_forall_lt'", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "lt_iff_not_ge", "le_or_lt", "not_lt_of_le", "max_lt", "nat.find_min'", "lt_of_le_of_ne", "add_lt_of_nonpos_of_lt", "one_div_lt_neg_one", "one_lt_div_of_lt", "lt_add_of_pos_of_le", "not_le_of_gt", "lt_of_not_ge", "ne_of_gt", "lt_of_add_lt_add_right", "decidable_linear_ordered_cancel_comm_monoid", "add_lt_of_neg_of_lt", "decidable.not_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "eq_or_lt_of_not_lt", "ordering.compares.eq_lt", "gt_of_ge_of_gt", "push_neg.not_lt_eq", "le_div_of_mul_le", "decidable.lt_by_cases", "nat.pow_le_pow_of_le_right", "lt_min", "gt_of_gt_of_ge", "lt_add_of_neg_add_lt_left", "neg_lt_neg", "gt_iff_lt", "mul_self_lt_mul_self_iff", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "ordering.compares.eq_gt", "lt_of_add_lt_add_left", "decidable.lt_or_le", "lt.trans", "one_div_lt_one_div_of_lt_of_neg", "lt_iff_le_not_le", "div_mul_le_div_mul_of_div_le_div_pos", "sub_lt_of_abs_sub_lt_right", "add_neg_of_nonpos_of_neg", "mul_lt_mul", "ne_iff_lt_or_gt", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "lt_add_of_nonneg_of_lt", "lt_trans", "lt_of_mul_lt_mul_right", "mul_pos", "lt_asymm", "le_of_eq_or_lt", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "not_le_of_lt", "nat.mul_mod_mul_left", "gt_irrefl", "nat.mod_le", "lt_add_of_neg_lt_sub_left", "decidable.lt_or_eq_of_le", "decidable_linear_order", "add_lt_add", "pos_of_mul_pos_right", "not_lt_of_ge", "ordered_semiring", "decidable_lt_of_decidable_le", "not_lt_iff_eq_or_lt", "lt_add_of_pos_left", "lt_trichotomy", "lt_of_one_lt_div", "mul_le_of_le_div", "nat.zero_mod", "le_of_one_div_le_one_div_of_neg", "has_lt.lt.decidable", "add_neg_of_neg_of_nonpos", "discrete_linear_ordered_field", "not_lt", "abs_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "decidable.le_imp_le_of_lt_imp_lt", "one_div_neg_of_neg", "one_div_le_of_one_div_le_of_pos", "lt_of_sub_pos", "le_not_le_of_lt", "linear_ordered_ring", "is_strict_total_order_of_decidable_linear_order", "mul_neg_of_neg_of_pos", "mul_pos_of_neg_of_neg", "add_neg", "neg_of_neg_pos", "not_le", "decidable.le_iff_lt_or_eq", "le_of_mul_le_mul_right", "d_array.of_beq_aux_eq_ff", "eq_zero_of_neg_eq", "sub_lt_self", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "nonneg_of_mul_nonneg_right", "le_of_not_gt", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "decidable.le_imp_le_iff_lt_imp_lt", "le_of_lt_or_eq", "add_pos_of_nonneg_of_pos", "le_of_forall_lt", "neg_of_mul_neg_right", "sub_lt_of_abs_sub_lt_left", "div_lt_div_of_lt_of_neg", "norm_num.pos_bit0_helper", "le_of_lt", "lt_or_ge", "lt_mul_of_gt_one_right", "decidable.le_or_lt", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "sub_lt_sub_left", "mul_self_lt_mul_self", "div_pos_of_pos_of_pos", "mul_le_of_div_le_of_neg", "nat.mod_zero", "norm_num.nonzero_of_pos_helper", "div_lt_div_of_lt_of_pos", "lt_irrefl", "decidable.lt_trichotomy", "lt_add_of_neg_add_lt", "gt_of_mul_lt_mul_neg_left", "pos_of_mul_pos_left", "lt_add_of_neg_add_lt_right", "lt_of_mul_lt_mul_left", "ne_of_lt", "sub_left_lt_of_lt_add", "neg_pos_of_neg", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "add_pos", "le_imp_le_iff_lt_imp_lt", "add_lt_of_lt_sub_right", "div_nonpos_of_nonneg_of_neg", "abs_pos_of_neg", "lt_iff_lt_of_le_iff_le", "eq_iff_le_not_lt", "nat.strong_rec_on", "lt_add_of_neg_lt_sub_right", "neg_of_mul_neg_left", "le_iff_eq_or_lt", "lt_of_le_not_le", "lt_neg_of_lt_neg", "cmp_compares", "lt_add_of_pos_of_lt", "cmp_swap", "neg_lt_of_neg_lt", "ordered_comm_group", "add_lt_add_of_le_of_lt", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "lt_or_le", "nat.mul_self_lt_mul_self", "add_lt_add_right", "sub_lt_of_sub_lt", "nat.zero_div", "lt_sub_right_of_add_lt", "ordered_ring.mul_lt_mul_of_pos_right", "div_lt_div_of_pos_of_lt_of_pos", "le_of_not_lt", "abs_pos_of_pos", "decidable.le_iff_le_iff_lt_iff_lt", "neg_add_lt_left_of_lt_add", "two_pos", "lt_of_neg_lt_neg", "sub_pos_of_lt", "one_div_le_one_div_of_le", "dist_bdd_within_interval", "pos_of_neg_neg", "sub_lt_sub_of_le_of_lt", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "lt_add_of_pos_right", "decidable.le_of_not_lt", "lt_add_of_lt_of_pos", "decidable_linear_ordered_comm_ring", "decidable.ne_iff_lt_or_gt", "lt_of_sub_neg", "lt_of_le_of_ne'", "lt_or_eq_of_le", "lt_iff_le_and_ne", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "nonpos_of_mul_nonpos_right", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "abs_lt_of_lt_of_neg_lt", "one_div_le_one_div_of_le_of_neg", "le_imp_le_of_lt_imp_lt", "eq_or_lt_of_le", "neg_of_one_div_neg", "min_eq_right_of_lt", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "mul_lt_mul_of_pos_right", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "linear_ordered_field", "lt_add_of_sub_left_lt", "zero_lt_one", "div_le_of_le_mul", "lt_of_lt_of_le", "lt_neg_add_of_add_lt", "nat.le_div_iff_mul_le", "sub_lt_sub", "lt_iff_lt_of_le_iff_le'", "lt_of_le_of_lt", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "add_lt_of_lt_of_neg", "max_eq_right_of_lt", "le_iff_le_iff_lt_iff_lt", "ordered_ring.mul_lt_mul_of_pos_left", "mul_lt_mul'", "div_neg_of_neg_of_pos", "neg_lt_sub_right_of_lt_add", "le_or_gt", "ordered_ring", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.div_zero", "four_pos", "div_two_lt_of_pos", "ordering.compares.eq_eq", "decidable_linear_ordered_comm_group", "gt_trans", "one_lt_one_div", "sub_neg_of_lt", "forall_lt_iff_le'", "max_eq_left_of_lt", "neg_neg_of_pos", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg", "lt_iff_not_ge'", "lt_sub_left_of_add_lt"]}, {"id": "decidable_linear_order", "parentIds": ["decidable.lt_or_gt_of_ne", "is_strict_weak_order_of_decidable_linear_order", "list.length_take_le", "min_eq_left_of_lt", "max_self", "max_comm", "max_lt", "max_assoc", "has_le.le.is_total_preorder", "le_min", "max_eq_right", "le_max_left", "decidable.not_lt", "eq_or_lt_of_not_lt", "eq_min", "decidable.lt_by_cases", "lt_min", "decidable.lt_or_le", "min_eq_left", "max", "has_le.le.decidable", "decidable_linear_ordered_comm_group.to_decidable_linear_order", "has_lt.lt.decidable", "min_comm", "decidable.le_imp_le_of_lt_imp_lt", "max_le", "list.length_take", "is_strict_total_order_of_decidable_linear_order", "decidable.le_imp_le_iff_lt_imp_lt", "min_le_right", "decidable.le_or_lt", "decidable_linear_order.to_linear_order", "decidable.lt_trichotomy", "max_eq_left", "min_assoc", "cmp_compares", "min_left_comm", "min", "eq.decidable", "decidable.le_iff_le_iff_lt_iff_lt", "decidable.le_of_not_lt", "list.length_map\u2082", "decidable.ne_iff_lt_or_gt", "min_self", "min_eq_right", "min_eq_right_of_lt", "max_left_comm", "eq_max", "decidable_linear_ordered_semiring.to_decidable_linear_order", "max_eq_right_of_lt", "min_le_left", "decidable_linear_ordered_comm_group", "decidable_linear_ordered_cancel_comm_monoid.to_decidable_linear_order", "le_max_right", "max_eq_left_of_lt"]}, {"id": "or.imp_right", "parentIds": ["decidable.lt_or_gt_of_ne", "or_and_distrib_left", "or_of_or_of_imp_right", "or.assoc", "decidable.lt_trichotomy", "int.le_total", "forall_or_of_or_forall"]}, {"id": "decidable.lt_trichotomy", "parentIds": ["decidable.lt_or_gt_of_ne"]}, {"id": "prod.has_to_tactic_format", "parentIds": []}, {"id": "tactic.pp", "parentIds": ["prod.has_to_tactic_format", "reflected.has_to_tactic_format", "tactic.interactive.squeeze_simp", "tactic.trace", "option_to_tactic_format", "unused_arguments", "tactic.cc_core", "print_arguments", "tactic.interactive.rcases", "array.has_to_tactic_format", "tactic.terminal_goal", "old_conv.conversion", "module_info.has_to_tactic_format", "tactic.suggest.tactic_statement", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.squeeze_simpa", "buffer.has_to_tactic_format", "tactic.explode", "tactic.eqn_stub", "tactic.list_constructors_hole", "print_item_crawl", "tactic.match_stub", "tactic.interactive.has_to_tactic_format", "binder.has_to_tactic_format", "tactic.interactive.simpa", "list.has_to_tactic_format", "where.format_variable", "interactive.param_desc", "tactic.to_pfmt", "tactic.has_to_tactic_format"]}, {"id": "alternative", "parentIds": ["prod.has_to_tactic_format", "tactic.interactive.record_lit", "lean.parser.sep_by", "smt_tactic.interactive.assume", "has_sizeof_derive_handler", "tactic.strip_prefix", "interactive.types.ident_", "tactic.apply_iff", "tactic.mllist.m_of_list", "lean.parser.many", "interactive.types.opt_pexpr_list", "to_additive.target_name", "tactic.interactive.trivial", "option_t.run_pure", "lean.parser.reflectable.optional", "tactic.cases", "guard", "tactic.existsi", "optional", "tactic.apply_inj_lemma", "interactive.types.only_flag", "tactic.rcases_hint", "simp_attr.pre_smt", "restate_axiom", "conv.alternative", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.symm_apply", "restate_axiom_cmd", "succeeds", "opt_minus", "localized_attr", "to_additive.proceed_fields", "tactic.interactive.rename'_args_parser", "tactic.interactive.triv", "tactic.mk_simp_attr", "tactic.assoc_refl", "tactic.mllist.empty", "tactic.mllist.head", "interactive.types.with_ident_list", "user_attribute.parse_reflect", "ematch_lhs", "parser.alternative", "nolint_attr", "user_attribute.dflt_parser", "list.alternative", "tactic.alias.alias_attr", "can_lift_attr", "tactic.terminal_goal", "option_t.run_map", "simps_add_projection", "tactic.mllist.force", "tactic.mllist.enum_from", "tactic.interactive.unfold_projs", "tactic.ext_parse", "old_conv.orelse", "old_conv.conversion", "tactic.mllist.map", "tactic.mllist.enum", "tactic.interactive.let", "ext_param", "tactic.try_apply_opt_auto_param_for_apply", "tactic.constr_to_prop", "tactic.rintro_parse", "interactive.types.without_ident_list", "tactic.match_expr", "tactic.resolve_constant", "well_founded_tactics.default_dec_tac'", "tactic.interactive.congr_core'", "tactic.interactive.change'", "tactic.apply_assumption", "no_rsimp", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "tactic.mllist.filter", "user_attribute.dflt_cache_cfg", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.interactive.simp_core_aux", "smt_tactic.alternative", "doc_blame_report_defn", "tactic.mllist.fix", "option.to_monad", "tactic.interactive.suffices", "tactic.mllist.squash", "tactic.by_cases", "rsimp_attr", "state_t.alternative", "tactic.mk_inhabited_instance", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "old_conv.find_pattern", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "old_conv.interactive.find", "option_t.alternative", "interactive.types.pexpr_list_or_texpr", "list.mfirst", "mtry", "tactic.mllist.range", "ematch", "tactic.interactive.assume", "library_note_attr", "tactic.mllist.concat", "tactic.suggest.apply_and_solve", "simp_attr.functor_norm", "simp_attr.norm", "old_conv.alternative", "name_with_opt", "tactic.mllist.of_list", "tactic.mllist.fixl_with", "tactic.use", "tactic.comp_val", "tactic.mllist.bind_", "tactic.mllist.uncons", "tactic.interactive.guard_hyp", "tactic.contradiction", "tactic.mllist.mmap", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "parser.sep_by", "tactic.ancestor_attr", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "conv.interactive.find", "rsimp.collect_implied_eqs", "tactic.iff_mpr", "tactic.interactive.concat_tags", "failure", "tactic.by_contradiction", "simp_attr.split_if_reduction", "tactic.mllist.filter_map", "tactic.interactive.return_cast", "assert", "tactic.mllist.monad_lift", "tactic.mllist.join", "tactic.rcases", "tactic.interactive.conv", "get_linters", "option.alternative", "reader_t.orelse", "tactic.interactive.change", "guard_true", "state_t.orelse", "tactic.mk_simp_set_core", "debugger.attr", "derive_handler_attr", "tactic.mllist.mfirst", "reader_t.alternative", "tactic.mllist.take", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.ext1", "list.has_to_tactic_format", "tactic.interactive.refine_one", "lean.parser.alternative", "old_conv.find", "tactic.interactive.guard_expr_eq", "tactic.apply_rules", "tactic.iff_mp", "where.is_variable_name", "tactic.mllist.mfilter", "tactic.get_ancestors", "tactic.mllist.append", "tactic.assumption", "tactic.mk_assoc_instance", "tactic.interactive.rw_rules", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "instance_derive_handler", "tactic.inhabited_instance", "tactic.simp_arg_list", "tactic.alternative", "tactic.simp_arg", "tactic.interactive.have", "interactive.loc.apply", "guard_false", "tactic.mk_inj_eq", "tactic.rcases_patt_parse_core", "tactic.decidable_eq_derive_handler", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.mllist.mfilter_map", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "reader_t.failure", "guardb", "mk_hinst_lemma_attr_core", "interactive.types.using_ident", "state_t.failure", "has_reflect_derive_handler", "tactic.mllist.fixl", "doc_blame_report_thm", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "interactive.types.location", "environment.get_modifiers", "derive_struct_ext_lemma", "tactic.reduce_ifs_at", "tactic.congr_core", "interactive.types.brackets", "tactic.suggest.apply_declaration", "tactic.mk_simp_set", "tactic.module_doc_strings", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "has_seq", "parentIds": ["prod.has_to_tactic_format", "tactic.interactive.record_lit", "lean.parser.sep_by", "id.is_comm_applicative", "comp.applicative", "option.is_lawful_monad", "applicative_transformation.preserves_map", "applicative.map_seq_map", "functor.add_const.is_lawful_applicative", "applicative_transformation", "sum.is_lawful_monad", "parser.sep_by1", "tactic.interactive.generalize_hyp", "comp.seq_mk", "is_comm_applicative", "task.monad", "monad_from_pure_bind", "ext_param", "expr.traverse", "parser.is_lawful_monad", "sum.monad", "parser.monad", "reader_t.is_lawful_monad", "is_comm_applicative.commutative_map", "comp.has_seq", "functor.const.applicative", "except.monad", "tactic.interactive.rw_rule_p", "parser.many1", "comp.run_seq", "applicative_transformation.preserves_seq", "comp.applicative_id_comp", "tactic.unsafe.type_context.monad", "name_with_opt", "interaction_monad.monad", "id.is_lawful_monad", "applicative", "map_seq", "comp.is_comm_applicative", "tactic.alias.alias_cmd", "tactic.interactive.rename'_arg_parser", "comp.pure_seq_eq_map", "list.monad", "functor.const.is_lawful_applicative", "applicative.pure_seq_eq_map'", "old_conv.monad", "simps_parser", "exceptional.monad", "list.is_lawful_monad", "applicative.ext", "vm_core.monad", "pure_id_seq", "id.monad", "seq_map_assoc", "comp.applicative_comp_id", "except_t.is_lawful_monad", "except_t.monad", "tactic.get_ancestors", "pure_id'_seq", "state_t.monad", "tactic.interactive.rw_rules", "option.monad", "is_lawful_monad", "functor.add_const.applicative", "tactic.has_append", "option_t.is_lawful_monad", "tactic.interactive.parse_config", "comp.seq_pure", "option_t.monad", "reader_t.monad", "state_t.is_lawful_monad", "seq_eq_bind_map", "is_lawful_applicative", "comp.seq_assoc"]}, {"id": "has_to_tactic_format", "parentIds": ["prod.has_to_tactic_format", "reflected.has_to_tactic_format", "tactic.trace", "option_to_tactic_format", "tactic.pp", "option.has_to_tactic_format", "print_arguments", "hinst_lemma.has_to_tactic_format", "old_conv.trace", "native.rb_map.has_to_tactic_format", "smt_tactic.trace", "array.has_to_tactic_format", "module_info.has_to_tactic_format", "tactic.tactic.has_to_tactic_format", "smt_tactic.interactive.trace", "buffer.has_to_tactic_format", "expr.has_to_tactic_format", "tactic.explode.has_to_tactic_format", "tactic.interactive.trace", "tactic.interactive.has_to_tactic_format", "cc_state.has_to_tactic_format", "binder.has_to_tactic_format", "hinst_lemmas.has_to_tactic_format", "list.has_to_tactic_format", "tactic.pformat.has_to_tactic_format", "simp_lemmas.has_to_tactic_format", "has_to_format_to_has_to_tactic_format", "tactic.to_pfmt", "tactic.interactive.parse_config", "tactic.has_to_tactic_format"]}, {"id": "tactic", "parentIds": ["prod.has_to_tactic_format", "tactic.rcases.process_constructors", "tactic.eval_expr'", "tactic.mk_congr_arg", "tactic.unsafe_change", "tactic.clear_lst", "smt_tactic.interactive.assume", "tactic.simplify", "tactic.find_if_cond_at", "has_sizeof_derive_handler", "tactic.interactive.constructor", "tactic.get_subsingleton_info", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "tactic.replace_at", "tactic.library_search_hole_cmd", "cc_state.mk_using_hs_core", "tactic.trace", "conv.execute", "user_attribute.set_untyped", "tactic.mk_const", "tactic.first", "tactic.mk_eq_refl", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.instance_cache.get", "get_localized", "tactic.cc_dbg_core", "tactic.delta", "tactic.to_simp_lemmas", "tactic.interactive.skip", "tactic.i_to_expr_strict", "tactic.focus1", "print_content", "tactic.rintro_hint", "tactic.flat_assoc", "tactic.change", "old_conv", "tactic.interactive.with_cases", "pexpr.get_uninst_pis", "tactic.revertible_local_context", "tactic.apply_iff", "infer_type_cmd", "smt_tactic.failed", "tactic.interactive.rsimp", "option_to_tactic_format", "tactic.rewrite_core", "tactic.get_expl_arity", "tactic.mk_constructor_arg_names", "tactic.admit", "tactic.explode.core", "user_attribute.get_param_untyped", "tactic.unify", "tactic.copy_attribute", "well_founded_tactics.clear_internals", "tactic.find_same_type", "expr.mk_exists_lst", "tactic.rcases_hint.process_constructors", "tactic.using_new_ref", "tactic.mk_congr_fun", "tactic.pp", "tactic.injections_with", "tactic.interactive.any_goals", "smt_tactic.definev", "tactic.rotate", "tactic.mk_mapp", "tactic.interactive.contradiction", "tactic.interactive.refl", "tactic.open_namespaces", "tactic.build_list_expr_for_apply", "tactic.target", "tactic.interactive.recover", "tactic.explode.args", "tactic.save_const_type_info", "smt_tactic.interactive.destruct", "to_additive.target_name", "tactic.timetac", "tactic.focus", "smt_tactic.set_goals", "tactic.interactive.trivial", "tactic.find_assumption", "where.trace_namespace", "tactic.mk_assoc_pattern'", "cc_state.mk_using_hs", "smt_tactic.execute_with", "tactic.interactive.field_simp", "tactic.doc_string", "attribute.register", "tactic.cases", "tactic.existsi", "unused_arguments", "tactic.local_context", "tactic.cc_core", "ematch_state.internalize", "tactic.mk_comp", "tactic.back_lemmas_find", "tactic.apply_inj_lemma", "tactic.interactive.from", "tactic.mk_has_sizeof_instance_core", "smt_tactic.trace_state", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "tactic.mk_psigma", "tactic.instance_cache.append_typeclasses", "tactic.dsimplify", "tactic.interactive.loc.get_local_pp_names", "tactic.try_intros", "where.trace_variables", "tactic.mk_brec_on_rec_value", "attribute.get_instances", "tactic.simplify_top_down", "tactic.get_env", "where.mk_flag", "tactic.interactive.guard_tags", "old_conv.failed", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "simp_attr.pre_smt", "hole_command", "simp_lemmas.rewrite", "tactic.set_basic_attribute", "tactic.cleanup", "tactic.is_prop", "tactic.kdepends_on", "transport_multiplicative_to_additive", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "using_smt", "tactic.decl_name", "smt_tactic.interactive.guard_target", "tactic.enable_tags", "tactic.interactive.focus", "tactic.match_or", "tactic.mk_higher_order_type", "tactic.interactive.symmetry", "tactic.get_unused_decl_name", "tactic.apply_list_expr", "tactic.is_in_mathlib", "tactic.get_pi_binders", "tactic.interactive.by_contra", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "tactic.interactive.cc", "tactic.interactive.min_tac", "lean.parser.of_tactic", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "tactic.by_elim_opt", "old_conv.execute", "old_conv.trace", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "rbtree.default_lt", "old_conv.findp", "tactic.symm_apply", "tactic.revert_kdependencies", "tactic.interactive.unfold_coes", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "tactic.read_ref", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "tactic.symmetry_hyp", "tactic.note", "old_conv.dsimp", "tactic.interactive.apply_opt_param", "tactic.transport_with_prefix_fun", "tactic.interactive.apply_assumption", "tactic.is_assigned", "cc_state.proof_for", "interactive.executor", "tactic.elim_gen_sum", "localized_attr", "native.rb_map.has_to_tactic_format", "tactic.repeat1", "tactic.interactive.split_ifs", "tactic.save_type_info", "tactic.pis", "tactic.congr", "smt_tactic.trace", "tactic.mk_eq_mp", "to_additive.proceed_fields", "tactic.dunfold_head", "tactic.match_app_of", "tactic.interactive.clear_dependent", "cc_state.add", "push_neg.normalize_negations", "tactic.elide.replace", "tactic.interactive.rotate", "old_conv.change", "tactic.interactive.apply_iff_congr_core", "tactic.non_dep_prop_hyps", "use_cmd", "tactic.iterate_range", "where.trace_nl", "tactic.left", "smt_tactic.write", "tactic.interactive.triv", "tactic.mk_simp_attr", "tactic.assoc_refl", "array.has_to_tactic_format", "tactic.interactive.have_field", "smt_tactic", "tactic.independent_goal", "tactic.head_zeta", "tactic.dsimp_hyp", "ematch_lhs", "smt_tactic.interactive.have", "tactic.interactive.subst_vars", "tactic.mk_pattern", "tactic.match_subexpr", "tactic.mk_dec_eq_instance", "print_localized_commands", "tactic.suggest_scripts", "tactic.generalize_proofs", "tactic.interactive.refine", "tactic_format_expr", "nolint_attr", "register_attribute", "apply_nolint_cmd", "tactic.mk_instance", "interactive.loc.try_apply", "user_attribute.dflt_parser", "tactic.interactive.right", "to_additive.parser", "tactic.alias.alias_attr", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "tactic.result", "tactic.library_search", "tactic.econstructor", "tactic.interactive.clear_aux_decl", "can_lift_attr", "tactic.add_inductive", "tactic.match_hypothesis", "tactic.terminal_goal", "tactic.mk_local'", "tactic.interactive.clear'", "old_conv.apply_lemmas_core", "smt_tactic.monad_fail", "tactic.mk_user_fresh_name", "tactic.back_lemmas_add_extra", "simps_add_projection", "tactic.interactive.lift", "tactic.exact", "tactic.mk_mvar_list", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.down", "add_interactive", "old_conv.orelse", "smt_tactic.when", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "smt_tactic.slift", "localized_cmd", "tactic.unsafe.type_context.run", "tactic.join_user_simp_lemmas_core", "tactic.mk_eq_simp_ext", "tactic.mk_local_pisn", "tactic.choose1", "tactic.assertv_core", "old_conv.to_tactic", "old_conv.conversion", "tactic.extract_def", "tactic.interactive.continue", "tactic.delta_target", "tactic.whnf", "tactic.interactive.unfreezeI", "conv.interactive.guard_lhs", "tactic.norm_num", "tactic.interactive.abstract", "simps_tac", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "module_info.has_to_tactic_format", "tactic.tactic.has_to_tactic_format", "tactic.try_apply_opt_auto_param_for_apply", "tactic.back_lemmas_insert_core", "tactic.constr_to_prop", "tactic.ext", "tactic.interactive.econstructor", "tactic.local_proof", "smt_tactic.pose", "tactic.cc", "tactic.interactive.split", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "simp_lemmas.add", "push_neg.whnf_reducible", "tactic.solve_aux", "smt_tactic.add_ematch_lemma_core", "tactic.dsimplify_core", "tactic.ext_simplify_core", "tactic.try_for", "list.any_of", "tactic.suggest.message", "tactic.propositional_goal", "tactic.choose", "tactic.match_eq", "tactic.success_if_fail", "tactic.match_expr", "tactic.save_info", "cc_state.refutation_for", "smt_tactic.interactive.trace", "tactic.get_goal", "tactic.resolve_constant", "tactic.interactive.set", "well_founded_tactics.default_dec_tac'", "simp_lemmas.add_congr", "tactic.subst_core", "simp_lemmas.add_simp", "tactic.interactive.injections_and_clear", "smt_tactic.interactive.dsimp", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "tactic.returnopt", "tactic.assoc_root", "tactic.interactive.letI", "cc_state.pp_eqc", "tactic.mk_congr_lemma_simp", "tactic.match_assoc_pattern'", "tactic.intros_dep", "tactic.instance_stub", "tactic.mk_specialized_congr_lemma", "tactic.interactive.simp", "tactic.in_open_namespaces", "where.get_includes_core", "tactic.interactive.type_check", "lean.parser.get_includes", "tactic.updateex_env", "where.trace_includes", "smt_tactic.proof_for", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.trace_result", "no_rsimp", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.sleep", "tactic.rintro", "tactic.interactive.success_if_fail", "conv.funext", "old_conv.match_pattern", "tactic.change_with_at", "conv.interactive.done", "expr.get_pis", "tactic.match_target_subexpr", "tactic.reflexivity", "tactic.constructor_idx", "tactic.constructor_num_fields", "tactic.clear_aux_decl", "tactic.intro1", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "old_conv.funext", "tactic.interactive.refine_struct", "tactic.interactive.elide", "tactic.interactive.repeat", "hinst_lemma.pp", "tactic.interactive.rec.to_tactic_format", "tactic.has_attribute'", "tactic.is_type_app_of", "user_attribute.dflt_cache_cfg", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "simps_add_projections", "tactic.abstract", "tactic.interactive.iterate", "tactic.format_result", "tactic.interactive.rintros", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.whnf_no_delta", "tactic.interactive.try_for", "tactic.ematch_all_core", "conv.dsimp", "tactic.assert_core", "tactic.successes", "tactic.interactive.simp_core_aux", "tactic.get_simp_lemmas_or_default", "tactic.rcases_hint_core", "tactic.right", "tactic.frozen_local_instances", "tactic.fail_if_success", "buffer.has_to_tactic_format", "tactic.def_replacer_cmd", "tactic.trace_error", "tactic.mk_patterns", "tactic.generalizes", "tactic.istep", "tactic.interactive.clear", "tactic.interactive.injection", "smt_tactic.alternative", "tactic.interactive.exact", "doc_blame_report_defn", "tactic.interactive.existsi", "tactic.fapply", "tactic.assert", "tactic.apply_at_aux", "tactic.rewrite_hyp", "tactic.transport_with_prefix_dict", "tactic.match_heq", "tactic.interactive.suffices", "tactic.skip", "to_additive.map_namespace", "print_all_content", "tactic.get_string_option", "tactic.explode.may_be_proof", "tactic.iterate_exactly", "tactic.case_bash", "declaration.in_current_file", "tactic.elim_gen_prod", "interactive.executor.execute_with_explicit", "tactic.by_cases", "smt_tactic.to_expr", "rsimp_attr", "show_goal_cmd", "tactic.interactive.library_search", "tactic.add_theorem_by", "tactic.mk_app", "tactic.when_tracing", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "tactic.decorate_ex", "tactic.simp_intros_aux", "tactic.try_apply_opt_auto_param", "tactic.interactive.rename", "smt_tactic.interactive.add_simp_lemmas", "tactic.get_unused_decl_name_aux", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "conv.solve1", "tactic.mk_has_sizeof_instance", "smt_tactic.interactive.let", "conv.skip", "merge_hinst_lemma_attrs", "well_founded_tactics.cancel_nat_add_lt", "simp_lemmas.mk_default", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.interactive.all_goals", "tactic.ac_refl", "where.trace_opens", "tactic.get_pi_binders_aux", "tactic.set_main_tag", "tactic.to_expr_strict", "tactic.apply_heq_congr_core", "tactic.mk_constructors_arg_names", "tactic.lock_tactic_state", "old_conv.lhs", "tactic.read", "mk_hinst_lemma_attrs_core", "tactic.match_not", "tactic.interactive.exactI", "tactic.opt_to_tac", "tactic.enum_assoc_subexpr", "well_founded_tactics.is_psigma_mk", "smt_tactic.define", "find_cmd", "tactic.interactive.substs", "tactic.cc_dbg", "tactic.mk_local_pis_whnf", "rsimp.explicit_size", "ematch", "tactic.assoc_refl'", "smt_tactic.slift_aux", "tactic.try_core", "tactic.interactive.assume", "tactic.any_hyp", "control_laws_tac", "tactic.decl_mk_const", "tactic.interactive.assumption'", "tactic.interactive.collect_struct'", "tactic.iterate1", "tactic.rcases_hint.continue", "tactic.back_chaining", "tactic.interactive.haveI", "library_note_attr", "tactic.olean_doc_strings", "tactic.mk_local_pis", "tactic.write", "smt_tactic.save_info", "tactic.match_ne", "rsimp.rsimplify_at", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.interactive.compact_decl_aux", "tactic.dunfold_target", "smt_tactic.assertv", "tactic.introv", "tactic.suggest.apply_and_solve", "tactic.definev_core", "simp_attr.functor_norm", "tactic.mk_mvar", "simp_attr.norm", "hinst_lemma.mk_from_decl", "tactic.fill_args", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "tactic.eval_expr", "tactic.trace_state", "tactic.suggest_core", "tactic.local_def_value", "tactic.use", "tactic.comp_val", "well_founded_tactics.unfold_sizeof", "tactic.interactive.loc.get_local_uniq_names", "mnot", "old_conv.congr_core", "where.get_opens", "tactic.symmetry", "smt_tactic.fail", "user_attribute.get_cache", "apply_nolint_tac", "tactic.interactive.obtain", "smt_tactic.try", "tactic.interactive.itactic", "expr.is_eta_expansion_aux", "where.trace_end", "tactic.fold_explicit_args", "tactic.alias.mk_iff_mp_app", "expr.of_int", "tactic.simplify_bottom_up", "tactic.interactive.guard_hyp", "tactic.is_class", "tactic.pformat", "tactic.match_target", "tactic.ematch_core", "tactic.get_spec_subsingleton_info", "tactic.interactive.resetI", "tactic.interactive.reflexivity", "tactic.apply", "tactic.contradiction", "tactic.get_main_tag", "old_conv.apply_propext_lemmas_core", "lean.parser.has_coe'", "tactic.instantiate_mvars", "tactic.interactive.erw", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.try", "is_valid_simp_lemma", "tactic.set_env_core", "tactic.intron", "tactic.iterate'", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "tactic.is_instance", "smt_tactic.execute", "tactic.interactive.transitivity", "tactic.interactive.success_if_fail_with_msg", "tactic.split_ifs", "tactic.ancestor_attr", "tactic.set_nat_option", "tactic.simp_intros", "tactic.match_and", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.mk_back_lemmas_core", "interactive.loc.get_locals", "derive_handler", "tactic.define_core", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.to_expr'", "smt_tactic.monad_state", "get_ext_subject", "rsimp.to_repr_map", "smt_tactic.note", "tactic.step", "tactic.interactive.ext", "tactic.alias.alias_direct", "smt_tactic.istep", "tactic.interactive.unelide", "interactive.interactive.executor", "tactic.solve_by_elim", "conv", "lint_hole_cmd", "tactic.interactive.show", "tactic.ematch_all", "rsimp.collect_implied_eqs", "tactic.interactive.admit", "tactic.relation_lhs_rhs", "tactic.interactive.assoc_rw", "tactic.interactive.simp_intros", "tactic.head_beta", "tactic.dunfold_hyp", "attribute.fingerprint", "tactic.interactive.erewrite", "tactic.apply_congr_core", "where.get_variables_core", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "tactic.no_mvars_in_target", "tactic.iff_mpr", "simp_lemmas.rewrites", "tactic.retrieve", "tactic.join_user_simp_lemmas", "tactic.interactive.guard_target'", "tactic.explode_expr", "is_valid_simp_lemma_cnst", "tactic.unfold_projs", "tactic.unset_attribute", "tactic.head_eta", "copy_decl_using", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "fold_over_with_cond", "linter", "tactic.define", "user_attribute.set", "tactic.mk_specialized_congr_lemma_simp", "tactic.by_contradiction", "tactic.interactive.replace", "tactic.interactive.find", "tactic.interactive.subst", "simp_attr.split_if_reduction", "tactic.get_arity", "tactic.intros", "tactic.save_info_thunk", "tactic.rcases.continue", "tactic.find_ancestors", "tactic.interactive.clear_", "tactic.interactive.return_cast", "tactic.has_attribute", "conv.replace_lhs", "tactic.match_iff", "tactic.destruct", "tactic.set_string_option", "tactic.constructor", "smt_tactic.assert", "tactic.match_refl_app", "cc_state.pp_core", "tactic.head_eta_expand", "tactic.assertv", "tactic.revert_kdeps", "tactic.type_check", "tactic.andthen_seq_focus", "tactic.instantiate_mvars_in_goals", "tactic.get_pi_arity", "list.for_each", "tactic.rcases", "tactic.fsplit", "tactic.interactive.constructor_matching", "tactic.enum_assoc_subexpr'", "tactic.assoc_rewrite", "expr.simp", "open_locale_cmd", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "tactic.interactive.conv", "expr.dsimp", "tactic.resolve_name", "tactic.reset_instance_cache", "lean.parser.has_coe", "tactic.interactive.guard_expr_strict", "smt_tactic.has_monad_lift", "get_linters", "tactic.iterate", "smt_tactic.get_goals", "tactic.set_env", "tactic.interactive.trace_state", "tactic.subsingleton_goal", "tactic.revert", "tactic.mk_assoc", "tactic.ematch", "tactic.interactive.intro", "tactic.injection_with", "user_attribute_cache_cfg", "tactic.interactive.convert_to", "tactic.set_tag", "tactic.induction", "tactic.unfold_proj", "tactic.save_options", "smt_tactic.interactive.apply", "tactic.interactive.funext", "tactic.interactive.congr'", "tactic.lambdas", "get_attribute_cache_dyn", "tactic.interactive.assoc_rewrite", "tactic.subst_vars", "tactic.fconstructor", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "tactic.rename", "tactic.interactive.exacts", "tactic.interactive.change", "tactic.collect_ctx_simps", "tactic.simp_bottom_up'", "tactic.match_stub", "tactic.mk_constructor_fresh_names", "tactic.interactive.refine_recursively", "tactic.delta_hyp", "tactic.interactive.trace", "tactic.interactive.has_to_tactic_format", "tactic.i_to_expr_no_subgoals", "list_linters", "tactic.fold_explicit_args_aux", "lint_aux", "get_hinst_lemmas_for_attr", "tactic.interactive.list_cast_of", "tactic.get_decl", "tactic.interactive.simp_core", "well_founded_tactics.unfold_wf_rel", "tactic.any_hyp_aux", "user_attribute", "tactic.def_replacer", "tactic.injection", "tactic.interactive.conv_rhs", "well_founded_tactics.trivial_nat_lt", "tactic.interactive.done", "tactic.is_def_eq", "tactic.interactive.match_target", "tactic.mk_eq_mpr", "tactic.zeta", "binder.has_to_tactic_format", "to_hinst_lemmas_core", "tactic.mk_simp_set_core", "tactic.whnf_ginductive", "tactic.interactive.async", "debugger.attr", "tactic.back_chaining_using", "tactic.simp_hyp", "tactic.explode.format_aux", "derive_handler_attr", "tactic.iterate_at_most_on_all_goals", "tactic.back_lemmas_insert", "linter.doc_blame", "tactic.get_options", "tactic.repeat", "tactic.mk_eq_trans", "tactic.solve1", "smt_tactic.monad", "tactic.iterate_at_most", "tactic.cases_core", "tactic.get_tag", "tactic.alias.alias_iff", "tactic.ex_to_tac", "conv.interactive.for", "tactic.rotate_left", "tactic.andthen_seq", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "tactic.mk_local_def", "list.has_to_tactic_format", "tactic.interactive.mapply", "cc_state.is_not_eqv", "tactic.interactive.specialize", "smt_tactic.read", "get_name_set_for_attr", "tactic.get_assignment", "tactic.mk_meta_pis", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "tactic.kabstract", "tactic.interactive.apply_with", "tactic.interactive.left", "tactic.interactive.exfalso", "old_conv.whnf", "tactic.pose", "tactic.match_pattern", "tactic.funext", "tactic.apply_core", "tactic.mk_congr", "tactic.interactive.fapply", "tactic.swap", "tactic.get_nat_option", "tactic.interactive.apply_auto_param", "old_conv.find", "tactic.split", "tactic.interactive.try", "lean.parser.itactic", "fold_over_with_cond_sorted", "tactic.instantiate_mvars_in_target", "tactic.solve_by_elim_aux", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.returnex", "tactic.dsimp_target", "where.trace_where", "tactic.interactive.casesm", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "tactic.mk_meta_var", "expr.is_eta_expansion", "expr.drop_pis", "tactic.unfold_projs_target", "tactic.select", "tactic.apply_rules", "tactic.simp_all", "tactic.rexact", "rsimp.rsimplify", "tactic.unfreeze_local_instances", "tactic.up", "tactic.mk_fresh_name", "tactic.intro1_aux", "simp_lemmas.append", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "tactic.rsimp", "tactic.iff_mp", "tactic.add_decl", "tactic.interactive.guard_expr_eq'", "tactic.mk_constructors_fresh_names", "tactic.alias.get_alias_target", "where.is_variable_name", "cc_state.proof_for_false", "tactic.add_meta_definition", "tactic.get_ancestors", "tactic.dunfold", "tactic.assumption", "tactic.is_proof", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "tactic.infer_type", "tactic.interactive.apply_instance", "tactic.chain_eq_trans", "tactic.add_doc_string", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "tactic.replace_target", "smt_tactic.by_contradiction", "tactic.trace_call_stack", "tactic.mk_replacer", "tactic.interactive.guard_target", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "tactic.intro_core", "tactic.trace_algebra_info", "tactic.mk_num_meta_univs", "tactic.try_lst", "tactic.replacer_core", "instance_priority", "unfolds_to_class", "tactic.interactive.introI", "tactic.clear", "tactic.interactive.dunfold", "tactic.interactive.rw", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "tactic.mk_back_lemmas", "instance_derive_handler", "tactic.inhabited_instance", "smt_tactic.interactive.rsimp", "tactic.get_local", "tactic.set_goals", "lean.parser.itactic_reflected", "tactic.get_fun_info", "tactic.interactive.extract_goal", "tactic.alternative", "conv.istep", "tactic.seq", "tactic.get_mathlib_dir", "smt_tactic.induction", "tactic.interactive.have", "using_smt_with", "old_conv.pure", "environment.mfilter", "tactic.definev", "tactic.interactive.field", "tactic_to_smt_tactic", "has_to_tactic_format", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "tactic.add_defn_equations", "tactic.local_decls", "tactic.delta_instance", "smt_tactic.interactive.simp", "hinst_lemma.mk_from_decl_core", "tactic.interactive.injections", "tactic.mk_hcongr_lemma", "get_checks", "tactic.interactive.clear_except", "tactic.interactive.fail_if_success", "tactic.flatten", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "cc_state.internalize", "smt_tactic.interactive.apply_instance", "tactic.mk_inj_eq", "well_founded_tactics.process_lex", "smt_tactic.interactive.change", "tactic.applyc", "smt_tactic.interactive.add_fact", "tactic.unify_prefix", "smt_tactic.has_coe", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.interactive.apply_rules", "tactic.triv", "tactic.interactive.destruct", "tactic.revert_lst", "old_conv.seq", "tactic.simp_config_ext", "tactic.decidable_eq_derive_handler", "where.format_variable", "tactic.interactive.h_generalize", "tactic.get_univ_assignment", "interactive.param_desc", "tactic.interactive.intros", "tactic.funext_lst", "tactic.interactive.ac_change", "tactic.alias.make_left_right", "has_to_format_to_has_to_tactic_format", "well_founded_tactics", "tactic.interactive.fsplit", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "tactic.has_append", "tactic.funext_core", "tactic.injections_and_clear", "saturate_fun", "smt_tactic.destruct", "tactic.interactive.choose", "tactic.rotate_right", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "tactic.set_options", "tactic.interactive.source_fields", "tactic.interactive.solve1", "tactic.to_pfmt", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "tactic.interactive.fconstructor", "tactic.write_ref", "tactic.explode_cmd", "conv.convert", "tactic.find_private_decl", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "tactic.split_if1", "has_reflect_derive_handler", "tactic.induction'", "tactic.any_goals", "where.compile_variable_list", "doc_blame_report_thm", "tactic.rcases_core", "tactic.mk_eq_proof", "tactic.interactive.introsI", "tactic.rename'", "tactic.resolve_name'", "tactic.solve", "simp_lemmas.pp", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "interactive.executor.execute_explicit", "tactic.interactive.classical", "tactic.mk_eq_symm", "tactic.interactive.suggest", "tactic.get_unused_name", "tactic.has_to_tactic_format", "tactic.interactive.contrapose", "tactic.get_goals", "environment.get_modifiers", "tactic.to_expr", "tactic.interactive.ac_reflexivity", "old_conv.fail", "tactic.suggest.library_defs", "tactic.failed", "tactic.interactive.push_neg", "simp_lemmas.dsimplify", "tactic.get_user_simp_lemmas", "tactic.interactive.conv_lhs", "tactic.intros1", "tactic.get_bool_option", "tactic.backward_chaining_core", "derive_struct_ext_lemma", "tactic.exact_dec_trivial", "cc_state.is_eqv", "smt_tactic.refutation_for", "tactic.mk_instance_cache", "old_conv.map", "tactic.interactive.rewrite", "lint_mathlib", "tactic.intro_lst", "tactic.done", "tactic.reduce_ifs_at", "tactic.num_goals", "tactic.clear_aux_decl_aux", "ge_or_gt_in_statement", "lint_all", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "tactic.interactive.collect_struct", "tactic.interactive.sorry", "has_inhabited_instance", "tactic.interactive.apply", "tactic.run_async", "old_conv.lift_tactic", "dedup", "tactic.import_private_cmd", "tactic.expanded_field_list", "tactic.transitivity", "tactic.interactive.delta", "tactic.metavariables", "simp_lemmas.drewrite", "tactic.success_if_fail_with_msg", "dup_namespace", "tactic.triv'", "old_conv.mk_match_expr", "tactic.congr_core", "tactic.unfold_projs_hyp", "hinst_lemma.mk_core", "tactic.apply_opt_param", "tactic.i_to_expr", "expr.of_nat", "conv.discharge_eq_lhs", "tactic.add_aux_decl", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "tactic.interactive.congr", "tactic.interactive.ac_refl", "cc_state.eqv_proof", "tactic.get_pi_binders_dep_aux", "print_name", "tactic.mk_sorry", "smt_tactic.interactive.fapply", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "tactic.pexpr_to_pattern", "user_attribute.get_param", "tactic.get_local_type", "tactic.perm_ac", "tactic.interactive.comp_val", "tactic.mk_simp_set", "tactic.get_pi_binders_dep", "tactic.interactive.compact_decl", "tactic.interactive.generalize_proofs", "well_founded_tactics.check_target_is_value_lt", "tactic.tags_enabled", "tactic.module_doc_strings", "tactic.get_spec_prefix_size", "tactic.eapply", "tactic.interactive.assumption", "tactic.apply_at", "tactic.get_eqn_lemmas_for", "tactic.mk_meta_univ", "tactic.note_anon", "tactic.fail", "tactic.match_fn", "tactic.mk_congr_lemma", "transport_with_dict", "tactic.get_expl_pi_arity", "tactic.is_simp_lemma", "old_conv.match_expr", "tactic.generalize"]}, {"id": "applicative", "parentIds": ["prod.has_to_tactic_format", "tactic.interactive.record_lit", "lean.parser.sep_by", "smt_tactic.interactive.assume", "except_t.lift", "has_sizeof_derive_handler", "tactic.strip_prefix", "interactive.types.ident_", "id.is_comm_applicative", "comp.applicative", "tactic.rintro_hint", "tactic.revertible_local_context", "comp.run_pure", "comp.map_pure", "to_additive.target_name", "option.is_lawful_monad", "mjoin_map_map", "option_t.run_pure", "lean.parser.reflectable.optional", "guard", "unused_arguments", "applicative_transformation.preserves_map", "applicative.map_seq_map", "optional", "functor.add_const.is_lawful_applicative", "tactic.apply_inj_lemma", "print_arguments", "smt_tactic.interactive.induction", "tactic.interactive.loc.get_local_pp_names", "interactive.types.only_flag", "tactic.rcases_hint", "simp_attr.pre_smt", "except_t.run_pure", "option.traversable", "restate_axiom", "tactic.interactive.convert", "string.get_rest", "bind_pure", "reader_t.run_read", "tactic.replacer", "applicative_transformation", "tactic.interactive.induction", "succeeds", "option_t.fail", "opt_minus", "state_t.run_map", "localized_attr", "to_additive.proceed_fields", "expr.to_int", "sum.is_lawful_monad", "tactic.interactive.rename'_args_parser", "reader_t.run_map", "lean.parser.val", "tactic.mk_simp_attr", "tactic.mllist.empty", "interactive.types.with_ident_list", "user_attribute.parse_reflect", "ematch_lhs", "smt_tactic.interactive.have", "parser.alternative", "reader_t.run_pure", "nolint_attr", "user_attribute.dflt_parser", "to_additive.parser", "parser.sep_by1", "tactic.alias.alias_attr", "tactic.unsafe.type_context.list_mvars", "can_lift_attr", "tactic.terminal_goal", "tactic.to_texpr", "native.rb_set.mfilter", "option_t.run_map", "simps_add_projection", "tactic.trace_macro", "tactic.ext_parse", "where.get_def_variables", "tactic.interactive.generalize_hyp", "except_t.return", "comp.seq_mk", "is_comm_applicative", "task.monad", "tactic.extract_def", "state_t.put", "expr.mfoldl", "tactic.interactive.let", "monad_from_pure_bind", "ext_param", "tactic.try_apply_opt_auto_param_for_apply", "state_t.run_adapt", "tactic.rintro_parse", "interactive.types.without_ident_list", "expr.traverse", "mjoin_pure", "tactic.match_expr", "parser.is_lawful_monad", "tactic.resolve_constant", "sum.monad", "parser.monad", "tactic.interactive.change'", "lint", "tactic.interactive.letI", "reader_t.is_lawful_monad", "comp.seq", "is_comm_applicative.commutative_map", "comp.has_seq", "no_rsimp", "functor.const.applicative", "except.monad", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "tactic.interactive.rw_rule_p", "parser.many1", "tactic.interactive.rec.to_tactic_format", "user_attribute.dflt_cache_cfg", "tactic.interactive.guard_hyp_strict", "tactic.interactive.ext1", "fish_pipe", "tactic.interactive.squeeze_simpa", "tactic.successes", "comp.run_seq", "id.map_eq", "tactic.def_replacer_cmd", "tactic.mk_patterns", "except_t.run_map", "state_t.run_monad_lift", "lean.parser.get_namespace", "state_t.run_get", "functor.comp.functor_id_comp", "tactic.interactive.suffices", "reader_t.read", "to_additive.map_namespace", "mzip_with'", "tactic.rcases_parse_depth", "functor.comp.functor_comp_id", "rsimp_attr", "applicative_transformation.preserves_seq", "state_t.alternative", "list.traversable", "tactic.explode", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "state_t.lift", "name_set.mfilter", "smt_tactic.interactive.let", "except_t.run_monad_lift", "linter_attr", "mjoin_map_pure", "comp.applicative_id_comp", "interactive.types.pexpr_list_or_texpr", "comp.has_pure", "mtry", "tactic.enum_assoc_subexpr", "tactic.mllist.range", "ematch", "option_t.pure", "tactic.interactive.assume", "tactic.decl_mk_const", "tactic.interactive.haveI", "library_note_attr", "tactic.list_constructors_hole", "simp_attr.functor_norm", "simp_attr.norm", "tactic.unsafe.type_context.monad", "name_with_opt", "alternative", "tactic.interactive.loc.get_local_uniq_names", "interaction_monad.monad", "where.get_opens", "id.is_lawful_monad", "tactic.unsafe.type_context.print_mvars", "parser.many_char1", "expr.is_eta_expansion_aux", "tactic.interactive.guard_hyp", "map_seq", "tactic.interactive.generalize", "native.rb_map.mfilter", "tactic.iterate'", "tactic.find_local", "comp.is_comm_applicative", "tactic.ancestor_attr", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "is_lawful_traversable", "tactic.interactive.rename'_arg_parser", "tactic.interactive.ext", "tactic.alias.alias_direct", "comp.pure_seq_eq_map", "where.get_variables_core", "tactic.no_mvars_in_target", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "applicative_transformation.has_coe_to_fun", "list.monad", "fold_over_with_cond", "tactic.interactive.replace", "functor.const.is_lawful_applicative", "simp_attr.split_if_reduction", "tactic.interactive.return_cast", "except_t.adapt", "assert", "tactic.mllist.monad_lift", "applicative.pure_seq_eq_map'", "old_conv.monad", "native.rb_map.mmap", "tactic.suggest.process_declaration", "sum.traverse", "parser.run", "tactic.assoc_rewrite", "tactic.interactive.conv", "tactic.interactive.guard_expr_strict", "simps_parser", "option.alternative", "exceptional.monad", "list.is_lawful_monad", "tactic.interactive.convert_to", "applicative.ext", "state_t.run_put", "when", "tactic.interactive.change", "tactic.simp_bottom_up'", "tactic.match_stub", "seq_bind_eq", "guard_true", "tactic.interactive.has_to_tactic_format", "monad", "tactic.interactive.list_cast_of", "vm_core.monad", "tactic.interactive.conv_rhs", "pure_id_seq", "traversable", "lean.parser.reflectable.expr", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "except_t.monad_except", "debugger.attr", "sum.is_lawful_functor", "state_t.monad_state", "derive_handler_attr", "is_lawful_applicative.map_comp_pure", "linter.doc_blame", "reader_t.pure", "tactic.using_texpr", "state_t.modify", "mjoin_map_mjoin", "id.monad", "tactic.unsafe.type_context.orelse", "reader_t.alternative", "tactic.alias.alias_iff", "seq_map_assoc", "tactic.interactive.simpa", "tactic.unsafe.type_context.trace", "list.has_to_tactic_format", "sequence", "comp.applicative_comp_id", "tactic.interactive.refine_one", "except_t.is_lawful_monad", "return", "name_set.mmap", "tactic.interactive.guard_expr_eq", "impossible_instance", "parser.many_char", "incorrect_type_class_argument", "except_t.monad", "state_t.pure", "tactic.interactive.guard_expr_eq'", "option.traverse", "tactic.alias.get_alias_target", "tactic.get_ancestors", "pure_id'_seq", "state_t.monad", "tactic.mk_assoc_instance", "fish_pure", "tactic.interactive.rw_rules", "mk_hinst_lemma_attr_set", "id.pure_eq", "mzip_with", "instance_derive_handler", "tactic.inhabited_instance", "tactic.simp_arg_list", "option.monad", "tactic.simp_arg", "tactic.interactive.have", "tactic.interactive.field", "applicative_transformation.preserves_pure", "is_lawful_monad", "tactic.interactive.erase_simp_args", "tactic.local_decls", "tactic.delta_instance", "sum.traversable", "get_checks", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "guard_false", "tactic.interactive.get_current_field", "tactic.rcases_patt_parse_core", "tactic.decidable_eq_derive_handler", "tactic.interactive.h_generalize", "interactive.param_desc", "map_bind", "tactic.interactive.ac_change", "tactic.alias.make_left_right", "functor.add_const.applicative", "tactic.replaceable_attr", "mk_name_set_attr", "tactic.interactive.case", "tactic.has_append", "comp.is_lawful_applicative", "saturate_fun", "tactic.interactive.choose", "dangerous_instance", "mk_hinst_lemma_attr_core", "option_t.is_lawful_monad", "tactic.interactive.source_fields", "interactive.types.using_ident", "tactic.interactive.parse_config", "tactic.find_private_decl", "comp.seq_pure", "option_t.monad", "id.traversable", "has_reflect_derive_handler", "where.compile_variable_list", "tactic.mk_eq_proof", "tactic.rename'", "reader_t.monad", "tactic.resolve_name'", "tactic.replacer_attr", "tactic.subst", "option_t.run_monad_lift", "state_t.is_lawful_monad", "option_t.lift", "interactive.types.location", "list.traverse", "seq_eq_bind_map", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "derive_struct_ext_lemma", "lint_mathlib", "lint_all", "tactic.interactive.collect_struct", "has_inhabited_instance", "state_t.run_pure", "tactic.import_private_cmd", "tactic.expanded_field_list", "state_t.get", "tactic.metavariables", "interactive.types.brackets", "tactic.fail_macro", "is_lawful_applicative", "smt_tactic.num_goals", "tactic.mk_simp_set", "comp.seq_assoc", "tactic.module_doc_strings", "tactic.match_fn", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "tactic.alternative", "parentIds": ["prod.has_to_tactic_format", "has_sizeof_derive_handler", "tactic.interactive.squeeze_simp", "tactic.replace_at", "tactic.strip_prefix", "tactic.delta", "tactic.apply_iff", "to_additive.target_name", "tactic.interactive.trivial", "tactic.cases", "tactic.existsi", "tactic.apply_inj_lemma", "tactic.simplify_top_down", "tactic.interactive.guard_tags", "tactic.rcases_hint", "restate_axiom", "conv.alternative", "tactic.interactive.get_rule_eqn_lemmas", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.symm_apply", "to_additive.proceed_fields", "tactic.match_app_of", "tactic.interactive.triv", "tactic.assoc_refl", "ematch_lhs", "nolint_attr", "tactic.alias.alias_attr", "tactic.library_search", "tactic.terminal_goal", "simps_add_projection", "tactic.interactive.unfold_projs", "old_conv.orelse", "old_conv.conversion", "tactic.try_apply_opt_auto_param_for_apply", "tactic.constr_to_prop", "tactic.propositional_goal", "tactic.match_expr", "tactic.resolve_constant", "well_founded_tactics.default_dec_tac'", "tactic.interactive.congr_core'", "tactic.mk_iff_of_inductive_prop", "tactic.apply_assumption", "conv.funext", "old_conv.funext", "tactic.has_attribute'", "user_attribute.dflt_cache_cfg", "tactic.interactive.unfold_aux", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_core_aux", "smt_tactic.alternative", "doc_blame_report_defn", "tactic.by_cases", "tactic.mk_inhabited_instance", "tactic.try_apply_opt_auto_param", "old_conv.find_pattern", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "old_conv.interactive.find", "tactic.apply_heq_congr_core", "ematch", "library_note_attr", "tactic.suggest.apply_and_solve", "tactic.apply_eq_congr_core", "tactic.suggest_core", "tactic.use", "tactic.comp_val", "old_conv.congr_core", "tactic.simplify_bottom_up", "tactic.contradiction", "old_conv.apply_propext_lemmas_core", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.ancestor_attr", "interactive.loc.get_locals", "conv.interactive.find", "tactic.relation_lhs_rhs", "tactic.no_mvars_in_target", "tactic.iff_mpr", "tactic.explode_expr", "tactic.interactive.concat_tags", "tactic.by_contradiction", "tactic.interactive.clear_", "tactic.interactive.return_cast", "tactic.rcases", "tactic.assoc_rewrite", "tactic.interactive.guard_expr_strict", "get_linters", "tactic.mk_simp_set_core", "debugger.attr", "derive_handler_attr", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.ext1", "list.has_to_tactic_format", "tactic.interactive.refine_one", "old_conv.find", "tactic.interactive.guard_expr_eq", "tactic.apply_rules", "rsimp.rsimplify", "tactic.iff_mp", "tactic.alias.get_alias_target", "tactic.get_ancestors", "tactic.assumption", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "instance_priority", "instance_derive_handler", "tactic.inhabited_instance", "interactive.loc.apply", "tactic.mk_inj_eq", "tactic.decidable_eq_derive_handler", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "tactic.interactive.case", "mk_hinst_lemma_attr_core", "has_reflect_derive_handler", "doc_blame_report_thm", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "environment.get_modifiers", "derive_struct_ext_lemma", "tactic.reduce_ifs_at", "tactic.get_classes", "tactic.congr_core", "tactic.suggest.apply_declaration", "tactic.mk_simp_set", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings"]}, {"id": "functor", "parentIds": ["prod.has_to_tactic_format", "tactic.interactive.record_lit", "lean.parser.sep_by", "smt_tactic.interactive.assume", "except_t.lift", "functor.map_comp_map", "tactic.strip_prefix", "id.is_comm_applicative", "comp.applicative", "functor.map_const_rev", "comp.map_pure", "option.is_lawful_monad", "mjoin_map_map", "lean.parser.reflectable.optional", "unused_arguments", "applicative_transformation.preserves_map", "applicative.map_seq_map", "optional", "functor.add_const.is_lawful_applicative", "tactic.apply_inj_lemma", "print_arguments", "tactic.interactive.loc.get_local_pp_names", "string.get_rest", "bind_pure", "ulift.functor", "tactic.replacer", "opt_minus", "state_t.run_map", "is_lawful_functor", "to_additive.proceed_fields", "expr.to_int", "functor.comp.functor", "sum.is_lawful_monad", "tactic.interactive.rename'_args_parser", "reader_t.run_map", "lean.parser.val", "tactic.mllist.empty", "user_attribute.parse_reflect", "functor.comp.comp_map", "parser.alternative", "to_additive.parser", "parser.sep_by1", "functor.const.is_lawful_functor", "tactic.terminal_goal", "option_t.run_map", "tactic.ext_parse", "functor.comp.map_mk", "where.get_def_variables", "tactic.interactive.generalize_hyp", "comp.seq_mk", "is_comm_applicative", "task.monad", "tactic.extract_def", "expr.mfoldl", "monad_from_pure_bind", "ext_param", "tactic.try_apply_opt_auto_param_for_apply", "tactic.rintro_parse", "expr.traverse", "tactic.match_expr", "parser.is_lawful_monad", "sum.monad", "parser.monad", "lint", "reader_t.is_lawful_monad", "is_comm_applicative.commutative_map", "set.functor", "functor.const.applicative", "except.monad", "functor.comp.map", "tactic.interactive.rw_rule_p", "parser.many1", "tactic.successes", "comp.run_seq", "functor.add_const.functor", "id.map_eq", "except_t.run_map", "lean.parser.get_namespace", "functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "state_t.alternative", "tactic.subobject_names", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "except_t.run_monad_lift", "mjoin_map_pure", "interactive.types.pexpr_list_or_texpr", "tactic.enum_assoc_subexpr", "tactic.interactive.assume", "tactic.decl_mk_const", "tactic.list_constructors_hole", "tactic.unsafe.type_context.monad", "name_with_opt", "tactic.interactive.loc.get_local_uniq_names", "interaction_monad.monad", "where.get_opens", "id.is_lawful_monad", "parser.many_char1", "expr.is_eta_expansion_aux", "applicative", "map_seq", "native.rb_map.mfilter", "functor.map_id", "tactic.iterate'", "tactic.find_local", "comp.is_comm_applicative", "tactic.alias.alias_cmd", "is_lawful_traversable", "tactic.interactive.rename'_arg_parser", "tactic.alias.alias_direct", "comp.pure_seq_eq_map", "where.get_variables_core", "tactic.no_mvars_in_target", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "list.monad", "fold_over_with_cond", "functor.const.is_lawful_applicative", "except_t.adapt", "tactic.mllist.monad_lift", "id_map'", "applicative.pure_seq_eq_map'", "old_conv.monad", "native.rb_map.mmap", "tactic.suggest.process_declaration", "functor.comp.is_lawful_functor", "simps_parser", "option.alternative", "exceptional.monad", "list.is_lawful_monad", "map_ext_congr", "applicative.ext", "tactic.simp_bottom_up'", "seq_bind_eq", "functor.comp.run_map", "tactic.interactive.list_cast_of", "vm_core.monad", "pure_id_seq", "traversable", "lean.parser.reflectable.expr", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "sum.is_lawful_functor", "is_lawful_applicative.map_comp_pure", "linter.doc_blame", "mjoin_map_mjoin", "id.monad", "reader_t.alternative", "tactic.alias.alias_iff", "seq_map_assoc", "list.has_to_tactic_format", "comp.applicative_comp_id", "tactic.interactive.refine_one", "except_t.is_lawful_monad", "impossible_instance", "parser.many_char", "incorrect_type_class_argument", "except_t.monad", "tactic.get_ancestors", "state_t.monad", "tactic.mk_assoc_instance", "tactic.interactive.rw_rules", "functor.const.functor", "option.monad", "tactic.simp_arg", "is_lawful_monad", "tactic.delta_instance", "get_checks", "functor.comp.id_map", "tactic.interactive.get_current_field", "tactic.rcases_patt_parse_core", "tactic.interactive.h_generalize", "interactive.param_desc", "map_bind", "functor.add_const.applicative", "tactic.has_append", "saturate_fun", "tactic.interactive.choose", "dangerous_instance", "option_t.is_lawful_monad", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "comp.seq_pure", "option_t.monad", "where.compile_variable_list", "reader_t.monad", "tactic.subst", "option_t.run_monad_lift", "state_t.is_lawful_monad", "option_t.lift", "interactive.types.location", "seq_eq_bind_map", "functor.ext", "derive_struct_ext_lemma", "lint_mathlib", "lint_all", "tactic.interactive.collect_struct", "has_inhabited_instance", "tactic.expanded_field_list", "tactic.metavariables", "is_lawful_applicative", "smt_tactic.num_goals", "tactic.mk_simp_set", "comp.seq_assoc", "map_map", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "prod.has_to_format", "parentIds": ["prod.has_to_tactic_format"]}, {"id": "format.has_to_format", "parentIds": ["prod.has_to_tactic_format", "tactic.interactive.squeeze_simp", "param_info.to_format", "where.trace_namespace", "tactic.cc_core", "smt_tactic.trace_state", "where.trace_variables", "tactic.clear'", "tactic.interactive.rcases", "tactic.assoc_refl", "ematch_lhs", "smt_tactic.monad_fail", "simps_add_projection", "old_conv.conversion", "tactic.instance_stub", "where.trace_includes", "tactic.trace_result", "tactic.unprime", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.interactive.squeeze_simpa", "tactic.trace_error", "tactic.mk_patterns", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.eqn_stub", "where.trace_opens", "ematch", "tactic.list_constructors_hole", "tactic.trace_state", "tactic.local_def_value", "tactic.use", "tactic.unsafe.type_context.print_mvars", "where.trace_end", "tactic.interactive.rintro", "get_linters", "hinst_lemmas.pp", "tactic.match_stub", "tactic.interactive.simpa", "tactic.ext1", "list.has_to_tactic_format", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "tactic.get_lift_prf", "mk_hinst_lemma_attr_core", "tactic.interactive.trace_simp_set", "tactic.rename'", "tactic.replacer_attr", "equiv_type_constr", "tactic.has_to_tactic_format", "tactic.success_if_fail_with_msg", "interaction_monad.monad_fail"]}, {"id": "to_fmt", "parentIds": ["prod.has_to_tactic_format", "tactic.interactive.squeeze_simp", "name.has_to_format", "tactic.interactive.format_names", "tactic_state.has_to_string", "array.has_to_format", "option_to_tactic_format", "print_decls_sorted", "param_info.to_format", "where.trace_namespace", "unused_arguments", "format.when", "sigma.has_to_format", "tactic.cc_core", "print_arguments", "where.trace_variables", "sum_has_to_format", "tactic.clear'", "tactic.interactive.rcases", "name_set.has_to_format", "native.rb_map.has_to_tactic_format", "subtype.has_to_format", "tactic.assoc_refl", "print_decls", "ematch_lhs", "smt_tactic.monad_fail", "simps_add_projection", "occurrences_to_format", "old_conv.conversion", "native.has_to_format", "tactic.unsafe.type_context.monad_fail", "reflected.has_to_format", "tactic.instance_stub", "where.trace_includes", "tactic.unprime", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.guard_hyp_nums", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "print_decls_sorted_mathlib", "tactic.mk_inhabited_instance", "tactic.explode", "interaction_monad.mk_exception", "tactic.eqn_stub", "where.trace_opens", "ematch", "tactic.list_constructors_hole", "tactic.trace_state", "tactic.local_def_value", "tactic.use", "tactic.unsafe.type_context.print_mvars", "native.rb_set.has_to_format", "where.trace_end", "prod.has_to_format", "option.has_to_format", "vm.trace", "list.to_format", "get_linters", "hinst_lemmas.pp", "tactic.match_stub", "buffer.has_to_format", "tactic.interactive.has_to_tactic_format", "lint_aux", "unsigned.has_to_format", "trace_val", "tactic.interactive.simpa", "tactic.ext1", "tactic.unsafe.type_context.trace", "list.has_to_tactic_format", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "format.bracket", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "interactive.param_desc", "has_to_format_to_has_to_tactic_format", "mk_hinst_lemma_attr_core", "local_context.to_format", "tactic.rename'", "tactic.replacer_attr", "equiv_type_constr", "tactic.has_to_tactic_format", "format.dcbrace", "tactic.success_if_fail_with_msg", "unit.has_to_format", "interaction_monad.monad_fail", "module_info.has_to_format"]}, {"id": "tactic.rcases.process_constructors", "parentIds": []}, {"id": "tactic.list_Sigma", "parentIds": ["tactic.rcases.process_constructors", "tactic.rcases_hint.process_constructors", "tactic.interactive.rcases", "tactic.rcases_patt_inverted.format_list", "tactic.rcases_patt.name", "tactic.rcases_patt", "tactic.ext_parse", "tactic.rintro_parse", "tactic.rcases_patt.invert_many", "tactic.interactive.obtain_parse", "tactic.rcases_parse", "tactic.interactive.obtain", "tactic.rcases_patt.invert", "tactic.rcases_patt_inverted.invert", "tactic.rcases", "tactic.rcases_patt.invert_list", "tactic.rcases_patt_inverted", "tactic.rcases_patt_parse_core", "tactic.rcases_patt_inverted.invert_list", "tactic.rcases_core", "tactic.rcases_patt_parse_list"]}, {"id": "tactic.list_Pi", "parentIds": ["tactic.rcases.process_constructors", "tactic.rintro_hint", "tactic.rcases_hint.process_constructors", "tactic.rcases.process_constructor", "tactic.interactive.rcases", "tactic.rcases_patt.name", "tactic.rcases_patt", "tactic.rintro_parse", "tactic.rcases_patt.invert_many", "tactic.rintro", "tactic.lift", "tactic.interactive.rintros", "tactic.rcases_parse", "tactic.rcases_hint.continue", "tactic.interactive.rintro", "tactic.rcases.continue", "tactic.rcases", "tactic.rcases_patt.invert_list", "tactic.rcases_patt_inverted", "tactic.ext_patt", "tactic.rcases_patt_parse_core", "tactic.rcases_patt.invert'", "tactic.rcases_patt_inverted.invert_list", "tactic.rcases_core"]}, {"id": "tactic.rcases_patt", "parentIds": ["tactic.rcases.process_constructors", "tactic.rintro_hint", "tactic.rcases_hint.process_constructors", "tactic.rcases.process_constructor", "tactic.rcases_hint", "tactic.rcases_patt.format", "tactic.interactive.rcases", "tactic.rcases_patt.merge", "tactic.rcases_patt.name", "tactic.ext_parse", "tactic.rintro_parse", "tactic.rcases_patt.invert_many", "tactic.rintro", "tactic.interactive.ext1", "tactic.lift", "tactic.interactive.rintros", "tactic.rcases_hint_core", "tactic.rcases_parse", "tactic.rcases_patt.has_to_format", "tactic.rcases_hint.continue", "tactic.rcases_patt.invert", "tactic.rcases_patt.inhabited", "tactic.interactive.ext", "tactic.interactive.rintro", "tactic.rcases.continue", "tactic.rcases_patt_inverted.invert", "tactic.rcases", "tactic.rcases_patt.invert_list", "tactic.ext_patt", "tactic.rcases_patt.invert'", "tactic.rcases_patt_inverted.invert_list", "tactic.rcases_core", "tactic.rcases_patt.has_reflect"]}, {"id": "dlist", "parentIds": ["tactic.rcases.process_constructors", "dlist.to_list_empty", "tactic.mk_assoc_pattern'", "dlist.to_list_concat", "dlist.to_list_cons", "dlist.of_list_to_list", "dlist.concat", "parser.mk_error_msg", "dlist.lazy_of_list", "dlist.to_list_append", "dlist.cons", "dlist.join", "tactic.enum_assoc_subexpr", "dlist.empty", "tactic.mk_assoc_pattern", "dlist.singleton", "dlist.to_list", "tactic.enum_assoc_subexpr'", "dlist.has_append", "parse_result", "dlist.to_list_of_list", "dlist.append", "tactic.expanded_field_list", "dlist.of_list", "dlist.to_list_singleton"]}, {"id": "iff_not_comm", "parentIds": []}, {"id": "and_congr", "parentIds": ["iff_not_comm", "not_iff_not", "and.left_comm", "not_iff_comm", "and_or_distrib_right", "iff_congr", "lt_iff_lt_of_le_iff_le'", "nat.div_zero", "exists_unique_congr"]}, {"id": "iff_def", "parentIds": ["iff_not_comm", "not_iff_not", "not_iff_comm", "iff_def'"]}, {"id": "not_imp_comm", "parentIds": ["iff_not_comm", "not_iff_comm"]}, {"id": "imp_not_comm", "parentIds": ["iff_not_comm", "not_and'", "not_iff_comm"]}, {"id": "list.decidable_bex", "parentIds": ["list.decidable_ball"]}, {"id": "Exists", "parentIds": ["list.decidable_bex", "not_exists", "classical.not_exists_not", "classical.inhabited_of_exists", "list.not_bex_nil", "int.le.dest", "exists_prop_decidable", "function.surjective.of_comp", "list.decidable_ball", "nonempty_sigma", "exists_prop", "exists_ge_of_linear", "not_exists_of_forall_not", "bex.elim", "mul_dvd_mul", "function.inv_fun_on_eq", "function.involutive.surjective", "function.surjective", "function.inv_fun_on_neg", "bex_def", "function.inv_fun_eq", "int.le.dest_sub", "bex_congr", "exists_imp_exists'", "add_right_surjective", "classical.epsilon_spec", "set.image", "ge_of_forall_ge_sub", "list.is_prefix", "exists_add_lt_and_pos_of_lt", "function.left_inverse_inv_fun", "nat.find_min'", "classical.some_spec2", "set.sUnion", "exists_unique_of_exists_of_unique", "function.surjective.has_right_inverse", "function.has_right_inverse", "function.inv_fun_eq_of_injective_of_right_inverse", "int.sub_nat_nat_elim", "nat.find_min", "not_forall_not", "function.surjective_of_has_right_inverse", "list.is_infix", "forall_iff_forall_surj", "bex.imp_right", "Exists.fst", "list.choose_x", "exists_unique", "bex_imp_distrib", "function.inv_fun_on_eq'", "can_lift", "Exists.imp", "int.eq_coe_or_neg", "nonempty_of_exists", "function.inv_fun_on", "function.inv_fun_on_pos", "nonempty_psigma", "exists_eq", "bex_or_distrib", "nat.mul_le_mul_left", "exists_of_exists_unique", "exists_eq_mul_left_of_dvd", "option.decidable_exists_mem", "exists_or_distrib", "mul_right_surjective", "quot.exists_rep", "classical.not_ball", "classical.exists_cases", "subtype.exists_of_subtype", "list.is_suffix", "exists_eq_mul_right_of_dvd", "function.injective_surj_inv", "function.partial_inv", "exists.elim", "classical.not_forall", "classical.skolem", "exists_and_distrib_right", "function.inv_fun_surjective", "not_ball", "nat.dvd_add_iff_right", "classical.epsilon_spec_aux", "Exists.snd", "int.eq_neg_succ_of_lt_zero", "list.choose", "nat.find", "exists_eq_left", "d_array.of_beq_aux_eq_ff", "push_neg.not_forall_eq", "classical.strong_indefinite_description", "exists_false", "array.mem", "not_exists_not", "function.inv_fun_neg", "function.inv_fun_on_mem", "dvd_trans", "ex_of_psig", "int.eq_succ_of_zero_lt", "exists_eq_right", "not_forall_of_exists_not", "list.bex_cons", "int.eq_coe_of_zero_le", "nat.le.dest", "quotient.exists_rep", "nonempty_subtype", "int.eq_nat_abs_of_zero_le", "exists_and_distrib_left", "bool.exists_bool", "nat.exists_eq_succ_of_ne_zero", "exists_prop_of_true", "classical.some_spec", "int.coe_nat_le_coe_nat_of_le", "classical.epsilon", "classical.indefinite_description", "bex.imp_left", "function.surjective_comp", "nat.add_le_add_left", "function.surjective_id", "mul_left_surjective", "int.neg_succ_lt_zero", "comm_semiring_has_dvd", "sum.exists", "forall_not_of_not_exists", "exists_prop_of_false", "function.cantor_surjective", "add_left_surjective", "exists.classical_rec_on", "exists_eq_right'", "int.exists_eq_neg_of_nat", "nat.dvd_of_mul_dvd_mul_left", "int.nat_abs_of_nonneg", "bool.decidable_exists_bool", "bex_of_exists", "classical.exists_true_of_nonempty", "nat.le_of_add_le_add_left", "buffer.mem", "nat.find_spec", "exists_swap", "bex.intro", "int.sign_eq_neg_one_of_neg", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "exists_true_iff_nonempty", "classical.subtype_of_exists", "int.lt.dest", "push_neg.not_exists_eq", "classical.epsilon_singleton", "nonempty.exists", "set.is_lawful_functor", "classical.some", "exists_imp_distrib", "int.sign_eq_one_of_pos", "exists.intro", "not_ball_of_bex_not", "function.partial_inv_of_injective", "exists_eq_left'", "exists_eq'", "classical.axiom_of_choice", "function.cantor_injective", "not_forall", "exists_pempty", "function.bijective_iff_has_inverse", "exists_of_bex", "nat.find_x", "prod.exists", "not_bex", "exists_imp_exists", "function.injective.has_left_inverse", "exists_const", "exists_congr", "function.has_left_inverse"]}, {"id": "decidable_pred", "parentIds": ["list.decidable_bex", "option.guard", "parser.sat", "list.decidable_ball", "list.split_on_p_aux", "list.filter", "list.drop_while", "nat.find_min'", "option.filter", "list.find", "nat.find_min", "list.filter_cons_of_neg", "list.erasep", "list.filter_append", "list.filter_nil", "list.choose_x", "list.extractp", "option.decidable_exists_mem", "tactic.mllist.filter", "char.decidable_is_digit", "classical.dec_pred", "char.decidable_is_punctuation", "list.find_indexes_aux", "list.choose", "nat.find", "char.decidable_is_upper", "list.partition", "list.find_indexes", "list.split_on_p", "list.countp", "list.filter_sublist", "char.decidable_is_lower", "list.after", "list.filter_cons_of_pos", "char.decidable_is_whitespace", "list.span", "char.decidable_is_alpha", "nat.find_spec", "list.take_while", "list.find_index", "native.rb_map.filter", "char.decidable_is_alphanum", "list.partition_eq_filter_filter", "nat.find_x", "option.decidable_forall_mem", "expr.contains_constant"]}, {"id": "neg_mul_eq_neg_mul_symm", "parentIds": ["neg_mul_comm", "neg_eq_neg_one_mul", "norm_num.neg_mul_pos_helper", "mul_sub_right_distrib", "norm_num.neg_mul_neg_helper", "neg_mul_neg"]}, {"id": "has_neg", "parentIds": ["neg_mul_eq_neg_mul_symm", "abs_add_le_abs_add_abs", "sub_lt_sub_of_lt_of_le", "int.neg_succ_of_nat_coe'", "neg_eq_iff_neg_eq", "dvd_neg_iff_dvd", "sub_eq_sub_iff_sub_eq_sub", "neg_add_le_of_le_add", "neg_add_self", "eq_add_neg_iff_add_eq", "min_neg_neg", "int.le.dest", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "discrete_field", "div_sub_div", "add_sub_comm", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "sub_right_comm", "int.neg_ne_of_pos", "add_midpoint", "int.zero_ne_neg_of_ne", "add_comm_group", "neg_add_eq_sub", "set.has_neg", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "int.nat_abs_eq", "neg_le_abs_self", "add_group.to_has_neg", "add_sub_cancel'", "add_right_surjective", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "sub_le_sub_left", "int.neg_of_nat_zero", "sub_left_le_of_le_add", "neg_inj'", "int.neg_ne_zero_of_ne", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "list.func.neg", "add_le_of_le_neg_add", "expr.to_int", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "integral_domain", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "div_two_sub_self", "add_neg_eq_iff_eq_add", "int.mk_numeral", "eq_add_neg_of_add_eq", "max_eq_neg_min_neg_neg", "norm_num.subst_into_subtr", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "lt_add_of_neg_add_lt_left", "int.sign_eq_neg_one_iff_neg", "neg_lt_neg", "left_inverse_neg_add_add_right", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "int.eq_coe_or_neg", "int.add_left_neg", "left_inverse_add_right_neg_add", "int.of_nat_nat_abs_of_nonpos", "norm_num.neg_add_pos_eq_of_eq_add", "norm_num.neg_add_pos_helper2", "eq_neg_iff_eq_neg", "ring", "neg_add", "int.sub_nat_nat_eq_coe", "division_ring", "neg_neg_sub_neg", "zero_sub", "add_eq_zero_iff_neg_eq", "linear_ordered_comm_ring", "norm_num.neg_zero_helper", "neg_mul_comm", "int.ne_neg_of_ne", "le_add_of_neg_le_sub_left", "neg_add_eq_iff_eq_add", "lt_add_of_neg_lt_sub_left", "neg_add_cancel_right", "add_sub_add_right_eq_sub", "abs_nonneg", "eq_add_of_add_neg_eq", "abs_mul", "neg_le_neg", "left_inverse_neg", "neg_add_le_right_of_le_add", "abs", "sub_sub", "discrete_linear_ordered_field", "int.le.intro", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "abs_of_neg", "add_neg_self", "neg_add_le_left_of_le_add", "comm_ring", "add_group", "linear_ordered_ring", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "sub_sub_assoc_swap", "int.nat_abs_neg", "neg_of_neg_pos", "eq_zero_of_neg_eq", "sub_lt_self", "sub_eq_of_eq_add", "sub_sub_sub_cancel_left", "mul_le_mul_of_nonpos_left", "int.abs_eq_nat_abs", "sub_sub_self", "sub_eq_of_eq_add'", "neg_dvd_of_dvd", "neg_comm_of_comm", "neg_dvd_iff_dvd", "sub_le_sub_right", "abs_neg", "le_add_of_neg_add_le", "int.sign_neg_one", "neg_nonpos_of_nonneg", "add_neg_cancel_right", "add_group.add_right_cancel", "sub_lt_of_abs_sub_lt_left", "algebra.sub", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "sub_zero", "sub_lt_sub_left", "eq_zero_of_abs_eq_zero", "norm_num.nonzero_of_neg_helper", "neg_le_sub_right_of_le_add", "eq_neg_iff_add_eq_zero", "add_eq_of_eq_add_neg", "one_div_neg_one_eq_neg_one", "lt_add_of_neg_add_lt", "gt_of_mul_lt_mul_neg_left", "one_div_neg_eq_neg_one_div", "int.eq_coe_of_zero_le", "mul_neg_eq_neg_mul_symm", "neg_sub", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "int.neg_neg_of_nat_succ", "sub_left_lt_of_lt_add", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "add_right_neg", "neg_pos_of_neg", "zero_gt_neg_one", "dvd_of_neg_dvd", "abs_pos_of_neg", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "native.float.has_neg", "int.sign_mul_nat_abs", "neg_involutive", "int.le_total", "lt_add_of_neg_lt_sub_right", "add_sub", "abs_of_nonneg", "mul_sub_right_distrib", "int.shiftr", "lt_neg_of_lt_neg", "add_left_neg", "le_sub_right_of_add_le", "division_ring.neg_div_neg_eq", "min_eq_neg_max_neg_neg", "int.has_neg", "eq_of_neg_eq_neg", "neg_lt_of_neg_lt", "neg_inj", "ordered_comm_group", "add_neg_cancel_left", "add_add_neg_cancel'_right", "abs_by_cases", "int.neg_of_sign_eq_neg_one", "neg_add_rev", "dvd_sub", "neg_add_cancel_left", "neg_eq_iff_add_eq_zero", "le_add_of_neg_add_le_right", "add_left_surjective", "neg_eq_zero", "lt_sub_right_of_add_lt", "sub_add_eq_add_sub", "neg_ne_zero", "field", "int.exists_eq_neg_of_nat", "norm_num.neg_mul_neg_helper", "dvd_neg_of_dvd", "nonpos_of_neg_nonneg", "neg_add_lt_left_of_lt_add", "lt_of_neg_lt_neg", "eq_sub_of_add_eq'", "sub_pos_of_lt", "mul_self_eq_mul_self_iff", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "pos_of_neg_neg", "sub_lt_sub_of_le_of_lt", "neg_div_neg_eq", "neg_neg", "sub_nonpos_of_le", "sub_le_sub", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "decidable_linear_ordered_comm_ring", "eq_neg_of_add_eq_zero", "sub_le_self", "neg_div", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "div_neg_eq_neg_div", "int.sign_eq_neg_one_of_neg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "div_sub_div_same", "int.ne_neg_of_pos", "mul_sub_left_distrib", "sub_eq_add_neg", "int.neg_of_nat_of_succ", "norm_num.neg_add_neg_helper", "abs_lt_of_lt_of_neg_lt", "sub_left_inj", "abs_sub", "neg_add'", "neg_of_one_div_neg", "neg_mul_eq_mul_neg", "sub_add_eq_sub_sub", "neg_mul_neg", "eq_neg_add_iff_add_eq", "linear_ordered_field", "sub_eq_neg_add", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "sub_right_inj", "nonneg_of_neg_nonpos", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "sub_lt_sub", "sub_add", "neg_nonneg_of_nonpos", "ordered_comm_group.le_of_add_le_add_left", "dvd_of_dvd_neg", "neg_eq_of_add_eq_zero", "neg_lt_sub_right_of_lt_add", "ordered_ring", "mul_self_eq_one_iff", "add_eq_of_eq_neg_add", "neg_zero", "division_ring.one_div_neg_eq_neg_one_div", "max_neg_neg", "decidable_linear_ordered_comm_group", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "le_neg_add_of_add_le", "add_group.add_left_cancel", "neg_neg_of_pos", "sub_nonneg_of_le", "neg_add_lt_right_of_lt_add", "add_sub_assoc", "add_neg_eq_zero", "one_div_le_neg_one", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt", "neg_le_of_neg_le", "mul_le_mul_of_nonpos_right"]}, {"id": "mul_zero_class.to_has_mul", "parentIds": ["neg_mul_eq_neg_mul_symm", "le_mul_of_div_le", "div_zero", "ne_zero_of_mul_ne_zero_left", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "division_def", "mul_lt_mul_of_neg_left", "nat.pow_le_pow_of_le_left", "mul_self_sub_one_eq", "discrete_field", "div_sub_div", "div_pos_of_neg_of_neg", "dvd.intro", "mul_nonpos_of_nonpos_of_nonneg", "two_mul", "div_lt_of_mul_lt_of_pos", "mul_ne_zero_comm", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "eq_zero_of_zero_dvd", "mul_nonneg_of_nonpos_of_nonpos", "mul_dvd_mul", "mul_le_mul_of_nonneg_right", "nat.mul_div_assoc", "mul_inv_eq", "decidable_linear_ordered_semiring", "div_nonneg_of_nonpos_of_neg", "norm_num.mul_bit1_helper", "dvd_mul_left", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "field.one_div_mul_one_div", "mul_eq_of_eq_div", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "nonneg_of_mul_nonneg_left", "lt_div_of_mul_lt", "dvd_of_mul_left_dvd", "nat.bit0_val", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "div_div_eq_div_mul", "neg_mul_eq_neg_mul", "div_mul_eq_mul_div", "mul_div_mul_left'", "div_le_div_of_mul_sub_mul_div_nonpos", "one_lt_div_of_lt", "one_dvd", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "one_div_zero", "div_mul_cancel", "le_div_of_mul_le", "mul_div_cancel_left", "div_self", "dvd_of_mul_right_dvd", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "ne_zero_of_mul_ne_zero_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "mul_lt_mul", "add_mul_self_eq", "norm_num.zero_mul", "lt_of_mul_lt_mul_right", "mul_pos", "division_ring", "exists_eq_mul_left_of_dvd", "algebra.div", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "mul_self_le_mul_self_iff", "neg_mul_comm", "add_div_eq_mul_add_div", "nat.mul_mod_mul_left", "dvd.elim", "mul_one_div_cancel", "pos_of_mul_pos_right", "zero_div", "ordered_semiring", "exists_eq_mul_right_of_dvd", "lt_of_one_lt_div", "field.div_div_div_div_eq", "abs_mul", "mul_le_of_le_div", "norm_num.div_add_helper", "zero_mul", "mul_sub", "discrete_linear_ordered_field", "dvd.intro_left", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "eq_div_of_mul_eq", "le_mul_of_ge_one_left", "linear_ordered_ring", "mul_neg_of_neg_of_pos", "nat.dvd_add_iff_right", "mul_pos_of_neg_of_neg", "nat.dvd_mod_iff", "one_div_ne_zero", "le_of_mul_le_mul_right", "field.div_mul_left", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "neg_dvd_of_dvd", "one_inv_eq", "le_of_mul_le_mul_left", "mul_inv_cancel", "neg_of_mul_neg_right", "dvd_trans", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "sub_mul", "neg_eq_neg_one_mul", "lt_mul_of_gt_one_right", "dvd_mul_of_dvd_right", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "div_eq_mul_one_div", "div_mul_right", "mul_inv'", "mul_le_of_div_le_of_neg", "add_self_div_two", "dvd_mul_of_dvd_left", "div_lt_div_of_lt_of_pos", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "mul_neg_eq_neg_mul_symm", "nat.div_eq_of_lt_le", "abs_div", "pos_of_mul_pos_left", "div_mul_eq_div_mul_one_div", "mul_self_sub_mul_self_eq", "lt_of_mul_lt_mul_left", "norm_num.neg_mul_pos_helper", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "mul_div_assoc", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "mul_dvd_mul_left", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "dvd_mul_right", "neg_of_mul_neg_left", "mul_sub_right_distrib", "mul_dvd_mul_right", "dvd_add", "mul_eq_mul_of_div_eq_div", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "div_eq_one_iff_eq", "mul_div_mul_left", "nat.mul_self_lt_mul_self", "comm_semiring_has_dvd", "dvd.elim_left", "dvd_refl", "ordered_ring.mul_lt_mul_of_pos_right", "div_lt_div_of_pos_of_lt_of_pos", "eq_of_mul_eq_mul_left", "field", "norm_num.neg_mul_neg_helper", "mul_div_cancel'", "dvd_neg_of_dvd", "dvd_of_mul_left_eq", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_div_mul_right", "nat.dvd_of_mul_dvd_mul_left", "div_one", "mul_self_eq_mul_self_iff", "add_halves", "field.div_div_eq_mul_div", "distrib_three_right", "mul_div_cancel", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "mul_nonpos_of_nonneg_of_nonpos", "decidable_linear_ordered_comm_ring", "div_mul_eq_mul_div_comm", "neg_div", "div_div_div_div_eq", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "nat.le_of_dvd", "mul_self_nonneg", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_zero", "nonpos_of_mul_nonpos_right", "eq_one_div_of_mul_eq_one", "mul_sub_left_distrib", "one_div_add_one_div", "nat.eq_of_mul_eq_mul_left", "mul_nonneg", "neg_mul_eq_mul_neg", "norm_num.mul_bit1", "mul_mul_div", "neg_mul_neg", "mul_lt_mul_of_pos_right", "nonneg_le_nonneg_of_squares_le", "nat.zero_pow", "norm_num.div_helper", "linear_ordered_field", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "mul_zero", "div_le_of_le_mul", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "le_of_one_le_div", "ordered_ring.mul_lt_mul_of_pos_left", "mul_lt_mul'", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_mul_div", "ordered_ring", "div_add_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "dvd_zero", "division_ring.one_div_neg_eq_neg_one_div", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "mul_self_le_mul_self", "eq_div_iff_mul_eq", "dvd_of_mul_right_eq", "nat.mod_eq_zero_of_dvd", "mul_le_mul", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "neg_mul_eq_neg_mul", "parentIds": ["neg_mul_eq_neg_mul_symm", "mul_lt_mul_of_neg_left", "abs_mul", "mul_le_mul_of_nonpos_left", "gt_of_mul_lt_mul_neg_left"]}, {"id": "ring.to_semiring", "parentIds": ["neg_mul_eq_neg_mul_symm", "le_mul_of_div_le", "div_zero", "div_le_div_of_le_of_pos", "division_def", "mul_lt_mul_of_neg_left", "int.add_comm_monoid", "mul_self_sub_one_eq", "discrete_field", "div_sub_div", "div_pos_of_neg_of_neg", "mul_ne_zero_comm", "mul_inv_eq", "div_nonneg_of_nonpos_of_neg", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "field.one_div_mul_one_div", "mul_eq_of_eq_div", "abs_sub_square", "one_le_div_of_le", "dvd_add_iff_right", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "field.div_mul_eq_div_mul_one_div", "div_div_eq_div_mul", "neg_mul_eq_neg_mul", "div_mul_eq_mul_div", "mul_div_mul_left'", "div_le_div_of_mul_sub_mul_div_nonpos", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "one_div_zero", "div_mul_cancel", "mul_div_cancel_left", "div_self", "mul_le_mul_of_mul_div_le", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "add_mul_self_eq", "division_ring", "algebra.div", "linear_ordered_comm_ring", "neg_mul_comm", "add_div_eq_mul_add_div", "mul_one_div_cancel", "zero_div", "lt_of_one_lt_div", "field.div_div_div_div_eq", "abs_mul", "mul_le_of_le_div", "norm_num.div_add_helper", "mul_sub", "discrete_linear_ordered_field", "eq_div_of_mul_eq", "linear_ordered_ring", "one_div_ne_zero", "field.div_mul_left", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "mul_le_mul_of_nonpos_left", "neg_dvd_of_dvd", "one_inv_eq", "mul_eq_zero_iff_eq_zero_or_eq_zero", "mul_inv_cancel", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "sub_mul", "neg_eq_neg_one_mul", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "div_eq_mul_one_div", "div_mul_right", "mul_inv'", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "mul_neg_eq_neg_mul_symm", "abs_div", "div_mul_eq_div_mul_one_div", "mul_self_sub_mul_self_eq", "norm_num.neg_mul_pos_helper", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "mul_div_assoc", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "mul_sub_right_distrib", "mul_eq_mul_of_div_eq_div", "mul_lt_of_lt_div", "div_eq_one_iff_eq", "mul_div_mul_left", "ordered_ring.mul_lt_mul_of_pos_right", "div_lt_div_of_pos_of_lt_of_pos", "eq_of_mul_eq_mul_left", "field", "norm_num.neg_mul_neg_helper", "mul_div_cancel'", "dvd_neg_of_dvd", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_div_mul_right", "div_one", "mul_self_eq_mul_self_iff", "add_halves", "field.div_div_eq_mul_div", "mul_div_cancel", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "decidable_linear_ordered_comm_ring", "div_mul_eq_mul_div_comm", "neg_div", "int.semiring", "div_div_div_div_eq", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "mul_sub_left_distrib", "one_div_add_one_div", "neg_mul_eq_mul_neg", "mul_mul_div", "neg_mul_neg", "norm_num.div_helper", "linear_ordered_field", "field.div_div_eq_div_mul", "div_le_of_le_mul", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "le_of_one_le_div", "ordered_ring.mul_lt_mul_of_pos_left", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_mul_div", "ordered_ring", "div_add_div", "division_ring.one_div_neg_eq_neg_one_div", "eq_div_iff_mul_eq", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "ring.to_add_comm_group", "parentIds": ["neg_mul_eq_neg_mul_symm", "int.neg_succ_of_nat_coe'", "dvd_neg_iff_dvd", "mul_sub_mul_div_mul_nonpos", "int.le.dest", "mul_lt_mul_of_neg_left", "mul_self_sub_one_eq", "ring.mul_zero", "div_sub_div", "add_midpoint", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "abs_sub_square", "int.has_sub", "ge_of_forall_ge_sub", "int.neg_ne_zero_of_ne", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "div_two_sub_self", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "sub_lt_of_abs_sub_lt_right", "two_gt_one", "int.sub_nat_nat_eq_coe", "mul_sub_mul_div_mul_neg", "neg_mul_comm", "int.ne_neg_of_ne", "int.lt_irrefl", "int.add_lt_add_left", "int.le_antisymm", "abs_mul", "mul_sub", "int.le.intro", "mul_le_mul_of_nonpos_left", "neg_dvd_of_dvd", "neg_dvd_iff_dvd", "sub_lt_of_abs_sub_lt_left", "sub_mul", "int.add_monoid", "neg_eq_neg_one_mul", "ordered_ring.mul_le_mul_of_nonneg_right", "one_div_neg_one_eq_neg_one", "gt_of_mul_lt_mul_neg_left", "one_div_neg_eq_neg_one_div", "int.eq_coe_of_zero_le", "mul_neg_eq_neg_mul_symm", "mul_self_sub_mul_self_eq", "norm_num.neg_mul_pos_helper", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "zero_gt_neg_one", "dvd_of_neg_dvd", "int.sign_mul_nat_abs", "int.le_total", "mul_sub_right_distrib", "sub_le_of_abs_sub_le_right", "division_ring.neg_div_neg_eq", "dvd_sub", "ordered_ring.mul_lt_mul_of_pos_right", "div_lt_div_of_pos_of_lt_of_pos", "eq_of_mul_eq_mul_left", "int.exists_eq_neg_of_nat", "norm_num.neg_mul_neg_helper", "sub_self_div_two", "dvd_neg_of_dvd", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_self_eq_mul_self_iff", "neg_div_neg_eq", "neg_div", "div_neg_eq_neg_div", "div_sub_div_same", "mul_sub_left_distrib", "neg_of_one_div_neg", "neg_mul_eq_mul_neg", "neg_mul_neg", "abs_abs_sub_abs_le_abs_sub", "dvd_add_iff_left", "int.neg_succ_of_nat_lt_zero", "ring.zero_mul", "ordered_ring.mul_lt_mul_of_pos_left", "dvd_of_dvd_neg", "mul_self_eq_one_iff", "division_ring.one_div_neg_eq_neg_one_div", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "ring", "parentIds": ["neg_mul_eq_neg_mul_symm", "ring.mul_zero", "discrete_field", "ring.to_add_comm_group", "ring.to_monoid", "neg_mul_eq_neg_mul", "comm_ring.to_ring", "ring.to_semiring", "norm_num.pos_mul_neg_helper", "division_ring", "linear_ordered_comm_ring", "neg_mul_comm", "mul_sub", "discrete_linear_ordered_field", "linear_ordered_ring", "sub_mul", "neg_eq_neg_one_mul", "mul_neg_eq_neg_mul_symm", "norm_num.neg_mul_pos_helper", "mul_sub_right_distrib", "division_ring.to_ring", "field", "norm_num.neg_mul_neg_helper", "int.ring", "decidable_linear_ordered_comm_ring", "mul_sub_left_distrib", "neg_mul_eq_mul_neg", "neg_mul_neg", "linear_ordered_field", "ring.zero_mul", "ring.to_distrib", "ordered_ring", "ordered_ring.to_ring"]}, {"id": "add_comm_group.to_add_group", "parentIds": ["neg_mul_eq_neg_mul_symm", "lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "sub_lt_sub_of_lt_of_le", "int.neg_succ_of_nat_coe'", "dvd_neg_iff_dvd", "sub_eq_sub_iff_sub_eq_sub", "neg_add_le_of_le_add", "mul_sub_mul_div_mul_nonpos", "min_neg_neg", "int.le.dest", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "ring.mul_zero", "div_sub_div", "abs_add_three", "add_sub_comm", "le_add_of_sub_left_le", "abs_of_pos", "abs_pos_of_ne_zero", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "sub_right_comm", "add_midpoint", "add_add_sub_cancel", "neg_add_eq_sub", "eq_zero_of_mul_eq_self_right", "sub_add_add_cancel", "eq_of_mul_eq_mul_right", "neg_le_abs_self", "add_sub_cancel'", "abs_sub_square", "int.has_sub", "ordered_comm_group.lt_of_add_lt_add_left", "sub_le_sub_left", "sub_left_le_of_le_add", "add_sub_sub_cancel", "ge_of_forall_ge_sub", "int.neg_ne_zero_of_ne", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "add_le_of_le_neg_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "div_two_sub_self", "max_eq_neg_min_neg_neg", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "sub_sub_cancel", "add_sub_cancel'_right", "lt_add_of_neg_add_lt_left", "sub_le_of_sub_le", "neg_lt_neg", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "sub_lt_of_abs_sub_lt_right", "int.of_nat_nat_abs_of_nonpos", "norm_num.neg_add_pos_eq_of_eq_add", "two_gt_one", "norm_num.neg_add_pos_helper2", "neg_add", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "neg_mul_comm", "int.ne_neg_of_ne", "int.lt_irrefl", "int.add_lt_add_left", "le_add_of_neg_le_sub_left", "lt_add_of_neg_lt_sub_left", "int.le_antisymm", "abs_nonneg", "abs_mul", "neg_le_neg", "neg_add_le_right_of_le_add", "abs", "sub_sub", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "mul_sub", "discrete_linear_ordered_field", "int.le.intro", "neg_le_sub_left_of_le_add", "abs_of_neg", "neg_add_le_left_of_le_add", "lt_of_sub_pos", "linear_ordered_ring", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "neg_of_neg_pos", "eq_zero_of_neg_eq", "sub_lt_self", "sub_sub_sub_cancel_left", "mul_le_mul_of_nonpos_left", "int.abs_eq_nat_abs", "sub_sub_self", "sub_eq_of_eq_add'", "neg_dvd_of_dvd", "neg_dvd_iff_dvd", "sub_le_sub_right", "abs_neg", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "neg_nonpos_of_nonneg", "sub_lt_of_abs_sub_lt_left", "sub_mul", "int.add_monoid", "neg_eq_neg_one_mul", "sub_lt_sub_left", "eq_zero_of_abs_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "norm_num.nonzero_of_neg_helper", "abs_zero", "neg_le_sub_right_of_le_add", "one_div_neg_one_eq_neg_one", "lt_add_of_neg_add_lt", "gt_of_mul_lt_mul_neg_left", "one_div_neg_eq_neg_one_div", "int.eq_coe_of_zero_le", "mul_neg_eq_neg_mul_symm", "ne_zero_of_abs_ne_zero", "abs_div", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "sub_left_lt_of_lt_add", "norm_num.neg_mul_pos_helper", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "neg_pos_of_neg", "zero_gt_neg_one", "add_lt_of_lt_sub_right", "dvd_of_neg_dvd", "abs_pos_of_neg", "le_abs_self", "int.sign_mul_nat_abs", "int.le_total", "lt_add_of_neg_lt_sub_right", "abs_of_nonneg", "mul_sub_right_distrib", "sub_le_of_abs_sub_le_right", "lt_neg_of_lt_neg", "le_sub_right_of_add_le", "division_ring.neg_div_neg_eq", "min_eq_neg_max_neg_neg", "neg_lt_of_neg_lt", "ordered_comm_group", "add_add_neg_cancel'_right", "abs_by_cases", "dvd_sub", "le_add_of_neg_add_le_right", "sub_lt_of_sub_lt", "lt_sub_right_of_add_lt", "ordered_ring.mul_lt_mul_of_pos_right", "sub_add_eq_add_sub", "div_lt_div_of_pos_of_lt_of_pos", "eq_of_mul_eq_mul_left", "int.exists_eq_neg_of_nat", "norm_num.neg_mul_neg_helper", "sub_self_div_two", "abs_pos_of_pos", "dvd_neg_of_dvd", "eq_of_abs_sub_eq_zero", "nonpos_of_neg_nonneg", "ordered_ring.mul_le_mul_of_nonneg_left", "neg_add_lt_left_of_lt_add", "lt_of_neg_lt_neg", "eq_sub_of_add_eq'", "sub_pos_of_lt", "mul_self_eq_mul_self_iff", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "pos_of_neg_neg", "sub_lt_sub_of_le_of_lt", "neg_div_neg_eq", "sub_nonpos_of_le", "sub_le_sub", "norm_num.pos_add_neg_helper", "decidable_linear_ordered_comm_ring", "sub_le_self", "neg_div", "lt_of_sub_neg", "eq_add_of_sub_eq'", "div_neg_eq_neg_div", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "div_sub_div_same", "mul_sub_left_distrib", "norm_num.neg_add_neg_helper", "abs_lt_of_lt_of_neg_lt", "abs_sub", "neg_add'", "neg_of_one_div_neg", "neg_mul_eq_mul_neg", "sub_add_eq_sub_sub", "neg_mul_neg", "linear_ordered_field", "lt_add_of_sub_left_lt", "abs_abs_sub_abs_le_abs_sub", "sub_eq_neg_add", "sub_eq_sub_add_sub", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "nonneg_of_neg_nonpos", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "sub_lt_sub", "sub_add_sub_cancel'", "sub_add", "neg_nonneg_of_nonpos", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'", "ring.zero_mul", "ordered_ring.mul_lt_mul_of_pos_left", "ordered_comm_group.le_of_add_le_add_left", "dvd_of_dvd_neg", "neg_lt_sub_right_of_lt_add", "ordered_ring", "mul_self_eq_one_iff", "le_of_sub_nonpos", "division_ring.one_div_neg_eq_neg_one_div", "max_neg_neg", "decidable_linear_ordered_comm_group", "sub_neg_of_lt", "le_neg_add_of_add_le", "neg_neg_of_pos", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "one_div_le_neg_one", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt", "neg_le_of_neg_le", "mul_le_mul_of_nonpos_right"]}, {"id": "eq.symm", "parentIds": ["neg_mul_eq_neg_mul_symm", "abs_add_le_abs_add_abs", "int.neg_succ_of_nat_coe'", "max_add_add_left", "heq_of_eq_rec_left", "eq_add_neg_iff_add_eq", "id.is_comm_applicative", "nat.mod_lt", "ne_of_eq_of_ne", "int.le.dest", "mul_lt_mul_of_neg_left", "ring.mul_zero", "nat.shiftl_eq_mul_pow", "div_sub_div", "int.nat_abs_bit1_nonneg_step", "dvd.intro", "norm_num.mul_bit0_helper", "sum.lex_acc_inr", "div_lt_of_mul_lt_of_pos", "option.is_lawful_monad", "nat.mul_div_mul", "mjoin_map_map", "classical.forall_or_distrib", "applicative_transformation.preserves_map", "functor.add_const.is_lawful_applicative", "eq_mul_inv_iff_mul_eq", "int.add_assoc", "not_imp_eq_of_eq_false_right", "int.neg_ne_of_pos", "nat.mul_div_assoc", "add_midpoint", "norm_num.bit1_add_one_helper", "mul_inv_rev", "mul_inv_eq", "nat.sub_eq_zero_of_le", "nat.sub_sub_self", "one_div_le_of_one_div_le_of_neg", "list.length_le_of_sublist", "nat.succ_mul_succ_eq", "and_eq_of_eq_true_left", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "norm_num.subst_into_sum", "sum.elim_injective", "add_sub_sub_cancel", "and_eq_of_eq_true_right", "imp_eq_of_eq_false_right", "lt_div_of_mul_lt", "neg_inj'", "nat.bit0_val", "nat.pow_lt_pow_of_lt_right", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "state_t.run_map", "imp_eq_of_eq_false_left", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "sum.is_lawful_monad", "reader_t.run_map", "function.update", "congr_arg_heq", "nat.shiftr_eq_div_pow", "classical.cases_true_false", "nat.binary_rec_eq", "one_lt_div_of_lt", "right_comm", "heq_of_eq_mp", "function.injective_of_partial_inv_right", "add_neg_eq_iff_eq_add", "int.sub_nat_nat_elim", "option_t.run_map", "nat.mod_two_of_bodd", "eq_add_neg_of_add_eq", "eq_of_mul_eq_mul_of_nonzero_right", "false_ne_true", "div_lt_of_mul_gt_of_neg", "function.update_same", "list.length_drop", "nat.add_mul_div_left", "nat.sub_eq_iff_eq_add", "le_div_of_mul_le", "forall_iff_forall_surj", "nat.sub_mul_mod", "nat.pow_le_pow_of_le_right", "add_sub_cancel'_right", "nat.add_comm", "norm_num.bit1_add_bit0_helper", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "nat.one_le_bit0", "one_div_lt_one_div_of_lt_of_neg", "int.nat_abs_bit0_step", "parser.is_lawful_monad", "eq.substr", "int.of_nat_nat_abs_of_nonpos", "reader_t.is_lawful_monad", "int.coe_nat_lt_coe_nat_iff", "plift.down_inj", "nat.mul_le_mul_left", "trans_rel_right", "nat.add_sub_assoc", "min_eq_left", "option.is_none_iff_eq_none", "psigma.rev_lex_accessible", "fin.eq_of_veq", "eq_inv_mul_iff_mul_eq", "division_ring.one_div_one_div", "nat.mul_mod_mul_left", "int.distrib_left", "neg_add_eq_iff_eq_add", "eq_comm", "function.injective_of_partial_inv", "int.le_antisymm", "norm_num.bit0_add_bit1_helper", "except_t.run_map", "abs_nonneg", "lt_trichotomy", "int.lt_iff_le_and_ne", "eq_add_of_add_neg_eq", "norm_num.div_add_helper", "char.veq_of_eq", "mul_inv_eq_iff_eq_mul", "and_eq_of_eq_false_right", "add_le_of_le_sub_left", "function.equiv.symm", "int.le.intro", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "prod.mk.inj_iff", "mjoin_map_pure", "mul_inv_cancel_left", "fin.veq_of_eq", "one_div_le_of_one_div_le_of_pos", "eq_rec_compose", "int.le_trans", "ne.symm", "not_eq_of_eq_false", "eq_iff_eq_of_sub_eq_sub", "nat.bitwise_bit", "eq_iff_eq_cancel_left", "min_add_add_left", "nat.dvd_add_iff_right", "forall_eq", "one_div_ne_zero", "eq_equivalence", "list.lt_eq_not_ge", "sub_sub_sub_cancel_left", "field.div_mul_eq_mul_div_comm", "mul_le_mul_of_nonpos_left", "or_eq_of_eq_true_right", "neg_comm_of_comm", "id.is_lawful_monad", "inv_mul_cancel_left", "norm_num.add1_bit1_helper", "map_seq", "or_iff_not_and_not", "norm_num.add_div_helper", "int.mul_pos", "int.eq_succ_of_zero_lt", "sum.lex_acc_inl", "imp_eq_of_eq_true_left", "eq_sub_of_add_eq", "and_eq_of_eq_false_left", "or_eq_of_eq_false_left", "inv_eq_one", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "inv_inj'", "nat.mul_mod_right", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "add_self_div_two", "decidable.lt_trichotomy", "sub_add_sub_cancel", "max_eq_left", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "prod.lex_accessible", "mul_neg_eq_neg_mul_symm", "function.left_inverse_of_surjective_of_right_inverse", "ne_zero_of_abs_ne_zero", "abs_div", "nat.le.dest", "function.update_noteq", "div_mul_eq_div_mul_one_div", "unique_of_exists_unique", "of_eq_true", "functor.const.is_lawful_applicative", "eq_neg_add_of_add_eq", "nat.succ_sub", "one_div_lt_one_div_of_lt", "nat.sub_mul_div", "and_iff_not_or_not", "field.div_mul_right", "quot.eqv_gen_sound", "div_div_eq_mul_div", "subtype.eq", "division_ring.mul_ne_zero", "int.coe_nat_le_coe_nat_of_le", "eq_of_mul_eq_mul_of_nonzero_left", "norm_num.sub_nat_pos_helper", "int.sign_mul_nat_abs", "nat.strong_rec_on", "list.is_lawful_monad", "inv_comm_of_comm", "applicative.ext", "nat.test_bit_succ", "eq_is_equiv", "or_eq_of_eq_false_right", "seq_bind_eq", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "add_neg_cancel_left", "abs_by_cases", "char.eq_of_veq", "neg_add_rev", "mul_div_mul_left", "eq_mul_of_inv_mul_eq", "iff_eq_of_eq_true_left", "neg_add_cancel_left", "mjoin_map_mjoin", "neg_eq_zero", "one_ne_zero", "div_lt_div_of_pos_of_lt_of_pos", "seq_map_assoc", "nat.mod_add_div", "le_antisymm_iff", "int.exists_eq_neg_of_nat", "prod.ext_iff", "div_add_div_same", "except_t.is_lawful_monad", "iff_eq_of_eq_true_right", "eq_sub_of_add_eq'", "inv_eq_of_mul_eq_one", "int.mul_nonneg", "int.to_nat_sub", "mul_self_eq_mul_self_iff", "function.injective_of_left_inverse", "imp_eq_of_eq_true_right", "eq_inv_of_mul_eq_one", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "eq_inv_mul_of_mul_eq", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "norm_num.pos_add_neg_helper", "division_ring.eq_of_one_div_eq_one_div", "eq_neg_of_add_eq_zero", "list.length_map_accumr\u2082", "neg_div", "eq_of_one_div_eq_one_div", "prod.lex_def", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "div_neg_eq_neg_div", "eq_rec_heq", "div_sub_div_same", "eq_one_div_of_mul_eq_one_left", "int.lt.dest", "one_div_add_one_div", "psigma.eq", "nat.sub_lt", "cast_heq", "nat.eq_of_mul_eq_mul_left", "nat.add_mul_mod_self_left", "list.ball_cons", "abs_sub", "norm_num.one_add_bit1_helper", "if_eq_of_eq", "neg_of_one_div_neg", "neg_mul_eq_mul_neg", "sigma.eq", "map_bind", "nat.mod_pow_succ", "nat.zero_pow", "norm_num.div_helper", "eq_neg_add_iff_add_eq", "abs_abs_sub_abs_le_abs_sub", "option_t.is_lawful_monad", "div_le_of_le_mul", "nat.add_sub_of_le", "nat.le_div_iff_mul_le", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "nat.add_le_to_le_sub", "ring.zero_mul", "norm_num.mul_div_helper", "neg_eq_of_add_eq_zero", "state_t.is_lawful_monad", "not_eq_of_eq_true", "eq_mul_of_mul_inv_eq", "or_eq_of_eq_true_left", "div_add_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "seq_eq_bind_map", "functor.ext", "inv_mul_eq_iff_eq_mul", "division_ring.one_div_neg_eq_neg_one_div", "int.zero_ne_one", "nat.min_succ_succ", "max_neg_neg", "nat.div_div_eq_div_mul", "nat.zero_lt_bit0", "eq_div_iff_mul_eq", "add_lt_of_lt_sub_left", "add_sub_assoc", "nat.dvd_antisymm", "map_map", "left_comm", "mul_le_mul_of_nonpos_right"]}, {"id": "semiring.to_mul_zero_class", "parentIds": ["neg_mul_eq_neg_mul_symm", "le_mul_of_div_le", "div_zero", "ne_zero_of_mul_ne_zero_left", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "division_def", "mul_lt_mul_of_neg_left", "one_div_pos_of_pos", "nat.pow_le_pow_of_le_left", "mul_self_sub_one_eq", "discrete_field", "div_sub_div", "div_pos_of_neg_of_neg", "dvd.intro", "mul_nonpos_of_nonpos_of_nonneg", "two_mul", "div_lt_of_mul_lt_of_pos", "mul_ne_zero_comm", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "eq_zero_of_zero_dvd", "mul_nonneg_of_nonpos_of_nonpos", "mul_dvd_mul", "mul_le_mul_of_nonneg_right", "nat.mul_div_assoc", "zero_le_one", "mul_inv_eq", "decidable_linear_ordered_semiring", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "norm_num.mul_bit1_helper", "dvd_mul_left", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "field.one_div_mul_one_div", "mul_eq_of_eq_div", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "nonneg_of_mul_nonneg_left", "lt_div_of_mul_lt", "dvd_of_mul_left_dvd", "nat.bit0_val", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "div_div_eq_div_mul", "neg_mul_eq_neg_mul", "div_mul_eq_mul_div", "mul_div_mul_left'", "nat.mul_div_right", "div_le_div_of_mul_sub_mul_div_nonpos", "one_lt_div_of_lt", "one_dvd", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "nat.add_mul_div_left", "one_div_zero", "div_mul_cancel", "le_div_of_mul_le", "nat.sub_mul_mod", "mul_div_cancel_left", "div_self", "dvd_of_mul_right_dvd", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "ne_zero_of_mul_ne_zero_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "mul_lt_mul", "two_gt_one", "add_mul_self_eq", "lt_of_mul_lt_mul_right", "mul_pos", "division_ring", "exists_eq_mul_left_of_dvd", "algebra.div", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "mul_self_le_mul_self_iff", "neg_mul_comm", "add_div_eq_mul_add_div", "nat.mul_mod_mul_left", "dvd.elim", "nat.bodd_mul", "nat.pos_of_dvd_of_pos", "mul_one_div_cancel", "pos_of_mul_pos_right", "zero_div", "ordered_semiring", "exists_eq_mul_right_of_dvd", "norm_num.nonneg_bit1_helper", "lt_of_one_lt_div", "field.div_div_div_div_eq", "abs_mul", "mul_le_of_le_div", "norm_num.div_add_helper", "mul_sub", "discrete_linear_ordered_field", "dvd.intro_left", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "eq_div_of_mul_eq", "le_mul_of_ge_one_left", "nat.mul_pred_left", "linear_ordered_ring", "mul_neg_of_neg_of_pos", "nat.dvd_add_iff_right", "mul_pos_of_neg_of_neg", "nat.dvd_mod_iff", "one_div_ne_zero", "le_of_mul_le_mul_right", "field.div_mul_left", "mul_lt_of_gt_div_of_neg", "norm_num.nonneg_bit0_helper", "field.div_mul_eq_mul_div_comm", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "neg_dvd_of_dvd", "one_inv_eq", "mul_eq_zero_iff_eq_zero_or_eq_zero", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "mul_inv_cancel", "neg_of_mul_neg_right", "dvd_trans", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "norm_num.pos_bit0_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "sub_mul", "neg_eq_neg_one_mul", "lt_mul_of_gt_one_right", "dvd_mul_of_dvd_right", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "div_eq_mul_one_div", "div_mul_right", "mul_inv'", "mul_le_of_div_le_of_neg", "add_self_div_two", "dvd_mul_of_dvd_left", "norm_num.nonzero_of_pos_helper", "div_lt_div_of_lt_of_pos", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "mul_neg_eq_neg_mul_symm", "nat.div_eq_of_lt_le", "abs_div", "pos_of_mul_pos_left", "div_mul_eq_div_mul_one_div", "mul_self_sub_mul_self_eq", "lt_of_mul_lt_mul_left", "norm_num.neg_mul_pos_helper", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "mul_div_assoc", "nat.sub_mul_div", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "mul_dvd_mul_left", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "dvd_mul_right", "neg_of_mul_neg_left", "mul_sub_right_distrib", "mul_dvd_mul_right", "dvd_add", "mul_eq_mul_of_div_eq_div", "nat.mul_sub_right_distrib", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "div_eq_one_iff_eq", "mul_div_mul_left", "nat.mul_self_lt_mul_self", "comm_semiring_has_dvd", "dvd.elim_left", "dvd_refl", "ordered_ring.mul_lt_mul_of_pos_right", "div_lt_div_of_pos_of_lt_of_pos", "nat.mod_add_div", "eq_of_mul_eq_mul_left", "field", "norm_num.neg_mul_neg_helper", "mul_div_cancel'", "dvd_neg_of_dvd", "dvd_of_mul_left_eq", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_div_mul_right", "nat.dvd_of_mul_dvd_mul_left", "div_one", "mul_self_eq_mul_self_iff", "add_halves", "field.div_div_eq_mul_div", "distrib_three_right", "mul_div_cancel", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "nat.zero_shiftl", "mul_nonpos_of_nonneg_of_nonpos", "decidable_linear_ordered_comm_ring", "div_mul_eq_mul_div_comm", "neg_div", "nat.div_mul_le_self", "div_div_div_div_eq", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "nat.le_of_dvd", "mul_self_nonneg", "eq_one_div_of_mul_eq_one_left", "nonpos_of_mul_nonpos_right", "eq_one_div_of_mul_eq_one", "mul_sub_left_distrib", "one_div_add_one_div", "nat.eq_of_mul_eq_mul_left", "nat.add_mul_mod_self_left", "mul_nonneg", "neg_mul_eq_mul_neg", "norm_num.mul_bit1", "mul_mul_div", "neg_mul_neg", "mul_lt_mul_of_pos_right", "nonneg_le_nonneg_of_squares_le", "nat.zero_pow", "norm_num.div_helper", "linear_ordered_field", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "zero_lt_one", "div_le_of_le_mul", "nat.le_div_iff_mul_le", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "le_of_one_le_div", "ordered_ring.mul_lt_mul_of_pos_left", "mul_lt_mul'", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_mul_div", "ordered_ring", "div_add_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "dvd_zero", "division_ring.one_div_neg_eq_neg_one_div", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "mul_self_le_mul_self", "eq_div_iff_mul_eq", "dvd_of_mul_right_eq", "nat.mod_eq_zero_of_dvd", "mul_le_mul", "nat.dvd_antisymm", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "has_mul", "parentIds": ["neg_mul_eq_neg_mul_symm", "native.rb_map.scale", "comm_semiring", "list.prod", "le_mul_of_div_le", "div_zero", "eq_zero_or_eq_zero_of_mul_eq_zero", "ne_zero_of_mul_ne_zero_left", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "division_def", "abs_mul_abs_self", "mul_lt_mul_of_neg_left", "nat.pow_le_pow_of_le_left", "mul_self_sub_one_eq", "ring.mul_zero", "discrete_field", "nat.shiftl_eq_mul_pow", "norm_num.mul_bit0", "div_sub_div", "nat.add_mul_mod_self_right", "div_pos_of_neg_of_neg", "dvd.intro", "mul_nonpos_of_nonpos_of_nonneg", "two_mul", "norm_num.mul_bit0_helper", "eq_inv_iff_mul_eq_one", "div_lt_of_mul_lt_of_pos", "mul_ne_zero_comm", "nat.mul_one", "nat.mul_div_mul", "nat.lcm", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "eq_zero_of_zero_dvd", "monoid_to_is_left_id", "mul_nonneg_of_nonpos_of_nonpos", "mul_right_eq_self", "mul_dvd_mul", "eq_mul_inv_iff_mul_eq", "mul_le_mul_of_nonneg_right", "nat.mul_div_assoc", "right_distrib", "mul_inv_rev", "mul_inv_eq", "decidable_linear_ordered_semiring", "int.nat_abs_mul_self", "div_nonneg_of_nonpos_of_neg", "norm_num.mul_bit1_helper", "dvd_mul_left", "eq_zero_of_mul_eq_self_right", "nat.eq_of_mul_eq_mul_right", "eq_of_mul_eq_mul_right", "nat.bodd_add_div2", "field.one_div_mul_one_div", "nat.succ_mul_succ_eq", "nat.add_mul_div_right", "mul_eq_one_iff_inv_eq", "mul_eq_of_eq_div", "norm_num.mul_one", "abs_sub_square", "int.zero_mul", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "nonneg_of_mul_nonneg_left", "mul_right_cancel", "lt_div_of_mul_lt", "dvd_of_mul_left_dvd", "nat.bit0_val", "comm_group", "nat.pow_lt_pow_of_lt_right", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "mul_right_inj", "div_div_eq_div_mul", "neg_mul_eq_neg_mul", "div_mul_eq_mul_div", "mul_zero_class.to_has_mul", "nat.has_mul", "mul_one", "mul_div_mul_left'", "nat.le_mul_self", "integral_domain", "int.distrib_right", "nat.mul_div_right", "mul_assoc", "nat.shiftr_eq_div_pow", "semiring", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "mul_zero_class", "one_lt_div_of_lt", "mul_inv", "nat.mod_two_of_bodd", "one_dvd", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "one_mul", "nat.add_mul_div_left", "one_div_zero", "div_mul_cancel", "le_div_of_mul_le", "unsigned.has_mul", "mul_ne_zero", "no_zero_divisors", "nat.sub_mul_mod", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "mul_div_cancel_left", "distrib.to_has_mul", "nat.zero_mul", "mul_left_comm", "div_self", "comm_semigroup_to_is_commutative", "dvd_of_mul_right_dvd", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "eq_zero_of_mul_self_eq_zero", "string.hash", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "nat.mul_self_le_mul_self_iff", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "int.mul_one", "ne_zero_of_mul_ne_zero_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "mul_self_iff_eq_one", "div_mul_le_div_mul_of_div_le_div_pos", "no_zero_divisors.to_has_mul", "mul_lt_mul", "nat.one_shiftl", "add_mul_self_eq", "ring", "norm_num.zero_mul", "nat.mul_le_mul_left", "div_mul_left", "lt_of_mul_lt_mul_right", "int.coe_nat_mul_out", "mul_pos", "functor.const.applicative", "division_ring", "nat.mul_zero", "exists_eq_mul_left_of_dvd", "algebra.div", "nat.div_le_of_le_mul", "mul_right_surjective", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "eq_inv_mul_iff_mul_eq", "mul_self_le_mul_self_iff", "neg_mul_comm", "add_div_eq_mul_add_div", "nat.mul_mod_mul_left", "dvd.elim", "nat.bodd_mul", "int.distrib_left", "mul_eq_one_iff_eq_inv", "nat.mul_self_lt_mul_self_iff", "semigroup.to_has_mul", "int.of_nat_mul", "nat.div_mul_cancel", "nat.eq_zero_of_mul_eq_zero", "mul_eq_of_eq_inv_mul", "nat.div_eq_of_eq_mul_right", "int.has_mul", "nat.mul_div_cancel'", "mul_one_div_cancel", "pos_of_mul_pos_right", "mul_left_eq_self", "int.eq_one_of_mul_eq_self_left", "mul_right_comm", "zero_div", "ordered_semiring", "exists_eq_mul_right_of_dvd", "lt_of_one_lt_div", "field.div_div_div_div_eq", "abs_mul", "mul_le_of_le_div", "left_distrib", "norm_num.div_add_helper", "mul_inv_eq_iff_eq_mul", "zero_mul", "mul_sub", "discrete_linear_ordered_field", "dvd.intro_left", "nat.bit_decomp", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "eq_div_of_mul_eq", "mul_inv_cancel_left", "le_mul_of_ge_one_left", "comm_ring", "int.one_mul", "mul_left_cancel", "nat.pow_succ", "nat.mul_pred_left", "linear_ordered_ring", "fin.mul_def", "mul_neg_of_neg_of_pos", "nat.dvd_add_iff_right", "mul_pos_of_neg_of_neg", "nat.dvd_mod_iff", "one_div_ne_zero", "le_of_mul_le_mul_right", "distrib", "mul_right_inv", "field.div_mul_left", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "mul_le_mul_of_nonpos_left", "mul_inv_self", "le_of_mul_le_of_ge_one", "int.mul_zero", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "neg_dvd_of_dvd", "one_inv_eq", "comm_monoid", "mul_eq_zero_iff_eq_zero_or_eq_zero", "int.sign_mul_abs", "inv_mul_cancel_left", "nat.mul_lt_mul_of_pos_left", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "group", "nat.mul_le_mul_right", "mul_inv_cancel", "neg_of_mul_neg_right", "add_mul", "dvd_trans", "div_lt_div_of_lt_of_neg", "nat.dvd_of_mul_dvd_mul_right", "norm_num.add_div_helper", "int.mul_pos", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "mul_eq_of_eq_mul_inv", "sub_mul", "mul_right_cancel_iff", "neg_eq_neg_one_mul", "lt_mul_of_gt_one_right", "dvd_mul_of_dvd_right", "nat.mul_mod_left", "div_nonpos_of_nonpos_of_pos", "nat.mul_lt_mul_of_pos_right", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "div_eq_mul_one_div", "nat.div_lt_self", "div_mul_right", "nat.mul_mod_right", "group.mul_left_cancel", "mul_inv'", "mul_le_of_div_le_of_neg", "nat.mul_succ", "nat.div2_val", "nat.mul_self_le_mul_self", "nat.bit1_val", "add_self_div_two", "dvd_mul_of_dvd_left", "div_lt_div_of_lt_of_pos", "nat.mul_div_left", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "mul_neg_eq_neg_mul_symm", "nat.div_eq_of_lt_le", "int.mul_assoc", "abs_div", "pos_of_mul_pos_left", "div_mul_eq_div_mul_one_div", "mul_self_sub_mul_self_eq", "lt_of_mul_lt_mul_left", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "functor.const.is_lawful_applicative", "comm_semigroup", "norm_num.neg_mul_pos_helper", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "nat.div_le_self", "nat.bodd_bit", "one_div_lt_one_div_of_lt", "mul_div_assoc", "nat.sub_mul_div", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "nat.left_distrib", "division_ring.mul_ne_zero", "mul_dvd_mul_left", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "dvd_mul_right", "mul_inv_eq_one", "neg_of_mul_neg_left", "mul_left_injective", "nat.right_distrib", "semigroup_to_is_associative", "inv_comm_of_comm", "mul_sub_right_distrib", "norm_num.subst_into_prod", "mul_dvd_mul_right", "eq_zero_of_mul_self_add_mul_self_eq_zero", "nat.div2_bit", "dvd_add", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "nat.mul_sub_right_distrib", "mul_left_surjective", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "nat.mul_self_sub_mul_self_eq", "div_eq_one_iff_eq", "mul_div_mul_left", "monoid", "nat.mul_self_lt_mul_self", "comm_semiring_has_dvd", "eq_mul_of_inv_mul_eq", "inv_mul_self", "nat.bit_val", "nat.pow_lt_pow_of_lt_left", "dvd.elim_left", "nat.dvd_of_mod_eq_zero", "mul_div_mul_right'", "dvd_refl", "ordered_ring.mul_lt_mul_of_pos_right", "mul_comm", "div_lt_div_of_pos_of_lt_of_pos", "nat.mod_add_div", "eq_of_mul_eq_mul_left", "field", "norm_num.neg_mul_neg_helper", "native.float.has_mul", "mul_inv_eq_of_eq_mul", "fin.has_mul", "mul_div_cancel'", "nat.mul_div_cancel_left", "dvd_neg_of_dvd", "dvd_of_mul_left_eq", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_div_mul_right", "eq_zero_of_mul_eq_self_left", "nat.dvd_of_mul_dvd_mul_left", "div_one", "inv_eq_of_mul_eq_one", "int.mul_nonneg", "mul_self_eq_mul_self_iff", "eq_inv_of_mul_eq_one", "add_halves", "field.div_div_eq_mul_div", "distrib_three_right", "mul_div_cancel", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "nat.zero_shiftl", "nat.succ_mul", "eq_inv_mul_of_mul_eq", "mul_nonpos_of_nonneg_of_nonpos", "decidable_linear_ordered_comm_ring", "div_mul_eq_mul_div_comm", "neg_div", "nat.div_mul_le_self", "div_div_div_div_eq", "int.eq_one_of_mul_eq_self_right", "right_cancel_semigroup", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "mul_self_nonneg", "mul_left_inv", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_zero", "nonpos_of_mul_nonpos_right", "mul_left_cancel_iff", "eq_one_div_of_mul_eq_one", "mul_sub_left_distrib", "left_cancel_semigroup", "nat.mul_comm", "one_div_add_one_div", "nat.eq_of_mul_eq_mul_left", "nat.add_mul_mod_self_left", "mul_nonneg", "monoid_to_is_right_id", "neg_mul_eq_mul_neg", "semigroup", "norm_num.mul_bit1", "mul_mul_div", "neg_mul_neg", "int.mul_comm", "mul_lt_mul_of_pos_right", "mul_right_injective", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "nat.zero_pow", "norm_num.div_helper", "linear_ordered_field", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "mul_zero", "mul_inv_cancel_right", "nat.one_mul", "div_le_of_le_mul", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "nat.le_div_iff_mul_le", "mul_left_inj", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "ring.zero_mul", "ordered_ring.mul_lt_mul_of_pos_left", "mul_mul_mul_comm", "mul_lt_mul'", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "eq_mul_of_mul_inv_eq", "div_mul_div", "ordered_ring", "mul_self_eq_one_iff", "nat.mul_mod_mul_right", "div_add_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.shiftl'_tt_eq_mul_pow", "int.coe_nat_mul", "dvd_zero", "inv_mul_eq_iff_eq_mul", "division_ring.one_div_neg_eq_neg_one_div", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "abs_mul_self", "mul_self_le_mul_self", "eq_div_iff_mul_eq", "nat.div_one", "dvd_of_mul_right_eq", "nat.mod_eq_zero_of_dvd", "mul_le_mul", "group.mul_right_cancel", "div_lt_div_of_mul_sub_mul_div_neg", "inv_mul_cancel_right", "nat.mul_div_cancel", "nat.pow_one", "mul_le_mul_of_nonpos_right", "mul_add"]}, {"id": "add_group.to_has_neg", "parentIds": ["neg_mul_eq_neg_mul_symm", "abs_add_le_abs_add_abs", "sub_lt_sub_of_lt_of_le", "int.neg_succ_of_nat_coe'", "neg_eq_iff_neg_eq", "dvd_neg_iff_dvd", "sub_eq_sub_iff_sub_eq_sub", "neg_add_le_of_le_add", "neg_add_self", "eq_add_neg_iff_add_eq", "min_neg_neg", "int.le.dest", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "div_sub_div", "add_sub_comm", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "sub_right_comm", "add_midpoint", "neg_add_eq_sub", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "neg_le_abs_self", "add_sub_cancel'", "add_right_surjective", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "sub_le_sub_left", "sub_left_le_of_le_add", "neg_inj'", "int.neg_ne_zero_of_ne", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "add_le_of_le_neg_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "div_two_sub_self", "add_neg_eq_iff_eq_add", "eq_add_neg_of_add_eq", "max_eq_neg_min_neg_neg", "norm_num.subst_into_subtr", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "lt_add_of_neg_add_lt_left", "neg_lt_neg", "left_inverse_neg_add_add_right", "norm_num.pos_mul_neg_helper", "mul_lt_mul_of_neg_right", "left_inverse_add_right_neg_add", "int.of_nat_nat_abs_of_nonpos", "norm_num.neg_add_pos_eq_of_eq_add", "norm_num.neg_add_pos_helper2", "eq_neg_iff_eq_neg", "neg_add", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "zero_sub", "add_eq_zero_iff_neg_eq", "norm_num.neg_zero_helper", "neg_mul_comm", "le_add_of_neg_le_sub_left", "neg_add_eq_iff_eq_add", "lt_add_of_neg_lt_sub_left", "neg_add_cancel_right", "add_sub_add_right_eq_sub", "abs_nonneg", "eq_add_of_add_neg_eq", "abs_mul", "neg_le_neg", "left_inverse_neg", "neg_add_le_right_of_le_add", "abs", "sub_sub", "int.le.intro", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "abs_of_neg", "add_neg_self", "neg_add_le_left_of_le_add", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "sub_sub_assoc_swap", "neg_of_neg_pos", "eq_zero_of_neg_eq", "sub_lt_self", "sub_eq_of_eq_add", "sub_sub_sub_cancel_left", "mul_le_mul_of_nonpos_left", "int.abs_eq_nat_abs", "sub_sub_self", "sub_eq_of_eq_add'", "neg_dvd_of_dvd", "neg_comm_of_comm", "neg_dvd_iff_dvd", "sub_le_sub_right", "abs_neg", "le_add_of_neg_add_le", "neg_nonpos_of_nonneg", "add_neg_cancel_right", "add_group.add_right_cancel", "sub_lt_of_abs_sub_lt_left", "algebra.sub", "neg_eq_neg_one_mul", "eq_sub_of_add_eq", "sub_zero", "sub_lt_sub_left", "eq_zero_of_abs_eq_zero", "norm_num.nonzero_of_neg_helper", "neg_le_sub_right_of_le_add", "eq_neg_iff_add_eq_zero", "add_eq_of_eq_add_neg", "one_div_neg_one_eq_neg_one", "lt_add_of_neg_add_lt", "gt_of_mul_lt_mul_neg_left", "one_div_neg_eq_neg_one_div", "int.eq_coe_of_zero_le", "mul_neg_eq_neg_mul_symm", "neg_sub", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "sub_left_lt_of_lt_add", "norm_num.neg_mul_pos_helper", "eq_neg_add_of_add_eq", "add_right_neg", "neg_pos_of_neg", "zero_gt_neg_one", "dvd_of_neg_dvd", "abs_pos_of_neg", "int.sign_mul_nat_abs", "neg_involutive", "int.le_total", "lt_add_of_neg_lt_sub_right", "add_sub", "abs_of_nonneg", "mul_sub_right_distrib", "lt_neg_of_lt_neg", "add_left_neg", "le_sub_right_of_add_le", "division_ring.neg_div_neg_eq", "min_eq_neg_max_neg_neg", "eq_of_neg_eq_neg", "neg_lt_of_neg_lt", "neg_inj", "add_neg_cancel_left", "add_add_neg_cancel'_right", "abs_by_cases", "neg_add_rev", "dvd_sub", "neg_add_cancel_left", "neg_eq_iff_add_eq_zero", "le_add_of_neg_add_le_right", "add_left_surjective", "neg_eq_zero", "lt_sub_right_of_add_lt", "sub_add_eq_add_sub", "neg_ne_zero", "int.exists_eq_neg_of_nat", "norm_num.neg_mul_neg_helper", "dvd_neg_of_dvd", "nonpos_of_neg_nonneg", "neg_add_lt_left_of_lt_add", "lt_of_neg_lt_neg", "eq_sub_of_add_eq'", "sub_pos_of_lt", "mul_self_eq_mul_self_iff", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "pos_of_neg_neg", "sub_lt_sub_of_le_of_lt", "neg_div_neg_eq", "neg_neg", "sub_nonpos_of_le", "sub_le_sub", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "eq_neg_of_add_eq_zero", "sub_le_self", "neg_div", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "div_neg_eq_neg_div", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "div_sub_div_same", "mul_sub_left_distrib", "sub_eq_add_neg", "norm_num.neg_add_neg_helper", "abs_lt_of_lt_of_neg_lt", "sub_left_inj", "abs_sub", "neg_add'", "neg_of_one_div_neg", "neg_mul_eq_mul_neg", "sub_add_eq_sub_sub", "neg_mul_neg", "eq_neg_add_iff_add_eq", "sub_eq_neg_add", "sub_eq_sub_add_sub", "norm_num.neg_neg_helper", "sub_right_inj", "nonneg_of_neg_nonpos", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "sub_lt_sub", "sub_add", "neg_nonneg_of_nonpos", "ordered_comm_group.le_of_add_le_add_left", "dvd_of_dvd_neg", "neg_eq_of_add_eq_zero", "neg_lt_sub_right_of_lt_add", "mul_self_eq_one_iff", "add_eq_of_eq_neg_add", "neg_zero", "division_ring.one_div_neg_eq_neg_one_div", "max_neg_neg", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "le_neg_add_of_add_le", "add_group.add_left_cancel", "neg_neg_of_pos", "sub_nonneg_of_le", "neg_add_lt_right_of_lt_add", "add_sub_assoc", "add_neg_eq_zero", "one_div_le_neg_one", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt", "neg_le_of_neg_le", "mul_le_mul_of_nonpos_right"]}, {"id": "int.lt_of_le_sub_one", "parentIds": []}, {"id": "decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring", "parentIds": ["int.lt_of_le_sub_one", "abs_mul_abs_self", "int.le_of_lt_add_one", "int.neg_ne_of_pos", "abs_sub_square", "int.zero_nonneg", "int.one_pos", "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "sub_le_of_abs_sub_le_left", "int.nat_abs_add_nonneg", "sub_lt_of_abs_sub_lt_right", "int.of_nat_nat_abs_of_nonpos", "int.of_nat_nat_abs_eq_of_nonneg", "int.bit1_pos", "int.eq_one_of_mul_eq_self_left", "abs_mul", "int.one_nonneg", "int.le_sub_one_of_lt", "int.eq_neg_succ_of_lt_zero", "sub_lt_of_abs_sub_lt_left", "int.bit0_pos", "int.nat_abs_bit1_nonneg", "abs_div", "int.lt_of_sub_one_le", "sub_le_of_abs_sub_le_right", "eq_zero_of_mul_self_add_mul_self_eq_zero", "int.neg_succ_lt_zero", "int.sub_one_le_of_lt", "int.exists_eq_neg_of_nat", "int.eq_one_of_mul_eq_self_right", "int.lt_add_one_of_le", "int.bit0_nonneg", "abs_abs_sub_abs_le_abs_sub", "int.le_nat_abs", "abs_mul_self"]}, {"id": "ordered_ring.to_ordered_comm_group", "parentIds": ["int.lt_of_le_sub_one", "lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "mul_lt_mul_of_neg_left", "one_div_pos_of_pos", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "mul_nonneg_of_nonpos_of_nonpos", "int.neg_ne_of_pos", "add_midpoint", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "one_div_le_of_one_div_le_of_neg", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "int.zero_nonneg", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "int.nat_abs_add_nonneg", "le_div_of_mul_le", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "sub_lt_of_abs_sub_lt_right", "int.of_nat_nat_abs_of_nonpos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "int.of_nat_nat_abs_eq_of_nonneg", "mul_self_le_mul_self_iff", "lt_of_one_lt_div", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "discrete_linear_ordered_field", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "int.le_sub_one_of_lt", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "linear_ordered_ring", "mul_pos_of_neg_of_neg", "int.eq_neg_succ_of_lt_zero", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "div_mul_le_div_mul_of_div_le_div_pos'", "sub_lt_of_abs_sub_lt_left", "div_lt_div_of_lt_of_neg", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "ordered_ring.mul_le_mul_of_nonneg_right", "norm_num.nonzero_of_neg_helper", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "gt_of_mul_lt_mul_neg_left", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "int.lt_of_sub_one_le", "sub_le_of_abs_sub_le_right", "eq_zero_of_mul_self_add_mul_self_eq_zero", "mul_lt_of_lt_div", "ordered_ring.mul_lt_mul_of_pos_right", "div_lt_div_of_pos_of_lt_of_pos", "int.sub_one_le_of_lt", "int.exists_eq_neg_of_nat", "two_ge_one", "ordered_ring.mul_le_mul_of_nonneg_left", "two_pos", "one_div_le_one_div_of_le", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "decidable_linear_ordered_comm_ring", "mul_self_nonneg", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "nonneg_le_nonneg_of_squares_le", "linear_ordered_field", "abs_abs_sub_abs_le_abs_sub", "div_le_of_le_mul", "int.le_nat_abs", "le_of_one_le_div", "ordered_ring.mul_lt_mul_of_pos_left", "div_neg_of_neg_of_pos", "pos_and_pos_or_neg_and_neg_of_mul_pos", "four_pos", "div_two_lt_of_pos", "one_lt_one_div", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "int.has_lt", "parentIds": ["int.lt_of_le_sub_one", "int.add_one_le_of_lt", "int.decidable_lt", "int.lt_of_add_one_le", "int.lt.intro", "int.le_of_lt_add_one", "int.neg_ne_of_pos", "int.lt.elim", "int.one_pos", "int.lt_succ", "int.nat_abs_add_neg", "int.lt_add_succ", "int.nat_abs_add_nonneg", "int.sign_eq_neg_one_iff_neg", "int.lt_of_coe_nat_lt_coe_nat", "int.coe_nat_lt_coe_nat_iff", "int.of_nat_nat_abs_eq_of_nonneg", "int.lt_irrefl", "int.bit1_pos", "int.add_lt_add_left", "int.sign_eq_one_iff_pos", "int.lt_iff_le_and_ne", "int.zero_lt_one", "int.le_sub_one_of_lt", "int.eq_neg_succ_of_lt_zero", "int.ne_of_lt", "int.nonneg_of_pos", "int.mul_pos", "int.eq_succ_of_zero_lt", "int.bit0_pos", "int.coe_nat_lt_coe_nat_of_lt", "int.lt_iff_le_not_le", "int.lt_of_sub_one_le", "int.pos_of_sign_eq_one", "int.neg_succ_lt_zero", "int.neg_of_sign_eq_neg_one", "int.sub_one_le_of_lt", "int.lt_add_one_of_le", "int.sign_eq_neg_one_of_neg", "int.ne_neg_of_pos", "int.lt.dest", "int.coe_succ_pos", "int.sign_eq_one_of_pos", "int.lt_iff_add_one_le", "int.neg_succ_of_nat_lt_zero", "int.le_of_lt"]}, {"id": "has_sub", "parentIds": ["int.lt_of_le_sub_one", "lt_add_of_sub_right_lt", "int.decidable_lt", "sub_lt_sub_of_lt_of_le", "int.neg_succ_of_nat_coe'", "sub_eq_sub_iff_sub_eq_sub", "nat.sub_succ", "nat.mod_lt", "mul_sub_mul_div_mul_nonpos", "int.le.dest", "nat.div_eq_of_lt", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "div_sub_div", "add_sub_comm", "le_add_of_sub_left_le", "tactic.existsi", "nat.succ_sub_sub_succ", "unused_arguments", "array.take", "abs_sub_le", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "sub_right_comm", "add_midpoint", "add_add_sub_cancel", "neg_add_eq_sub", "nat.div_def", "nat.sub_eq_zero_of_le", "int.le.dest_sub", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "sub_add_add_cancel", "nat.sub_sub_self", "eq_of_mul_eq_mul_right", "nat.sub_le_sub_left", "add_sub_cancel'", "parser.foldl", "nat.shiftl_sub", "abs_sub_square", "int.has_sub", "sub_le_sub_left", "tactic.interactive.induction", "sub_left_le_of_le_add", "add_sub_sub_cancel", "sub_eq_zero_of_eq", "fin.has_sub", "ge_of_forall_ge_sub", "string.iterator.length_next_to_string_next", "exists_add_lt_and_pos_of_lt", "list.func.sub", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "div_two_sub_self", "sub_ne_zero_of_ne", "int.sub_nat_nat_elim", "sub_eq_iff_eq_add", "list.length_drop", "norm_num.subst_into_subtr", "neg_sub_neg", "nat.sub_eq_iff_eq_add", "nat.succ_sub_succ_eq_sub", "nat.sub_eq_sub_min", "sub_sub_cancel", "nat.sub_mul_mod", "nat.div_def_aux", "add_sub_cancel'_right", "parser.foldr", "sub_le_of_sub_le", "nat.mod_eq_of_lt", "left_inverse_add_left_sub", "sub_lt_of_abs_sub_lt_right", "nat.lt_of_sub_eq_succ", "nat.shiftl'_sub", "buffer.drop", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "nat.add_sub_cancel", "neg_neg_sub_neg", "zero_sub", "int.of_nat_sub", "tactic.constructor_idx", "tactic.constructor_num_fields", "mul_sub_mul_div_mul_neg", "nat.sub_pos_of_lt", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "add_group_has_sub", "le_add_of_neg_le_sub_left", "lt_add_of_neg_lt_sub_left", "nat.zero_sub", "add_sub_add_right_eq_sub", "nat.succ_sub_succ", "buffer.lt_aux_2", "nat.sub_self", "nat.zero_mod", "sub_add_cancel", "sub_sub", "nat.sub_lt_of_pos_le", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "mul_sub", "nat.add_mod_right", "int.le.intro", "nat.add_sub_add_right", "neg_le_sub_left_of_le_add", "nat.add_sub_cancel_left", "sub_eq_zero", "int.le_sub_one_of_lt", "lt_of_sub_pos", "nat.mul_pred_left", "sub_right_le_of_le_add", "sub_ne_zero", "le_sub_left_of_add_le", "eq_iff_eq_of_sub_eq_sub", "sub_sub_assoc_swap", "nat.dvd_add_iff_right", "nat.dvd_sub", "sub_lt_self", "sub_eq_of_eq_add", "sub_sub_sub_cancel_left", "sub_sub_self", "array.take_right", "sub_eq_of_eq_add'", "int.sub_nat_nat", "nat.sub_self_add", "sub_le_sub_right", "le_add_of_sub_right_le", "nat.sub_one_sub_lt", "sub_lt_of_abs_sub_lt_left", "buffer.lt_aux_3", "sub_mul", "eq_sub_of_add_eq", "nat.add_div_right", "sub_zero", "list.length_tail", "sub_lt_sub_left", "ordered_ring.mul_le_mul_of_nonneg_right", "neg_le_sub_right_of_le_add", "nat.mod_zero", "sub_add_sub_cancel", "array.drop", "int.eq_coe_of_zero_le", "neg_sub", "tactic.explode.pad_right", "mul_self_sub_mul_self_eq", "add_sub_cancel", "int.coe_nat_sub", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "sub_left_lt_of_lt_add", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "nat.sub_add_comm", "nat.succ_sub", "nat.le_of_le_of_sub_le_sub_right", "nat.sub_mul_div", "fin.sub_def", "add_lt_of_lt_sub_right", "nat.sub.right_comm", "nat.mod_self", "norm_num.sub_nat_pos_helper", "int.le_total", "lt_add_of_neg_lt_sub_right", "int.lt_of_sub_one_le", "tactic.injection_with", "add_sub", "mul_sub_right_distrib", "sub_le_of_abs_sub_le_right", "parser.remaining", "tactic.rename", "le_sub_right_of_add_le", "nat.sub_sub", "nat.sub_zero", "nat.mul_sub_right_distrib", "nat.sub_add_min_cancel", "nat.le_of_sub_eq_zero", "nat.mul_self_sub_mul_self_eq", "dvd_sub", "left_inverse_sub_add_left", "nat.div_eq_sub_div", "nat.sub_le_sub_right_iff", "sub_lt_of_sub_lt", "nat.zero_div", "parser.fix", "lt_sub_right_of_add_lt", "nat.mod_def_aux", "ordered_ring.mul_lt_mul_of_pos_right", "sub_add_eq_add_sub", "div_lt_div_of_pos_of_lt_of_pos", "int.sub_one_le_of_lt", "nat.mod_add_div", "eq_of_mul_eq_mul_left", "tactic.interactive.swap", "eq_sub_iff_add_eq", "sub_self_div_two", "nat.mod_eq_sub_mod", "eq_of_abs_sub_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_left", "eq_sub_of_add_eq'", "sub_pos_of_lt", "int.to_nat_sub", "mul_self_eq_mul_self_iff", "dist_bdd_within_interval", "sub_lt_sub_of_le_of_lt", "expr.ith_arg", "nat.sub_le", "sub_nonpos_of_le", "sub_le_sub", "sub_sub_sub_cancel_right", "sub_le_self", "nat.sub_le_sub_right", "lt_of_sub_neg", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "int.le.intro_sub", "nat.sub_eq_zero_iff_le", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "div_sub_div_same", "mul_sub_left_distrib", "sub_eq_add_neg", "nat.sub_lt", "sub_left_inj", "abs_sub", "neg_add'", "sub_add_eq_sub_sub", "sub_eq_zero_iff_eq", "nat.sub_one", "nat.mod_pow_succ", "nat.has_sub", "lt_add_of_sub_left_lt", "abs_abs_sub_abs_le_abs_sub", "tactic.interactive.case", "sub_eq_neg_add", "sub_eq_sub_add_sub", "nat.succ_sub_one", "tactic.rotate_right", "sub_right_inj", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "nat.mod_def", "nat.add_sub_of_le", "nat.le_div_iff_mul_le", "sub_lt_sub", "sub_add_sub_cancel'", "sub_add", "native.float.has_sub", "sub_eq_iff_eq_add'", "nat.add_le_to_le_sub", "eq_sub_iff_add_eq'", "list.length_remove_nth", "nat.sub_lt_succ", "ordered_ring.mul_lt_mul_of_pos_left", "nat.sub_add_cancel", "sub_self", "neg_lt_sub_right_of_lt_add", "int.le", "array.slice", "le_of_sub_nonpos", "nat.div_zero", "unsigned.has_sub", "nat.mul_sub_div", "add_eq_of_eq_sub", "sub_neg_eq_add", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "add_sub_assoc", "int.decidable_le", "nat.add_sub_add_left", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt"]}, {"id": "int.decidable_linear_ordered_comm_ring", "parentIds": ["int.lt_of_le_sub_one", "int.le_of_lt_add_one", "int.neg_ne_of_pos", "int.zero_nonneg", "int.one_pos", "int.nat_abs_add_nonneg", "int.of_nat_nat_abs_of_nonpos", "int.of_nat_nat_abs_eq_of_nonneg", "int.bit1_pos", "int.eq_one_of_mul_eq_self_left", "int.one_nonneg", "int.le_sub_one_of_lt", "int.eq_neg_succ_of_lt_zero", "int.bit0_pos", "int.nat_abs_bit1_nonneg", "int.lt_of_sub_one_le", "int.neg_succ_lt_zero", "int.sub_one_le_of_lt", "int.exists_eq_neg_of_nat", "int.eq_one_of_mul_eq_self_right", "int.lt_add_one_of_le", "int.decidable_linear_ordered_comm_group", "int.bit0_nonneg", "int.le_nat_abs"]}, {"id": "int.has_one", "parentIds": ["int.lt_of_le_sub_one", "int.add_one_le_of_lt", "int.decidable_lt", "int.neg_succ_of_nat_coe'", "int.lt_of_add_one_le", "int.nat_abs_bit1_nonneg_step", "int.le_of_lt_add_one", "int.bit", "int.zero_ne_one_class", "int.one_pos", "int.lt_succ", "int.lt_add_succ", "int.sign_one", "int.sign_eq_neg_one_iff_neg", "int.mul_one", "int.coe_nat_lt_coe_nat_iff", "int.sub_nat_nat_eq_coe", "int.bit1_pos", "int.coe_nat_add_one_out", "int.eq_one_of_mul_eq_self_left", "int.sign_eq_one_iff_pos", "int.zero_lt_one", "int.bit1_nonneg", "int.one_nonneg", "int.le_sub_one_of_lt", "int.one_mul", "int.coe_nat_one", "int.sign_neg_one", "int.eq_succ_of_zero_lt", "int.coe_nat_succ", "int.nat_abs_bit1_nonneg", "int.neg_succ_of_nat_eq", "int.lt_of_sub_one_le", "int.pos_of_sign_eq_one", "int.neg_of_sign_eq_neg_one", "int.sub_one_le_of_lt", "int.nat_abs_one", "int.of_nat_one", "int.sign_of_succ", "int.eq_one_of_mul_eq_self_right", "int.lt_add_one_of_le", "int.of_nat_succ", "int.sign_eq_neg_one_of_neg", "int.lt.dest", "int.sign_eq_one_of_pos", "int.lt_iff_add_one_le", "int.neg_succ_of_nat_lt_zero", "int.zero_ne_one", "int.lt"]}, {"id": "int.has_sub", "parentIds": ["int.lt_of_le_sub_one", "int.decidable_lt", "int.neg_succ_of_nat_coe'", "int.le.dest", "int.le.dest_sub", "int.sub_nat_nat_eq_coe", "int.of_nat_sub", "int.le.intro", "int.le_sub_one_of_lt", "int.eq_coe_of_zero_le", "int.coe_nat_sub", "int.le_total", "int.lt_of_sub_one_le", "int.sub_one_le_of_lt", "int.to_nat_sub", "int.le.intro_sub", "int.le", "int.decidable_le"]}, {"id": "int", "parentIds": ["int.lt_of_le_sub_one", "int.add_one_le_of_lt", "int.decidable_lt", "int.neg_succ_of_nat_coe'", "int.of_nat_ge_zero", "int.lt_of_add_one_le", "int.add_comm", "int.le.dest", "int.nat_abs_of_nat", "int.add_comm_monoid", "int.coe_nat_add_out", "int.has_add", "int.neg_of_nat", "int.lt.intro", "int.nat_abs_bit1_nonneg_step", "int.le_of_lt_add_one", "int.repr", "int.has_lt", "int.mod", "int.add_assoc", "int.neg_ne_of_pos", "int.has_div", "int.le_of_coe_nat_le_coe_nat", "int.zero_ne_neg_of_ne", "int.bit", "int.nat_abs_mul_self", "int.le.dest_sub", "int.add_comm_semigroup", "int.nat_abs_eq", "int.ne_of_nat_ne_nonneg_case", "int.has_zero", "int.has_sub", "int.zero_mul", "int.neg_of_nat_zero", "int.zero_nonneg", "int.zero_ne_one_class", "int.comm_semiring", "int.neg_ne_zero_of_ne", "int.coe_nat_le_coe_nat_iff", "int.lt.elim", "int.add_zero", "expr.to_int", "int.one_pos", "int.rem", "int.distrib_right", "native.float.specification.emin", "int.of_nat_inj", "int.lt_succ", "int.of_nat_zero", "int.nat_abs_add_neg", "int.sub_nat_nat_elim", "int.mk_numeral", "int.nat_abs_pos_of_ne_zero", "int.lt_add_succ", "int.sign_one", "int.add", "int.nat_abs_add_nonneg", "int.has_repr", "int.sign_eq_neg_one_iff_neg", "int.nat_bitwise", "int.neg_succ_of_nat_inj_iff", "int.lt_of_coe_nat_lt_coe_nat", "native.float.exponent", "int.mul_one", "int.eq_coe_or_neg", "int.add_left_neg", "int.nat_abs_bit0_step", "int.of_nat_nat_abs_of_nonpos", "int.coe_nat_lt_coe_nat_iff", "int.coe_nat_mul_out", "int.sub_nat_nat_eq_coe", "int.of_nat_nonneg", "int.comm_ring", "int.of_nat_sub", "int.coe_nat_zero", "int.mul", "native.float.frexp", "int.of_nat_nat_abs_eq_of_nonneg", "int.bitwise", "int.ne_neg_of_ne", "int.distrib_left", "int.lt_irrefl", "int.bit1_pos", "int.add_lt_add_left", "int.of_nat_mul", "int.add_semigroup", "int.has_mul", "int.coe_nat_add_one_out", "int.le_antisymm", "int.div2", "int.eq_one_of_mul_eq_self_left", "int.sign_eq_one_iff_pos", "int.lt_iff_le_and_ne", "int.zero_lt_one", "int.has_le", "int.bit1_nonneg", "int.has_to_string", "int.le.intro", "int.one_nonneg", "int.le_sub_one_of_lt", "int.quot", "int.coe_nat_add", "int.one_mul", "int.le_trans", "int.zero", "int.coe_nat_eq", "int.has_one", "int.has_coe", "int.nat_abs_neg", "int.land", "int.eq_neg_succ_of_lt_zero", "int.ne_of_lt", "int.nat_abs_bit0", "native.float.of_int_coe", "int.abs_eq_nat_abs", "int.coe_nat_one", "int.mul_zero", "int.sub_nat_nat", "int.nonneg_of_pos", "int.sign_mul_abs", "int.sign_neg_one", "expr.of_int", "int.sign_zero", "int.nat_abs_of_nat_core", "int.zero_add", "int.mul_pos", "int.eq_succ_of_zero_lt", "int.ldiff", "int.one", "int.add_monoid", "int.semigroup", "int.decidable_linear_ordered_comm_ring", "int.bit0_pos", "int.fmod", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "int.coe_nat_lt_coe_nat_of_lt", "int.coe_nat_succ", "int.coe_nat_inj", "int.lnot", "int.eq_coe_of_zero_le", "int.mul_assoc", "int.coe_nat_eq_coe_nat_iff", "int.nat_abs_bit1_nonneg", "int.add_le_add_left", "int.of_nat_eq_coe", "int.coe_nat_sub", "int.has_mod", "int.neg_neg_of_nat_succ", "int.eq_nat_abs_of_zero_le", "int.sign", "int.nat_mod", "int.lt_iff_le_not_le", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "int.coe_nat_le_coe_nat_of_le", "int.sign_eq_zero_iff_zero", "int.sign_mul_nat_abs", "int.le_total", "int.lt_of_sub_one_le", "int.shiftr", "int.pos_of_sign_eq_one", "int.has_neg", "native.float.mantissa", "int.neg_succ_lt_zero", "int.neg_of_sign_eq_neg_one", "int.le_refl", "int.sub_one_le_of_lt", "int.bodd", "int.exists_eq_neg_of_nat", "int.neg", "int.shiftl", "int.nat_abs_of_nonneg", "int.test_bit", "int.nat_abs_one", "int.mul_nonneg", "int.to_nat_sub", "int.le.elim", "int.of_nat_one", "int.ring", "int.neg_succ_of_nat_inj", "int.nat_abs_of_neg_succ_of_nat", "int.of_nat_add", "int.distrib", "int.sign_of_succ", "int.nat_abs", "int.semiring", "int.eq_one_of_mul_eq_self_right", "int.fdiv", "int.lt_add_one_of_le", "int.decidable_linear_ordered_comm_group", "int.of_nat_succ", "int.le.intro_sub", "int.sign_eq_neg_one_of_neg", "int.comm_monoid", "int.ne_neg_of_pos", "int.to_nat", "native.float.of_int", "int.eq_zero_of_sign_eq_zero", "int.lt.dest", "int.bit0_nonneg", "int.neg_of_nat_of_succ", "int.monoid", "int.coe_succ_pos", "int.decidable_eq", "int.of_nat_eq_of_nat_iff", "int.sign_eq_one_of_pos", "int.mul_comm", "nat.can_lift", "int.lt_iff_add_one_le", "int.neg_succ_of_nat_lt_zero", "int.le_nat_abs", "int.le_of_lt", "int.gcd", "int.le", "int.eq_zero_of_nat_abs_eq_zero", "int.coe_nat_mul", "int.comm_semigroup", "int.zero_ne_one", "int.nat_abs_abs", "int.lt", "int.lor", "int.coe_zero_le", "int.decidable_le", "int.nat_abs_zero", "int.lxor", "int.div"]}, {"id": "linear_ordered_ring.to_ordered_ring", "parentIds": ["int.lt_of_le_sub_one", "lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "abs_mul_abs_self", "one_div_pos_of_pos", "int.le_of_lt_add_one", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "int.neg_ne_of_pos", "add_midpoint", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "one_div_le_of_one_div_le_of_neg", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "int.zero_nonneg", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "int.nat_abs_add_nonneg", "le_div_of_mul_le", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "sub_lt_of_abs_sub_lt_right", "int.of_nat_nat_abs_of_nonpos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "mul_sub_mul_div_mul_neg", "int.of_nat_nat_abs_eq_of_nonneg", "mul_self_le_mul_self_iff", "int.bit1_pos", "lt_of_one_lt_div", "abs_mul", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "int.le_sub_one_of_lt", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "int.eq_neg_succ_of_lt_zero", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "le_of_mul_le_of_ge_one", "div_mul_le_div_mul_of_div_le_div_pos'", "sub_lt_of_abs_sub_lt_left", "div_lt_div_of_lt_of_neg", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "norm_num.nonzero_of_neg_helper", "int.bit0_pos", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "gt_of_mul_lt_mul_neg_left", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "int.lt_of_sub_one_le", "sub_le_of_abs_sub_le_right", "eq_zero_of_mul_self_add_mul_self_eq_zero", "mul_lt_of_lt_div", "div_lt_div_of_pos_of_lt_of_pos", "int.sub_one_le_of_lt", "int.exists_eq_neg_of_nat", "two_ge_one", "two_pos", "one_div_le_one_div_of_le", "add_halves", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "int.lt_add_one_of_le", "mul_self_nonneg", "int.bit0_nonneg", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "nonneg_le_nonneg_of_squares_le", "abs_abs_sub_abs_le_abs_sub", "div_le_of_le_mul", "int.le_nat_abs", "le_of_one_le_div", "div_neg_of_neg_of_pos", "pos_and_pos_or_neg_and_neg_of_mul_pos", "four_pos", "div_two_lt_of_pos", "one_lt_one_div", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "add_le_of_le_sub_right", "parentIds": ["int.lt_of_le_sub_one", "le_add_of_neg_le_sub_left"]}, {"id": "int.has_le", "parentIds": ["int.lt_of_le_sub_one", "int.add_one_le_of_lt", "int.of_nat_ge_zero", "int.lt_of_add_one_le", "int.le.dest", "int.nat_abs_bit1_nonneg_step", "int.le_of_lt_add_one", "int.neg_ne_of_pos", "int.le_of_coe_nat_le_coe_nat", "int.le.dest_sub", "int.ne_of_nat_ne_nonneg_case", "int.zero_nonneg", "int.coe_nat_le_coe_nat_iff", "int.nat_abs_add_nonneg", "int.of_nat_nat_abs_of_nonpos", "int.coe_nat_lt_coe_nat_iff", "int.of_nat_nonneg", "int.of_nat_nat_abs_eq_of_nonneg", "int.bit1_pos", "int.add_lt_add_left", "int.le_antisymm", "int.lt_iff_le_and_ne", "int.bit1_nonneg", "int.le.intro", "int.one_nonneg", "int.le_sub_one_of_lt", "int.le_trans", "int.nonneg_of_pos", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "int.eq_coe_of_zero_le", "int.nat_abs_bit1_nonneg", "int.add_le_add_left", "int.eq_nat_abs_of_zero_le", "int.lt_iff_le_not_le", "int.coe_nat_le_coe_nat_of_le", "int.le_total", "int.lt_of_sub_one_le", "int.le_refl", "int.sub_one_le_of_lt", "int.exists_eq_neg_of_nat", "int.nat_abs_of_nonneg", "int.mul_nonneg", "int.le.elim", "int.lt_add_one_of_le", "int.le.intro_sub", "int.bit0_nonneg", "nat.can_lift", "int.lt_iff_add_one_le", "int.le_nat_abs", "int.le_of_lt", "int.lt", "int.coe_zero_le", "int.decidable_le"]}, {"id": "linear_ordered_comm_ring.to_linear_ordered_ring", "parentIds": ["int.lt_of_le_sub_one", "abs_mul_abs_self", "int.le_of_lt_add_one", "int.neg_ne_of_pos", "abs_sub_square", "int.zero_nonneg", "int.one_pos", "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "sub_le_of_abs_sub_le_left", "int.nat_abs_add_nonneg", "sub_lt_of_abs_sub_lt_right", "int.of_nat_nat_abs_of_nonpos", "int.of_nat_nat_abs_eq_of_nonneg", "int.bit1_pos", "abs_mul", "int.one_nonneg", "int.le_sub_one_of_lt", "int.eq_neg_succ_of_lt_zero", "sub_lt_of_abs_sub_lt_left", "int.bit0_pos", "int.nat_abs_bit1_nonneg", "int.lt_of_sub_one_le", "sub_le_of_abs_sub_le_right", "eq_zero_of_mul_self_add_mul_self_eq_zero", "int.neg_succ_lt_zero", "int.sub_one_le_of_lt", "int.exists_eq_neg_of_nat", "int.lt_add_one_of_le", "int.bit0_nonneg", "abs_abs_sub_abs_le_abs_sub", "int.le_nat_abs"]}, {"id": "iff.refl", "parentIds": ["neg_eq_iff_neg_eq", "cmp_using_eq_gt", "cmp_using_eq_lt", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "eq.congr_left", "mul_eq_one_iff_inv_eq", "iff.rfl", "div_mul_cancel", "div_self", "eq.congr", "inv_eq_iff_inv_eq", "int.coe_nat_lt_coe_nat_iff", "add_eq_zero_iff_neg_eq", "and.left_comm", "mul_one_div_cancel", "eq_iff_eq_cancel_right", "or.left_comm", "eq_iff_eq_of_sub_eq_sub", "eq_iff_eq_cancel_left", "d_array.of_beq_aux_eq_ff", "one_inv_eq", "or_iff_not_and_not", "one_div_mul_cancel", "inv_eq_one", "and_iff_not_or_not", "neq_of_not_iff", "mul_inv_eq_one", "div_eq_one_iff_eq", "neg_eq_zero", "prod.ext_iff", "mul_div_cancel", "cmp_using_eq_eq", "eq.congr_right", "classical.iff_iff_not_or_and_or_not", "mul_mul_div", "int.lt_iff_add_one_le", "nat.le_div_iff_mul_le", "sub_eq_iff_eq_add'", "nat.add_le_to_le_sub", "eq_sub_iff_add_eq'", "nat.div_zero", "list.partition_eq_filter_filter", "add_neg_eq_zero", "function.update_comp"]}, {"id": "false_of_a_eq_not_a", "parentIds": []}, {"id": "absurd", "parentIds": ["false_of_a_eq_not_a", "binder.decidable_eq", "is_strict_weak_order_of_is_total_preorder", "decidable.of_not_not", "cmp_using_eq_gt", "decidable_eq_inl_refl", "nat.one_lt_bit0", "lt_or_gt_of_ne", "int.neg_ne_of_pos", "fin.vne_of_ne", "d_array.of_beq_aux_eq_tt", "is_asymm_of_is_trans_of_is_irrefl", "not.elim", "int.neg_ne_zero_of_ne", "if_ctx_congr_prop", "non_contradictory_intro", "nat.pred_lt_pred", "dif_pos", "not_and_self", "lt_of_not_ge", "ne_of_gt", "not_non_contradictory_iff_absurd", "eq_of_incomp", "nat.lt_wf", "if_pos", "not.decidable", "int.nat_abs_add_nonneg", "nat.add_self_ne_one", "if_ctx_congr", "nat.one_le_bit0", "lt_of_incomp_of_lt", "or.neg_resolve_left", "int.of_nat_nat_abs_eq_of_nonneg", "int.ne_neg_of_ne", "string.str_ne_str_right", "fin.ne_of_vne", "nat.zero_mod", "not_of_not_not_not", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "nat.bit1_ne_bit0", "or.resolve_right", "char.ne_of_vne", "ne_zero_of_one_div_ne_zero", "int.eq_neg_succ_of_lt_zero", "non_contradictory_em", "one_div_ne_zero", "int.ne_of_lt", "eq_zero_of_neg_eq", "dif_ctx_congr", "classical.strong_indefinite_description", "le_of_not_gt", "not_or", "eq_false_of_not_eq_true", "to_bool_iff", "iff_iff_and_or_not_and_not", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "char.vne_of_ne", "nat.div_eq_of_lt_le", "ne_of_lt", "nat.bit0_ne_one", "not_lt_of_lt", "nat.pred_lt", "division_ring.mul_ne_zero", "not_and_of_not_or_not", "neq_of_not_iff", "nat.strong_rec_on", "or.neg_resolve_right", "string.str_ne_str_left", "nat.succ_ne_self", "dif_neg", "if_neg", "nat.pow_lt_pow_of_lt_left", "decidable.not_and_iff_or_not", "and_not_self", "pos_of_one_div_pos", "nat.bit1_ne_one", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "nat.mod_two_eq_zero_or_one", "nat.sub_lt", "nat.pred_inj", "int.decidable_eq", "sum.decidable_eq", "nat.bit1_ne", "lt_of_lt_of_incomp", "decidable_eq_inr_neg", "nat.bit0_ne_zero", "nat.one_lt_bit1", "nat.bit0_ne", "nat.bit1_lt_bit0", "pos_and_pos_or_neg_and_neg_of_mul_pos", "int.eq_zero_of_nat_abs_eq_zero", "or.resolve_left", "division_ring.one_div_neg_eq_neg_one_div", "nat.zero_lt_bit0", "nat.succ_pred_eq_of_pos", "nat.le_antisymm"]}, {"id": "function.right_id", "parentIds": []}, {"id": "rfl", "parentIds": ["function.right_id", "nat.pred_zero", "fin.of_nat_zero", "nat.sub_succ", "heq_of_eq_rec_left", "int.add_comm", "if_t_t", "id.is_comm_applicative", "division_def", "abs_mul_abs_self", "comp.run_pure", "auto_param_eq", "nat.bit_zero", "int.nat_abs_of_nat", "coe_sort_coe_base", "int.coe_nat_add_out", "nat.shiftl'_add", "decidable_eq_inl_refl", "nat.lxor_bit", "nat.test_bit_ldiff", "list.length_cons", "option.is_lawful_monad", "prod.id_prod", "coe_fn_coe_trans", "option_t.run_pure", "nat.succ_eq_add_one", "eq.symm", "function.uncurry_curry", "function.comp.assoc", "functor.add_const.is_lawful_applicative", "prod.mk.eta", "array.read_mem", "norm_num.bit1_add_one", "int.nat_abs_mul_self", "except_t.run_pure", "nat_add_zero", "int.nat_abs_eq", "nat.bodd_add_div2", "reader_t.run_read", "int.neg_of_nat_zero", "nat.test_bit_lor", "option.eq_of_eq_some", "int.add_zero", "nat.ldiff_bit", "function.left_inverse_inv_fun", "sum.is_lawful_monad", "function.equiv.refl", "id.bind_eq", "nat.eq_zero_or_pos", "nat.pred_lt_pred", "nat.nat_zero_eq_zero", "reader_t.run_pure", "right_comm", "dif_pos", "heq_of_eq_mp", "nat.lor_bit", "int.of_nat_zero", "int.nat_abs_add_neg", "functor.const.is_lawful_functor", "monad_lift_refl", "int.sub_nat_nat_elim", "state_t.run_monad_map", "if_pos", "ordering.compares.eq_lt", "functor.comp.map_mk", "int.sign_one", "function.update_same", "list.length_drop", "comp.seq_mk", "int.nat_abs_add_nonneg", "function.curry_uncurry", "list.filter_append", "opt_param_eq", "nat.mul_assoc", "nat.zero_mul", "to_bool_false_eq_ff", "nat.bit0_inj", "list.filter_nil", "nat.bodd_one", "nat.add_succ", "function.inv_fun_on_eq'", "ordering.compares.eq_gt", "ulift.up_down", "nat.one_le_bit0", "int.add_left_neg", "parser.is_lawful_monad", "nat.shiftl'_sub", "to_bool_true_eq_tt", "sum.elim_inl", "exists_eq", "option_t.run_monad_map", "reader_t.is_lawful_monad", "plift.down_inj", "monad_map_refl", "quot.lift_beta", "eq_of_heq", "int.coe_nat_mul_out", "nat.mul_zero", "inv_image.accessible", "int.of_nat_sub", "int.coe_nat_zero", "option.is_none_iff_eq_none", "rbnode.color.decidable_eq", "psigma.rev_lex_accessible", "fin.eq_of_veq", "int.of_nat_nat_abs_eq_of_nonneg", "quot.ind_beta", "list.cons_append", "function.uncurry_bicompr", "nat.div2_zero", "nat.bodd_zero", "prod.swap_swap", "quot.exists_rep", "congr_arg", "comp.run_seq", "prod.map_fst", "id.map_eq", "nat.zero_sub", "id.def", "int.of_nat_mul", "nat.eq_zero_of_mul_eq_zero", "function.injective_of_partial_inv", "list.map_cons", "int.coe_nat_add_one_out", "list.mem_cons_self", "state_t.run_monad_lift", "string.str_ne_str_right", "state_t.run_get", "functor.comp.functor_id_comp", "coe_sort_coe_trans", "functor.comp.functor_comp_id", "char.veq_of_eq", "list.qsort_cons", "bool.coe_sort_tt", "except_t.run_monad_lift", "option.eq_some_of_is_some", "comp.applicative_id_comp", "fin.veq_of_eq", "function.restrict_eq", "int.coe_nat_add", "nat.shiftr_add", "eq_rec_compose", "nat.pow_succ", "int.coe_nat_eq", "option.map_id", "nat.bitwise_bit", "int.eq_neg_succ_of_lt_zero", "function.comp_apply", "forall_eq", "ne.irrefl", "exists_eq_left", "sub_lt_self", "list.lt_eq_not_ge", "nat.bitwise_bit_aux", "prod.fst_swap", "option_t.run_bind", "int.coe_nat_one", "int.mul_zero", "ordering.swap_swap", "bool.cond_ff", "id.is_lawful_monad", "reader_t.run_monad_lift", "nat.discriminate", "eq_self_iff_true", "nat.test_bit_lxor", "nat.succ_add", "int.sign_neg_one", "int.sign_zero", "function.comp_app", "int.nat_abs_of_nat_core", "subtype.eta", "let_value_eq", "prod.lt_def", "nat.add_zero", "nat.land_bit", "list.mem_cons_eq", "bool.cond_tt", "to_bool_iff", "list.nil_append", "function.comp.right_id", "nat.mul_succ", "int.coe_nat_succ", "ulift.down_up", "prod.lex_accessible", "coe_fn_coe_base", "function.left_inverse_of_surjective_of_right_inverse", "list.length_map_accumr", "bool.bnot_false", "nat.le.dest", "nat.one_succ_zero", "int.of_nat_eq_coe", "prod.map_snd", "nat.eq_or_lt_of_le", "functor.const.is_lawful_applicative", "dif_eq_if", "int.neg_neg_of_nat_succ", "cast_proof_irrel", "nat.pred_lt", "function.uncurry_def", "quot.eqv_gen_sound", "subtype.eq", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "nat.shiftl_succ", "functor.comp.is_lawful_functor", "int.sign_mul_nat_abs", "prod.snd_swap", "dvd_mul_right", "nat.right_distrib", "except_t.run_monad_map", "list.is_lawful_monad", "state_t.run_put", "bool.default_bool", "sum.elim_inr", "ne.def", "nat.sub_zero", "subtype.tag_irrelevant", "functor.comp.run_map", "function.surjective_id", "char.eq_of_veq", "nat.add_one", "dif_neg", "if_neg", "sum.is_lawful_functor", "function.comp_const_right", "norm_num.one_add_one", "well_founded.fix_F_eq", "nat.bit1_eq_succ_bit0", "function.comp.left_id", "proof_irrel", "reader_t.run_bind", "comp.applicative_comp_id", "punit_eq", "except_t.is_lawful_monad", "except_t.run_bind", "nat.test_bit_land", "function.is_partial_inv_left", "int.nat_abs_of_nonneg", "reader_t.run_monad_map", "int.nat_abs_one", "psigma.lex_accessible", "bool.bnot_true", "int.of_nat_one", "to_bool_congr", "prod.swap_prod_mk", "int.nat_abs_of_neg_succ_of_nat", "int.of_nat_add", "list.map_singleton", "nat.succ_mul", "int.sign_of_succ", "sub_le_self", "list.length_map_accumr\u2082", "id.pure_eq", "function.uncurry'_bicompr", "nat.bit1_ne_one", "nat.shiftl_zero", "int.of_nat_succ", "nat.pow_zero", "int.sign_eq_neg_one_of_neg", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "sub_eq_add_neg", "int.neg_of_nat_of_succ", "psigma.eq", "nat.pred_inj", "classical.epsilon_singleton", "set.is_lawful_functor", "plift.down_up", "nat.div2_two", "if_eq_of_eq", "int.sign_eq_one_of_pos", "sigma.eq", "nat.sub_one", "norm_num.add1_one", "comp.is_lawful_applicative", "option.eq_none_of_is_none", "nat.succ_sub_one", "option_t.is_lawful_monad", "function.partial_inv_of_injective", "nat.bit0_ne_zero", "option.iget_some", "fin.val_zero", "norm_num.bit0_add_one", "cast_eq", "exists_eq'", "list.length_remove_nth", "nat.zero_add", "option_t.run_monad_lift", "state_t.is_lawful_monad", "function.cantor_injective", "nat.pred_succ", "congr", "function.funext_iff", "function.left_id", "list.le_eq_not_gt", "int.coe_nat_mul", "coe_coe", "ordering.compares.eq_eq", "state_t.run_pure", "list.partition_eq_filter_filter", "nat.zero_lt_bit0", "norm_num.add1_bit0", "nat.div2_one", "nat.succ_pred_eq_of_pos", "int.nat_abs_zero", "nat.add_assoc", "left_comm", "nat.le_antisymm", "nat.bodd_two", "plift.up_down"]}, {"id": "classical.inhabited_of_nonempty'", "parentIds": []}, {"id": "inhabited", "parentIds": ["classical.inhabited_of_nonempty'", "classical.inhabited_of_exists", "tactic.apply_cfg.inhabited", "forall_prop_of_true", "tactic.explode.entries.inhabited", "default", "interactive.loc.inhabited", "pos.inhabited", "function.inv_fun_on_eq", "tactic.rcases_patt_inverted.inhabited", "function.inv_fun_on_neg", "function.inv_fun_eq", "smt_pre_config.inhabited", "reducibility_hints.inhabited", "expr.inhabited", "list.head", "function.inv_fun", "list.ilast", "name.inhabited", "arbitrary", "tactic.suggest.head_symbol_match.inhabited", "environment.projection_info.inhabited", "rbmap.inhabited", "tactic.unfold_proj_config.inhabited", "interactive.executor", "bin_tree.inhabited", "function.left_inverse_inv_fun", "list.func.sub", "name_map.inhabited", "vm_decl_kind.inhabited", "forall_const", "classical.decidable_inhabited", "binder_info.inhabited", "function.inv_fun_eq_of_injective_of_right_inverse", "sum.inhabited_left", "list.func.set", "parser.inhabited", "list.func.equiv", "rsimp.config.inhabited", "buffer.read_eq_read'", "function.inv_fun_on_eq'", "bool.inhabited", "function.inv_fun_on", "function.inv_fun_on_pos", "ulift.inhabited", "punit.inhabited", "string.inhabited", "tactic.simp_config.inhabited", "format.inhabited", "true.inhabited", "psum.inhabited_right", "tactic.transparency.inhabited", "sum.inhabited_right", "to_additive.value_type.inhabited", "tactic.rewrite_cfg.inhabited", "prod.inhabited", "tactic.new_goals.inhabited", "function.inv_fun_surjective", "option.iget", "name_set.inhabited", "rbnode.inhabited", "unsigned.inhabited", "subtype.inhabited", "nat.inhabited", "format.color.inhabited", "classical.inhabited_of_nonempty", "list.func.pointwise", "nonempty_of_inhabited", "array.read'", "function.inv_fun_neg", "function.inv_fun_on_mem", "tactic.delta_config.inhabited", "tactic.rcases_patt.inhabited", "subsingleton_info.inhabited", "buffer.read'", "rbnode.color.inhabited", "tactic.dsimp_config.inhabited", "char.inhabited", "interactive.interactive.executor", "native.rb_map.inhabited", "option.inhabited", "smt_config.inhabited", "assert", "congr_arg_kind.inhabited", "unification_constraint.inhabited", "function.injective_iff_has_left_inverse", "exists_prop_of_true", "binder.inhabited", "unification_hint.inhabited", "list.inth", "pprod.inhabited", "fun_info.inhabited", "array.read_eq_read'", "list.take'", "tactic.dunfold_config.inhabited", "native.rb_set.inhabited", "prop.inhabited", "options.inhabited", "cc_config.inhabited", "environment.inhabited", "string.iterator.inhabited", "fun.inhabited", "list.func.get", "native.rb_lmap.inhabited", "pi.inhabited", "ematch_config.inhabited", "rbtree.inhabited", "param_info.inhabited", "level.inhabited", "tactic.explode.status.inhabited", "list.inhabited", "plift.inhabited", "string_imp.inhabited", "ordering.inhabited", "sort.inhabited", "function.inv_fun_comp", "tactic.unfold_config.inhabited", "list.func.add", "option.iget_some", "interactive.executor.execute_explicit", "tactic.simp_intros_config.inhabited", "environment.implicit_infer_kind.inhabited", "function.right_inverse_inv_fun", "psum.inhabited_left", "smt_tactic.interactive.executor", "string.iterator_imp.inhabited", "native.rb_map.ifind", "sort.inhabited'", "vm_obj_kind.inhabited", "function.injective.has_left_inverse", "exists_const", "occurrences.inhabited"]}, {"id": "classical.choice", "parentIds": ["classical.inhabited_of_nonempty'", "classical.strong_indefinite_description", "classical.inhabited_of_nonempty", "classical.prop_decidable", "classical.indefinite_description", "classical.nonempty_pi"]}, {"id": "nonempty", "parentIds": ["classical.inhabited_of_nonempty'", "nonempty_sum", "nonempty_sigma", "nonempty_empty", "nonempty_ulift", "classical.type_decidable", "nonempty.map2", "classical.choice", "nonempty.elim", "nonempty.map", "nonempty_of_exists", "nonempty_psigma", "classical.epsilon_spec_aux", "nonempty_Prop", "classical.strong_indefinite_description", "classical.inhabited_of_nonempty", "nonempty_of_inhabited", "nonempty_subtype", "classical.epsilon", "classical.indefinite_description", "classical.nonempty_pi", "nonempty.congr", "classical.exists_true_of_nonempty", "nonempty_plift", "exists_true_iff_nonempty", "classical.epsilon_singleton", "nonempty.exists", "nonempty_psum", "not_nonempty_iff_imp_false", "nonempty_prod", "nonempty_pprod", "not_nonempty_pempty", "nonempty.forall"]}, {"id": "tactic.interactive.record_lit", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "lean.parser.tk", "parentIds": ["tactic.interactive.record_lit", "smt_tactic.interactive.assume", "tactic.interactive.squeeze_simp", "where.where_cmd", "interactive.types.ident_", "smt_tactic.interactive.induction", "interactive.types.only_flag", "tactic.interactive.convert", "tactic.mk_simp_attribute_cmd", "tactic.interactive.induction", "restate_axiom_cmd", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "opt_minus", "tactic.interactive.rename'_args_parser", "lint_cmd", "interactive.types.with_ident_list", "smt_tactic.interactive.have", "apply_nolint_cmd", "tactic.to_texpr", "tactic.trace_macro", "tactic.interactive.generalize_hyp", "localized_cmd", "tactic.interactive.let", "ext_param", "tactic.rintro_parse", "interactive.types.without_ident_list", "tactic.interactive.set", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.simp", "tactic.interactive.rw_rule_p", "tactic.interactive.guard_hyp_strict", "tactic.interactive.obtain_parse", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "lint_all_cmd", "tactic.interactive.suffices", "tactic.rcases_parse_depth", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.let", "find_cmd", "tactic.interactive.assume", "tactic.interactive.haveI", "name_with_opt", "tactic.interactive.guard_hyp", "tactic.interactive.generalize", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.rename'_arg_parser", "tactic.interactive.ext", "tactic.pformat_macro", "format_macro", "tactic.interactive.replace", "tactic.interactive.constructor_matching", "open_locale_cmd", "tactic.interactive.conv", "tactic.interactive.guard_expr_strict", "simps_parser", "tactic.interactive.convert_to", "tactic.interactive.change", "list_linters", "tactic.interactive.conv_rhs", "tactic.using_texpr", "tactic.interactive.simpa", "tactic.interactive.guard_expr_eq", "tactic.interactive.casesm", "tactic.interactive.guard_expr_eq'", "tactic.interactive.rw_rules", "sformat_macro", "library_note", "tactic.simp_arg_list", "tactic.setup_tactic_parser_cmd", "tactic.simp_arg", "tactic.interactive.have", "smt_tactic.interactive.simp", "tactic.interactive.guard_hyp'", "tactic.rcases_patt_parse_core", "tactic.interactive.h_generalize", "tactic.interactive.ac_change", "tactic.interactive.case", "tactic.interactive.choose", "interactive.types.using_ident", "tactic.explode_cmd", "interactive.types.location", "tactic.interactive.contrapose", "interactive.types.list_of", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.import_private_cmd", "lint_mathlib_cmd", "interactive.types.brackets", "tactic.fail_macro"]}, {"id": "sum", "parentIds": ["tactic.interactive.record_lit", "smt_tactic.interactive.assume", "sum.bind", "nonempty_sum", "sum.lex_acc_inr", "sum.elim", "sum_has_to_format", "parser.run_string", "tactic.interactive.rcases", "sum.elim_injective", "sum.swap_right_inverse", "opt_minus", "sum.is_lawful_monad", "sum.inhabited_left", "sum.swap", "tactic.constr_to_prop", "tactic.rintro_parse", "sum.has_reflect", "sum.monad", "sum.map", "sum.elim_inl", "sum.inl.inj_iff", "tactic.mk_iff_of_inductive_prop", "sum.has_to_string", "tactic.interactive.rintros", "sum.lex_wf", "sum.inhabited_right", "tactic.rcases_parse", "sum.lex_inl_inl", "tactic.interactive.assume", "ext_param_type", "sum.lex_acc_inl", "sum.lex", "tactic.interactive.rintro", "sum.inl_ne_inr", "sum.lex_inr_inr", "sum.traverse", "parser.run", "sum.has_repr", "sum.elim_inr", "sum.exists", "sum.swap_swap_eq", "sum.is_lawful_functor", "sum.swap_swap", "sum.swap_left_inverse", "sum.lex_inr_inl", "sum.forall", "sum.has_sizeof", "sum.traversable", "list.partition_map", "sum.inr_ne_inl", "sum.decidable_eq", "tactic.alias.make_left_right", "sum.inr.inj_iff"]}, {"id": "interaction_monad.monad", "parentIds": ["tactic.interactive.record_lit", "tactic.eval_expr'", "lean.parser.sep_by", "tactic.find_if_cond_at", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "tactic.replace_at", "tactic.library_search_hole_cmd", "tactic.trace", "tactic.mk_const", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.instance_cache.get", "get_localized", "tactic.cc_dbg_core", "tactic.delta", "interactive.types.ident_", "tactic.focus1", "print_content", "tactic.rintro_hint", "tactic.interactive.with_cases", "tactic.revertible_local_context", "tactic.apply_iff", "infer_type_cmd", "option_to_tactic_format", "tactic.get_expl_arity", "tactic.mk_constructor_arg_names", "lean.parser.get_variables", "tactic.admit", "tactic.copy_attribute", "well_founded_tactics.clear_internals", "expr.mk_exists_lst", "interactive.types.opt_pexpr_list", "tactic.injections_with", "tactic.interactive.recover", "tactic.save_const_type_info", "to_additive.target_name", "tactic.focus", "smt_tactic.set_goals", "tactic.find_assumption", "lean.parser.reflectable.optional", "tactic.cases", "tactic.existsi", "unused_arguments", "tactic.cc_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "tactic.instance_cache.append_typeclasses", "tactic.dsimplify", "conv.monad", "tactic.interactive.loc.get_local_pp_names", "where.trace_variables", "interactive.types.only_flag", "tactic.mk_brec_on_rec_value", "tactic.simplify_top_down", "tactic.get_env", "where.mk_flag", "tactic.interactive.guard_tags", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "simp_attr.pre_smt", "tactic.cleanup", "tactic.is_prop", "transport_multiplicative_to_additive", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "using_smt", "tactic.match_or", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "tactic.get_pi_binders", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "old_conv.trace", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "rbtree.default_lt", "old_conv.findp", "tactic.symm_apply", "tactic.revert_kdependencies", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "smt_tactic.interactive.intros", "tactic.interactive.solve_by_elim", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "lean.parser.emit_command_here", "tactic.symmetry_hyp", "tactic.note", "opt_minus", "old_conv.dsimp", "tactic.transport_with_prefix_fun", "tactic.interactive.apply_assumption", "tactic.elim_gen_sum", "localized_attr", "native.rb_map.has_to_tactic_format", "to_additive.proceed_fields", "tactic.match_app_of", "tactic.interactive.clear_dependent", "push_neg.normalize_negations", "old_conv.change", "tactic.non_dep_prop_hyps", "use_cmd", "tactic.interactive.rename'_args_parser", "tactic.left", "lean.parser.val", "tactic.mk_simp_attr", "tactic.assoc_refl", "tactic.interactive.have_field", "tactic.independent_goal", "tactic.dsimp_hyp", "interactive.types.with_ident_list", "ematch_lhs", "smt_tactic.interactive.have", "tactic.match_subexpr", "tactic.mk_dec_eq_instance", "print_localized_commands", "tactic.suggest_scripts", "tactic.generalize_proofs", "tactic_format_expr", "apply_nolint_cmd", "interactive.loc.try_apply", "to_additive.parser", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "tactic.library_search", "can_lift_attr", "tactic.match_hypothesis", "tactic.terminal_goal", "tactic.to_texpr", "tactic.mk_local'", "tactic.interactive.clear'", "old_conv.apply_lemmas_core", "tactic.mk_user_fresh_name", "simps_add_projection", "tactic.trace_macro", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.ext_parse", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "localized_cmd", "tactic.mk_eq_simp_ext", "tactic.choose1", "old_conv.to_tactic", "old_conv.conversion", "tactic.extract_def", "tactic.delta_target", "smt_tactic.interactive.add_eqn_lemmas", "conv.interactive.guard_lhs", "simps_tac", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "ext_param", "tactic.tactic.has_to_tactic_format", "tactic.try_apply_opt_auto_param_for_apply", "tactic.constr_to_prop", "tactic.rintro_parse", "tactic.local_proof", "interactive.types.without_ident_list", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "tactic.solve_aux", "tactic.suggest.message", "tactic.propositional_goal", "tactic.match_eq", "tactic.match_expr", "tactic.save_info", "tactic.get_goal", "tactic.resolve_constant", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "well_founded_tactics.default_dec_tac'", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "tactic.interactive.letI", "tactic.instance_stub", "tactic.in_open_namespaces", "tactic.interactive.type_check", "lean.parser.get_includes", "tactic.updateex_env", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.trace_result", "no_rsimp", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.rintro", "conv.funext", "old_conv.match_pattern", "tactic.change_with_at", "tactic.match_target_subexpr", "tactic.constructor_idx", "tactic.constructor_num_fields", "tactic.clear_aux_decl", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "old_conv.funext", "tactic.interactive.refine_struct", "tactic.interactive.elide", "tactic.interactive.rec.to_tactic_format", "tactic.is_type_app_of", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "tactic.interactive.obtain_parse", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.abstract", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.interactive.try_for", "tactic.successes", "tactic.interactive.simp_core_aux", "tactic.get_simp_lemmas_or_default", "tactic.right", "tactic.def_replacer_cmd", "tactic.trace_error", "tactic.mk_patterns", "tactic.interactive.clear", "tactic.interactive.injection", "smt_tactic.alternative", "tactic.interactive.exact", "doc_blame_report_defn", "tactic.assert", "tactic.rewrite_hyp", "lean.parser.get_namespace", "tactic.match_heq", "tactic.interactive.suffices", "to_additive.map_namespace", "print_all_content", "tactic.get_string_option", "tactic.explode.may_be_proof", "tactic.rcases_parse_depth", "tactic.case_bash", "declaration.in_current_file", "tactic.by_cases", "rsimp_attr", "show_goal_cmd", "tactic.interactive.library_search", "tactic.add_theorem_by", "tactic.when_tracing", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "conv.solve1", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "tactic.set_main_tag", "tactic.apply_heq_congr_core", "tactic.mk_constructors_arg_names", "old_conv.lhs", "tactic.match_not", "tactic.interactive.exactI", "tactic.enum_assoc_subexpr", "well_founded_tactics.is_psigma_mk", "find_cmd", "tactic.interactive.substs", "tactic.mk_local_pis_whnf", "ematch", "smt_tactic.slift_aux", "tactic.interactive.assume", "tactic.any_hyp", "control_laws_tac", "tactic.decl_mk_const", "tactic.iterate1", "tactic.interactive.haveI", "tactic.match_ne", "rsimp.rsimplify_at", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.dunfold_target", "tactic.suggest.apply_and_solve", "simp_attr.functor_norm", "tactic.mk_mvar", "simp_attr.norm", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "name_with_opt", "tactic.trace_state", "tactic.suggest_core", "tactic.local_def_value", "tactic.use", "tactic.comp_val", "well_founded_tactics.unfold_sizeof", "tactic.interactive.loc.get_local_uniq_names", "mnot", "old_conv.congr_core", "where.get_opens", "apply_nolint_tac", "tactic.interactive.obtain", "expr.is_eta_expansion_aux", "tactic.fold_explicit_args", "expr.of_int", "tactic.simplify_bottom_up", "tactic.interactive.guard_hyp", "tactic.match_target", "tactic.apply", "tactic.contradiction", "tactic.get_main_tag", "old_conv.apply_propext_lemmas_core", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.iterate'", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "tactic.interactive.transitivity", "tactic.ancestor_attr", "tactic.set_nat_option", "tactic.match_and", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.rename'_arg_parser", "tactic.interactive.to_expr'", "smt_tactic.monad_state", "rsimp.to_repr_map", "tactic.interactive.ext", "tactic.alias.alias_direct", "tactic.interactive.unelide", "interactive.interactive.executor", "tactic.solve_by_elim", "lint_hole_cmd", "tactic.interactive.show", "tactic.relation_lhs_rhs", "tactic.interactive.simp_intros", "tactic.pformat_macro", "tactic.apply_congr_core", "where.get_variables_core", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "tactic.no_mvars_in_target", "tactic.iff_mpr", "tactic.join_user_simp_lemmas", "tactic.interactive.guard_target'", "tactic.explode_expr", "tactic.unfold_projs", "copy_decl_using", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "fold_over_with_cond", "tactic.define", "tactic.by_contradiction", "tactic.interactive.replace", "tactic.interactive.subst", "simp_attr.split_if_reduction", "tactic.get_arity", "tactic.interactive.clear_", "tactic.interactive.return_cast", "tactic.match_iff", "tactic.set_string_option", "tactic.constructor", "tactic.match_refl_app", "tactic.assertv", "tactic.get_pi_arity", "tactic.rcases", "tactic.fsplit", "tactic.interactive.constructor_matching", "tactic.assoc_rewrite", "expr.simp", "open_locale_cmd", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "lean.parser.reflectable.has_reflect", "expr.dsimp", "tactic.interactive.guard_expr_strict", "simps_parser", "get_linters", "tactic.subsingleton_goal", "tactic.interactive.intro", "tactic.injection_with", "tactic.interactive.convert_to", "tactic.save_options", "tactic.interactive.funext", "get_attribute_cache_dyn", "tactic.subst_vars", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "tactic.rename", "tactic.interactive.change", "tactic.simp_bottom_up'", "tactic.match_stub", "tactic.mk_constructor_fresh_names", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "tactic.interactive.list_cast_of", "tactic.get_decl", "tactic.interactive.simp_core", "tactic.def_replacer", "tactic.injection", "tactic.interactive.conv_rhs", "lean.parser.reflectable.expr", "tactic.interactive.match_target", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "tactic.simp_hyp", "linter.doc_blame", "tactic.get_options", "tactic.repeat", "tactic.using_texpr", "tactic.solve1", "smt_tactic.monad", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "list.has_to_tactic_format", "tactic.interactive.mapply", "tactic.interactive.specialize", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "lean.parser.alternative", "tactic.interactive.apply_with", "old_conv.whnf", "tactic.pose", "tactic.interactive.fapply", "tactic.swap", "tactic.get_nat_option", "old_conv.find", "tactic.split", "fold_over_with_cond_sorted", "tactic.instantiate_mvars_in_target", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.dsimp_target", "where.trace_where", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "expr.is_eta_expansion", "tactic.unfold_projs_target", "tactic.apply_rules", "tactic.simp_all", "rsimp.rsimplify", "simp_lemmas.append", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "tactic.rsimp", "tactic.iff_mp", "tactic.interactive.guard_expr_eq'", "tactic.mk_constructors_fresh_names", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.get_ancestors", "tactic.assumption", "tactic.is_proof", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "tactic.interactive.rw_rules", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "tactic.replace_target", "tactic.interactive.guard_target", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "instance_priority", "tactic.interactive.introI", "tactic.interactive.dunfold", "where.fetch_potential_variable_names", "instance_derive_handler", "tactic.inhabited_instance", "library_note", "tactic.simp_arg_list", "tactic.interactive.extract_goal", "tactic.alternative", "tactic.seq", "tactic.get_mathlib_dir", "tactic.simp_arg", "smt_tactic.induction", "tactic.interactive.have", "old_conv.pure", "environment.mfilter", "tactic.definev", "tactic.interactive.field", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "tactic.add_defn_equations", "tactic.local_decls", "tactic.delta_instance", "tactic.interactive.injections", "get_checks", "tactic.interactive.clear_except", "tactic.flatten", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "tactic.mk_inj_eq", "tactic.applyc", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.triv", "tactic.interactive.destruct", "tactic.rcases_patt_parse_core", "old_conv.seq", "where.format_variable", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.interactive.intros", "tactic.interactive.ac_change", "tactic.alias.make_left_right", "has_to_format_to_has_to_tactic_format", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "tactic.has_append", "tactic.injections_and_clear", "saturate_fun", "tactic.interactive.choose", "tactic.rotate_right", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "tactic.set_options", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "tactic.explode_cmd", "conv.convert", "tactic.find_private_decl", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "has_reflect_derive_handler", "tactic.induction'", "tactic.any_goals", "where.compile_variable_list", "doc_blame_report_thm", "tactic.mk_eq_proof", "tactic.interactive.introsI", "tactic.rename'", "tactic.resolve_name'", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "tactic.interactive.suggest", "interactive.types.location", "tactic.has_to_tactic_format", "environment.get_modifiers", "tactic.suggest.library_defs", "tactic.interactive.push_neg", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.intros1", "tactic.get_bool_option", "derive_struct_ext_lemma", "tactic.exact_dec_trivial", "tactic.mk_instance_cache", "old_conv.map", "lint_mathlib", "tactic.done", "tactic.reduce_ifs_at", "tactic.num_goals", "ge_or_gt_in_statement", "lint_all", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "tactic.interactive.collect_struct", "has_inhabited_instance", "tactic.interactive.apply", "tactic.run_async", "old_conv.lift_tactic", "dedup", "tactic.import_private_cmd", "tactic.expanded_field_list", "tactic.interactive.delta", "tactic.metavariables", "dup_namespace", "tactic.triv'", "old_conv.mk_match_expr", "tactic.congr_core", "tactic.apply_opt_param", "expr.of_nat", "conv.discharge_eq_lhs", "tactic.fail_macro", "print_name", "tactic.mk_sorry", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "tactic.pexpr_to_pattern", "user_attribute.get_param", "tactic.get_local_type", "tactic.interactive.generalize_proofs", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "tactic.apply_at", "tactic.note_anon", "tactic.match_fn", "transport_with_dict", "tactic.get_expl_pi_arity", "old_conv.match_expr"]}, {"id": "pexpr.mk_structure_instance", "parentIds": ["tactic.interactive.record_lit", "tactic.interactive.refine_one"]}, {"id": "lean.parser.ident", "parentIds": ["tactic.interactive.record_lit", "tactic.interactive.cases", "interactive.types.ident_", "smt_tactic.interactive.induction", "tactic.interactive.guard_tags", "tactic.interactive.by_contra", "tactic.mk_simp_attribute_cmd", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "restate_axiom_cmd", "smt_tactic.interactive.intros", "tactic.interactive.clear_dependent", "smt_tactic.interactive.have", "to_additive.parser", "tactic.interactive.clear'", "tactic.interactive.unfold1", "tactic.interactive.generalize_hyp", "localized_cmd", "smt_tactic.interactive.add_eqn_lemmas", "tactic.interactive.abstract", "tactic.interactive.let", "ext_param", "interactive.types.without_ident_list", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "tactic.interactive.letI", "tactic.interactive.guard_hyp_strict", "tactic.def_replacer_cmd", "tactic.interactive.clear", "tactic.interactive.suffices", "tactic.interactive.by_contradiction", "tactic.interactive.rename", "smt_tactic.interactive.let", "tactic.interactive.substs", "tactic.interactive.haveI", "name_with_opt", "tactic.interactive.guard_hyp", "tactic.interactive.generalize", "tactic.ancestor_attr", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.rename'_arg_parser", "tactic.interactive.replace", "tactic.rcases", "open_locale_cmd", "tactic.interactive.conv", "simps_parser", "tactic.interactive.conv_rhs", "tactic.interactive.dunfold", "tactic.interactive.extract_goal", "tactic.simp_arg", "tactic.interactive.have", "tactic.interactive.field", "tactic.interactive.clear_except", "tactic.interactive.guard_hyp'", "tactic.interactive.h_generalize", "tactic.interactive.choose", "interactive.types.using_ident", "tactic.explode_cmd", "interactive.types.location", "tactic.interactive.conv_lhs", "tactic.import_private_cmd", "tactic.interactive.delta"]}, {"id": "interactive.types.texpr", "parentIds": ["tactic.interactive.record_lit", "smt_tactic.interactive.assume", "smt_tactic.interactive.destruct", "tactic.interactive.from", "tactic.interactive.guard_target_strict", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "smt_tactic.interactive.have", "tactic.interactive.refine", "to_additive.parser", "tactic.to_texpr", "tactic.interactive.lift", "conv.interactive.guard_lhs", "tactic.interactive.let", "tactic.interactive.set", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.type_check", "tactic.interactive.refine_struct", "tactic.interactive.guard_hyp_strict", "tactic.interactive.obtain_parse", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "tactic.interactive.injection", "tactic.interactive.exact", "tactic.interactive.suffices", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.let", "interactive.types.pexpr_list_or_texpr", "conv.interactive.change", "tactic.interactive.exactI", "tactic.interactive.assume", "tactic.interactive.haveI", "tactic.interactive.guard_hyp", "tactic.interactive.transitivity", "tactic.interactive.eapply", "tactic.interactive.show", "tactic.interactive.guard_target'", "tactic.interactive.replace", "tactic.interactive.subst", "tactic.interactive.guard_expr_strict", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "tactic.interactive.change", "tactic.interactive.match_target", "tactic.using_texpr", "tactic.interactive.simpa", "tactic.interactive.mapply", "tactic.interactive.specialize", "tactic.interactive.fapply", "tactic.interactive.guard_expr_eq", "tactic.interactive.clean", "tactic.interactive.guard_expr_eq'", "tactic.interactive.rw_rules", "tactic.interactive.guard_target", "smt_tactic.interactive.from", "tactic.simp_arg", "tactic.interactive.have", "tactic.interactive.guard_hyp'", "smt_tactic.interactive.change", "smt_tactic.interactive.add_fact", "tactic.interactive.destruct", "tactic.interactive.ac_change", "tactic.interactive.choose", "smt_tactic.interactive.by_cases", "smt_tactic.interactive.guard_expr_eq", "old_conv.interactive.change", "tactic.interactive.apply", "smt_tactic.interactive.exact", "smt_tactic.interactive.fapply"]}, {"id": "list.partition_map", "parentIds": ["tactic.interactive.record_lit"]}, {"id": "monad", "parentIds": ["tactic.interactive.record_lit", "tactic.eval_expr'", "tactic.find_if_cond_at", "except_t.lift", "tactic.interactive.squeeze_simp", "fish", "tactic.add_library_note", "tactic.replace_at", "tactic.library_search_hole_cmd", "put", "tactic.trace", "tactic.mk_const", "parser.eof", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.instance_cache.get", "get_localized", "smt_tactic.solve1", "tactic.cc_dbg_core", "tactic.delta", "id.is_comm_applicative", "tactic.focus1", "print_content", "tactic.rintro_hint", "tactic.interactive.with_cases", "tactic.revertible_local_context", "tactic.apply_iff", "tactic.mllist.m_of_list", "infer_type_cmd", "option_to_tactic_format", "tactic.get_expl_arity", "tactic.mk_constructor_arg_names", "lean.parser.get_variables", "tactic.admit", "lean.parser.many", "tactic.copy_attribute", "well_founded_tactics.clear_internals", "name_set.mfold", "expr.mk_exists_lst", "tactic.injections_with", "smt_tactic.definev", "tactic.interactive.recover", "environment.mfold", "state_t.run_bind", "tactic.save_const_type_info", "smt_tactic.interactive.destruct", "to_additive.target_name", "tactic.focus", "option.is_lawful_monad", "parser.one_of'", "smt_tactic.set_goals", "mjoin_map_map", "tactic.find_assumption", "option_t.run_pure", "tactic.cases", "state_t.monad_map", "tactic.existsi", "unused_arguments", "tactic.cc_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "smt_tactic.trace_state", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "tactic.instance_cache.append_typeclasses", "tactic.dsimplify", "conv.monad", "tactic.interactive.loc.get_local_pp_names", "smt_tactic.add_lemmas_from_facts", "where.trace_variables", "tactic.mk_brec_on_rec_value", "tactic.simplify_top_down", "tactic.get_env", "where.mk_flag", "tactic.interactive.guard_tags", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "simp_attr.pre_smt", "tactic.cleanup", "tactic.is_prop", "smt_tactic.seq", "except_t.run_pure", "transport_multiplicative_to_additive", "option.traversable", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "using_smt", "smt_tactic.interactive.guard_target", "conv.interactive.conv", "conv.lhs", "string.get_rest", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "tactic.get_pi_binders", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "bind_pure", "tactic.interactive.by_cases", "reader_t.run_read", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "old_conv.trace", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "rbtree.default_lt", "old_conv.findp", "tactic.symm_apply", "parser.many'", "state_t.bind", "tactic.revert_kdependencies", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "option_t.fail", "tactic.interactive.solve_by_elim", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "lean.parser.emit_command_here", "tactic.symmetry_hyp", "tactic.note", "opt_minus", "old_conv.dsimp", "tactic.transport_with_prefix_fun", "state_t.run_map", "monad.filter", "interactive.executor", "tactic.elim_gen_sum", "localized_attr", "native.rb_map.has_to_tactic_format", "old_conv.istep", "to_additive.proceed_fields", "tactic.match_app_of", "expr.to_int", "tactic.interactive.clear_dependent", "reader_t.monad_except", "push_neg.normalize_negations", "old_conv.change", "tactic.non_dep_prop_hyps", "sum.is_lawful_monad", "use_cmd", "tactic.interactive.rename'_args_parser", "reader_t.run_map", "tactic.left", "lean.parser.val", "tactic.mk_simp_attr", "tactic.assoc_refl", "tactic.interactive.have_field", "tactic.mllist.empty", "tactic.independent_goal", "tactic.mllist.head", "tactic.dsimp_hyp", "ematch_lhs", "smt_tactic.swap", "smt_tactic.interactive.have", "tactic.match_subexpr", "id.bind_eq", "tactic.mk_dec_eq_instance", "parser.alternative", "print_localized_commands", "tactic.suggest_scripts", "tactic.generalize_proofs", "tactic_format_expr", "reader_t.run_pure", "apply_nolint_cmd", "interactive.loc.try_apply", "to_additive.parser", "list.alternative", "parser.sep_by1", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "tactic.library_search", "tactic.unsafe.type_context.list_mvars", "can_lift_attr", "tactic.match_hypothesis", "tactic.terminal_goal", "option_t.bind", "tactic.to_texpr", "tactic.mk_local'", "tactic.interactive.clear'", "state_t.run_monad_map", "old_conv.apply_lemmas_core", "native.rb_set.mfilter", "option_t.run_map", "tactic.mk_user_fresh_name", "simps_add_projection", "tactic.trace_macro", "tactic.mllist.force", "tactic.mllist.enum_from", "tactic.interactive.unfold_projs", "tactic.ext_parse", "list.mpartition", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "smt_tactic.slift", "localized_cmd", "except_t.return", "tactic.mk_eq_simp_ext", "tactic.choose1", "old_conv.to_tactic", "reader_t.adapt", "conv.update_lhs", "task.monad", "old_conv.conversion", "tactic.extract_def", "tactic.delta_target", "state_t.put", "old_conv.apply_propext_simp_set", "expr.mfoldl", "conv.interactive.guard_lhs", "tactic.mllist.map", "simps_tac", "tactic.mllist.enum", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "monad_from_pure_bind", "ext_param", "tactic.tactic.has_to_tactic_format", "tactic.try_apply_opt_auto_param_for_apply", "smt_tactic.classical", "state_t.run_adapt", "tactic.constr_to_prop", "tactic.rintro_parse", "tactic.local_proof", "smt_tactic.pose", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "tactic.solve_aux", "monad.foldl", "smt_tactic.add_ematch_lemma_core", "mjoin_pure", "tactic.suggest.message", "tactic.propositional_goal", "tactic.match_expr", "tactic.save_info", "tactic.get_goal", "parser.is_lawful_monad", "tactic.resolve_constant", "tactic.interactive.set", "well_founded_tactics.default_dec_tac'", "sum.monad", "tactic.apply_auto_param", "mjoin", "tactic.change_core", "parser.monad", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "tactic.interactive.letI", "old_conv.trace_lhs", "option_t.run_monad_map", "reader_t.is_lawful_monad", "monad.sequence'", "list.mmap_filter", "option_t.orelse", "tactic.instance_stub", "tactic.in_open_namespaces", "tactic.interactive.type_check", "lean.parser.get_includes", "tactic.updateex_env", "where.trace_includes", "smt_tactic.proof_for", "state_t.monad_except", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.trace_result", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.rintro", "conv.funext", "except.monad", "old_conv.match_pattern", "tactic.change_with_at", "tactic.match_target_subexpr", "tactic.constructor_idx", "tactic.constructor_num_fields", "tactic.clear_aux_decl", "option_t.monad_map", "mk_hinst_lemma_attr_from_simp_attr", "reader_t.monad_reader_adapter", "tactic.unprime", "old_conv.funext", "tactic.interactive.refine_struct", "parser.many1", "tactic.interactive.elide", "tactic.interactive.rec.to_tactic_format", "tactic.mllist.filter", "tactic.is_type_app_of", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "state_t.adapt", "tactic.interactive.obtain_parse", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "fish_pipe", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.abstract", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.interactive.try_for", "conv.dsimp", "tactic.successes", "tactic.interactive.simp_core_aux", "tactic.right", "id.map_eq", "monad.whenb", "tactic.def_replacer_cmd", "tactic.trace_error", "tactic.mk_patterns", "list.mmap_accuml", "conv.interactive.trace_lhs", "smt_tactic.focus1", "tactic.interactive.injection", "conv.whnf", "tactic.interactive.exact", "doc_blame_report_defn", "smt_tactic.get_facts", "tactic.assert", "except_t.run_map", "state_t.run_monad_lift", "tactic.rewrite_hyp", "lean.parser.get_namespace", "state_t.run_get", "functor.comp.functor_id_comp", "option.to_monad", "tactic.interactive.suffices", "reader_t.read", "to_additive.map_namespace", "print_all_content", "tactic.get_string_option", "tactic.explode.may_be_proof", "tactic.mllist.squash", "tactic.rcases_parse_depth", "tactic.case_bash", "functor.comp.functor_comp_id", "declaration.in_current_file", "interactive.executor.execute_with_explicit", "tactic.by_cases", "rsimp_attr", "reader_t.monad_reader", "show_goal_cmd", "tactic.interactive.library_search", "tactic.add_theorem_by", "state_t.alternative", "list.traversable", "except_t.bind_cont", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "state_t.lift", "conv.solve1", "name_set.mfilter", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "except_t.run_monad_lift", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "mjoin_map_pure", "comp.applicative_id_comp", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "option_t.alternative", "tactic.set_main_tag", "tactic.apply_heq_congr_core", "tactic.mk_constructors_arg_names", "monad.join", "smt_tactic.all_goals", "list.mfirst", "conv.interactive.change", "tactic.interactive.exactI", "tactic.enum_assoc_subexpr", "smt_tactic.define", "find_cmd", "tactic.interactive.substs", "tactic.mk_local_pis_whnf", "ematch", "smt_tactic.slift_aux", "option_t.pure", "tactic.any_hyp", "control_laws_tac", "tactic.decl_mk_const", "native.rb_set.mfold", "tactic.iterate1", "list.mfilter", "tactic.interactive.haveI", "smt_tactic.get_refuted_facts", "smt_tactic.save_info", "tactic.mllist.concat", "rsimp.rsimplify_at", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.dunfold_target", "smt_tactic.assertv", "tactic.suggest.apply_and_solve", "option_t.run_bind", "simp_attr.functor_norm", "reader_t.bind", "tactic.mk_mvar", "simp_attr.norm", "old_conv.alternative", "tactic.unsafe.type_context.monad", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "name_with_opt", "tactic.trace_state", "parser.one_of", "tactic.local_def_value", "tactic.mllist.of_list", "tactic.mllist.fixl_with", "option_t.catch", "tactic.comp_val", "well_founded_tactics.unfold_sizeof", "option_t.monad_functor", "tactic.interactive.loc.get_local_uniq_names", "interaction_monad.monad", "tactic.mllist.bind_", "old_conv.congr_core", "where.get_opens", "id.is_lawful_monad", "reader_t.run_monad_lift", "tactic.unsafe.type_context.print_mvars", "tactic.interactive.obtain", "parser.many_char1", "expr.is_eta_expansion_aux", "monad_fail_lift", "tactic.mllist.uncons", "tactic.fold_explicit_args", "expr.of_int", "tactic.simplify_bottom_up", "tactic.interactive.guard_hyp", "tactic.match_target", "list.mmap_accumr", "except_t.monad_map", "tactic.apply", "tactic.contradiction", "tactic.get_main_tag", "old_conv.apply_propext_lemmas_core", "expr.mfold", "monad.sequence", "tactic.mllist.mmap", "monad.cond", "tactic.interactive.generalize", "tactic.interactive.use", "native.rb_map.mfilter", "tactic.mk_has_reflect_instance", "state_t.monad_state_adapter", "tactic.iterate'", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "reader_t.has_monad_lift", "tactic.interactive.transitivity", "tactic.set_nat_option", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "is_lawful_traversable", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.rename'_arg_parser", "tactic.interactive.to_expr'", "rsimp.to_repr_map", "smt_tactic.note", "tactic.interactive.ext", "tactic.alias.alias_direct", "smt_tactic.istep", "tactic.interactive.unelide", "tactic.solve_by_elim", "native.rb_map.mfold", "lint_hole_cmd", "tactic.interactive.show", "rsimp.collect_implied_eqs", "tactic.relation_lhs_rhs", "tactic.interactive.simp_intros", "tactic.pformat_macro", "tactic.apply_congr_core", "reader_t.lift", "where.get_variables_core", "monad.mapm", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "tactic.no_mvars_in_target", "tactic.iff_mpr", "tactic.join_user_simp_lemmas", "tactic.interactive.guard_target'", "tactic.explode_expr", "tactic.unfold_projs", "copy_decl_using", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "list.monad", "fold_over_with_cond", "tactic.define", "tactic.by_contradiction", "tactic.interactive.replace", "tactic.interactive.subst", "simp_attr.split_if_reduction", "tactic.mllist.filter_map", "tactic.get_arity", "tactic.interactive.clear_", "tactic.interactive.return_cast", "cc_state.mfold_eqc", "conv.replace_lhs", "except_t.adapt", "modify", "reader_t.monad_functor", "tactic.mllist.monad_lift", "vm.trace", "tactic.set_string_option", "old_conv.monad", "tactic.constructor", "smt_tactic.assert", "tactic.mllist.join", "tactic.match_refl_app", "native.rb_map.mmap", "tactic.suggest.process_declaration", "parser.run", "tactic.assertv", "tactic.get_pi_arity", "tactic.rcases", "tactic.fsplit", "tactic.interactive.constructor_matching", "tactic.assoc_rewrite", "expr.simp", "open_locale_cmd", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "lean.parser.reflectable.has_reflect", "state_t.has_monad_lift", "expr.dsimp", "tactic.interactive.guard_expr_strict", "simps_parser", "get_linters", "option.alternative", "smt_tactic.get_goals", "tactic.subsingleton_goal", "except_t.run_monad_map", "exceptional.monad", "list.is_lawful_monad", "tactic.interactive.intro", "tactic.injection_with", "tactic.interactive.convert_to", "reader_t.monad_map", "reader_t.orelse", "old_conv.apply_simp_set", "tactic.save_options", "tactic.interactive.funext", "get_attribute_cache_dyn", "parser.ch", "tactic.subst_vars", "state_t.run_put", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "tactic.rename", "when", "tactic.interactive.change", "tactic.simp_bottom_up'", "tactic.match_stub", "seq_bind_eq", "tactic.mk_constructor_fresh_names", "tactic.interactive.has_to_tactic_format", "list_linters", "state_t.orelse", "lint_aux", "tactic.interactive.list_cast_of", "tactic.get_decl", "tactic.interactive.simp_core", "vm_core.monad", "tactic.def_replacer", "tactic.injection", "tactic.interactive.conv_rhs", "lean.parser.reflectable.expr", "tactic.interactive.match_target", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "except_t.monad_except", "smt_tactic.eblast", "sum.is_lawful_functor", "tactic.simp_hyp", "state_t.monad_state", "linter.doc_blame", "reader_t.pure", "tactic.mllist.mfirst", "tactic.get_options", "smt_tactic.interactive.eblast_using", "tactic.repeat", "conv.change", "tactic.using_texpr", "state_t.modify", "mjoin_map_mjoin", "id.monad", "tactic.solve1", "tactic.unsafe.type_context.orelse", "smt_tactic.monad", "reader_t.alternative", "tactic.mllist.take", "list.mmap", "tactic.alias.alias_iff", "conv.interactive.for", "list.mfoldl", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "tactic.unsafe.type_context.trace", "except_t.monad_functor", "reader_t.run_bind", "tactic.interactive.mapply", "tactic.interactive.specialize", "smt_tactic.read", "comp.applicative_comp_id", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "lean.parser.alternative", "tactic.interactive.apply_with", "old_conv.whnf", "except_t.is_lawful_monad", "tactic.pose", "except_t.run_bind", "return", "tactic.interactive.fapply", "tactic.swap", "tactic.get_nat_option", "old_conv.find", "tactic.split", "name_set.mmap", "fold_over_with_cond_sorted", "tactic.instantiate_mvars_in_target", "except_t.bind", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.dsimp_target", "where.trace_where", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "monad.unlessb", "parser.many_char", "old_conv.bind", "incorrect_type_class_argument", "reader_t.run_monad_map", "tactic.interactive.clean", "expr.is_eta_expansion", "tactic.unfold_projs_target", "tactic.apply_rules", "tactic.simp_all", "except_t.monad", "rsimp.rsimplify", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "tactic.rsimp", "conv.interactive.simp", "tactic.iff_mp", "state_t.pure", "smt_tactic.step", "tactic.interactive.guard_expr_eq'", "conv.step", "mwhen", "tactic.mk_constructors_fresh_names", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.mllist.mfilter", "tactic.get_ancestors", "tactic.mllist.append", "fish_assoc", "tactic.assumption", "state_t.monad", "tactic.is_proof", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "fish_pure", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "tactic.replace_target", "monad.mapm'", "smt_tactic.by_contradiction", "tactic.interactive.guard_target", "old_conv.bottom_up", "id.pure_eq", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "instance_priority", "tactic.interactive.introI", "tactic.interactive.dunfold", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "instance_derive_handler", "tactic.inhabited_instance", "library_note", "option.monad", "smt_tactic.interactive.rsimp", "tactic.interactive.extract_goal", "tactic.alternative", "tactic.seq", "tactic.get_mathlib_dir", "smt_tactic.induction", "tactic.interactive.have", "environment.mfilter", "tactic.definev", "option_t.has_monad_lift", "tactic.interactive.field", "is_lawful_monad", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "tactic.add_defn_equations", "tactic.local_decls", "tactic.delta_instance", "sum.traversable", "tactic.interactive.injections", "get_checks", "tactic.interactive.clear_except", "tactic.flatten", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "mcond", "tactic.mk_inj_eq", "tactic.applyc", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "conv.save_info", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.triv", "tactic.interactive.destruct", "tactic.rcases_patt_parse_core", "old_conv.seq", "where.format_variable", "tactic.interactive.h_generalize", "map_bind", "option_t.bind_cont", "tactic.interactive.intros", "tactic.interactive.ac_change", "tactic.alias.make_left_right", "tactic.mllist.mfilter_map", "conv.congr", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "tactic.has_append", "option_t.monad_except", "tactic.injections_and_clear", "reader_t.failure", "saturate_fun", "tactic.interactive.choose", "except_t.catch", "tactic.rotate_right", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "option_t.is_lawful_monad", "conv.rhs", "smt_tactic.add_ematch_eqn_lemmas_for_core", "tactic.set_options", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "state_t.failure", "conv.interactive.to_lhs", "tactic.explode_cmd", "conv.convert", "tactic.find_private_decl", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "option_t.monad", "id.traversable", "has_reflect_derive_handler", "tactic.mllist.fixl", "conv.interactive.to_rhs", "tactic.induction'", "tactic.any_goals", "except_t.monad_except_adapter", "where.compile_variable_list", "doc_blame_report_thm", "tactic.mk_eq_proof", "tactic.interactive.introsI", "tactic.rename'", "reader_t.monad", "tactic.resolve_name'", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "interactive.executor.execute_explicit", "tactic.interactive.suggest", "option_t.run_monad_lift", "state_t.is_lawful_monad", "old_conv.step", "option_t.lift", "tactic.has_to_tactic_format", "environment.get_modifiers", "conv.interactive.dsimp", "list.mfoldr", "tactic.suggest.library_defs", "seq_eq_bind_map", "tactic.interactive.push_neg", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.intros1", "tactic.get_bool_option", "derive_struct_ext_lemma", "tactic.exact_dec_trivial", "smt_tactic.refutation_for", "tactic.mk_instance_cache", "old_conv.map", "lint_mathlib", "tactic.done", "tactic.reduce_ifs_at", "tactic.num_goals", "state_t.monad_functor", "lint_all", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "tactic.interactive.collect_struct", "has_inhabited_instance", "state_t.run_pure", "tactic.interactive.apply", "tactic.run_async", "old_conv.lift_tactic", "dedup", "tactic.import_private_cmd", "tactic.expanded_field_list", "state_t.get", "tactic.interactive.delta", "tactic.metavariables", "dup_namespace", "tactic.triv'", "old_conv.mk_match_expr", "get", "tactic.congr_core", "tactic.apply_opt_param", "expr.of_nat", "conv.discharge_eq_lhs", "list.mmap'", "smt_tactic.add_ematch_lemma_from_decl_core", "tactic.fail_macro", "print_name", "tactic.mk_sorry", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "smt_tactic.num_goals", "tactic.pexpr_to_pattern", "user_attribute.get_param", "tactic.get_local_type", "except_t.has_monad_lift", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "tactic.apply_at", "tactic.note_anon", "tactic.match_fn", "transport_with_dict", "tactic.unsafe.type_context.type_context_alternative", "tactic.get_expl_pi_arity", "old_conv.match_expr"]}, {"id": "has_orelse", "parentIds": ["tactic.interactive.record_lit", "lean.parser.sep_by", "smt_tactic.interactive.assume", "tactic.strip_prefix", "interactive.types.ident_", "tactic.apply_iff", "interactive.types.opt_pexpr_list", "to_additive.target_name", "tactic.interactive.trivial", "lean.parser.reflectable.optional", "tactic.cases", "tactic.existsi", "optional", "interactive.types.only_flag", "tactic.rcases_hint", "restate_axiom", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.explode.append_dep", "tactic.symm_apply", "restate_axiom_cmd", "succeeds", "opt_minus", "to_additive.proceed_fields", "tactic.interactive.rename'_args_parser", "tactic.interactive.triv", "tactic.assoc_refl", "interactive.types.with_ident_list", "ematch_lhs", "parser.alternative", "list.alternative", "tactic.terminal_goal", "simps_add_projection", "tactic.interactive.unfold_projs", "tactic.ext_parse", "old_conv.orelse", "old_conv.conversion", "ext_param", "tactic.constr_to_prop", "tactic.rintro_parse", "interactive.types.without_ident_list", "well_founded_tactics.default_dec_tac'", "tactic.interactive.congr_core'", "tactic.apply_assumption", "tactic.interactive.rw_rule_p", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.interactive.simp_core_aux", "doc_blame_report_defn", "tactic.by_cases", "state_t.alternative", "tactic.mk_inhabited_instance", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "old_conv.find_pattern", "well_founded_tactics.cancel_nat_add_lt", "old_conv.interactive.find", "option_t.alternative", "interactive.types.pexpr_list_or_texpr", "mtry", "ematch", "tactic.interactive.assume", "tactic.suggest.apply_and_solve", "old_conv.alternative", "name_with_opt", "tactic.use", "tactic.comp_val", "alternative", "tactic.contradiction", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "parser.sep_by", "tactic.alias.alias_cmd", "conv.interactive.find", "rsimp.collect_implied_eqs", "tactic.iff_mpr", "tactic.by_contradiction", "tactic.interactive.return_cast", "tactic.rcases", "get_linters", "option.alternative", "reader_t.orelse", "state_t.orelse", "reader_t.alternative", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.ext1", "tactic.interactive.refine_one", "lean.parser.alternative", "old_conv.find", "tactic.apply_rules", "tactic.iff_mp", "where.is_variable_name", "tactic.get_ancestors", "tactic.assumption", "tactic.mk_assoc_instance", "tactic.interactive.rw_rules", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "instance_derive_handler", "tactic.inhabited_instance", "tactic.simp_arg_list", "tactic.alternative", "tactic.simp_arg", "tactic.mk_inj_eq", "tactic.rcases_patt_parse_core", "tactic.interactive.h_generalize", "tactic.get_lift_prf", "tactic.interactive.case", "mk_hinst_lemma_attr_core", "doc_blame_report_thm", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "interactive.types.location", "environment.get_modifiers", "derive_struct_ext_lemma", "tactic.reduce_ifs_at", "tactic.congr_core", "tactic.suggest.apply_declaration", "tactic.module_doc_strings", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "lean.parser", "parentIds": ["tactic.interactive.record_lit", "lean.parser.sep_by", "smt_tactic.interactive.assume", "tactic.interactive.squeeze_simp", "where.where_cmd", "tactic.interactive.cases", "interactive.types.ident_", "lean.parser.get_variables", "lean.parser.reflectable.to_parser", "interactive.types.opt_pexpr_list", "where.trace_namespace", "lean.parser.reflectable.optional", "smt_tactic.interactive.induction", "where.trace_variables", "interactive.types.only_flag", "where.mk_flag", "tactic.interactive.guard_tags", "simp_attr.pre_smt", "tactic.interactive.convert", "tactic.interactive.by_contra", "tactic.mk_simp_attribute_cmd", "lean.parser.of_tactic", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "lean.parser.with_input", "restate_axiom_cmd", "tactic.interactive.cases_matching", "smt_tactic.interactive.intros", "tactic.interactive.solve_by_elim", "lean.parser.emit_command_here", "opt_minus", "localized_attr", "tactic.interactive.clear_dependent", "lean.parser.skip_info", "tactic.interactive.rename'_args_parser", "lint_cmd", "lean.parser.val", "tactic.mk_simp_attr", "interactive.types.with_ident_list", "user_attribute.parse_reflect", "ematch_lhs", "smt_tactic.interactive.have", "interactive.types.pexpr_list", "nolint_attr", "apply_nolint_cmd", "user_attribute.dflt_parser", "to_additive.parser", "tactic.alias.alias_attr", "can_lift_attr", "tactic.to_texpr", "tactic.interactive.clear'", "tactic.trace_macro", "tactic.interactive.unfold1", "tactic.ext_parse", "tactic.interactive.generalize_hyp", "localized_cmd", "smt_tactic.interactive.add_eqn_lemmas", "lean.parser.set_goal_info_pos", "interactive.with_desc", "tactic.interactive.abstract", "tactic.interactive.let", "ext_param", "tactic.rintro_parse", "interactive.types.without_ident_list", "lean.parser.reflectable", "lean.parser.set_env", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.simp", "lean.parser.get_includes", "no_rsimp", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "tactic.interactive.guard_hyp_strict", "tactic.interactive.obtain_parse", "lean.parser.of_tactic'", "tactic.interactive.iterate", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "lint_all_cmd", "tactic.interactive.clear", "lean.parser.small_nat", "lean.parser.get_namespace", "tactic.interactive.suffices", "tactic.rcases_parse_depth", "rsimp_attr", "tactic.interactive.by_contradiction", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.let", "linter_attr", "interactive.types.pexpr_list_or_texpr", "interactive.types.texpr", "find_cmd", "tactic.interactive.substs", "ematch", "tactic.interactive.assume", "tactic.interactive.haveI", "library_note_attr", "simp_attr.functor_norm", "simp_attr.norm", "name_with_opt", "lean.parser.emit_code_here", "lean.parser.tk", "interactive.decl_attributes.apply", "tactic.interactive.guard_hyp", "lean.parser.has_coe'", "tactic.interactive.generalize", "tactic.rcases_patt_parse", "tactic.interactive.transitivity", "interactive.inductive_decl.parse", "tactic.ancestor_attr", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.rename'_arg_parser", "tactic.interactive.ext", "tactic.interactive.simp_intros", "tactic.pformat_macro", "format_macro", "where.get_variables_core", "lean.parser.ident", "interactive.parse_binders", "tactic.interactive.replace", "simp_attr.split_if_reduction", "tactic.rcases", "tactic.interactive.constructor_matching", "open_locale_cmd", "lean.parser.reflectable.has_reflect", "tactic.interactive.conv", "lean.parser.has_coe", "tactic.interactive.guard_expr_strict", "simps_parser", "tactic.interactive.intro", "tactic.interactive.convert_to", "tactic.interactive.funext", "tactic.interactive.congr'", "tactic.interactive.change", "list_linters", "lean.parser.command_like", "user_attribute", "lean.parser.reflectable.cast", "tactic.interactive.conv_rhs", "interactive.parse_binders_core", "lean.parser.reflectable.expr", "debugger.attr", "derive_handler_attr", "tactic.using_texpr", "tactic.interactive.simpa", "lean.parser.alternative", "lean.parser.pexpr", "lean.parser.itactic", "tactic.interactive.guard_expr_eq", "where.trace_where", "tactic.interactive.casesm", "lean.parser.parser_orelse", "tactic.interactive.guard_expr_eq'", "where.is_variable_name", "lean.parser.reflect", "lean.parser.cur_pos", "tactic.interactive.rw_rules", "mk_hinst_lemma_attr_set", "sformat_macro", "tactic.interactive.introI", "tactic.interactive.dunfold", "library_note", "tactic.simp_arg_list", "lean.parser.itactic_reflected", "tactic.interactive.extract_goal", "tactic.setup_tactic_parser_cmd", "tactic.simp_arg", "tactic.interactive.have", "smt_tactic.interactive.simp", "tactic.interactive.clear_except", "tactic.interactive.guard_hyp'", "tactic.rcases_patt_parse_core", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.ac_change", "tactic.replaceable_attr", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "mk_hinst_lemma_attr_core", "interactive.types.using_ident", "tactic.explode_cmd", "interactive.parse", "tactic.interactive.introsI", "tactic.replacer_attr", "tactic.interactive.suggest", "interactive.types.location", "tactic.interactive.contrapose", "interactive.types.list_of", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.import_private_cmd", "tactic.interactive.delta", "lint_mathlib_cmd", "interactive.types.brackets", "tactic.fail_macro", "tactic.rcases_patt_parse_list", "tactic.interactive.generalize_proofs"]}, {"id": "pexpr", "parentIds": ["tactic.interactive.record_lit", "smt_tactic.interactive.assume", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "tactic.library_search_hole_cmd", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.i_to_expr_strict", "pexpr.get_uninst_pis", "infer_type_cmd", "tactic.interactive.rw_rule.has_reflect", "interactive.types.opt_pexpr_list", "tactic.build_list_expr_for_apply", "smt_tactic.interactive.destruct", "tactic.interactive.from", "tactic.mk_assumption_set", "smt_tactic.interactive.induction", "tactic.rcases_hint", "hole_command", "tactic.interactive.guard_target_strict", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "tactic.interactive.min_tac", "tactic.interactive.induction", "tactic.interactive.rcases", "old_conv.findp", "pexpr.of_expr", "tactic.interactive.cases_matching", "tactic.replace", "old_conv.change", "pexpr.mk_placeholder", "use_cmd", "smt_tactic.interactive.have", "interactive.types.pexpr_list", "tactic.match_subexpr", "tactic.interactive.refine", "to_additive.parser", "tactic.match_hypothesis", "tactic.to_texpr", "tactic.interactive.lift", "tactic.trace_macro", "tactic.interactive.generalize_hyp", "localized_cmd", "conv.interactive.guard_lhs", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "tactic.interactive.convert_to_core", "has_to_pexpr", "tactic.match_expr", "tactic.resolve_constant", "tactic.interactive.set", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.instance_stub", "tactic.interactive.type_check", "tactic.change_with_at", "tactic.match_target_subexpr", "tactic.interactive.rw_rule_p", "tactic.interactive.refine_struct", "tactic.simp_arg_type.has_reflect", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.guard_hyp_strict", "tactic.interactive.obtain_parse", "tactic.lift", "pexpr.mk_structure_instance", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "tactic.def_replacer_cmd", "tactic.interactive.injection", "tactic.interactive.exact", "tactic.interactive.existsi", "tactic.interactive.suffices", "smt_tactic.to_expr", "show_goal_cmd", "tactic.explode", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "pexpr.is_placeholder", "smt_tactic.interactive.let", "old_conv.interactive.find", "tactic.eqn_stub", "tactic.to_expr_strict", "interactive.types.pexpr_list_or_texpr", "smt_tactic.interactive.add_lemma", "conv.interactive.change", "tactic.interactive.exactI", "reflected.has_to_pexpr", "interactive.types.texpr", "find_cmd", "tactic.interactive.assume", "tactic.interactive.collect_struct'", "tactic.apply_under_pis", "tactic.interactive.haveI", "tactic.interactive.rw_rule", "tactic.list_constructors_hole", "tactic.use", "tactic.simp_arg_type", "tactic.interactive.obtain", "tactic.interactive.guard_hyp", "tactic.match_target", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.find_local", "tactic.interactive.transitivity", "derive_handler", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.to_expr'", "lint_hole_cmd", "tactic.interactive.show", "tactic.pformat_macro", "format_macro", "tactic.interactive.guard_target'", "interactive.parse_binders", "tactic.interactive.replace", "tactic.interactive.find", "tactic.interactive.subst", "tactic.rcases", "tactic.interactive.constructor_matching", "tactic.interactive.conv", "tactic.resolve_name", "tactic.interactive.guard_expr_strict", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "get_attribute_cache_dyn", "tactic.interactive.exacts", "tactic.interactive.change", "tactic.match_stub", "tactic.interactive.has_to_tactic_format", "tactic.i_to_expr_no_subgoals", "structure_instance_info", "tactic.interactive.conv_rhs", "interactive.parse_binders_core", "tactic.interactive.match_target", "tactic.mk_simp_set_core", "smt_tactic.interactive.eblast_using", "tactic.using_texpr", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.mapply", "tactic.interactive.specialize", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.apply_with", "lean.parser.pexpr", "tactic.interactive.fapply", "tactic.interactive.guard_expr_eq", "tactic.interactive.casesm", "tactic.interactive.clean", "tactic.apply_rules", "tactic.decode_simp_arg_list", "pexpr.has_to_pexpr", "tactic.interactive.guard_expr_eq'", "pexpr.mk_explicit", "pexpr.is_choice_macro", "to_pexpr", "tactic.interactive.guard_target", "sformat_macro", "tactic.suggest.replace_mvars", "instance_derive_handler", "smt_tactic.interactive.from", "library_note", "pexpr.mk_field_macro", "tactic.simp_arg", "tactic.interactive.have", "tactic.interactive.erase_simp_args", "tactic.add_defn_equations", "tactic.delta_instance", "pexpr.get_structure_instance_info", "tactic.interactive.guard_hyp'", "tactic.mk_inj_eq", "smt_tactic.interactive.change", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "tactic.interactive.apply_rules", "tactic.interactive.destruct", "tactic.interactive.h_generalize", "tactic.interactive.ac_change", "tactic.get_lift_prf", "tactic.interactive.choose", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "tactic.resolve_name'", "smt_tactic.interactive.add_lhs_lemma", "tactic.to_expr", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.ids_to_simp_arg_list", "tactic.interactive.collect_struct", "old_conv.interactive.change", "tactic.interactive.apply", "old_conv.mk_match_expr", "tactic.i_to_expr", "smt_tactic.interactive.exact", "tactic.fail_macro", "smt_tactic.interactive.fapply", "tactic.pexpr_to_pattern", "derive_attr", "old_conv.match_expr"]}, {"id": "option", "parentIds": ["tactic.interactive.record_lit", "interactive.loc.has_reflect", "option.guard", "tactic.find_if_cond_at", "tactic.get_subsingleton_info", "option.decidable_eq_none", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "user_attribute.set_untyped", "option.has_sizeof", "expr.is_sorry", "tactic.interactive.cases", "tactic.instance_cache.get", "vm_decl.olean", "tactic.delta", "expr.is_annotation", "tactic.revertible_local_context", "file_name", "string.iterator.extract", "option_to_tactic_format", "lean.parser.get_variables", "tactic.copy_attribute", "expr.is_iff", "option.lift_or_get_comm", "tactic.elide.unelide", "tactic.mk_mapp", "option_t.ext", "option.is_lawful_monad", "environment.is_projection", "option.has_to_tactic_format", "cc_state.mk_using_hs", "option.bind", "option_t.run_pure", "attribute.register", "try_for", "lean.parser.reflectable.optional", "tactic.cases", "unused_arguments", "optional", "option.lift_or_get_idem", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "smt_tactic.interactive.induction", "expr.to_nat", "tactic.mk_iff_mp_app", "rbmap.min", "option.orelse", "tactic.interactive.loc.get_local_pp_names", "interaction_monad.orelse'", "tactic.simplify_top_down", "where.mk_flag", "simp_attr.pre_smt", "tactic.set_basic_attribute", "option.traversable", "option_t.monad_run", "tactic.interactive.convert", "using_smt", "tactic.match_or", "tactic.simp_all_entry", "string.get_rest", "tactic.interactive.by_contra", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "tactic.interactive.min_tac", "native.rb_lmap.find", "old_conv.trace", "exceptional.to_option", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "restate_axiom_cmd", "tactic.interactive.dsimp", "mk_nat_val_le_proof", "tactic.interactive.cases_matching", "expr.is_ne", "option_t.fail", "tactic.interactive.solve_by_elim", "tactic.replace", "rsimp.rsimplify_goal", "tactic.symmetry_hyp", "tactic.note", "opt_minus", "old_conv.dsimp", "tactic.transport_with_prefix_fun", "rbtree.max", "option.eq_of_eq_some", "tactic.unsafe.type_context.get_fun_info", "old_conv_result", "localized_attr", "expr.to_int", "push_neg.normalize_negations", "old_conv.change", "to_additive.value_type", "expr.is_ge", "interaction_monad.fail", "option.some_inj", "tactic.mk_simp_attr", "tactic.assoc_refl", "tactic.interactive.have_field", "tactic.mllist.empty", "tactic.mllist.head", "tactic.dsimp_hyp", "option.filter", "ematch_lhs", "smt_tactic.interactive.have", "tactic.suggest_scripts", "nolint_attr", "function.injective_of_partial_inv_right", "option.lift_or_get_is_left_id", "to_additive.parser", "tactic.alias.alias_attr", "local_context.mk_local", "can_lift_attr", "tactic.explode.head'", "option_t.bind", "rbnode.max", "old_conv.apply_lemmas_core", "option_t.run_map", "simps_add_projection", "list.find", "tactic.interactive.lift", "tactic.interactive.unfold_projs", "tactic.down", "option.is_none", "expr.is_heq", "local_decl", "tactic.revert_all", "tactic.interactive.generalize_hyp", "localized_cmd", "old_conv.to_tactic", "tactic.interactive.continue", "tactic.interactive.abstract", "interaction_monad.result_to_string", "tactic.interactive.let", "ext_param", "interaction_monad.result", "tactic.constr_to_prop", "tactic.ext", "local_context.get_local_decl", "smt_tactic.pose", "tactic.cc", "mk_int_val_ne_proof", "tactic.ext_simplify_core", "tactic.try_for", "expr.replace", "native.float.exponent", "to_additive.value_type.has_reflect", "tactic.match_eq", "tactic.success_if_fail", "expr.is_eq", "tactic.interactive.set", "well_founded_tactics.default_dec_tac'", "mk_nat_val_ne_proof", "option.has_mem", "smt_tactic.interactive.dsimp", "environment.decl_filter_map", "tactic.change_core", "tactic.interactive.change'", "lint", "interaction_monad.get_result", "tactic.returnopt", "tactic.interactive.letI", "option_t.run_monad_map", "tactic.mk_congr_lemma_simp", "list.mmap_filter", "list.extractp", "option_t.orelse", "environment.relation_info", "tactic.interactive.simp", "lean.parser.get_includes", "environment.is_refl_app", "tactic.mk_iff_of_inductive_prop", "tactic.find_if_cond", "tactic.iff_mp_core", "no_rsimp", "option.decidable_exists_mem", "tactic.suggest.match_head_symbol", "old_conv.match_pattern", "tactic.change_with_at", "tactic.constructor_idx", "tactic.constructor_num_fields", "mk_fin_val_ne_proof", "option.is_none_iff_eq_none", "option_t.monad_map", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "old_conv.funext", "tactic.interactive.elide", "tactic.interactive.rec.to_tactic_format", "environment.trans_for", "tactic.classical", "tactic.interactive.obtain_parse", "lean.parser.of_tactic'", "tactic.lift", "tactic.abstract", "tactic.interactive.iterate", "tactic.unsafe.type_context.mk_mvar", "interactive.loc", "option.rhoare", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "conv.dsimp", "string.iterator.extract_core", "tactic.successes", "option.lift_or_get", "tactic.get_simp_lemmas_or_default", "tactic.frozen_local_instances", "tactic.fail_if_success", "tactic.def_replacer_cmd", "tactic.trace_error", "tactic.mk_patterns", "tactic.mk_replacer\u2082", "function.injective_of_partial_inv", "expr.is_gt", "doc_blame_report_defn", "pos_line", "lean.parser.get_namespace", "tactic.match_heq", "option.to_monad", "tactic.interactive.suffices", "loc.to_string_aux", "to_additive.map_namespace", "function.partial_inv", "to_additive.value_type.inhabited", "tactic.rcases_parse_depth", "tactic.by_cases", "rsimp_attr", "function.is_partial_inv", "tactic.interactive.by_contradiction", "expr.pos", "tactic.subobject_names", "tactic.decorate_ex", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "old_conv.find_pattern", "rbmap.find", "smt_tactic.interactive.let", "interaction_monad.mk_exception", "option.map", "option.eq_some_of_is_some", "linter_attr", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.interactive.simp_rw", "declaration.instantiate_value_univ_params", "where.find_var", "tactic.apply_heq_congr_core", "tactic.explode.entries.head", "tactic.lock_tactic_state", "mk_nat_val_lt_proof", "old_conv.lhs", "option.iget", "tactic.unsafe.type_context.is_stuck", "tactic.match_not", "option.map_id", "native.rb_map.max", "tactic.opt_to_tac", "environment.structure_fields_full", "environment.recursor_of", "rbmap.max", "tactic.cc_dbg", "ematch", "tactic.try_core", "option_t.pure", "tactic.explode.entries.find", "rbnode.find", "tactic.interactive.haveI", "library_note_attr", "tactic.olean_doc_strings", "tactic.match_ne", "tactic.higher_order_attr", "rsimp.rsimplify_at", "old_conv.save_info", "vm.stack_obj_info", "option_t.run_bind", "simp_attr.functor_norm", "simp_attr.norm", "expr.is_or", "environment.decl_olean", "name_with_opt", "expr.replace_with", "option_t.catch", "tactic.comp_val", "environment.decl_pos", "list.of_fn_nth_val", "old_conv.congr_core", "apply_nolint_tac", "tactic.interactive.rw_rules_t.has_reflect", "tactic.interactive.obtain", "smt_tactic.try", "rbmap.find_entry", "expr.is_eta_expansion_aux", "tactic.mllist", "ext_param_type", "tactic.mllist.uncons", "tactic.fold_explicit_args", "tactic.simplify_bottom_up", "rbnode.min", "check_unused_arguments", "old_conv.apply_propext_lemmas_core", "tactic.interactive.generalize", "tactic.mk_has_reflect_instance", "tactic.try", "environment.get_trusted_decls", "print_item_crawl", "smt_tactic.execute", "tactic.interactive.transitivity", "except.to_option", "tactic.split_ifs", "tactic.ancestor_attr", "tactic.match_and", "tactic.interactive.cases_type", "list.nth", "function.partial_inv_left", "interactive.loc.get_locals", "interactive.loc.include_goal", "conv.interactive.find", "tactic.interactive.rename'_arg_parser", "smt_tactic.note", "tactic.interactive.ext", "tactic.alias.alias_direct", "tactic.interactive.unelide", "expr.is_le", "rsimp.collect_implied_eqs", "tactic.relation_lhs_rhs", "where.get_variables_core", "list.reduce_option", "option.has_to_format", "tactic.iff_mpr", "expr.to_pos_nat", "tactic.iff_mpr_core", "fold_over_with_cond", "linter", "user_attribute.set", "option.inhabited", "smt_config.inhabited", "tactic.by_contradiction", "tactic.interactive.replace", "simp_attr.split_if_reduction", "tactic.mllist.filter_map", "option.has_repr", "environment.refl_for", "tactic.interactive.return_cast", "tactic.match_iff", "tactic.mllist.monad_lift", "tactic.match_refl_app", "option.get", "tactic.suggest.process_declaration", "option.lhoare", "tactic.rcases", "expr.is_bin_arith_app", "tactic.interactive.constructor_matching", "tactic.assoc_rewrite", "tactic.assoc_rewrite_hyp", "tactic.interactive.conv", "list.head'", "simps_parser", "option.alternative", "tactic.interactive.intro", "tactic.injection_with", "tactic.interactive.convert_to", "vm_decl.pos", "tactic.induction", "tactic.interactive.congr'", "tactic.interactive.change", "list.lookmap", "option.mem_to_list", "interaction_monad_fmap", "list_linters", "lint_aux", "name.map_prefix", "native.rb_lmap.insert", "tactic.interactive.list_cast_of", "tactic.interactive.simp_core", "user_attribute", "option.rel", "environment.structure_fields", "structure_instance_info", "tactic.def_replacer", "tactic.interactive.conv_rhs", "interaction_monad_orelse", "debugger.attr", "derive_handler_attr", "linter.doc_blame", "tactic.using_texpr", "tactic.unsafe.type_context.orelse", "loc.to_string", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.ext1", "rbtree.find", "tactic.unsafe.type_context.try", "tactic.interactive.specialize", "tactic.interactive.refine_one", "tactic.interactive.swap", "native.rb_map.find", "old_conv.whnf", "tactic.pose", "vm_local_info", "rbmap.to_value", "old_conv.find", "option.lift_or_get_is_right_id", "fold_over_with_cond_sorted", "function.is_partial_inv_left", "tactic.returnex", "tactic.dsimp_target", "where.trace_where", "tactic.interactive.casesm", "old_conv.top_down", "impossible_instance", "interaction_monad.result.clamp_pos", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "expr.is_eta_expansion", "cc_config.inhabited", "rsimp.rsimplify", "tactic.up", "lean.parser.parser_orelse", "tactic.rsimp", "tactic.iff_mp", "option.is_some", "expr.is_not", "option.traverse", "tactic.alias.get_alias_target", "where.is_variable_name", "expr.get_nat_value", "tactic.mk_assoc_instance", "tactic.interactive.rw_rules", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "tactic.mk_replacer", "old_conv.bottom_up", "tactic.rsimp_at", "option.mem_def", "tactic.suggest.replace_mvars", "instance_priority", "tactic.interactive.introI", "tactic.interactive.dunfold", "instance_derive_handler", "option.monad", "smt_tactic.interactive.rsimp", "rbtree.min", "tactic.get_fun_info", "native.rb_map.min", "tactic.interactive.extract_goal", "environment.inductive_type_of", "tactic.get_mathlib_dir", "smt_tactic.induction", "tactic.interactive.have", "old_conv.pure", "tactic.interactive.field", "tactic.delta_instance", "smt_tactic.interactive.simp", "mk_char_val_ne_proof", "tactic.mk_hcongr_lemma", "list.last'", "pexpr.get_structure_instance_info", "expr.is_eta_expansion_test", "expr.apply_replacement_fun", "option_t", "option.has_to_string", "option.to_list", "tactic.mk_inj_eq", "smt_tactic.interactive.change", "option.has_reflect", "smt_tactic.interactive.add_fact", "tactic.interactive.list_cast_of_aux", "list.get_rest", "old_conv.seq", "tactic.interactive.h_generalize", "option_t.bind_cont", "tactic.interactive.ac_change", "expr.is_internal_cnstr", "conv.congr", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.suggest.application", "option.eq_none_of_is_none", "option.lift_or_get_assoc", "tactic.interactive.choose", "dangerous_instance", "mk_hinst_lemma_attr_core", "option_t.is_lawful_monad", "tactic.interactive.source_fields", "coe_option", "function.partial_inv_of_injective", "interactive.types.using_ident", "option.iget_some", "tactic.interactive.parse_config", "cc_config", "tactic.find_private_decl", "local_context.get_local", "tactic.induction'", "tactic.interactive.rw_rules_t", "list.filter_map", "doc_blame_report_thm", "tactic.replacer_attr", "tactic.subst", "tactic.interactive.suggest", "option_t.run_monad_lift", "option_t.lift", "tactic.get_unused_name", "interactive.types.location", "tactic.interactive.contrapose", "conv.interactive.dsimp", "interaction_monad_bind", "environment.symm_for", "tactic.interactive.push_neg", "tactic.interactive.conv_lhs", "derive_struct_ext_lemma", "expr.is_lt", "option.get_or_else", "environment.decl_map", "old_conv.map", "lint_mathlib", "ge_or_gt_in_statement", "lint_all", "tactic.assoc_rewrite_target", "tactic.ids_to_simp_arg_list", "expr.is_and", "declaration.instantiate_type_univ_params", "interactive.decl_meta_info", "has_inhabited_instance", "smt_tactic.interactive.executor", "tactic.run_async", "old_conv.lift_tactic", "tactic.import_private_cmd", "tactic.interactive.delta", "mk_string_val_ne_proof", "tactic.success_if_fail_with_msg", "dup_namespace", "old_conv.mk_match_expr", "expr.of_nat", "option.decidable_forall_mem", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "tactic.module_doc_strings", "tactic.apply_at", "interaction_monad.silent_fail", "option.decidable_eq", "tactic.note_anon", "tactic.mk_congr_lemma", "old_conv.match_expr"]}, {"id": "has_pure", "parentIds": ["tactic.interactive.record_lit", "has_sizeof_derive_handler", "tactic.strip_prefix", "comp.applicative", "tactic.rintro_hint", "tactic.revertible_local_context", "comp.run_pure", "comp.map_pure", "to_additive.target_name", "mjoin_map_map", "option_t.run_pure", "guard", "applicative_transformation.preserves_map", "optional", "tactic.rcases_hint", "simp_attr.pre_smt", "except_t.run_pure", "restate_axiom", "bind_pure", "reader_t.run_read", "applicative_transformation", "tactic.interactive.induction", "succeeds", "option_t.fail", "opt_minus", "state_t.run_map", "localized_attr", "to_additive.proceed_fields", "sum.is_lawful_monad", "reader_t.run_map", "tactic.mk_simp_attr", "ematch_lhs", "reader_t.run_pure", "nolint_attr", "user_attribute.dflt_parser", "to_additive.parser", "tactic.alias.alias_attr", "tactic.unsafe.type_context.list_mvars", "can_lift_attr", "native.rb_set.mfilter", "option_t.run_map", "simps_add_projection", "tactic.trace_macro", "tactic.interactive.generalize_hyp", "except_t.return", "task.monad", "state_t.put", "monad_from_pure_bind", "state_t.run_adapt", "expr.traverse", "mjoin_pure", "parser.is_lawful_monad", "tactic.resolve_constant", "sum.monad", "parser.monad", "reader_t.is_lawful_monad", "no_rsimp", "functor.const.applicative", "except.monad", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "tactic.interactive.rec.to_tactic_format", "user_attribute.dflt_cache_cfg", "fish_pipe", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "except_t.run_map", "state_t.run_monad_lift", "state_t.run_get", "reader_t.read", "to_additive.map_namespace", "tactic.rcases_parse_depth", "rsimp_attr", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "state_t.lift", "name_set.mfilter", "linter_attr", "mjoin_map_pure", "comp.applicative_id_comp", "comp.has_pure", "mtry", "tactic.mllist.range", "ematch", "option_t.pure", "library_note_attr", "tactic.list_constructors_hole", "simp_attr.functor_norm", "simp_attr.norm", "tactic.unsafe.type_context.monad", "interaction_monad.monad", "tactic.unsafe.type_context.print_mvars", "applicative", "map_seq", "tactic.interactive.generalize", "tactic.ancestor_attr", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "comp.pure_seq_eq_map", "list.monad", "simp_attr.split_if_reduction", "tactic.interactive.return_cast", "assert", "applicative.pure_seq_eq_map'", "old_conv.monad", "tactic.assoc_rewrite", "exceptional.monad", "applicative.ext", "state_t.run_put", "when", "tactic.match_stub", "seq_bind_eq", "guard_true", "tactic.interactive.has_to_tactic_format", "vm_core.monad", "pure_id_seq", "except_t.monad_except", "debugger.attr", "state_t.monad_state", "derive_handler_attr", "is_lawful_applicative.map_comp_pure", "reader_t.pure", "state_t.modify", "mjoin_map_mjoin", "id.monad", "tactic.unsafe.type_context.orelse", "seq_map_assoc", "tactic.unsafe.type_context.trace", "comp.applicative_comp_id", "except_t.is_lawful_monad", "return", "name_set.mmap", "except_t.monad", "state_t.pure", "tactic.alias.get_alias_target", "tactic.get_ancestors", "pure_id'_seq", "state_t.monad", "fish_pure", "mk_hinst_lemma_attr_set", "id.pure_eq", "instance_derive_handler", "tactic.inhabited_instance", "option.monad", "tactic.interactive.field", "applicative_transformation.preserves_pure", "is_lawful_monad", "tactic.interactive.erase_simp_args", "tactic.local_decls", "interactive.loc.apply", "guard_false", "tactic.decidable_eq_derive_handler", "tactic.interactive.h_generalize", "map_bind", "tactic.alias.make_left_right", "functor.add_const.applicative", "tactic.replaceable_attr", "mk_name_set_attr", "saturate_fun", "mk_hinst_lemma_attr_core", "option_t.is_lawful_monad", "tactic.interactive.parse_config", "tactic.find_private_decl", "comp.seq_pure", "option_t.monad", "has_reflect_derive_handler", "tactic.mk_eq_proof", "tactic.rename'", "reader_t.monad", "tactic.replacer_attr", "state_t.is_lawful_monad", "derive_struct_ext_lemma", "has_inhabited_instance", "state_t.run_pure", "state_t.get", "tactic.fail_macro", "is_lawful_applicative", "tactic.module_doc_strings"]}, {"id": "list.unzip", "parentIds": ["tactic.interactive.record_lit", "tactic.interactive.refine_one"]}, {"id": "structure_instance_info", "parentIds": ["tactic.interactive.record_lit", "tactic.interactive.refine_struct", "tactic.interactive.rec.to_tactic_format", "pexpr.mk_structure_instance", "tactic.interactive.collect_struct'", "tactic.interactive.refine_recursively", "tactic.interactive.refine_one", "pexpr.get_structure_instance_info", "tactic.interactive.collect_struct"]}, {"id": "has_seq_left", "parentIds": ["tactic.interactive.record_lit", "comp.applicative", "sum.is_lawful_monad", "tactic.interactive.rename'_args_parser", "parser.alternative", "task.monad", "monad_from_pure_bind", "parser.is_lawful_monad", "sum.monad", "parser.monad", "reader_t.is_lawful_monad", "functor.const.applicative", "except.monad", "state_t.alternative", "tactic.explode", "tactic.unsafe.type_context.monad", "interaction_monad.monad", "applicative", "list.monad", "old_conv.monad", "parser.run", "option.alternative", "exceptional.monad", "applicative.ext", "vm_core.monad", "id.monad", "reader_t.alternative", "except_t.is_lawful_monad", "except_t.monad", "state_t.monad", "tactic.interactive.rw_rules", "option.monad", "functor.add_const.applicative", "comp.is_lawful_applicative", "option_t.is_lawful_monad", "option_t.monad", "reader_t.monad", "tactic.resolve_name'", "state_t.is_lawful_monad", "interactive.types.brackets", "is_lawful_applicative", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "lean.parser.sep_by", "parentIds": ["tactic.interactive.record_lit", "tactic.interactive.rename'_args_parser", "tactic.interactive.rw_rules", "tactic.rcases_patt_parse_core", "interactive.types.list_of"]}, {"id": "lean.parser_state", "parentIds": ["tactic.interactive.record_lit", "lean.parser.sep_by", "lean.parser_state.cur_pos", "interactive.types.ident_", "lean.parser.get_variables", "interactive.types.opt_pexpr_list", "lean.parser.reflectable.optional", "smt_tactic.interactive.induction", "where.trace_variables", "interactive.types.only_flag", "where.mk_flag", "tactic.interactive.guard_tags", "tactic.interactive.convert", "tactic.mk_simp_attribute_cmd", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "restate_axiom_cmd", "smt_tactic.interactive.intros", "lean.parser_state.options", "lean.parser.emit_command_here", "opt_minus", "lean.parser", "tactic.interactive.clear_dependent", "tactic.interactive.rename'_args_parser", "lean.parser.val", "interactive.types.with_ident_list", "smt_tactic.interactive.have", "apply_nolint_cmd", "to_additive.parser", "tactic.to_texpr", "tactic.interactive.clear'", "tactic.trace_macro", "tactic.interactive.unfold1", "tactic.ext_parse", "localized_cmd", "smt_tactic.interactive.add_eqn_lemmas", "ext_param", "tactic.rintro_parse", "interactive.types.without_ident_list", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "tactic.interactive.change'", "tactic.interactive.letI", "lean.parser.get_includes", "lean.parser_result", "tactic.interactive.guard_hyp_strict", "tactic.interactive.obtain_parse", "lean.parser.of_tactic'", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "tactic.interactive.clear", "lean.parser.get_namespace", "tactic.rcases_parse_depth", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.let", "find_cmd", "tactic.interactive.substs", "tactic.interactive.haveI", "name_with_opt", "tactic.ancestor_attr", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.rename'_arg_parser", "tactic.interactive.ext", "tactic.interactive.simp_intros", "tactic.pformat_macro", "where.get_variables_core", "tactic.interactive.replace", "open_locale_cmd", "lean.parser.reflectable.has_reflect", "tactic.interactive.guard_expr_strict", "simps_parser", "tactic.interactive.convert_to", "tactic.interactive.funext", "list_linters", "tactic.interactive.conv_rhs", "lean.parser.reflectable.expr", "lean.parser_state.env", "tactic.using_texpr", "tactic.interactive.simpa", "lean.parser.alternative", "where.trace_where", "lean.parser.parser_orelse", "tactic.interactive.guard_expr_eq'", "where.is_variable_name", "lean.parser.cur_pos", "tactic.interactive.rw_rules", "tactic.interactive.dunfold", "library_note", "tactic.simp_arg_list", "tactic.simp_arg", "tactic.interactive.clear_except", "tactic.interactive.guard_hyp'", "tactic.rcases_patt_parse_core", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.ac_change", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "tactic.explode_cmd", "tactic.interactive.introsI", "interactive.types.location", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.import_private_cmd", "tactic.interactive.delta", "tactic.fail_macro", "tactic.interactive.generalize_proofs"]}, {"id": "has_bind", "parentIds": ["tactic.interactive.record_lit", "tactic.eval_expr'", "tactic.find_if_cond_at", "tactic.interactive.squeeze_simp", "fish", "tactic.add_library_note", "tactic.replace_at", "tactic.library_search_hole_cmd", "tactic.trace", "tactic.mk_const", "parser.eof", "tactic.exfalso", "tactic.interactive.cases", "tactic.instance_cache.get", "get_localized", "smt_tactic.solve1", "tactic.delta", "tactic.focus1", "print_content", "tactic.rintro_hint", "tactic.interactive.with_cases", "tactic.revertible_local_context", "tactic.apply_iff", "infer_type_cmd", "option_to_tactic_format", "tactic.get_expl_arity", "tactic.mk_constructor_arg_names", "lean.parser.get_variables", "tactic.admit", "tactic.copy_attribute", "well_founded_tactics.clear_internals", "name_set.mfold", "expr.mk_exists_lst", "tactic.injections_with", "tactic.interactive.recover", "environment.mfold", "state_t.run_bind", "tactic.save_const_type_info", "smt_tactic.interactive.destruct", "to_additive.target_name", "tactic.focus", "option.is_lawful_monad", "mjoin_map_map", "tactic.find_assumption", "tactic.cases", "tactic.existsi", "unused_arguments", "tactic.cc_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "smt_tactic.trace_state", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "tactic.instance_cache.append_typeclasses", "tactic.dsimplify", "smt_tactic.add_lemmas_from_facts", "where.trace_variables", "tactic.mk_brec_on_rec_value", "tactic.simplify_top_down", "tactic.get_env", "where.mk_flag", "tactic.interactive.guard_tags", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "simp_attr.pre_smt", "tactic.cleanup", "tactic.is_prop", "smt_tactic.seq", "transport_multiplicative_to_additive", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "using_smt", "smt_tactic.interactive.guard_target", "conv.interactive.conv", "conv.lhs", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "tactic.get_pi_binders", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "bind_pure", "tactic.interactive.by_cases", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "old_conv.findp", "state_t.bind", "tactic.revert_kdependencies", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "lean.parser.emit_command_here", "tactic.symmetry_hyp", "tactic.note", "old_conv.dsimp", "tactic.transport_with_prefix_fun", "state_t.run_map", "tactic.elim_gen_sum", "localized_attr", "native.rb_map.has_to_tactic_format", "expr.to_int", "tactic.interactive.clear_dependent", "push_neg.normalize_negations", "old_conv.change", "tactic.non_dep_prop_hyps", "sum.is_lawful_monad", "use_cmd", "reader_t.run_map", "tactic.left", "tactic.mk_simp_attr", "tactic.assoc_refl", "tactic.interactive.have_field", "tactic.mllist.head", "tactic.dsimp_hyp", "smt_tactic.swap", "smt_tactic.interactive.have", "tactic.match_subexpr", "id.bind_eq", "tactic.mk_dec_eq_instance", "print_localized_commands", "tactic.suggest_scripts", "tactic.generalize_proofs", "tactic_format_expr", "apply_nolint_cmd", "interactive.loc.try_apply", "to_additive.parser", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "tactic.library_search", "can_lift_attr", "tactic.match_hypothesis", "tactic.terminal_goal", "option_t.bind", "tactic.mk_local'", "tactic.interactive.clear'", "old_conv.apply_lemmas_core", "native.rb_set.mfilter", "option_t.run_map", "tactic.mk_user_fresh_name", "simps_add_projection", "tactic.trace_macro", "tactic.interactive.unfold_projs", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "smt_tactic.slift", "localized_cmd", "tactic.mk_eq_simp_ext", "tactic.choose1", "old_conv.to_tactic", "conv.update_lhs", "task.monad", "old_conv.conversion", "tactic.extract_def", "tactic.delta_target", "old_conv.apply_propext_simp_set", "expr.mfoldl", "conv.interactive.guard_lhs", "simps_tac", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "monad_from_pure_bind", "tactic.tactic.has_to_tactic_format", "tactic.try_apply_opt_auto_param_for_apply", "smt_tactic.classical", "state_t.run_adapt", "tactic.constr_to_prop", "tactic.local_proof", "smt_tactic.pose", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "tactic.solve_aux", "smt_tactic.add_ematch_lemma_core", "tactic.suggest.message", "tactic.propositional_goal", "tactic.match_expr", "tactic.save_info", "has_bind.seq", "tactic.get_goal", "parser.is_lawful_monad", "tactic.resolve_constant", "tactic.interactive.set", "well_founded_tactics.default_dec_tac'", "sum.monad", "tactic.apply_auto_param", "mjoin", "tactic.change_core", "parser.monad", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "tactic.interactive.letI", "old_conv.trace_lhs", "reader_t.is_lawful_monad", "option_t.orelse", "tactic.instance_stub", "tactic.in_open_namespaces", "tactic.interactive.type_check", "lean.parser.get_includes", "tactic.updateex_env", "where.trace_includes", "smt_tactic.proof_for", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.trace_result", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.rintro", "conv.funext", "except.monad", "tactic.change_with_at", "tactic.match_target_subexpr", "tactic.constructor_idx", "tactic.constructor_num_fields", "tactic.clear_aux_decl", "mk_hinst_lemma_attr_from_simp_attr", "old_conv.funext", "tactic.interactive.refine_struct", "tactic.interactive.elide", "tactic.interactive.rec.to_tactic_format", "tactic.is_type_app_of", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "tactic.interactive.obtain_parse", "tactic.interactive.unfold_aux", "fish_pipe", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.abstract", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.interactive.try_for", "conv.dsimp", "tactic.interactive.simp_core_aux", "tactic.right", "tactic.def_replacer_cmd", "tactic.mk_patterns", "conv.interactive.trace_lhs", "smt_tactic.focus1", "tactic.interactive.injection", "conv.whnf", "tactic.interactive.exact", "smt_tactic.get_facts", "tactic.assert", "except_t.run_map", "state_t.run_monad_lift", "tactic.rewrite_hyp", "to_additive.map_namespace", "print_all_content", "tactic.get_string_option", "tactic.explode.may_be_proof", "tactic.rcases_parse_depth", "tactic.case_bash", "declaration.in_current_file", "tactic.by_cases", "rsimp_attr", "show_goal_cmd", "tactic.interactive.library_search", "tactic.add_theorem_by", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "state_t.lift", "name_set.mfilter", "smt_tactic.interactive.let", "has_bind.and_then", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "mjoin_map_pure", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "tactic.set_main_tag", "tactic.apply_heq_congr_core", "tactic.mk_constructors_arg_names", "smt_tactic.all_goals", "bind_ext_congr", "conv.interactive.change", "find_cmd", "tactic.interactive.substs", "tactic.mk_local_pis_whnf", "ematch", "smt_tactic.slift_aux", "tactic.any_hyp", "control_laws_tac", "tactic.decl_mk_const", "native.rb_set.mfold", "tactic.iterate1", "tactic.interactive.haveI", "smt_tactic.get_refuted_facts", "smt_tactic.save_info", "rsimp.rsimplify_at", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.dunfold_target", "option_t.run_bind", "simp_attr.functor_norm", "reader_t.bind", "tactic.mk_mvar", "simp_attr.norm", "tactic.unsafe.type_context.monad", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "tactic.trace_state", "parser.one_of", "tactic.local_def_value", "option_t.catch", "tactic.comp_val", "interaction_monad.monad", "old_conv.congr_core", "where.get_opens", "id.is_lawful_monad", "tactic.unsafe.type_context.print_mvars", "tactic.interactive.obtain", "expr.is_eta_expansion_aux", "tactic.fold_explicit_args", "expr.of_int", "tactic.simplify_bottom_up", "tactic.interactive.guard_hyp", "tactic.match_target", "tactic.apply", "tactic.contradiction", "tactic.get_main_tag", "old_conv.apply_propext_lemmas_core", "expr.mfold", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "tactic.interactive.transitivity", "tactic.set_nat_option", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.to_expr'", "rsimp.to_repr_map", "smt_tactic.note", "tactic.alias.alias_direct", "tactic.interactive.unelide", "tactic.solve_by_elim", "native.rb_map.mfold", "lint_hole_cmd", "tactic.interactive.show", "rsimp.collect_implied_eqs", "tactic.relation_lhs_rhs", "tactic.interactive.simp_intros", "tactic.pformat_macro", "tactic.apply_congr_core", "where.get_variables_core", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "tactic.no_mvars_in_target", "tactic.iff_mpr", "tactic.join_user_simp_lemmas", "tactic.interactive.guard_target'", "tactic.explode_expr", "tactic.unfold_projs", "copy_decl_using", "tactic.interactive.concat_tags", "list.monad", "tactic.define", "tactic.by_contradiction", "tactic.interactive.replace", "tactic.interactive.subst", "simp_attr.split_if_reduction", "tactic.get_arity", "tactic.interactive.clear_", "tactic.interactive.return_cast", "cc_state.mfold_eqc", "conv.replace_lhs", "vm.trace", "tactic.set_string_option", "old_conv.monad", "tactic.constructor", "tactic.match_refl_app", "tactic.get_pi_arity", "tactic.rcases", "tactic.fsplit", "tactic.interactive.constructor_matching", "tactic.assoc_rewrite", "expr.simp", "open_locale_cmd", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "lean.parser.reflectable.has_reflect", "expr.dsimp", "tactic.interactive.guard_expr_strict", "get_linters", "smt_tactic.get_goals", "tactic.subsingleton_goal", "exceptional.monad", "list.is_lawful_monad", "tactic.injection_with", "old_conv.apply_simp_set", "tactic.save_options", "get_attribute_cache_dyn", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "tactic.rename", "tactic.interactive.change", "tactic.match_stub", "seq_bind_eq", "tactic.mk_constructor_fresh_names", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "monad", "tactic.get_decl", "tactic.interactive.simp_core", "vm_core.monad", "tactic.def_replacer", "tactic.injection", "tactic.mk_simp_set_core", "tactic.simp_hyp", "tactic.get_options", "smt_tactic.interactive.eblast_using", "tactic.repeat", "conv.change", "mjoin_map_mjoin", "id.monad", "tactic.solve1", "tactic.unsafe.type_context.orelse", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "reader_t.run_bind", "tactic.interactive.mapply", "tactic.interactive.specialize", "smt_tactic.read", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "tactic.interactive.apply_with", "old_conv.whnf", "except_t.is_lawful_monad", "tactic.pose", "except_t.run_bind", "tactic.interactive.fapply", "tactic.swap", "tactic.get_nat_option", "old_conv.find", "tactic.split", "name_set.mmap", "fold_over_with_cond_sorted", "tactic.instantiate_mvars_in_target", "except_t.bind", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.dsimp_target", "where.trace_where", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "expr.is_eta_expansion", "tactic.unfold_projs_target", "tactic.apply_rules", "tactic.simp_all", "except_t.monad", "rsimp.rsimplify", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "tactic.rsimp", "conv.interactive.simp", "tactic.iff_mp", "tactic.interactive.guard_expr_eq'", "tactic.mk_constructors_fresh_names", "tactic.alias.get_alias_target", "where.is_variable_name", "fish_assoc", "tactic.assumption", "state_t.monad", "tactic.is_proof", "tactic.mk_assoc_instance", "fish_pure", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "tactic.replace_target", "smt_tactic.by_contradiction", "tactic.interactive.guard_target", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "instance_priority", "tactic.interactive.dunfold", "where.fetch_potential_variable_names", "smt_tactic.by_cases", "instance_derive_handler", "tactic.inhabited_instance", "library_note", "option.monad", "smt_tactic.interactive.rsimp", "tactic.interactive.extract_goal", "tactic.seq", "tactic.get_mathlib_dir", "tactic.interactive.have", "environment.mfilter", "tactic.interactive.field", "is_lawful_monad", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "tactic.add_defn_equations", "tactic.local_decls", "tactic.delta_instance", "tactic.interactive.injections", "get_checks", "tactic.interactive.clear_except", "tactic.flatten", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "mcond", "tactic.applyc", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "conv.save_info", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.triv", "tactic.interactive.destruct", "old_conv.seq", "where.format_variable", "tactic.interactive.h_generalize", "map_bind", "tactic.alias.make_left_right", "conv.congr", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.injections_and_clear", "saturate_fun", "tactic.interactive.choose", "except_t.catch", "tactic.rotate_right", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "option_t.is_lawful_monad", "conv.rhs", "smt_tactic.add_ematch_eqn_lemmas_for_core", "tactic.set_options", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "tactic.explode_cmd", "conv.convert", "tactic.find_private_decl", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "option_t.monad", "has_reflect_derive_handler", "tactic.any_goals", "tactic.mk_eq_proof", "tactic.rename'", "reader_t.monad", "tactic.resolve_name'", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "tactic.interactive.suggest", "state_t.is_lawful_monad", "tactic.has_to_tactic_format", "environment.get_modifiers", "conv.interactive.dsimp", "tactic.suggest.library_defs", "seq_eq_bind_map", "tactic.interactive.push_neg", "smt_tactic.interactive.guard_expr_eq", "tactic.intros1", "tactic.get_bool_option", "derive_struct_ext_lemma", "smt_tactic.refutation_for", "tactic.mk_instance_cache", "old_conv.map", "lint_mathlib", "tactic.done", "tactic.reduce_ifs_at", "tactic.num_goals", "lint_all", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "has_inhabited_instance", "tactic.interactive.apply", "tactic.run_async", "old_conv.lift_tactic", "dedup", "tactic.import_private_cmd", "tactic.interactive.delta", "dup_namespace", "tactic.triv'", "old_conv.mk_match_expr", "tactic.congr_core", "tactic.apply_opt_param", "expr.of_nat", "conv.discharge_eq_lhs", "smt_tactic.add_ematch_lemma_from_decl_core", "tactic.fail_macro", "print_name", "tactic.mk_sorry", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "tactic.pexpr_to_pattern", "user_attribute.get_param", "tactic.get_local_type", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "tactic.apply_at", "tactic.note_anon", "tactic.get_expl_pi_arity", "old_conv.match_expr"]}, {"id": "unit", "parentIds": ["tactic.interactive.record_lit", "tactic.unsafe_change", "tactic.clear_lst", "lean.parser.sep_by", "smt_tactic.interactive.assume", "tactic.simplify", "tactic.interactive.constructor", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "tactic.replace_at", "tactic.trace", "conv.execute", "user_attribute.set_untyped", "where.where_cmd", "parser.eof", "tactic.exfalso", "tactic.interactive.cases", "get_localized", "smt_tactic.solve1", "tactic.cc_dbg_core", "tactic.delta", "interactive.types.ident_", "tactic.interactive.skip", "tactic.focus1", "print_content", "tactic.rintro_hint", "tactic.change", "tactic.interactive.with_cases", "infer_type_cmd", "smt_tactic.iterate_exactly", "native.rb_set", "tactic.interactive.rsimp", "thunk", "tactic.admit", "tactic.explode.core", "smt_tactic.add_lemmas_from_facts_core", "tactic.unify", "old_conv.interactive.trace_state", "tactic.copy_attribute", "well_founded_tactics.clear_internals", "smt_tactic.interactive.by_contradiction", "native.rb_set.erase", "tactic.injections_with", "tactic.interactive.any_goals", "smt_tactic.definev", "smt_tactic.interactive.ematch", "tactic.rotate", "tactic.interactive.contradiction", "tactic.interactive.refl", "tactic.interactive.recover", "tactic.explode.args", "tactic.save_const_type_info", "smt_tactic.interactive.destruct", "to_additive.target_name", "tactic.timetac", "tactic.focus", "parser.one_of'", "smt_tactic.set_goals", "tactic.interactive.trivial", "where.trace_namespace", "smt_tactic.execute_with", "smt_tactic.ematch_using", "tactic.interactive.field_simp", "attribute.register", "tactic.cases", "guard", "tactic.existsi", "tactic.cc_core", "tactic.apply_inj_lemma", "tactic.interactive.from", "tactic.mk_has_sizeof_instance_core", "smt_tactic.trace_state", "tactic.get_constructors_for", "tactic.apply_instance", "smt_tactic.ematch_core", "tactic.interactive.propagate_tags", "tactic.whnf_target", "smt_tactic.interactive.induction", "tactic.dsimplify", "interaction_monad.orelse'", "smt_tactic.add_lemmas_from_facts", "old_conv.skip", "where.trace_variables", "interactive.types.only_flag", "tactic.simplify_top_down", "where.mk_flag", "tactic.interactive.guard_tags", "smt_tactic.add_ematch_lhs_lemma_from_decl", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "smt_tactic.add_ematch_lemma_from_decl", "simp_attr.pre_smt", "simp_lemmas.rewrite", "tactic.set_basic_attribute", "tactic.cleanup", "native.rb_set.size", "conv.interactive.itactic", "smt_tactic.seq", "transport_multiplicative_to_additive", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "using_smt", "smt_tactic.interactive.guard_target", "tactic.enable_tags", "conv.interactive.conv", "tactic.interactive.focus", "tactic.interactive.symmetry", "tactic.apply_list_expr", "tactic.interactive.by_contra", "tactic.mk_simp_attribute_cmd", "conv.interactive.skip", "tactic.interactive.by_cases", "old_conv.repeat", "trace_fmt", "tactic.interactive.cc", "tactic.interactive.min_tac", "tactic.clear'", "tactic.interactive.revert", "tactic.by_elim_opt", "old_conv.execute", "old_conv.trace", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "rbtree.default_lt", "old_conv.findp", "tactic.symm_apply", "parser.many'", "tactic.interactive.unfold_coes", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "smt_tactic.interactive.intros", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "tactic.replace", "rsimp.rsimplify_goal", "lean.parser.emit_command_here", "tactic.symmetry_hyp", "opt_minus", "old_conv.dsimp", "tactic.interactive.apply_opt_param", "tactic.transport_with_prefix_fun", "tactic.interactive.apply_assumption", "smt_tactic.intron", "interactive.executor", "tactic.elim_gen_sum", "localized_attr", "tactic.repeat1", "tactic.interactive.split_ifs", "old_conv.istep", "tactic.save_type_info", "tactic.congr", "smt_tactic.trace", "to_additive.proceed_fields", "tactic.match_app_of", "tactic.interactive.clear_dependent", "push_neg.normalize_negations", "tactic.interactive.rotate", "old_conv.change", "tactic.interactive.apply_iff_congr_core", "use_cmd", "tactic.iterate_range", "tactic.interactive.rename'_args_parser", "lint_cmd", "where.trace_nl", "smt_tactic.write", "tactic.interactive.triv", "tactic.mk_simp_attr", "tactic.assoc_refl", "tactic.interactive.have_field", "tactic.independent_goal", "tactic.dsimp_hyp", "interactive.types.with_ident_list", "ematch_lhs", "smt_tactic.swap", "smt_tactic.interactive.have", "tactic.interactive.subst_vars", "tactic.mk_dec_eq_instance", "print_localized_commands", "tactic.suggest_scripts", "tactic.generalize_proofs", "tactic.interactive.refine", "smt_tactic.when_tracing", "nolint_attr", "register_attribute", "apply_nolint_cmd", "interactive.loc.try_apply", "user_attribute.dflt_parser", "tactic.interactive.right", "parser.sep_by1", "old_conv.apply_propext_lemmas", "tactic.alias.alias_attr", "tactic.library_search", "tactic.interactive.clear_aux_decl", "can_lift_attr", "tactic.add_inductive", "tactic.terminal_goal", "tactic.to_texpr", "tactic.interactive.clear'", "old_conv.apply_lemmas_core", "simps_add_projection", "tactic.interactive.lift", "tactic.trace_macro", "tactic.exact", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.down", "add_interactive", "smt_tactic.when", "tactic.interactive.generalize_hyp", "localized_cmd", "tactic.mk_eq_simp_ext", "tactic.choose1", "tactic.assertv_core", "old_conv.to_tactic", "conv.update_lhs", "old_conv.conversion", "tactic.extract_def", "tactic.interactive.continue", "tactic.delta_target", "smt_tactic.interactive.add_eqn_lemmas", "tactic.interactive.unfreezeI", "old_conv.apply_propext_simp_set", "conv.interactive.guard_lhs", "tactic.interactive.abstract", "simps_tac", "tactic.interactive.apply_field", "interaction_monad.result_to_string", "tactic.rewrite", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "ext_param", "tactic.try_apply_opt_auto_param_for_apply", "interaction_monad.result", "tactic.constr_to_prop", "tactic.ext", "tactic.interactive.econstructor", "tactic.rintro_parse", "tactic.local_proof", "smt_tactic.pose", "tactic.cc", "tactic.interactive.split", "interactive.types.without_ident_list", "smt_tactic.interactive.itactic", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "smt_tactic.intros", "tactic.solve_aux", "smt_tactic.add_ematch_lemma_core", "tactic.try_for", "tactic.suggest.message", "tactic.propositional_goal", "tactic.choose", "tactic.success_if_fail", "tactic.save_info", "old_conv.apply_lemmas", "smt_tactic.interactive.trace", "lean.parser.set_env", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "well_founded_tactics.default_dec_tac'", "tactic.subst_core", "tactic.interactive.injections_and_clear", "smt_tactic.interactive.dsimp", "smt_tactic.close", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.congr_core'", "tactic.interactive.change'", "smt_tactic.interactive.trace_state", "interaction_monad.get_result", "tactic.interactive.letI", "old_conv.trace_lhs", "monad.sequence'", "tactic.interactive.simp", "tactic.interactive.type_check", "tactic.updateex_env", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.trace_result", "no_rsimp", "tactic.sleep", "tactic.rintro", "tactic.interactive.success_if_fail", "conv.funext", "old_conv.match_pattern", "tactic.change_with_at", "conv.interactive.done", "tactic.reflexivity", "tactic.clear_aux_decl", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "old_conv.funext", "tactic.interactive.refine_struct", "tactic.interactive.elide", "tactic.interactive.repeat", "user_attribute.dflt_cache_cfg", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "smt_tactic.add_ematch_lhs_lemma", "tactic.interactive.obtain_parse", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "simps_add_projections", "tactic.abstract", "tactic.interactive.iterate", "tactic.interactive.rintros", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.interactive.try_for", "conv.dsimp", "tactic.assert_core", "tactic.interactive.simp_core_aux", "tactic.fail_if_success", "monad.whenb", "tactic.def_replacer_cmd", "tactic.trace_error", "tactic.mk_patterns", "lint_all_cmd", "tactic.generalizes", "tactic.istep", "conv.interactive.trace_lhs", "tactic.interactive.clear", "smt_tactic.focus1", "tactic.interactive.injection", "conv.whnf", "tactic.interactive.exact", "tactic.interactive.existsi", "tactic.assert", "tactic.unsafe.type_context.assign", "tactic.transport_with_prefix_dict", "tactic.interactive.suffices", "tactic.skip", "to_additive.map_namespace", "smt_tactic.ematch", "smt_tactic.interactive.eblast", "print_all_content", "conv.interactive.rw", "tactic.rcases_parse_depth", "smt_tactic.has_andthen", "tactic.iterate_exactly", "tactic.case_bash", "native.rb_set.fold", "interactive.executor.execute_with_explicit", "tactic.by_cases", "rsimp_attr", "native.rb_set.contains", "show_goal_cmd", "tactic.interactive.library_search", "tactic.add_theorem_by", "tactic.when_tracing", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.decorate_ex", "tactic.interactive.cases_arg_p", "tactic.try_apply_opt_auto_param", "tactic.interactive.rename", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "old_conv.find_pattern", "smt_tactic.add_ematch_eqn_lemmas_for", "conv.solve1", "tactic.mk_has_sizeof_instance", "smt_tactic.interactive.let", "conv.skip", "smt_tactic.interactive.try", "well_founded_tactics.cancel_nat_add_lt", "interaction_monad.mk_exception", "linter_attr", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.interactive.all_goals", "old_conv.interactive.whnf", "tactic.ac_refl", "where.trace_opens", "tactic.set_main_tag", "tactic.apply_heq_congr_core", "tactic.lock_tactic_state", "simps_attr", "smt_tactic.interactive.iterate", "mk_hinst_lemma_attrs_core", "smt_tactic.all_goals", "smt_tactic.interactive.add_lemma", "conv.interactive.change", "mtry", "tactic.interactive.exactI", "smt_tactic.define", "find_cmd", "tactic.interactive.substs", "tactic.cc_dbg", "ematch", "smt_tactic.slift_aux", "tactic.try_core", "tactic.interactive.assume", "control_laws_tac", "tactic.interactive.assumption'", "parser.eps", "smt_tactic.add_ematch_lemma", "tactic.back_chaining", "tactic.interactive.haveI", "library_note_attr", "tactic.write", "smt_tactic.save_info", "tactic.higher_order_attr", "rsimp.rsimplify_at", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.dunfold_target", "smt_tactic.assertv", "tactic.suggest.apply_and_solve", "tactic.definev_core", "simp_attr.functor_norm", "simp_attr.norm", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "name_with_opt", "tactic.trace_state", "parser.one_of", "tactic.suggest_core", "smt_tactic.add_lemmas", "lean.parser.emit_code_here", "lean.parser.tk", "tactic.use", "option_t.catch", "tactic.comp_val", "well_founded_tactics.unfold_sizeof", "old_conv.congr_core", "tactic.symmetry", "tactic.unsafe.type_context.print_mvars", "apply_nolint_tac", "tactic.interactive.obtain", "smt_tactic.try", "tactic.interactive.itactic", "expr.is_eta_expansion_aux", "where.trace_end", "interactive.decl_attributes.apply", "tactic.simplify_bottom_up", "tactic.interactive.guard_hyp", "tactic.interactive.resetI", "tactic.interactive.reflexivity", "tactic.apply", "tactic.contradiction", "old_conv.apply_propext_lemmas_core", "tactic.interactive.erw", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.try", "tactic.set_env_core", "tactic.intron", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "smt_tactic.execute", "tactic.interactive.transitivity", "tactic.interactive.success_if_fail_with_msg", "parser.sep_by", "tactic.split_ifs", "tactic.ancestor_attr", "tactic.set_nat_option", "tactic.simp_intros", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.define_core", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.rename'_arg_parser", "tactic.interactive.to_expr'", "smt_tactic.note", "tactic.step", "conv.interactive.whnf", "tactic.interactive.ext", "tactic.alias.alias_direct", "smt_tactic.istep", "tactic.interactive.unelide", "interactive.interactive.executor", "tactic.solve_by_elim", "tactic.interactive.show", "rsimp.collect_implied_eqs", "tactic.interactive.admit", "tactic.relation_lhs_rhs", "tactic.interactive.assoc_rw", "tactic.interactive.simp_intros", "tactic.dunfold_hyp", "tactic.pformat_macro", "tactic.interactive.erewrite", "tactic.apply_congr_core", "format_macro", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "tactic.no_mvars_in_target", "simp_lemmas.rewrites", "tactic.interactive.guard_target'", "tactic.explode_expr", "tactic.unset_attribute", "copy_decl_using", "tactic.interactive.concat_tags", "tactic.define", "user_attribute.set", "tactic.by_contradiction", "tactic.interactive.replace", "tactic.interactive.find", "tactic.interactive.subst", "simp_attr.split_if_reduction", "tactic.save_info_thunk", "vm.put_str", "tactic.interactive.clear_", "tactic.interactive.return_cast", "conv.replace_lhs", "tactic.destruct", "vm.trace", "tactic.set_string_option", "smt_tactic.assert", "parser.run", "tactic.assertv", "tactic.type_check", "tactic.andthen_seq_focus", "tactic.instantiate_mvars_in_goals", "list.for_each", "tactic.rcases", "tactic.fsplit", "tactic.interactive.constructor_matching", "expr.simp", "open_locale_cmd", "tactic.rewrite_target", "tactic.interactive.conv", "tactic.reset_instance_cache", "tactic.interactive.guard_expr_strict", "simps_parser", "tactic.iterate", "tactic.set_env", "tactic.interactive.trace_state", "tactic.subsingleton_goal", "tactic.interactive.intro", "tactic.injection_with", "tactic.interactive.convert_to", "tactic.set_tag", "old_conv.apply_simp_set", "tactic.save_options", "smt_tactic.interactive.apply", "tactic.interactive.funext", "smt_tactic.interactive.close", "tactic.interactive.congr'", "tactic.interactive.assoc_rewrite", "parser.ch", "tactic.subst_vars", "native.rb_map.set_of_list", "tactic.fail_if_no_goals", "tactic.rename", "tactic.interactive.exacts", "when", "tactic.interactive.change", "tactic.simp_bottom_up'", "smt_tactic.iterate_at_most", "interaction_monad_fmap", "tactic.delta_hyp", "guard_true", "tactic.interactive.trace", "list_linters", "lean.parser.command_like", "tactic.interactive.simp_core", "well_founded_tactics.unfold_wf_rel", "user_attribute", "tactic.def_replacer", "tactic.interactive.conv_rhs", "well_founded_tactics.trivial_nat_lt", "conv.interactive.erw", "tactic.interactive.done", "tactic.is_def_eq", "interaction_monad_orelse", "smt_tactic.iterate", "tactic.interactive.match_target", "tactic.mk_simp_set_core", "tactic.interactive.async", "debugger.attr", "smt_tactic.eblast", "tactic.back_chaining_using", "tactic.simp_hyp", "derive_handler_attr", "tactic.iterate_at_most_on_all_goals", "smt_tactic.intro_lst", "smt_tactic.interactive.eblast_using", "tactic.repeat", "conv.change", "trace_val", "tactic.using_texpr", "tactic.solve1", "unit.has_to_string", "tactic.iterate_at_most", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.rotate_left", "tactic.andthen_seq", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "tactic.unsafe.type_context.trace", "tactic.interactive.mapply", "tactic.interactive.specialize", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "tactic.interactive.apply_with", "tactic.interactive.left", "tactic.interactive.exfalso", "old_conv.whnf", "tactic.funext", "tactic.interactive.fapply", "tactic.swap", "tactic.interactive.apply_auto_param", "old_conv.find", "tactic.interactive.try", "tactic.unsafe.type_context.level.assign", "lean.parser.itactic", "tactic.instantiate_mvars_in_target", "conv.interactive.rewrite", "tactic.solve_by_elim_aux", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.returnex", "tactic.dsimp_target", "where.trace_where", "tactic.interactive.casesm", "push_neg.push_neg_at_goal", "old_conv.top_down", "monad.unlessb", "interaction_monad.result.clamp_pos", "parser.str", "tactic.interactive.clean", "tactic.unfold_projs_target", "tactic.select", "native.mk_rb_set", "tactic.apply_rules", "tactic.simp_all", "tactic.rexact", "rsimp.rsimplify", "tactic.unfreeze_local_instances", "tactic.up", "lean.parser.parser_orelse", "tactic.rsimp", "conv.interactive.simp", "conv.interactive.congr", "tactic.add_decl", "smt_tactic.step", "tactic.interactive.guard_expr_eq'", "conv.step", "mwhen", "punit.reflect", "tactic.alias.get_alias_target", "tactic.add_meta_definition", "tactic.get_ancestors", "tactic.assumption", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "unit.has_repr", "tactic.interactive.apply_instance", "tactic.interactive.rw_rules", "tactic.add_doc_string", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "tactic.replace_target", "monad.mapm'", "smt_tactic.interactive.by_contra", "smt_tactic.by_contradiction", "tactic.trace_call_stack", "tactic.interactive.guard_target", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "sformat_macro", "tactic.trace_algebra_info", "parser.char_buf", "tactic.try_lst", "instance_priority", "tactic.interactive.introI", "native.rb_set.insert", "tactic.clear", "tactic.interactive.dunfold", "tactic.interactive.rw", "smt_tactic.by_cases", "instance_derive_handler", "smt_tactic.interactive.from", "tactic.inhabited_instance", "library_note", "tactic.simp_arg_list", "smt_tactic.interactive.rsimp", "tactic.set_goals", "lean.parser.itactic_reflected", "tactic.interactive.extract_goal", "tactic.setup_tactic_parser_cmd", "conv.istep", "tactic.seq", "tactic.simp_arg", "smt_tactic.induction", "tactic.interactive.have", "tactic.definev", "tactic.interactive.field", "tactic.add_defn_equations", "tactic.delta_instance", "smt_tactic.interactive.simp", "tactic.interactive.injections", "tactic.interactive.clear_except", "tactic.interactive.fail_if_success", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "smt_tactic.interactive.apply_instance", "guard_false", "tactic.mk_inj_eq", "well_founded_tactics.process_lex", "smt_tactic.interactive.change", "to_additive.attr", "tactic.applyc", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "tactic.unify_prefix", "conv.save_info", "smt_tactic.set_lemmas", "tactic.interactive.apply_rules", "tactic.triv", "tactic.interactive.destruct", "tactic.simp_config_ext", "tactic.interactive.h_generalize", "smt_tactic.skip", "unit.star", "tactic.interactive.intros", "tactic.funext_lst", "tactic.interactive.ac_change", "well_founded_tactics", "conv.congr", "tactic.interactive.fsplit", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "option_t.monad_except", "tactic.funext_core", "tactic.injections_and_clear", "guardb", "smt_tactic.destruct", "tactic.interactive.choose", "tactic.rotate_right", "tactic.replace_hyp", "mk_hinst_lemma_attr_core", "smt_tactic.add_ematch_eqn_lemmas_for_core", "tactic.set_options", "tactic.interactive.solve1", "interactive.types.using_ident", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "conv.interactive.to_lhs", "tactic.interactive.fconstructor", "parser.decorate_error", "tactic.write_ref", "task.delay", "tactic.explode_cmd", "conv.convert", "tactic.find_private_decl", "smt_tactic.interactive.all_goals", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "tactic.split_if1", "conv.interactive.to_rhs", "tactic.induction'", "tactic.any_goals", "tactic.interactive.introsI", "tactic.rename'", "tactic.resolve_name'", "tactic.solve", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "interactive.executor.execute_explicit", "tactic.interactive.classical", "tactic.interactive.suggest", "old_conv.step", "old_conv.congr", "interactive.types.location", "smt_tactic.interactive.add_lhs_lemma", "tactic.interactive.contrapose", "old_conv.interactive.dsimp", "interactive.types.list_of", "conv.interactive.dsimp", "tactic.interactive.ac_reflexivity", "interaction_monad_bind", "tactic.interactive.push_neg", "tactic.unsafe.type_context.pop_local", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.backward_chaining_core", "derive_struct_ext_lemma", "tactic.exact_dec_trivial", "tactic.mk_instance_cache", "tactic.interactive.rewrite", "tactic.done", "tactic.reduce_ifs_at", "tactic.clear_aux_decl_aux", "tactic.assoc_rewrite_target", "tactic.ids_to_simp_arg_list", "old_conv.interactive.change", "tactic.interactive.sorry", "smt_tactic.interactive.executor", "tactic.interactive.apply", "tactic.run_async", "dedup", "tactic.import_private_cmd", "tactic.transitivity", "tactic.interactive.delta", "lint_mathlib_cmd", "tactic.success_if_fail_with_msg", "tactic.triv'", "old_conv.mk_match_expr", "tactic.congr_core", "tactic.unfold_projs_hyp", "unit.has_to_format", "tactic.apply_opt_param", "native.rb_set.empty", "conv.discharge_eq_lhs", "interactive.types.brackets", "list.mmap'", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "tactic.interactive.congr", "tactic.interactive.ac_refl", "tactic.fail_macro", "old_conv.interactive.itactic", "print_name", "smt_tactic.interactive.fapply", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "tactic.interactive.comp_val", "tactic.interactive.generalize_proofs", "well_founded_tactics.check_target_is_value_lt", "smt_tactic.solve_goals", "tactic.interactive.assumption", "tactic.apply_at", "interaction_monad.silent_fail", "conv.interactive.funext", "derive_attr", "tactic.match_fn", "transport_with_dict", "old_conv.match_expr", "tactic.generalize"]}, {"id": "has_seq_right", "parentIds": ["tactic.interactive.record_lit", "lean.parser.sep_by", "smt_tactic.interactive.assume", "interactive.types.ident_", "comp.applicative", "smt_tactic.interactive.induction", "interactive.types.only_flag", "tactic.interactive.convert", "tactic.interactive.induction", "sum.is_lawful_monad", "tactic.interactive.rename'_args_parser", "interactive.types.with_ident_list", "smt_tactic.interactive.have", "parser.alternative", "tactic.to_texpr", "task.monad", "tactic.interactive.let", "monad_from_pure_bind", "interactive.types.without_ident_list", "parser.is_lawful_monad", "sum.monad", "parser.monad", "tactic.interactive.change'", "tactic.interactive.letI", "reader_t.is_lawful_monad", "functor.const.applicative", "except.monad", "tactic.interactive.guard_hyp_strict", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "tactic.interactive.suffices", "tactic.rcases_parse_depth", "state_t.alternative", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.let", "tactic.interactive.assume", "tactic.interactive.haveI", "tactic.unsafe.type_context.monad", "interaction_monad.monad", "tactic.interactive.guard_hyp", "applicative", "tactic.alias.alias_cmd", "tactic.interactive.rename'_arg_parser", "tactic.interactive.ext", "list.monad", "tactic.interactive.replace", "old_conv.monad", "tactic.interactive.conv", "tactic.interactive.guard_expr_strict", "option.alternative", "exceptional.monad", "tactic.interactive.convert_to", "applicative.ext", "tactic.interactive.change", "vm_core.monad", "tactic.interactive.conv_rhs", "tactic.using_texpr", "id.monad", "reader_t.alternative", "tactic.interactive.simpa", "except_t.is_lawful_monad", "tactic.interactive.guard_expr_eq", "except_t.monad", "tactic.interactive.guard_expr_eq'", "state_t.monad", "tactic.interactive.rw_rules", "tactic.simp_arg_list", "option.monad", "tactic.simp_arg", "tactic.interactive.have", "tactic.interactive.guard_hyp'", "tactic.interactive.ac_change", "functor.add_const.applicative", "tactic.interactive.case", "comp.is_lawful_applicative", "tactic.interactive.choose", "option_t.is_lawful_monad", "interactive.types.using_ident", "option_t.monad", "reader_t.monad", "state_t.is_lawful_monad", "interactive.types.location", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.import_private_cmd", "interactive.types.brackets", "is_lawful_applicative", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "lean.parser.alternative", "parentIds": ["tactic.interactive.record_lit", "lean.parser.sep_by", "smt_tactic.interactive.assume", "tactic.interactive.squeeze_simp", "tactic.interactive.cases", "interactive.types.ident_", "interactive.types.opt_pexpr_list", "lean.parser.reflectable.optional", "smt_tactic.interactive.induction", "interactive.types.only_flag", "tactic.interactive.guard_tags", "simp_attr.pre_smt", "tactic.interactive.convert", "tactic.interactive.by_contra", "tactic.mk_simp_attribute_cmd", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "restate_axiom_cmd", "tactic.interactive.cases_matching", "smt_tactic.interactive.intros", "tactic.interactive.solve_by_elim", "opt_minus", "localized_attr", "tactic.interactive.clear_dependent", "tactic.interactive.rename'_args_parser", "tactic.mk_simp_attr", "interactive.types.with_ident_list", "user_attribute.parse_reflect", "ematch_lhs", "smt_tactic.interactive.have", "nolint_attr", "apply_nolint_cmd", "user_attribute.dflt_parser", "to_additive.parser", "tactic.alias.alias_attr", "can_lift_attr", "tactic.interactive.clear'", "tactic.interactive.unfold1", "tactic.ext_parse", "tactic.interactive.generalize_hyp", "smt_tactic.interactive.add_eqn_lemmas", "tactic.interactive.abstract", "tactic.interactive.let", "ext_param", "tactic.rintro_parse", "interactive.types.without_ident_list", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.simp", "no_rsimp", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "tactic.interactive.obtain_parse", "tactic.interactive.iterate", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "tactic.interactive.clear", "tactic.interactive.suffices", "tactic.rcases_parse_depth", "rsimp_attr", "tactic.interactive.by_contradiction", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.let", "linter_attr", "interactive.types.pexpr_list_or_texpr", "tactic.interactive.substs", "ematch", "tactic.interactive.assume", "tactic.interactive.haveI", "library_note_attr", "simp_attr.functor_norm", "simp_attr.norm", "name_with_opt", "tactic.interactive.guard_hyp", "tactic.interactive.generalize", "tactic.interactive.transitivity", "tactic.ancestor_attr", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.rename'_arg_parser", "tactic.interactive.ext", "tactic.interactive.simp_intros", "tactic.interactive.replace", "simp_attr.split_if_reduction", "tactic.rcases", "tactic.interactive.constructor_matching", "open_locale_cmd", "tactic.interactive.conv", "simps_parser", "tactic.interactive.intro", "tactic.interactive.convert_to", "tactic.interactive.funext", "tactic.interactive.congr'", "tactic.interactive.change", "tactic.interactive.conv_rhs", "debugger.attr", "derive_handler_attr", "tactic.using_texpr", "tactic.interactive.simpa", "tactic.interactive.guard_expr_eq", "tactic.interactive.casesm", "where.is_variable_name", "tactic.interactive.rw_rules", "mk_hinst_lemma_attr_set", "tactic.interactive.introI", "tactic.interactive.dunfold", "tactic.simp_arg_list", "tactic.interactive.extract_goal", "tactic.simp_arg", "tactic.interactive.have", "smt_tactic.interactive.simp", "tactic.interactive.clear_except", "tactic.rcases_patt_parse_core", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.ac_change", "tactic.replaceable_attr", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "mk_hinst_lemma_attr_core", "interactive.types.using_ident", "tactic.interactive.introsI", "tactic.replacer_attr", "tactic.interactive.suggest", "interactive.types.location", "tactic.interactive.contrapose", "tactic.interactive.conv_lhs", "tactic.import_private_cmd", "tactic.interactive.delta", "interactive.types.brackets", "tactic.interactive.generalize_proofs"]}, {"id": "lean.parser.skip_info", "parentIds": ["tactic.interactive.record_lit", "tactic.interactive.rw_rules", "interactive.types.list_of"]}, {"id": "tactic.eval_expr'", "parentIds": ["tactic.replacer"]}, {"id": "reflected", "parentIds": ["tactic.eval_expr'", "reflected.has_to_tactic_format", "interactive.loc.has_reflect", "tactic.add_library_note", "user_attribute.set_untyped", "tactic.interactive.rw_rule.has_reflect", "prod.has_reflect", "lean.parser.reflectable.optional", "expr.mk_or_lst", "tactic.is_prop", "tactic.replacer", "tactic.mk_iff", "tactic.mk_simp_attr", "user_attribute.parse_reflect", "user_attribute.dflt_parser", "int.mk_numeral", "list.reflect", "localized_cmd", "bool.has_reflect", "to_additive.value_type.has_reflect", "sum.has_reflect", "reflected.has_to_format", "string.reflect", "mk_hinst_lemma_attr_from_simp_attr", "tactic.simp_arg_type.has_reflect", "user_attribute.dflt_cache_cfg", "reflected_value.subst", "nat.mk_numeral", "tactic.def_replacer_cmd", "tactic.mk_patterns", "binder_info.has_reflect", "to_additive.map_namespace", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "reflected.has_to_pexpr", "tactic.eval_expr", "tactic.local_def_value", "tactic.interactive.rw_rules_t.has_reflect", "expr.reflect", "expr.mk_and_lst", "user_attribute.set", "expr.has_coe", "reflected_value.expr", "has_reflect", "get_attribute_cache_dyn", "reflected.subst", "list_linters", "tactic.def_replacer", "punit.reflect", "mk_hinst_lemma_attr_set", "reflect", "tactic.replacer_core", "tactic.interactive.extract_goal", "unsigned.reflect", "option.has_reflect", "mk_name_set_attr", "mk_hinst_lemma_attr_core", "pos.has_reflect", "derive_struct_ext_lemma", "has_inhabited_instance", "reflected_value", "user_attribute.get_param", "reflected.to_expr"]}, {"id": "tactic.eval_expr", "parentIds": ["tactic.eval_expr'", "tactic.mk_simp_attribute_cmd", "tactic.get_library_notes", "localized_attr", "to_additive.parser", "localized_cmd", "tactic.apply_auto_param", "tactic.interactive.try_for", "get_linters", "get_attribute_cache_dyn", "tactic.interactive.parse_config", "user_attribute.get_param"]}, {"id": "tactic_state", "parentIds": ["tactic.eval_expr'", "tactic.find_if_cond_at", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "tactic.replace_at", "tactic.library_search_hole_cmd", "tactic.trace", "tactic.mk_const", "tactic.exfalso", "tactic.strip_prefix", "tactic.interactive.cases", "tactic.instance_cache.get", "tactic_state.has_to_string", "get_localized", "tactic.cc_dbg_core", "tactic.delta", "tactic.focus1", "print_content", "tactic.rintro_hint", "tactic.interactive.with_cases", "tactic.revertible_local_context", "tactic.apply_iff", "infer_type_cmd", "option_to_tactic_format", "tactic.get_expl_arity", "tactic.mk_constructor_arg_names", "tactic.admit", "tactic.copy_attribute", "well_founded_tactics.clear_internals", "expr.mk_exists_lst", "tactic.injections_with", "tactic.interactive.recover", "tactic.save_const_type_info", "to_additive.target_name", "tactic.timetac", "tactic.focus", "smt_tactic.set_goals", "tactic.find_assumption", "tactic.cases", "tactic.existsi", "unused_arguments", "tactic.cc_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "smt_tactic.trace_state", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.whnf_target", "tactic.mk_assumption_set", "tactic.instance_cache.append_typeclasses", "tactic_state.get_options", "tactic.dsimplify", "conv.monad", "tactic.interactive.loc.get_local_pp_names", "tactic.mk_brec_on_rec_value", "tactic.simplify_top_down", "tactic.get_env", "tactic.interactive.guard_tags", "tactic.rcases_hint", "tactic.back_chaining_using_hs", "simp_attr.pre_smt", "tactic.cleanup", "tactic.is_prop", "transport_multiplicative_to_additive", "tactic.seq_focus", "tactic.interactive.guard_target_strict", "restate_axiom", "tactic.interactive.convert", "using_smt", "tactic.match_or", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "tactic.get_pi_binders", "tactic.interactive.get_rule_eqn_lemmas", "conv.monad_fail", "tactic.interactive.by_cases", "tactic.clear'", "tactic.replacer", "tactic.interactive.revert", "old_conv.trace", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "rbtree.default_lt", "old_conv.findp", "tactic.symm_apply", "tactic.revert_kdependencies", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "has_dup", "tactic.replace", "rsimp.rsimplify_goal", "tactic.symmetry_hyp", "tactic.note", "old_conv.dsimp", "tactic.transport_with_prefix_fun", "tactic.interactive.apply_assumption", "tactic.elim_gen_sum", "localized_attr", "native.rb_map.has_to_tactic_format", "old_conv.istep", "to_additive.proceed_fields", "tactic.match_app_of", "tactic.interactive.clear_dependent", "push_neg.normalize_negations", "old_conv.change", "tactic.non_dep_prop_hyps", "use_cmd", "tactic.left", "smt_tactic.write", "tactic.mk_simp_attr", "tactic.assoc_refl", "tactic.interactive.have_field", "tactic.independent_goal", "tactic.dsimp_hyp", "ematch_lhs", "tactic.match_subexpr", "tactic.mk_dec_eq_instance", "print_localized_commands", "tactic.suggest_scripts", "tactic.generalize_proofs", "tactic_format_expr", "interactive.loc.try_apply", "to_additive.parser", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "tactic.library_search", "tactic_state.env", "can_lift_attr", "tactic.match_hypothesis", "tactic.terminal_goal", "tactic.mk_local'", "tactic.interactive.clear'", "old_conv.apply_lemmas_core", "tactic.mk_user_fresh_name", "simps_add_projection", "tactic.interactive.unfold_projs", "tactic.down", "smt_state.to_format", "where.get_def_variables", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.main_goal", "tactic.mk_eq_simp_ext", "tactic.choose1", "old_conv.to_tactic", "old_conv.conversion", "tactic.extract_def", "tactic.interactive.continue", "tactic.delta_target", "conv.interactive.guard_lhs", "simps_tac", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "tactic.tactic.has_to_tactic_format", "tactic.try_apply_opt_auto_param_for_apply", "tactic.constr_to_prop", "tactic.local_proof", "tactic.match_assoc_pattern", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "tactic.solve_aux", "tactic.try_for", "tactic.suggest.message", "tactic.propositional_goal", "tactic.match_eq", "tactic.success_if_fail", "tactic.match_expr", "tactic.save_info", "tactic.get_goal", "tactic.resolve_constant", "tactic.interactive.set", "well_founded_tactics.default_dec_tac'", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "tactic.returnopt", "tactic.interactive.letI", "tactic.instance_stub", "tactic.in_open_namespaces", "tactic.interactive.type_check", "tactic.updateex_env", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.has_opt_auto_param", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.trace_result", "no_rsimp", "tactic.kdependencies", "tactic.suggest.tactic_statement", "tactic.rintro", "conv.funext", "old_conv.match_pattern", "tactic.change_with_at", "tactic.match_target_subexpr", "tactic.constructor_idx", "tactic.constructor_num_fields", "tactic.clear_aux_decl", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "old_conv.funext", "tactic.interactive.refine_struct", "tactic.interactive.elide", "tactic.interactive.rec.to_tactic_format", "tactic.is_type_app_of", "tactic.classical", "tactic.dependent_pose_core", "tactic.interactive.guard_hyp_strict", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "lean.parser.of_tactic'", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.abstract", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.interactive.try_for", "tactic.successes", "tactic.interactive.simp_core_aux", "tactic.get_simp_lemmas_or_default", "tactic.right", "tactic.fail_if_success", "tactic.trace_error", "tactic.mk_patterns", "tactic.istep", "tactic.interactive.injection", "smt_tactic.alternative", "tactic.interactive.exact", "doc_blame_report_defn", "tactic.assert", "tactic.rewrite_hyp", "tactic.match_heq", "tactic.interactive.suffices", "tactic.skip", "to_additive.map_namespace", "print_all_content", "tactic.get_string_option", "tactic.explode.may_be_proof", "tactic.case_bash", "declaration.in_current_file", "tactic.by_cases", "rsimp_attr", "show_goal_cmd", "tactic.interactive.library_search", "tactic.add_theorem_by", "tactic.when_tracing", "tactic.interactive.by_contradiction", "tactic.mk_inhabited_instance", "tactic.intro", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "tactic.decorate_ex", "tactic.try_apply_opt_auto_param", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "conv.solve1", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.mk_dec_eq_instance_core", "tactic.target_lhs_rhs", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "tactic.set_main_tag", "tactic.apply_heq_congr_core", "tactic.mk_constructors_arg_names", "tactic.lock_tactic_state", "old_conv.lhs", "tactic.read", "tactic.match_not", "tactic.interactive.exactI", "tactic.enum_assoc_subexpr", "well_founded_tactics.is_psigma_mk", "tactic.interactive.substs", "tactic.mk_local_pis_whnf", "ematch", "smt_tactic.slift_aux", "tactic.try_core", "tactic.interactive.assume", "tactic.any_hyp", "control_laws_tac", "tactic.decl_mk_const", "tactic.iterate1", "tactic.interactive.haveI", "tactic.write", "smt_tactic.save_info", "tactic.match_ne", "rsimp.rsimplify_at", "old_conv.save_info", "tactic.list_constructors_hole", "tactic.dunfold_target", "tactic.suggest.apply_and_solve", "simp_attr.functor_norm", "tactic.mk_mvar", "simp_attr.norm", "tactic.revert_and_transform", "tactic.apply_eq_congr_core", "tactic.trace_state", "tactic.suggest_core", "tactic.local_def_value", "tactic.use", "tactic.comp_val", "well_founded_tactics.unfold_sizeof", "tactic.interactive.loc.get_local_uniq_names", "mnot", "old_conv.congr_core", "where.get_opens", "apply_nolint_tac", "tactic.interactive.obtain", "smt_tactic.try", "expr.is_eta_expansion_aux", "tactic.fold_explicit_args", "expr.of_int", "tactic.simplify_bottom_up", "tactic.interactive.guard_hyp", "tactic.match_target", "tactic.apply", "tactic.contradiction", "tactic.get_main_tag", "old_conv.apply_propext_lemmas_core", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.try", "tactic.iterate'", "print_item_crawl", "tactic.all_goals", "tactic.find_local", "tactic.interactive.transitivity", "tactic.set_nat_option", "tactic.match_and", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "interactive.loc.get_locals", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.to_expr'", "smt_tactic.monad_state", "rsimp.to_repr_map", "tactic.step", "tactic.interactive.ext", "tactic.alias.alias_direct", "smt_tactic.istep", "tactic.interactive.unelide", "interactive.interactive.executor", "tactic.solve_by_elim", "lint_hole_cmd", "tactic.interactive.show", "tactic.relation_lhs_rhs", "tactic.interactive.simp_intros", "tactic.apply_congr_core", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "tactic.no_mvars_in_target", "tactic.iff_mpr", "tactic.retrieve", "tactic.join_user_simp_lemmas", "tactic.interactive.guard_target'", "tactic.explode_expr", "tactic.unfold_projs", "copy_decl_using", "tactic.mk_assoc_pattern", "tactic.interactive.concat_tags", "fold_over_with_cond", "tactic.define", "tactic.by_contradiction", "tactic.interactive.replace", "tactic.interactive.subst", "simp_attr.split_if_reduction", "tactic.get_arity", "tactic.interactive.clear_", "tactic.interactive.return_cast", "tactic.match_iff", "tactic.set_string_option", "tactic_state.to_format", "tactic.constructor", "tactic.match_refl_app", "tactic.assertv", "tactic.get_pi_arity", "tactic.rcases", "tactic.fsplit", "tactic.interactive.constructor_matching", "tactic.assoc_rewrite", "expr.simp", "tactic.assoc_rewrite_hyp", "rsimp.choose", "tactic.rewrite_target", "expr.dsimp", "tactic.interactive.guard_expr_strict", "get_linters", "smt_tactic.get_goals", "tactic.subsingleton_goal", "tactic.interactive.intro", "tactic.injection_with", "tactic.interactive.convert_to", "tactic.save_options", "tactic.interactive.funext", "get_attribute_cache_dyn", "tactic.subst_vars", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "tactic.rename", "tactic.interactive.change", "tactic.simp_bottom_up'", "tactic.match_stub", "tactic.mk_constructor_fresh_names", "tactic.interactive.has_to_tactic_format", "lint_aux", "tactic_state.format_expr", "tactic.interactive.list_cast_of", "tactic.get_decl", "tactic.interactive.simp_core", "tactic.def_replacer", "tactic.injection", "tactic.interactive.match_target", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "tactic.simp_hyp", "linter.doc_blame", "tactic.get_options", "tactic.repeat", "tactic.solve1", "smt_tactic.monad", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.with_enable_tags", "tactic.ext1", "list.has_to_tactic_format", "tactic.interactive.mapply", "tactic.interactive.specialize", "smt_tactic.read", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.swap", "tactic.prove_goal_async", "tactic.interactive.apply_with", "old_conv.whnf", "tactic.pose", "tactic.interactive.fapply", "tactic.swap", "tactic.get_nat_option", "old_conv.find", "tactic.split", "fold_over_with_cond_sorted", "tactic.instantiate_mvars_in_target", "tactic.set_bool_option", "tactic.interactive.guard_expr_eq", "tactic.returnex", "tactic_state.set_options", "tactic.dsimp_target", "push_neg.push_neg_at_goal", "old_conv.top_down", "impossible_instance", "old_conv.bind", "incorrect_type_class_argument", "tactic.interactive.clean", "expr.is_eta_expansion", "tactic.unfold_projs_target", "tactic.apply_rules", "tactic.simp_all", "rsimp.rsimplify", "tactic.up", "simp_lemmas.append", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "tactic.rsimp", "tactic.iff_mp", "tactic.interactive.guard_expr_eq'", "tactic.mk_constructors_fresh_names", "tactic.alias.get_alias_target", "tactic.get_ancestors", "tactic.assumption", "tactic.is_proof", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "tactic.replace_target", "tactic.trace_call_stack", "tactic.interactive.guard_target", "old_conv.bottom_up", "tactic.rsimp_at", "push_neg.push_neg_at_hyp", "instance_priority", "tactic.interactive.introI", "tactic.interactive.dunfold", "where.fetch_potential_variable_names", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "tactic.alternative", "tactic.seq", "tactic.get_mathlib_dir", "smt_tactic.induction", "tactic.interactive.have", "old_conv.pure", "environment.mfilter", "tactic.definev", "tactic.interactive.field", "tactic.interactive.erase_simp_args", "tactic.is_prop_decl", "tactic.add_defn_equations", "tactic.local_decls", "tactic.delta_instance", "tactic.interactive.injections", "get_checks", "tactic.interactive.clear_except", "tactic.flatten", "tactic.interactive.guard_hyp'", "interactive.loc.apply", "tactic.mk_inj_eq", "tactic.applyc", "conv.save_info", "tactic.interactive.list_cast_of_aux", "tactic.interactive.get_current_field", "tactic.triv", "tactic.interactive.destruct", "old_conv.seq", "where.format_variable", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.interactive.intros", "tactic.alias.make_left_right", "has_to_format_to_has_to_tactic_format", "tactic.suggest", "tactic.replaceable_attr", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "tactic.has_append", "tactic.suggest.application", "tactic.injections_and_clear", "saturate_fun", "tactic.interactive.choose", "tactic.rotate_right", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "mk_hinst_lemma_attr_core", "tactic.set_options", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "conv.convert", "tactic.find_private_decl", "tactic.interactive.trace_simp_set", "order_laws_tac", "tactic.simp_target", "has_reflect_derive_handler", "tactic.induction'", "tactic.any_goals", "where.compile_variable_list", "doc_blame_report_thm", "tactic.mk_eq_proof", "tactic.interactive.introsI", "tactic.rename'", "tactic.resolve_name'", "tactic.replacer_attr", "equiv_type_constr", "tactic.subst", "tactic.interactive.suggest", "tactic.has_to_tactic_format", "environment.get_modifiers", "tactic.suggest.library_defs", "tactic.failed", "tactic.interactive.push_neg", "tactic.intros1", "tactic.get_bool_option", "derive_struct_ext_lemma", "tactic.exact_dec_trivial", "tactic.mk_instance_cache", "old_conv.map", "lint_mathlib", "tactic.done", "tactic.reduce_ifs_at", "tactic.num_goals", "ge_or_gt_in_statement", "tactic", "lint_all", "tactic.assoc_rewrite_target", "tactic.get_classes", "tactic.ids_to_simp_arg_list", "tactic.interactive.collect_struct", "has_inhabited_instance", "tactic.interactive.apply", "tactic.run_async", "old_conv.lift_tactic", "dedup", "tactic.expanded_field_list", "tactic.interactive.delta", "tactic.metavariables", "tactic.success_if_fail_with_msg", "dup_namespace", "tactic.triv'", "old_conv.mk_match_expr", "tactic.congr_core", "tactic.apply_opt_param", "expr.of_nat", "conv.discharge_eq_lhs", "print_name", "tactic_state.has_to_format", "tactic.mk_sorry", "vm_obj.to_tactic_state", "tactic.interactive.old_conv", "well_founded_tactics.default_dec_tac", "tactic.suggest.apply_declaration", "tactic.pexpr_to_pattern", "user_attribute.get_param", "tactic.get_local_type", "tactic_result", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "tactic.apply_at", "tactic.note_anon", "tactic.fail", "tactic.match_fn", "transport_with_dict", "tactic.get_expl_pi_arity", "old_conv.match_expr"]}, {"id": "tactic.mk_app", "parentIds": ["tactic.eval_expr'", "tactic.instance_cache.get", "tactic.cc_core", "simps_add_projection", "old_conv.funext", "tactic.lift", "tactic.by_cases", "tactic.mk_id_eq", "old_conv.congr_core", "expr.of_int", "old_conv.apply_propext_lemmas_core", "tactic.injection_with", "conv.change", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "instance_derive_handler", "tactic.interactive.h_generalize", "tactic.get_lift_prf", "conv.convert", "has_reflect_derive_handler", "tactic.subst", "derive_struct_ext_lemma", "tactic.get_classes", "expr.of_nat"]}, {"id": "tactic.transparency", "parentIds": ["tactic.eval_expr'", "tactic.interactive.constructor", "tactic.get_subsingleton_info", "tactic.replace_at", "tactic.instance_cache.get", "tactic.delta", "tactic.apply_iff", "tactic.apply_cfg.inhabited", "tactic.rewrite_core", "tactic.admit", "tactic.unify", "tactic.mk_mapp", "tactic.interactive.refl", "tactic.interactive.trivial", "tactic.cases", "tactic.existsi", "tactic.cc_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "tactic.apply_instance", "tactic.whnf_target", "tactic.dsimplify", "smt_tactic.add_ematch_lhs_lemma_from_decl", "tactic.rcases_hint", "smt_tactic.add_ematch_lemma_from_decl", "simp_lemmas.rewrite", "tactic.kdepends_on", "restate_axiom", "conv.interactive.conv", "tactic.interactive.symmetry", "tactic.clear'", "tactic.interactive.induction", "tactic.symm_apply", "tactic.revert_kdependencies", "tactic.interactive.dsimp", "tactic.symmetry_hyp", "tactic.unfold_proj_config.inhabited", "old_conv.dsimp", "tactic.dunfold_head", "old_conv.change", "tactic.interactive.apply_iff_congr_core", "use_cmd", "tactic.left", "tactic.interactive.triv", "tactic.assoc_refl", "tactic.dsimp_hyp", "ematch_lhs", "tactic.match_subexpr", "tactic.mk_dec_eq_instance", "user_attribute.dflt_parser", "tactic.econstructor", "tactic.match_hypothesis", "tactic.terminal_goal", "old_conv.apply_lemmas_core", "tactic.back_lemmas_add_extra", "simps_add_projection", "tactic.exact", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.unsafe.type_context.run", "tactic.mk_eq_simp_ext", "tactic.choose1", "conv.update_lhs", "old_conv.conversion", "tactic.extract_def", "tactic.whnf", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.back_lemmas_insert_core", "tactic.constr_to_prop", "tactic.interactive.cases_core", "tactic.interactive.convert_to_core", "push_neg.whnf_reducible", "smt_tactic.add_ematch_lemma_core", "tactic.dsimplify_core", "tactic.match_expr", "smt_tactic.interactive.add_eqn_lemmas_for", "smt_tactic.interactive.dsimp", "tactic.mk_congr_lemma_simp", "tactic.instance_stub", "tactic.mk_specialized_congr_lemma", "tactic.interactive.type_check", "tactic.apply_assumption", "tactic.kdependencies", "conv.funext", "old_conv.match_pattern", "tactic.match_target_subexpr", "tactic.reflexivity", "tactic.constructor_idx", "mk_hinst_lemma_attr_from_simp_attr", "old_conv.funext", "user_attribute.dflt_cache_cfg", "tactic.dependent_pose_core", "smt_tactic.add_ematch_lhs_lemma", "tactic.interactive.unfold_aux", "tactic.interactive.ext1", "tactic.lift", "tactic.abstract", "tactic.whnf_no_delta", "tactic.ematch_all_core", "conv.dsimp", "tactic.interactive.simp_core_aux", "tactic.right", "tactic.generalizes", "conv.whnf", "smt_tactic.mk_ematch_eqn_lemmas_for_core", "tactic.interactive.exact", "tactic.transparency.inhabited", "tactic.fapply", "tactic.rewrite_hyp", "conv.interactive.rw", "tactic.case_bash", "tactic.rewrite_cfg.inhabited", "tactic.by_cases", "rsimp_attr", "tactic.mk_app", "tactic.mk_inhabited_instance", "old_conv.find_pattern", "smt_tactic.add_ematch_eqn_lemmas_for", "conv.solve1", "conv.skip", "merge_hinst_lemma_attrs", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.mk_id_eq", "tactic.eqn_stub", "old_conv.interactive.whnf", "tactic.ac_refl", "tactic.apply_heq_congr_core", "smt_tactic.interactive.add_lemma", "tactic.interactive.substs", "tactic.mk_local_pis_whnf", "ematch", "control_laws_tac", "smt_tactic.add_ematch_lemma", "rsimp.rsimplify_at", "tactic.list_constructors_hole", "tactic.dunfold_target", "tactic.suggest.apply_and_solve", "hinst_lemma.mk_from_decl", "tactic.apply_eq_congr_core", "tactic.comp_val", "old_conv.congr_core", "tactic.symmetry", "expr.is_eta_expansion_aux", "tactic.fold_explicit_args", "expr.of_int", "tactic.match_target", "tactic.ematch_core", "tactic.get_spec_subsingleton_info", "tactic.interactive.reflexivity", "tactic.apply", "old_conv.apply_propext_lemmas_core", "tactic.interactive.erw", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.interactive.transitivity", "tactic.mk_back_lemmas_core", "conv.interactive.find", "tactic.dsimp_config.inhabited", "tactic.interactive.ext", "tactic.ematch_all", "tactic.interactive.simp_intros", "tactic.dunfold_hyp", "tactic.interactive.erewrite", "tactic.apply_congr_core", "simp_lemmas.rewrites", "tactic.unfold_projs", "tactic.dsimp_config", "tactic.mk_specialized_congr_lemma_simp", "tactic.by_contradiction", "tactic.interactive.subst", "tactic.interactive.return_cast", "tactic.destruct", "tactic.constructor", "tactic.revert_kdeps", "tactic.type_check", "tactic.get_pi_arity", "tactic.rcases", "tactic.fsplit", "tactic.assoc_rewrite", "tactic.rewrite_target", "expr.dsimp", "tactic.ematch", "tactic.injection_with", "tactic.induction", "tactic.unfold_proj", "tactic.subst_vars", "tactic.fconstructor", "tactic.match_stub", "tactic.interactive.simp_core", "well_founded_tactics.unfold_wf_rel", "conv.interactive.erw", "tactic.is_def_eq", "tactic.interactive.match_target", "to_hinst_lemmas_core", "tactic.apply_cfg", "tactic.whnf_ginductive", "tactic.back_lemmas_insert", "smt_tactic.interactive.eblast_using", "conv.change", "tactic.cases_core", "conv.interactive.for", "tactic.interactive.simpa", "tactic.back_chaining_core", "tactic.ext1", "tactic.interactive.mapply", "tactic.interactive.refine_one", "tactic.refine", "tactic.prove_goal_async", "tactic.kabstract", "old_conv.whnf", "tactic.match_pattern", "tactic.dunfold_config.inhabited", "tactic.apply_core", "tactic.split", "conv.interactive.rewrite", "tactic.dsimp_target", "tactic.interactive.clean", "tactic.unfold_projs_target", "tactic.rexact", "tactic.interactive.guard_expr_eq'", "tactic.dunfold", "tactic.assumption", "tactic.interactive.rwa", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "tactic.replace_target", "smt_tactic.by_contradiction", "tactic.interactive.dunfold", "tactic.interactive.rw", "smt_tactic.by_cases", "tactic.mk_back_lemmas", "instance_derive_handler", "tactic.inhabited_instance", "tactic.get_fun_info", "smt_tactic.induction", "hinst_lemma.mk_from_decl_core", "tactic.mk_hcongr_lemma", "tactic.applyc", "smt_tactic.interactive.ematch_using", "tactic.triv", "tactic.interactive.destruct", "tactic.interactive.h_generalize", "conv.congr", "tactic.get_lift_prf", "smt_tactic.destruct", "tactic.replace_hyp", "mk_hinst_lemma_attr_core", "smt_tactic.add_ematch_eqn_lemmas_for_core", "tactic.interactive.source_fields", "conv.convert", "order_laws_tac", "has_reflect_derive_handler", "tactic.induction'", "equiv_type_constr", "tactic.subst", "smt_tactic.interactive.add_lhs_lemma", "conv.interactive.dsimp", "simp_lemmas.dsimplify", "tactic.backward_chaining_core", "derive_struct_ext_lemma", "tactic.mk_instance_cache", "tactic.interactive.rewrite", "tactic.reduce_ifs_at", "tactic.get_classes", "has_inhabited_instance", "tactic.interactive.apply", "tactic.transitivity", "simp_lemmas.drewrite", "tactic.triv'", "old_conv.mk_match_expr", "tactic.unfold_projs_hyp", "hinst_lemma.mk_core", "tactic.apply_opt_param", "expr.of_nat", "smt_tactic.add_ematch_lemma_from_decl_core", "tactic.get_spec_prefix_size", "tactic.eapply", "tactic.match_fn", "tactic.mk_congr_lemma", "tactic.get_expl_pi_arity", "old_conv.match_expr", "tactic.generalize"]}, {"id": "tactic.mk_congr_arg", "parentIds": ["tactic.mk_eq_proof"]}, {"id": "tactic.unsafe_change", "parentIds": ["tactic.delta_target", "tactic.dunfold_target", "tactic.revert_and_transform", "tactic.dsimp_target", "tactic.unfold_projs_target"]}, {"id": "tactic.change", "parentIds": ["tactic.unsafe_change", "tactic.whnf_target", "conv.update_lhs", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.elide", "tactic.interactive.unfold_aux", "tactic.interactive.unelide", "conv.change", "tactic.instantiate_mvars_in_target"]}, {"id": "lt_add_of_sub_right_lt", "parentIds": ["sub_lt_of_abs_sub_lt_left", "lt_add_of_neg_add_lt_right", "lt_add_of_neg_lt_sub_right", "int.lt_of_sub_one_le", "sub_lt_of_sub_lt"]}, {"id": "ordered_comm_group.to_add_comm_group", "parentIds": ["lt_add_of_sub_right_lt", "sub_lt_sub_of_lt_of_le", "neg_add_le_of_le_add", "mul_sub_mul_div_mul_nonpos", "add_lt_of_lt_neg_add", "sub_right_lt_of_lt_add", "le_add_of_sub_left_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_midpoint", "ordered_comm_group.lt_of_add_lt_add_left", "sub_le_sub_left", "sub_left_le_of_le_add", "add_le_of_le_neg_add", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "lt_add_of_neg_add_lt_left", "sub_le_of_sub_le", "neg_lt_neg", "int.of_nat_nat_abs_of_nonpos", "mul_sub_mul_div_mul_neg", "le_add_of_neg_le_sub_left", "lt_add_of_neg_lt_sub_left", "abs_nonneg", "neg_le_neg", "neg_add_le_right_of_le_add", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "neg_le_sub_left_of_le_add", "neg_add_le_left_of_le_add", "lt_of_sub_pos", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "neg_of_neg_pos", "sub_lt_self", "sub_le_sub_right", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "neg_nonpos_of_nonneg", "sub_lt_of_abs_sub_lt_left", "sub_lt_sub_left", "norm_num.nonzero_of_neg_helper", "neg_le_sub_right_of_le_add", "lt_add_of_neg_add_lt", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "sub_left_lt_of_lt_add", "neg_pos_of_neg", "zero_gt_neg_one", "add_lt_of_lt_sub_right", "lt_add_of_neg_lt_sub_right", "abs_of_nonneg", "lt_neg_of_lt_neg", "le_sub_right_of_add_le", "neg_lt_of_neg_lt", "le_add_of_neg_add_le_right", "sub_lt_of_sub_lt", "lt_sub_right_of_add_lt", "div_lt_div_of_pos_of_lt_of_pos", "int.exists_eq_neg_of_nat", "nonpos_of_neg_nonneg", "neg_add_lt_left_of_lt_add", "lt_of_neg_lt_neg", "sub_pos_of_lt", "dist_bdd_within_interval", "pos_of_neg_neg", "sub_lt_sub_of_le_of_lt", "sub_nonpos_of_le", "sub_le_sub", "sub_le_self", "lt_of_sub_neg", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "lt_add_of_sub_left_lt", "nonneg_of_neg_nonpos", "lt_neg_add_of_add_lt", "sub_lt_sub", "neg_nonneg_of_nonpos", "ordered_comm_group.le_of_add_le_add_left", "neg_lt_sub_right_of_lt_add", "le_of_sub_nonpos", "sub_neg_of_lt", "le_neg_add_of_add_le", "neg_neg_of_pos", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "lt_sub_left_of_add_lt", "neg_le_of_neg_le"]}, {"id": "add_semigroup.to_has_add", "parentIds": ["lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "int.neg_succ_of_nat_coe'", "comm_semiring", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "int.of_nat_ge_zero", "add_lt_add_of_lt_of_le", "max_add_add_left", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "norm_num.add_comm_four", "neg_add_self", "eq_add_neg_iff_add_eq", "add_lt_of_lt_of_nonpos", "int.le.dest", "norm_num.bit0_add_bit1", "add_lt_of_lt_neg_add", "add_right_eq_self", "add_lt_of_le_of_neg", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "discrete_field", "div_sub_div", "abs_add_three", "add_assoc", "add_nonpos", "bit0_zero", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "add_sub_comm", "le_add_of_sub_left_le", "linear_ordered_semiring", "norm_num.add1_bit1", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "functor.add_const.is_lawful_applicative", "int.add_assoc", "add_midpoint", "add_add_sub_cancel", "add_comm_group", "decidable_linear_ordered_semiring", "neg_add_eq_sub", "lt_add_of_le_of_pos", "add_monoid_to_is_right_id", "eq_zero_of_mul_eq_self_right", "add_left_cancel_semigroup", "eq_of_sub_eq_zero", "sub_add_add_cancel", "nat.add_div_left", "nat.bodd_add_div2", "le_add_of_le_of_nonneg", "add_sub_cancel'", "nat.succ_mul_succ_eq", "add_right_surjective", "add_zero", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "sub_left_le_of_le_add", "dvd_add_iff_right", "add_sub_sub_cancel", "list.length_append", "string.iterator.length_next_to_string_next", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "le_add_of_nonneg_of_le", "add_le_of_le_neg_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "integral_domain", "nat.lt_add_of_pos_left", "nat.mul_div_right", "norm_num.add_comm_middle", "semiring", "div_le_div_of_mul_sub_mul_div_nonpos", "add_lt_of_nonpos_of_lt", "div_two_sub_self", "lt_add_of_pos_of_le", "add_neg_eq_iff_eq_add", "int.sub_nat_nat_elim", "lt_of_add_lt_add_right", "decidable_linear_ordered_cancel_comm_monoid", "add_lt_of_neg_of_lt", "eq_add_neg_of_add_eq", "sub_eq_iff_eq_add", "int.lt_add_succ", "norm_num.add1_zero", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "list.length_map", "nat.sub_mul_mod", "add_sub_cancel'_right", "lt_add_of_neg_add_lt_left", "neg_lt_neg", "left_inverse_neg_add_add_right", "norm_num.bit1_add_bit0_helper", "left_inverse_add_left_sub", "lt_of_add_lt_add_left", "add_left_injective", "left_inverse_add_right_neg_add", "add_neg_of_nonpos_of_neg", "add_le_add_right", "nat.shiftl'_sub", "norm_num.neg_add_pos_eq_of_eq_add", "add_mul_self_eq", "norm_num.neg_add_pos_helper2", "lt_add_of_nonneg_of_lt", "add_add_add_comm", "ring", "neg_add", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "nat.add_sub_cancel", "division_ring", "neg_neg_sub_neg", "add_monoid_to_is_left_id", "add_eq_zero_iff_neg_eq", "linear_ordered_comm_ring", "nat.sub_pos_of_lt", "add_self_iff_eq_zero", "nat.bodd_mul", "int.lt_irrefl", "le_add_of_neg_le_sub_left", "neg_add_eq_iff_eq_add", "lt_add_of_neg_lt_sub_left", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "add_semigroup_to_is_eq_associative", "add_sub_add_right_eq_sub", "nat.mul_div_cancel'", "int.le_antisymm", "norm_num.bit0_add_bit1_helper", "add_lt_add", "add_left_inj", "ordered_semiring", "lt_add_of_pos_left", "int.lt_iff_le_and_ne", "eq_add_of_add_neg_eq", "neg_le_neg", "le_of_add_le_add_left", "neg_add_le_right_of_le_add", "sub_add_cancel", "add_neg_of_neg_of_nonpos", "sub_sub", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "int.le.intro", "nat.add_sub_add_right", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "nat.bit_decomp", "add_right_cancel_semigroup", "add_neg_self", "add_right_cancel", "neg_add_le_left_of_le_add", "comm_ring", "lt_of_sub_pos", "min_add_add_right", "int.le_trans", "add_group", "linear_ordered_ring", "sub_right_le_of_le_add", "add_comm", "le_sub_left_of_add_le", "sub_sub_assoc_swap", "add_le_of_nonpos_of_le", "min_add_add_left", "add_comm_semigroup_to_is_eq_commutative", "add_neg", "eq_of_add_eq_add_right", "sub_lt_self", "sub_eq_of_eq_add", "sub_sub_sub_cancel_left", "sub_sub_self", "add_right_injective", "sub_eq_of_eq_add'", "norm_num.one_add_bit1", "neg_comm_of_comm", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "nat.sub_one_sub_lt", "add_le_add_three", "norm_num.add1_bit1_helper", "add_neg_cancel_right", "add_pos_of_nonneg_of_pos", "add_group.add_right_cancel", "int.mul_pos", "int.eq_succ_of_zero_lt", "algebra.sub", "eq_sub_of_add_eq", "sub_zero", "nat.mul_mod_right", "neg_le_sub_right_of_le_add", "norm_num.bit0_add_bit0_helper", "eq_neg_iff_add_eq_zero", "norm_num.bit1_add_bit0", "add_le_add_left", "sub_add_sub_cancel", "add_eq_of_eq_add_neg", "lt_add_of_neg_add_lt", "int.eq_coe_of_zero_le", "neg_sub", "int.add_le_add_left", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "add_sub_cancel", "sub_left_lt_of_lt_add", "eq_neg_add_of_add_eq", "add_right_neg", "add_right_comm", "bit1_zero", "nat.bodd_bit", "nat.sub_mul_div", "add_pos", "add_lt_of_lt_sub_right", "add_comm_semigroup", "nat.sub.right_comm", "add_comm_monoid", "norm_num.bin_zero_add", "int.le_total", "lt_add_of_neg_lt_sub_right", "nat.add_mod_left", "add_sub", "nat.test_bit_succ", "add_left_neg", "le_sub_right_of_add_le", "add_nonneg", "nat.sub_sub", "nat.div2_bit", "lt_add_of_pos_of_lt", "ordered_comm_group", "add_lt_add_of_le_of_lt", "add_neg_cancel_left", "add_add_neg_cancel'_right", "nat.le_of_sub_eq_zero", "neg_add_rev", "nat.mul_self_sub_mul_self_eq", "zero_add", "norm_num.bit1_add_bit1", "left_inverse_sub_add_left", "neg_add_cancel_left", "add_lt_add_right", "neg_eq_iff_add_eq_zero", "le_add_of_neg_add_le_right", "add_left_surjective", "add_left_cancel_iff", "lt_sub_right_of_add_lt", "sub_add_eq_add_sub", "add_le_add", "nat.mod_add_div", "field", "max_add_add_right", "eq_sub_iff_add_eq", "sub_self_div_two", "neg_add_lt_left_of_lt_add", "eq_sub_of_add_eq'", "sub_pos_of_lt", "int.to_nat_sub", "ordered_cancel_comm_monoid", "add_right_inj", "distrib_three_right", "sub_nonpos_of_le", "lt_add_of_pos_right", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "lt_add_of_lt_of_pos", "norm_num.pos_add_neg_helper", "decidable_linear_ordered_comm_ring", "eq_neg_of_add_eq_zero", "nat.div_self", "sub_le_self", "lt_of_sub_neg", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "div_sub_div_same", "sub_eq_add_neg", "int.lt.dest", "add_pos_of_pos_of_nonneg", "one_div_add_one_div", "norm_num.neg_add_neg_helper", "add_lt_add_left", "nat.add_mul_mod_self_left", "sub_left_inj", "norm_num.one_add_bit1_helper", "neg_add'", "neg_mul_eq_mul_neg", "norm_num.mul_bit1", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "sub_add_eq_sub_sub", "norm_num.bin_add_zero", "nat.mod_pow_succ", "eq_neg_add_iff_add_eq", "linear_ordered_field", "lt_add_of_sub_left_lt", "sub_eq_neg_add", "sub_eq_sub_add_sub", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "add_left_comm", "nat.le_div_iff_mul_le", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "add_monoid", "add_lt_of_lt_of_neg", "eq_sub_iff_add_eq'", "add_left_cancel", "norm_num.bit0_add_bit0", "ordered_comm_group.le_of_add_le_add_left", "nat.sub_add_cancel", "neg_eq_of_add_eq_zero", "nat.dvd_add_iff_left", "neg_lt_sub_right_of_lt_add", "add_right_cancel_iff", "ordered_ring", "le_of_sub_nonpos", "nat.div_zero", "add_eq_of_eq_neg_add", "le_add_of_nonneg_left", "decidable_linear_ordered_comm_group", "norm_num.one_add_bit0", "le_of_add_le_add_right", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "le_neg_add_of_add_le", "add_group.add_left_cancel", "eq_of_add_eq_add_left", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "add_sub_assoc", "add_neg_eq_zero", "nat.add_sub_add_left", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel", "lt_sub_left_of_add_lt"]}, {"id": "add_lt_add_right", "parentIds": ["lt_add_of_sub_right_lt", "add_lt_add_of_lt_of_le", "sub_right_lt_of_lt_add", "exists_add_lt_and_pos_of_lt", "neg_lt_neg", "add_lt_add", "lt_add_of_pos_left", "lt_of_sub_pos", "sub_left_lt_of_lt_add", "add_lt_of_lt_sub_right", "lt_sub_right_of_add_lt", "sub_pos_of_lt", "lt_of_sub_neg", "sub_lt_sub_right", "lt_add_of_sub_left_lt", "sub_neg_of_lt", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt"]}, {"id": "add_monoid.to_add_semigroup", "parentIds": ["lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "int.neg_succ_of_nat_coe'", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "int.of_nat_ge_zero", "add_lt_add_of_lt_of_le", "max_add_add_left", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "neg_add_self", "eq_add_neg_iff_add_eq", "add_lt_of_lt_of_nonpos", "add_lt_of_lt_neg_add", "add_right_eq_self", "add_lt_of_le_of_neg", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "discrete_field", "div_sub_div", "abs_add_three", "add_nonpos", "bit0_zero", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "add_sub_comm", "le_add_of_sub_left_le", "linear_ordered_semiring", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "functor.add_const.is_lawful_applicative", "add_midpoint", "add_add_sub_cancel", "add_comm_group", "decidable_linear_ordered_semiring", "neg_add_eq_sub", "lt_add_of_le_of_pos", "add_monoid_to_is_right_id", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "sub_add_add_cancel", "le_add_of_le_of_nonneg", "add_sub_cancel'", "add_right_surjective", "add_zero", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "sub_left_le_of_le_add", "add_sub_sub_cancel", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "le_add_of_nonneg_of_le", "add_le_of_le_neg_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "integral_domain", "div_le_div_of_mul_sub_mul_div_nonpos", "add_lt_of_nonpos_of_lt", "div_two_sub_self", "lt_add_of_pos_of_le", "add_neg_eq_iff_eq_add", "lt_of_add_lt_add_right", "decidable_linear_ordered_cancel_comm_monoid", "add_lt_of_neg_of_lt", "eq_add_neg_of_add_eq", "sub_eq_iff_eq_add", "norm_num.add1_zero", "norm_num.subst_into_subtr", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "add_sub_cancel'_right", "lt_add_of_neg_add_lt_left", "neg_lt_neg", "left_inverse_neg_add_add_right", "left_inverse_add_left_sub", "lt_of_add_lt_add_left", "left_inverse_add_right_neg_add", "add_neg_of_nonpos_of_neg", "add_le_add_right", "norm_num.neg_add_pos_eq_of_eq_add", "norm_num.neg_add_pos_helper2", "lt_add_of_nonneg_of_lt", "ring", "neg_add", "int.sub_nat_nat_eq_coe", "nat.add_sub_cancel", "division_ring", "neg_neg_sub_neg", "add_monoid_to_is_left_id", "add_eq_zero_iff_neg_eq", "linear_ordered_comm_ring", "nat.sub_pos_of_lt", "add_self_iff_eq_zero", "int.lt_irrefl", "le_add_of_neg_le_sub_left", "neg_add_eq_iff_eq_add", "lt_add_of_neg_lt_sub_left", "neg_add_cancel_right", "int.add_semigroup", "add_sub_add_right_eq_sub", "nat.mul_div_cancel'", "int.le_antisymm", "add_lt_add", "ordered_semiring", "lt_add_of_pos_left", "int.lt_iff_le_and_ne", "eq_add_of_add_neg_eq", "neg_le_neg", "le_of_add_le_add_left", "neg_add_le_right_of_le_add", "sub_add_cancel", "add_neg_of_neg_of_nonpos", "sub_sub", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "int.le.intro", "nat.add_sub_add_right", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "add_neg_self", "neg_add_le_left_of_le_add", "comm_ring", "lt_of_sub_pos", "min_add_add_right", "add_group", "linear_ordered_ring", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "sub_sub_assoc_swap", "add_le_of_nonpos_of_le", "min_add_add_left", "add_neg", "sub_lt_self", "sub_eq_of_eq_add", "sub_sub_sub_cancel_left", "sub_sub_self", "sub_eq_of_eq_add'", "neg_comm_of_comm", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "add_neg_cancel_right", "add_pos_of_nonneg_of_pos", "add_group.add_right_cancel", "algebra.sub", "eq_sub_of_add_eq", "sub_zero", "nat.mul_mod_right", "neg_le_sub_right_of_le_add", "eq_neg_iff_add_eq_zero", "add_le_add_left", "sub_add_sub_cancel", "add_eq_of_eq_add_neg", "lt_add_of_neg_add_lt", "int.eq_coe_of_zero_le", "neg_sub", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "add_sub_cancel", "sub_left_lt_of_lt_add", "eq_neg_add_of_add_eq", "add_right_neg", "bit1_zero", "nat.sub_mul_div", "add_pos", "add_lt_of_lt_sub_right", "norm_num.bin_zero_add", "int.le_total", "lt_add_of_neg_lt_sub_right", "add_sub", "add_left_neg", "le_sub_right_of_add_le", "add_nonneg", "nat.sub_sub", "nat.div2_bit", "lt_add_of_pos_of_lt", "ordered_comm_group", "add_lt_add_of_le_of_lt", "add_neg_cancel_left", "add_add_neg_cancel'_right", "nat.le_of_sub_eq_zero", "neg_add_rev", "zero_add", "left_inverse_sub_add_left", "neg_add_cancel_left", "add_lt_add_right", "neg_eq_iff_add_eq_zero", "le_add_of_neg_add_le_right", "add_left_surjective", "lt_sub_right_of_add_lt", "sub_add_eq_add_sub", "add_le_add", "field", "max_add_add_right", "eq_sub_iff_add_eq", "sub_self_div_two", "neg_add_lt_left_of_lt_add", "eq_sub_of_add_eq'", "sub_pos_of_lt", "ordered_cancel_comm_monoid", "sub_nonpos_of_le", "lt_add_of_pos_right", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "lt_add_of_lt_of_pos", "norm_num.pos_add_neg_helper", "decidable_linear_ordered_comm_ring", "eq_neg_of_add_eq_zero", "nat.div_self", "sub_le_self", "lt_of_sub_neg", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "div_sub_div_same", "nat.add_semigroup", "sub_eq_add_neg", "add_pos_of_pos_of_nonneg", "norm_num.neg_add_neg_helper", "add_lt_add_left", "neg_add'", "neg_mul_eq_mul_neg", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "sub_add_eq_sub_sub", "norm_num.bin_add_zero", "eq_neg_add_iff_add_eq", "linear_ordered_field", "lt_add_of_sub_left_lt", "sub_eq_neg_add", "sub_eq_sub_add_sub", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "add_lt_of_lt_of_neg", "eq_sub_iff_add_eq'", "ordered_comm_group.le_of_add_le_add_left", "neg_eq_of_add_eq_zero", "neg_lt_sub_right_of_lt_add", "ordered_ring", "le_of_sub_nonpos", "add_eq_of_eq_neg_add", "le_add_of_nonneg_left", "decidable_linear_ordered_comm_group", "le_of_add_le_add_right", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "le_neg_add_of_add_le", "add_group.add_left_cancel", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "add_sub_assoc", "add_neg_eq_zero", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel", "lt_sub_left_of_add_lt"]}, {"id": "add_group_has_sub", "parentIds": ["lt_add_of_sub_right_lt", "sub_lt_sub_of_lt_of_le", "int.neg_succ_of_nat_coe'", "sub_eq_sub_iff_sub_eq_sub", "mul_sub_mul_div_mul_nonpos", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "div_sub_div", "add_sub_comm", "le_add_of_sub_left_le", "abs_sub_le", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "sub_right_comm", "add_midpoint", "add_add_sub_cancel", "neg_add_eq_sub", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "sub_add_add_cancel", "eq_of_mul_eq_mul_right", "add_sub_cancel'", "abs_sub_square", "int.has_sub", "sub_le_sub_left", "sub_left_le_of_le_add", "add_sub_sub_cancel", "sub_eq_zero_of_eq", "ge_of_forall_ge_sub", "exists_add_lt_and_pos_of_lt", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "div_two_sub_self", "sub_ne_zero_of_ne", "sub_eq_iff_eq_add", "norm_num.subst_into_subtr", "neg_sub_neg", "sub_sub_cancel", "add_sub_cancel'_right", "sub_le_of_sub_le", "left_inverse_add_left_sub", "sub_lt_of_abs_sub_lt_right", "neg_neg_sub_neg", "zero_sub", "mul_sub_mul_div_mul_neg", "le_add_of_neg_le_sub_left", "lt_add_of_neg_lt_sub_left", "add_sub_add_right_eq_sub", "sub_add_cancel", "sub_sub", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "mul_sub", "int.le.intro", "neg_le_sub_left_of_le_add", "sub_eq_zero", "lt_of_sub_pos", "sub_right_le_of_le_add", "sub_ne_zero", "le_sub_left_of_add_le", "eq_iff_eq_of_sub_eq_sub", "sub_sub_assoc_swap", "sub_lt_self", "sub_eq_of_eq_add", "sub_sub_sub_cancel_left", "sub_sub_self", "sub_eq_of_eq_add'", "sub_le_sub_right", "le_add_of_sub_right_le", "sub_lt_of_abs_sub_lt_left", "sub_mul", "eq_sub_of_add_eq", "sub_zero", "sub_lt_sub_left", "ordered_ring.mul_le_mul_of_nonneg_right", "neg_le_sub_right_of_le_add", "sub_add_sub_cancel", "int.eq_coe_of_zero_le", "neg_sub", "mul_self_sub_mul_self_eq", "add_sub_cancel", "sub_left_lt_of_lt_add", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "add_lt_of_lt_sub_right", "lt_add_of_neg_lt_sub_right", "add_sub", "mul_sub_right_distrib", "sub_le_of_abs_sub_le_right", "le_sub_right_of_add_le", "dvd_sub", "left_inverse_sub_add_left", "sub_lt_of_sub_lt", "lt_sub_right_of_add_lt", "ordered_ring.mul_lt_mul_of_pos_right", "sub_add_eq_add_sub", "div_lt_div_of_pos_of_lt_of_pos", "eq_of_mul_eq_mul_left", "eq_sub_iff_add_eq", "sub_self_div_two", "eq_of_abs_sub_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_left", "eq_sub_of_add_eq'", "sub_pos_of_lt", "mul_self_eq_mul_self_iff", "dist_bdd_within_interval", "sub_lt_sub_of_le_of_lt", "sub_nonpos_of_le", "sub_le_sub", "sub_sub_sub_cancel_right", "sub_le_self", "lt_of_sub_neg", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "div_sub_div_same", "mul_sub_left_distrib", "sub_eq_add_neg", "sub_left_inj", "abs_sub", "neg_add'", "sub_add_eq_sub_sub", "sub_eq_zero_iff_eq", "lt_add_of_sub_left_lt", "abs_abs_sub_abs_le_abs_sub", "sub_eq_neg_add", "sub_eq_sub_add_sub", "sub_right_inj", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "sub_lt_sub", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'", "ordered_ring.mul_lt_mul_of_pos_left", "sub_self", "neg_lt_sub_right_of_lt_add", "le_of_sub_nonpos", "add_eq_of_eq_sub", "sub_neg_eq_add", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "add_sub_assoc", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt"]}, {"id": "sub_add_cancel", "parentIds": ["lt_add_of_sub_right_lt", "le_add_of_sub_left_le", "sub_add_add_cancel", "left_inverse_add_left_sub", "add_le_of_le_sub_right", "lt_of_sub_pos", "le_add_of_sub_right_le", "sub_add_sub_cancel", "add_lt_of_lt_sub_right", "lt_of_sub_neg", "le_of_sub_nonneg", "lt_add_of_sub_left_lt", "abs_sub_abs_le_abs_sub", "le_of_sub_nonpos"]}, {"id": "ordered_cancel_comm_monoid.to_partial_order", "parentIds": ["lt_add_of_sub_right_lt", "add_lt_add_of_lt_of_le", "nat.lt_add_left", "max_add_add_left", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "add_lt_of_lt_of_nonpos", "nat.div_eq_of_lt", "add_lt_of_lt_neg_add", "add_lt_of_le_of_neg", "nat.pow_le_pow_of_le_left", "sub_right_lt_of_lt_add", "mul_nonpos_of_nonpos_of_nonneg", "add_nonpos", "div_lt_of_mul_lt_of_pos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "le_add_of_sub_left_le", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "neg_add_lt_of_lt_add", "mul_le_mul_of_nonneg_right", "zero_le_one", "decidable_linear_ordered_semiring", "d_array.of_beq_aux_eq_tt", "lt_add_of_le_of_pos", "norm_num.pos_bit1_helper", "le_add_of_le_of_nonneg", "nat.sub_le_sub_left", "list.length_le_of_sublist", "one_le_div_of_le", "sub_left_le_of_le_add", "nonneg_of_mul_nonneg_left", "lt_div_of_mul_lt", "nat.pow_lt_pow_of_lt_right", "exists_add_lt_and_pos_of_lt", "le_add_of_nonneg_of_le", "add_le_of_le_neg_add", "nat.le_mul_self", "add_lt_of_nonpos_of_lt", "one_lt_div_of_lt", "lt_add_of_pos_of_le", "lt_of_add_lt_add_right", "add_lt_of_neg_of_lt", "le_div_of_mul_le", "nat.pow_le_pow_of_le_right", "nat.mod_eq_of_lt", "nat.mul_self_le_mul_self_iff", "lt_of_add_lt_add_left", "add_neg_of_nonpos_of_neg", "add_le_add_right", "mul_lt_mul", "two_gt_one", "lt_add_of_nonneg_of_lt", "lt_of_mul_lt_mul_right", "mul_pos", "nat.div_le_of_le_mul", "nat.sub_pos_of_lt", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "nat.mod_le", "nat.pos_of_dvd_of_pos", "add_lt_add", "pos_of_mul_pos_right", "ordered_semiring", "norm_num.nonneg_bit1_helper", "lt_add_of_pos_left", "nat.zero_mod", "le_of_add_le_add_left", "add_neg_of_neg_of_nonpos", "nat.sub_lt_of_pos_le", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "lt_of_sub_pos", "sub_right_le_of_le_add", "mul_neg_of_neg_of_pos", "le_sub_left_of_add_le", "add_le_of_nonpos_of_le", "min_add_add_left", "add_neg", "le_of_mul_le_mul_right", "d_array.of_beq_aux_eq_ff", "sub_lt_self", "norm_num.nonneg_bit0_helper", "nat.eq_one_of_dvd_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "le_of_mul_le_mul_left", "nat.sub_one_sub_lt", "add_pos_of_nonneg_of_pos", "neg_of_mul_neg_right", "buffer.lt_aux_3", "norm_num.pos_bit0_helper", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "nat.div_lt_self", "nat.mod_zero", "norm_num.nonzero_of_pos_helper", "add_le_add_left", "lt_add_of_neg_add_lt", "nat.div_eq_of_lt_le", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "sub_left_lt_of_lt_add", "nat.sub_mul_div", "add_pos", "add_lt_of_lt_sub_right", "nat.mod_self", "nat.strong_rec_on", "neg_of_mul_neg_left", "le_sub_right_of_add_le", "add_nonneg", "eq_zero_of_mul_self_add_mul_self_eq_zero", "lt_add_of_pos_of_lt", "add_lt_add_of_le_of_lt", "nat.le_of_sub_eq_zero", "mul_neg_of_pos_of_neg", "nat.mul_self_lt_mul_self", "buffer.lt_aux_1", "add_lt_add_right", "nat.pow_lt_pow_of_lt_left", "nat.zero_div", "lt_sub_right_of_add_lt", "add_le_add", "nat.mod_add_div", "d_array.of_beq_eq_tt", "sub_pos_of_lt", "sub_nonpos_of_le", "lt_add_of_pos_right", "mul_nonpos_of_nonneg_of_nonpos", "lt_add_of_lt_of_pos", "sub_le_self", "lt_of_sub_neg", "nat.div_mul_le_self", "le_of_sub_nonneg", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "nonpos_of_mul_nonpos_right", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "nat.eq_of_mul_eq_mul_left", "nat.pred_inj", "mul_nonneg", "nat.lt_add_right", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "mul_lt_mul_of_pos_right", "nonneg_le_nonneg_of_squares_le", "lt_add_of_sub_left_lt", "abs_abs_sub_abs_le_abs_sub", "zero_lt_one", "div_le_of_le_mul", "lt_neg_add_of_add_lt", "nat.le_div_iff_mul_le", "add_lt_of_lt_of_neg", "list.length_remove_nth", "mul_lt_mul'", "le_of_sub_nonpos", "nat.div_zero", "div_two_lt_of_pos", "le_add_of_nonneg_left", "le_of_add_le_add_right", "nat.div_div_eq_div_mul", "mul_self_le_mul_self", "sub_neg_of_lt", "le_neg_add_of_add_le", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_lt_of_lt_sub_left", "nat.succ_pred_eq_of_pos", "mul_le_mul", "nat.dvd_antisymm", "lt_sub_left_of_add_lt"]}, {"id": "has_add", "parentIds": ["lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "int.add_one_le_of_lt", "int.decidable_lt", "int.neg_succ_of_nat_coe'", "nat.eq_zero_of_add_eq_zero", "comm_semiring", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "int.of_nat_ge_zero", "add_lt_add_of_lt_of_le", "int.lt_of_add_one_le", "nat.lt_add_left", "parser.sat", "one_add_one_eq_two", "max_add_add_left", "int.add_comm", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "norm_num.add_comm_four", "neg_add_self", "eq_add_neg_iff_add_eq", "add_lt_of_lt_of_nonpos", "int.le.dest", "nat.div_eq_of_lt", "norm_num.bit0_add_bit1", "add_lt_of_lt_neg_add", "add_right_eq_self", "add_lt_of_le_of_neg", "add_eq_of_eq_sub'", "nat.add_right_cancel", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "ring.mul_zero", "discrete_field", "norm_num.mul_bit0", "div_sub_div", "int.coe_nat_add_out", "int.has_add", "nat.shiftl'_add", "nat.add_mul_mod_self_right", "int.lt.intro", "int.le_of_lt_add_one", "abs_add_three", "add_assoc", "two_mul", "nat.add_one_ne_zero", "norm_num.mul_bit0_helper", "add_nonpos", "list.length_cons", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "add_sub_comm", "le_add_of_sub_left_le", "nat.succ_eq_add_one", "nat.eq_zero_of_add_eq_zero_left", "nat.succ_sub_sub_succ", "array.push_back_idx", "linear_ordered_semiring", "norm_num.add1_bit1", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "functor.add_const.is_lawful_applicative", "native.rb_map.add", "print_arguments", "int.add_assoc", "add_midpoint", "int.le_of_coe_nat_le_coe_nat", "norm_num.bit1_add_one_helper", "right_distrib", "add_add_sub_cancel", "nat.le_add_left", "norm_num.bit1_add_one", "add_comm_group", "decidable_linear_ordered_semiring", "nat.lt_or_ge", "neg_add_eq_sub", "d_array.of_beq_aux_eq_tt", "lt_add_of_le_of_pos", "add_monoid_to_is_right_id", "norm_num.pos_bit1_helper", "nat.div_def", "norm_num.mul_bit1_helper", "nat.sub_eq_zero_of_le", "eq_zero_of_mul_eq_self_right", "add_left_cancel_semigroup", "nat_add_zero", "eq_of_sub_eq_zero", "sub_add_add_cancel", "nat.sub_sub_self", "nat.add_div_left", "nat.bodd_add_div2", "le_add_of_le_of_nonneg", "add_sub_cancel'", "nat.succ_mul_succ_eq", "nat.add_mul_div_right", "nat.bodd_add", "parser.foldl", "add_right_surjective", "add_zero", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "nat.add_le_add_iff_le_right", "norm_num.subst_into_sum", "sub_left_le_of_le_add", "dvd_add_iff_right", "add_sub_sub_cancel", "list.length_append", "ge_of_forall_ge_sub", "nat.bit0_val", "string.iterator.length_next_to_string_next", "exists_add_lt_and_pos_of_lt", "int.lt.elim", "int.add_zero", "tactic.elim_gen_sum", "nat.zero_lt_one_add", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "le_add_of_nonneg_of_le", "nat.add_right_comm", "add_le_of_le_neg_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.le_mul_self", "integral_domain", "nat.lt_add_of_pos_left", "int.distrib_right", "nat.mul_div_right", "norm_num.add_comm_middle", "nat.shiftr_eq_div_pow", "semiring", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "add_lt_of_nonpos_of_lt", "native.float.has_add", "div_two_sub_self", "lt_add_of_pos_of_le", "add_neg_eq_iff_eq_add", "int.lt_succ", "int.nat_abs_add_neg", "int.sub_nat_nat_elim", "lt_of_add_lt_add_right", "int.mk_numeral", "decidable_linear_ordered_cancel_comm_monoid", "nat.mod_two_of_bodd", "add_lt_of_neg_of_lt", "eq_add_neg_of_add_eq", "sub_eq_iff_eq_add", "int.lt_add_succ", "norm_num.add1_zero", "localized_cmd", "nat.add_mul_div_left", "norm_num.subst_into_subtr", "int.nat_abs_add_nonneg", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "nat.add_self_ne_one", "nat.sub_eq_iff_eq_add", "list.length_map", "char.to_lower", "nat.sub_mul_mod", "nat.div_def_aux", "nat.mul_assoc", "add_sub_cancel'_right", "lt_add_of_neg_add_lt_left", "nat.zero_mul", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "parser.foldr", "neg_lt_neg", "left_inverse_neg_add_add_right", "nat.add_comm", "norm_num.bit1_add_bit0_helper", "string.hash", "left_inverse_add_left_sub", "nat.add_succ", "lt_of_add_lt_add_left", "add_left_injective", "int.add_left_neg", "left_inverse_add_right_neg_add", "add_neg_of_nonpos_of_neg", "add_le_add_right", "nat.shiftl'_sub", "norm_num.neg_add_pos_eq_of_eq_add", "two_gt_one", "add_mul_self_eq", "norm_num.neg_add_pos_helper2", "lt_add_of_nonneg_of_lt", "add_add_add_comm", "ring", "int.coe_nat_lt_coe_nat_iff", "neg_add", "nat.mul_le_mul_left", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "nat.add_sub_cancel", "division_ring", "neg_neg_sub_neg", "int.of_nat_sub", "add_monoid_to_is_left_id", "nat.div_le_of_le_mul", "add_eq_zero_iff_neg_eq", "nat.lt_add_of_pos_right", "linear_ordered_comm_ring", "nat.sub_pos_of_lt", "add_self_iff_eq_zero", "add_div_eq_mul_add_div", "nat.bodd_mul", "int.distrib_left", "fin.has_add", "int.lt_irrefl", "int.add_lt_add_left", "le_add_of_neg_le_sub_left", "neg_add_eq_iff_eq_add", "lt_add_of_neg_lt_sub_left", "nat.mk_numeral", "neg_add_cancel_right", "nat.add_le_add_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "add_semigroup_to_is_eq_associative", "nat.has_add", "nat.eq_zero_of_mul_eq_zero", "add_sub_add_right_eq_sub", "array.pop_back_idx", "int.coe_nat_add_one_out", "nat.mul_div_cancel'", "int.le_antisymm", "norm_num.bit0_add_bit1_helper", "add_lt_add", "add_left_inj", "nat.lt_add_of_zero_lt_left", "ordered_semiring", "lt_add_of_pos_left", "int.lt_iff_le_and_ne", "eq_add_of_add_neg_eq", "neg_le_neg", "nat.add_left_cancel", "left_distrib", "le_of_add_le_add_left", "neg_add_le_right_of_le_add", "norm_num.div_add_helper", "sub_add_cancel", "add_neg_of_neg_of_nonpos", "sub_sub", "add_le_of_le_sub_left", "add_semigroup.to_has_add", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "nat.add_mod_right", "int.le.intro", "nat.add_sub_add_right", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "nat.bit_decomp", "nat.le_of_add_le_add_right", "nat.add_sub_cancel_left", "add_right_cancel_semigroup", "add_neg_self", "add_right_cancel", "neg_add_le_left_of_le_add", "comm_ring", "int.coe_nat_add", "nat.shiftr_add", "lt_of_sub_pos", "min_add_add_right", "int.le_trans", "list.length_take", "fin.add_def", "nat.mul_pred_left", "add_group", "linear_ordered_ring", "sub_right_le_of_le_add", "add_comm", "le_sub_left_of_add_le", "sub_sub_assoc_swap", "add_le_of_nonpos_of_le", "min_add_add_left", "nat.dvd_add_iff_right", "tactic.mllist.range", "add_comm_semigroup_to_is_eq_commutative", "bit0", "std.prec.max_plus", "add_neg", "nat.dvd_mod_iff", "nat.dvd_sub", "eq_of_add_eq_add_right", "d_array.of_beq_aux_eq_ff", "distrib", "sub_lt_self", "sub_eq_of_eq_add", "norm_num.nonneg_bit0_helper", "sub_sub_sub_cancel_left", "int.nat_abs_bit0", "sub_sub_self", "nat.case_strong_induction_on", "add_right_injective", "sub_eq_of_eq_add'", "nat.le.intro", "norm_num.one_add_bit1", "neg_comm_of_comm", "nat.sub_self_add", "le_add_of_neg_add_le", "nat.mul_lt_mul_of_pos_left", "le_add_of_sub_right_le", "nat.sub_one_sub_lt", "add_le_add_three", "nat.succ_add", "norm_num.add1_bit1_helper", "expr.of_int", "add_neg_cancel_right", "add_pos_of_nonneg_of_pos", "add_group.add_right_cancel", "add_mul", "nat.add_lt_add_right", "sub_lt_of_abs_sub_lt_left", "nat.le_add_right", "int.zero_add", "buffer.lt_aux_3", "norm_num.add_div_helper", "norm_num.pos_bit0_helper", "int.mul_pos", "int.eq_succ_of_zero_lt", "nat.add_zero", "algebra.sub", "eq_sub_of_add_eq", "nat.add_div_right", "sub_zero", "add_succ_defeq_succ_add_hint", "nat.mul_mod_right", "neg_le_sub_right_of_le_add", "nat.mul_succ", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "nat.one_add", "nat.bit1_val", "add_self_div_two", "eq_neg_iff_add_eq_zero", "int.coe_nat_succ", "norm_num.bit1_add_bit0", "add_le_add_left", "list.sum", "sub_add_sub_cancel", "add_eq_of_eq_add_neg", "lt_add_of_neg_add_lt", "int.eq_coe_of_zero_le", "neg_sub", "int.nat_abs_bit1_nonneg", "int.add_le_add_left", "nat.le.dest", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "options.has_add", "mul_self_sub_mul_self_eq", "add_sub_cancel", "nat.bit0_succ_eq", "sub_left_lt_of_lt_add", "eq_neg_add_of_add_eq", "add_right_neg", "nat.bit0_ne_one", "add_right_comm", "nat.sub_add_comm", "nat.succ_sub", "bit1_zero", "nat.bodd_bit", "nat.sub_mul_div", "add_pos", "add_lt_of_lt_sub_right", "int.neg_succ_of_nat_coe", "add_comm_semigroup", "nat.sub.right_comm", "nat.left_distrib", "int.neg_succ_of_nat_eq", "nat.shiftl_succ", "int.coe_nat_le_coe_nat_of_le", "add_comm_monoid", "norm_num.bin_zero_add", "norm_num.sub_nat_pos_helper", "int.sign_mul_nat_abs", "int.le_total", "lt_add_of_neg_lt_sub_right", "nat.add_mod_left", "nat.right_distrib", "add_sub", "nat.test_bit_succ", "mul_sub_right_distrib", "int.pos_of_sign_eq_one", "add_left_neg", "le_sub_right_of_add_le", "add_nonneg", "eq_zero_of_mul_self_add_mul_self_eq_zero", "nat.sub_sub", "nat.lt_of_add_lt_add_left", "nat.div2_bit", "lt_add_of_pos_of_lt", "nat.prio", "dvd_add", "ordered_comm_group", "nat.mul_sub_right_distrib", "add_lt_add_of_le_of_lt", "nat.sub_add_min_cancel", "add_neg_cancel_left", "nat.add_le_add_left", "add_add_neg_cancel'_right", "nat.le_of_sub_eq_zero", "nat.succ_ne_self", "nat.add_one", "int.neg_of_sign_eq_neg_one", "neg_add_rev", "nat.mul_self_sub_mul_self_eq", "zero_add", "array.pop_back", "norm_num.bit1_add_bit1", "left_inverse_sub_add_left", "buffer.lt_aux_1", "neg_add_cancel_left", "add_lt_add_right", "neg_eq_iff_add_eq_zero", "nat.bit_val", "nat.div_eq_sub_div", "le_add_of_neg_add_le_right", "add_left_surjective", "nat.dvd_of_mod_eq_zero", "norm_num.one_add_one", "add_left_cancel_iff", "nat.zero_div", "parser.fix", "lt_sub_right_of_add_lt", "sub_add_eq_add_sub", "add_le_add", "nat.shiftl_add", "conv.interactive.for", "nat.mod_add_div", "field", "max_add_add_right", "eq_sub_iff_add_eq", "div_add_div_same", "sub_self_div_two", "distrib.to_has_add", "unsigned.has_add", "neg_add_lt_left_of_lt_add", "two_pos", "eq_sub_of_add_eq'", "sub_pos_of_lt", "int.mul_nonneg", "int.to_nat_sub", "int.le.elim", "mul_self_eq_mul_self_iff", "nat.bit1_ne_zero", "ordered_cancel_comm_monoid", "int.of_nat_add", "add_halves", "add_right_inj", "distrib_three_right", "array.push_back", "sub_nonpos_of_le", "lt_add_of_pos_right", "nat.succ_mul", "list.length_map\u2082", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "nat.le_of_add_le_add_left", "lt_add_of_lt_of_pos", "norm_num.pos_add_neg_helper", "decidable_linear_ordered_comm_ring", "eq_neg_of_add_eq_zero", "nat.div_self", "sub_le_self", "lt_of_sub_neg", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "nat.bit1_ne_one", "int.lt_add_one_of_le", "int.of_nat_succ", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "div_sub_div_same", "nat.mod_two_eq_zero_or_one", "mul_sub_left_distrib", "sub_eq_add_neg", "nat.mul_comm", "int.lt.dest", "add_pos_of_pos_of_nonneg", "one_div_add_one_div", "norm_num.neg_add_neg_helper", "nat.sub_lt", "add_lt_add_left", "nat.add_mul_mod_self_left", "sub_left_inj", "norm_num.one_add_bit1_helper", "neg_add'", "neg_mul_eq_mul_neg", "nat.lt_add_right", "bit1", "norm_num.mul_bit1", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "sub_add_eq_sub_sub", "norm_num.bin_add_zero", "nat.add_left_comm", "nat.mod_pow_succ", "functor.add_const.applicative", "eq_neg_add_iff_add_eq", "linear_ordered_field", "nat.add_lt_add_left", "norm_num.add1_one", "lt_add_of_sub_left_lt", "abs_abs_sub_abs_le_abs_sub", "int.lt_iff_add_one_le", "tactic.interactive.case", "sub_eq_neg_add", "sub_eq_sub_add_sub", "list.func.add", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "nat.bit0_ne_zero", "nat.add_sub_of_le", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "add_left_comm", "nat.le_div_iff_mul_le", "norm_num.bit0_add_one", "sub_add_sub_cancel'", "sub_add", "list.length_repeat", "sub_eq_iff_eq_add'", "add_monoid", "nat.add_le_to_le_sub", "add_lt_of_lt_of_neg", "int.le_of_lt", "eq_sub_iff_add_eq'", "add_left_cancel", "list.length_remove_nth", "ring.zero_mul", "norm_num.bit0_add_bit0", "nat.zero_add", "ordered_comm_group.le_of_add_le_add_left", "nat.sub_add_cancel", "neg_eq_of_add_eq_zero", "nat.dvd_add_iff_left", "neg_lt_sub_right_of_lt_add", "add_right_cancel_iff", "nat.bit1_lt_bit0", "ordered_ring", "div_add_div", "le_of_sub_nonpos", "nat.shiftl'_tt_eq_mul_pow", "nat.div_zero", "div_two_lt_of_pos", "add_eq_of_eq_neg_add", "le_add_of_nonneg_left", "decidable_linear_ordered_comm_group", "norm_num.one_add_bit0", "le_of_add_le_add_right", "int.lt", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "nat.find_x", "norm_num.add1_bit0", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "le_neg_add_of_add_le", "add_group.add_left_cancel", "eq_of_add_eq_add_left", "nat.div_one", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "add_sub_assoc", "add_neg_eq_zero", "nat.add_assoc", "nat.add_sub_add_left", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel", "nat.eq_zero_of_add_eq_zero_right", "norm_num.add1", "lt_sub_left_of_add_lt", "add_semigroup", "mul_add"]}, {"id": "add_comm_monoid.to_add_monoid", "parentIds": ["lt_add_of_sub_right_lt", "add_lt_add_of_lt_of_le", "max_add_add_left", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "add_lt_of_lt_of_nonpos", "add_lt_of_lt_neg_add", "add_lt_of_le_of_neg", "sub_right_lt_of_lt_add", "abs_add_three", "add_nonpos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "le_add_of_sub_left_le", "linear_ordered_semiring", "neg_add_lt_of_lt_add", "decidable_linear_ordered_semiring", "lt_add_of_le_of_pos", "le_add_of_le_of_nonneg", "sub_left_le_of_le_add", "exists_add_lt_and_pos_of_lt", "le_add_of_nonneg_of_le", "add_le_of_le_neg_add", "add_lt_of_nonpos_of_lt", "lt_add_of_pos_of_le", "lt_of_add_lt_add_right", "decidable_linear_ordered_cancel_comm_monoid", "add_lt_of_neg_of_lt", "nat.bit0_inj", "lt_of_add_lt_add_left", "add_neg_of_nonpos_of_neg", "add_le_add_right", "lt_add_of_nonneg_of_lt", "add_lt_add", "ordered_semiring", "lt_add_of_pos_left", "le_of_add_le_add_left", "add_neg_of_neg_of_nonpos", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "nat.add_monoid", "lt_of_sub_pos", "min_add_add_right", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "add_le_of_nonpos_of_le", "min_add_add_left", "add_neg", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "add_pos_of_nonneg_of_pos", "add_le_add_left", "lt_add_of_neg_add_lt", "sub_left_lt_of_lt_add", "nat.sub_mul_div", "add_pos", "add_lt_of_lt_sub_right", "le_sub_right_of_add_le", "add_nonneg", "lt_add_of_pos_of_lt", "add_lt_add_of_le_of_lt", "nat.le_of_sub_eq_zero", "add_lt_add_right", "lt_sub_right_of_add_lt", "add_le_add", "max_add_add_right", "sub_pos_of_lt", "ordered_cancel_comm_monoid", "sub_nonpos_of_le", "lt_add_of_pos_right", "lt_add_of_lt_of_pos", "lt_of_sub_neg", "le_of_sub_nonneg", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "lt_add_of_sub_left_lt", "lt_neg_add_of_add_lt", "add_lt_of_lt_of_neg", "le_of_sub_nonpos", "le_add_of_nonneg_left", "le_of_add_le_add_right", "sub_neg_of_lt", "le_neg_add_of_add_le", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_lt_of_lt_sub_left", "lt_sub_left_of_add_lt"]}, {"id": "ordered_comm_group.to_partial_order", "parentIds": ["lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "sub_lt_sub_of_lt_of_le", "lt_of_one_div_lt_one_div", "le_mul_of_div_le", "neg_add_le_of_le_add", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "mul_lt_mul_of_neg_left", "add_lt_of_lt_neg_add", "one_div_pos_of_pos", "sub_right_lt_of_lt_add", "div_pos_of_neg_of_neg", "abs_add_three", "div_lt_of_mul_lt_of_pos", "le_add_of_sub_left_le", "abs_of_pos", "abs_pos_of_ne_zero", "mul_nonneg_of_nonpos_of_nonpos", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "int.neg_ne_of_pos", "add_midpoint", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "neg_le_abs_self", "one_div_le_of_one_div_le_of_neg", "ordered_comm_group.lt_of_add_lt_add_left", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "sub_le_sub_left", "sub_left_le_of_le_add", "int.zero_nonneg", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "add_le_of_le_neg_add", "le_neg_of_le_neg", "le_of_neg_le_neg", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "int.nat_abs_add_nonneg", "le_div_of_mul_le", "lt_add_of_neg_add_lt_left", "sub_le_of_sub_le", "neg_lt_neg", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "sub_lt_of_abs_sub_lt_right", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "int.of_nat_nat_abs_eq_of_nonneg", "mul_self_le_mul_self_iff", "le_add_of_neg_le_sub_left", "lt_add_of_neg_lt_sub_left", "abs_nonneg", "lt_of_one_lt_div", "neg_le_neg", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "neg_add_le_right_of_le_add", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "neg_le_sub_left_of_le_add", "abs_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "neg_add_le_left_of_le_add", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "lt_of_sub_pos", "linear_ordered_ring", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "mul_pos_of_neg_of_neg", "int.eq_neg_succ_of_lt_zero", "neg_of_neg_pos", "eq_zero_of_neg_eq", "sub_lt_self", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "sub_le_sub_right", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "div_mul_le_div_mul_of_div_le_div_pos'", "add_le_add_three", "neg_nonpos_of_nonneg", "sub_lt_of_abs_sub_lt_left", "div_lt_div_of_lt_of_neg", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "sub_lt_sub_left", "div_pos_of_pos_of_pos", "eq_zero_of_abs_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "abs_zero", "neg_le_sub_right_of_le_add", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "lt_add_of_neg_add_lt", "gt_of_mul_lt_mul_neg_left", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "sub_left_lt_of_lt_add", "neg_pos_of_neg", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "add_lt_of_lt_sub_right", "div_nonpos_of_nonneg_of_neg", "abs_pos_of_neg", "le_abs_self", "lt_add_of_neg_lt_sub_right", "abs_of_nonneg", "sub_le_of_abs_sub_le_right", "lt_neg_of_lt_neg", "le_sub_right_of_add_le", "eq_zero_of_mul_self_add_mul_self_eq_zero", "neg_lt_of_neg_lt", "mul_lt_of_lt_div", "le_add_of_neg_add_le_right", "sub_lt_of_sub_lt", "lt_sub_right_of_add_lt", "ordered_ring.mul_lt_mul_of_pos_right", "div_lt_div_of_pos_of_lt_of_pos", "abs_pos_of_pos", "nonpos_of_neg_nonneg", "two_ge_one", "ordered_ring.mul_le_mul_of_nonneg_left", "neg_add_lt_left_of_lt_add", "two_pos", "lt_of_neg_lt_neg", "sub_pos_of_lt", "one_div_le_one_div_of_le", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "pos_of_neg_neg", "sub_lt_sub_of_le_of_lt", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "sub_nonpos_of_le", "sub_le_sub", "decidable_linear_ordered_comm_ring", "sub_le_self", "lt_of_sub_neg", "le_of_sub_nonneg", "mul_self_nonneg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "abs_lt_of_lt_of_neg_lt", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "nonneg_le_nonneg_of_squares_le", "linear_ordered_field", "lt_add_of_sub_left_lt", "abs_abs_sub_abs_le_abs_sub", "div_le_of_le_mul", "abs_sub_abs_le_abs_sub", "nonneg_of_neg_nonpos", "lt_neg_add_of_add_lt", "sub_lt_sub", "int.le_nat_abs", "le_of_one_le_div", "neg_nonneg_of_nonpos", "ordered_ring.mul_lt_mul_of_pos_left", "ordered_comm_group.le_of_add_le_add_left", "div_neg_of_neg_of_pos", "neg_lt_sub_right_of_lt_add", "ordered_ring", "pos_and_pos_or_neg_and_neg_of_mul_pos", "le_of_sub_nonpos", "four_pos", "div_two_lt_of_pos", "max_neg_neg", "one_lt_one_div", "sub_neg_of_lt", "le_neg_add_of_add_le", "neg_neg_of_pos", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "one_div_le_neg_one", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt", "neg_le_of_neg_le", "mul_le_mul_of_nonpos_right"]}, {"id": "ordered_comm_group.to_ordered_cancel_comm_monoid", "parentIds": ["lt_add_of_sub_right_lt", "sub_lt_sub_of_lt_of_le", "neg_add_le_of_le_add", "add_lt_of_lt_neg_add", "sub_right_lt_of_lt_add", "abs_add_three", "le_add_of_sub_left_le", "neg_add_lt_of_lt_add", "sub_le_sub_left", "sub_left_le_of_le_add", "add_le_of_le_neg_add", "lt_add_of_neg_add_lt_left", "neg_lt_neg", "neg_le_neg", "neg_add_le_right_of_le_add", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "neg_le_sub_left_of_le_add", "neg_add_le_left_of_le_add", "lt_of_sub_pos", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "sub_lt_self", "sub_le_sub_right", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "sub_lt_sub_left", "lt_add_of_neg_add_lt", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "sub_left_lt_of_lt_add", "add_lt_of_lt_sub_right", "le_sub_right_of_add_le", "le_add_of_neg_add_le_right", "lt_sub_right_of_add_lt", "neg_add_lt_left_of_lt_add", "sub_pos_of_lt", "sub_lt_sub_of_le_of_lt", "sub_nonpos_of_le", "sub_le_sub", "sub_le_self", "lt_of_sub_neg", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "lt_add_of_sub_left_lt", "abs_sub_abs_le_abs_sub", "lt_neg_add_of_add_lt", "sub_lt_sub", "le_of_sub_nonpos", "sub_neg_of_lt", "le_neg_add_of_add_le", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "lt_sub_left_of_add_lt"]}, {"id": "ordered_cancel_comm_monoid.to_add_comm_monoid", "parentIds": ["lt_add_of_sub_right_lt", "add_lt_add_of_lt_of_le", "max_add_add_left", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "add_lt_of_lt_of_nonpos", "add_lt_of_lt_neg_add", "add_lt_of_le_of_neg", "sub_right_lt_of_lt_add", "abs_add_three", "add_nonpos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "le_add_of_sub_left_le", "neg_add_lt_of_lt_add", "lt_add_of_le_of_pos", "le_add_of_le_of_nonneg", "sub_left_le_of_le_add", "exists_add_lt_and_pos_of_lt", "le_add_of_nonneg_of_le", "add_le_of_le_neg_add", "add_lt_of_nonpos_of_lt", "lt_add_of_pos_of_le", "lt_of_add_lt_add_right", "add_lt_of_neg_of_lt", "lt_add_of_neg_add_lt_left", "lt_of_add_lt_add_left", "add_neg_of_nonpos_of_neg", "add_le_add_right", "lt_add_of_nonneg_of_lt", "add_lt_add", "lt_add_of_pos_left", "le_of_add_le_add_left", "neg_add_le_right_of_le_add", "add_neg_of_neg_of_nonpos", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "neg_le_sub_left_of_le_add", "neg_add_le_left_of_le_add", "lt_of_sub_pos", "min_add_add_right", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "add_le_of_nonpos_of_le", "min_add_add_left", "add_neg", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "add_pos_of_nonneg_of_pos", "add_le_add_left", "lt_add_of_neg_add_lt", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "sub_left_lt_of_lt_add", "nat.sub_mul_div", "add_pos", "add_lt_of_lt_sub_right", "le_sub_right_of_add_le", "add_nonneg", "lt_add_of_pos_of_lt", "add_lt_add_of_le_of_lt", "nat.le_of_sub_eq_zero", "add_lt_add_right", "le_add_of_neg_add_le_right", "lt_sub_right_of_add_lt", "add_le_add", "max_add_add_right", "neg_add_lt_left_of_lt_add", "sub_pos_of_lt", "sub_nonpos_of_le", "lt_add_of_pos_right", "lt_add_of_lt_of_pos", "lt_of_sub_neg", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "lt_add_of_sub_left_lt", "lt_neg_add_of_add_lt", "add_lt_of_lt_of_neg", "le_of_sub_nonpos", "le_add_of_nonneg_left", "le_of_add_le_add_right", "sub_neg_of_lt", "le_neg_add_of_add_le", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "lt_sub_left_of_add_lt"]}, {"id": "add_group.to_add_monoid", "parentIds": ["lt_add_of_sub_right_lt", "abs_add_le_abs_add_abs", "int.neg_succ_of_nat_coe'", "add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "neg_add_le_of_le_add", "neg_add_self", "eq_add_neg_iff_add_eq", "mul_sub_mul_div_mul_nonpos", "add_lt_of_lt_neg_add", "add_right_eq_self", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "sub_right_lt_of_lt_add", "ring.mul_zero", "div_sub_div", "abs_add_three", "add_sub_comm", "le_add_of_sub_left_le", "abs_of_pos", "abs_pos_of_ne_zero", "abs_sub_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "add_sub_add_left_eq_sub", "add_midpoint", "add_add_sub_cancel", "neg_add_eq_sub", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "sub_add_add_cancel", "add_sub_cancel'", "add_right_surjective", "abs_sub_square", "ordered_comm_group.lt_of_add_lt_add_left", "sub_left_le_of_le_add", "add_sub_sub_cancel", "sub_eq_zero_of_eq", "int.neg_ne_zero_of_ne", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "add_le_of_le_neg_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "div_two_sub_self", "add_neg_eq_iff_eq_add", "sub_ne_zero_of_ne", "eq_add_neg_of_add_eq", "sub_eq_iff_eq_add", "norm_num.subst_into_subtr", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "add_sub_cancel'_right", "lt_add_of_neg_add_lt_left", "neg_lt_neg", "left_inverse_neg_add_add_right", "left_inverse_add_left_sub", "left_inverse_add_right_neg_add", "norm_num.neg_add_pos_eq_of_eq_add", "two_gt_one", "norm_num.neg_add_pos_helper2", "neg_add", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "zero_sub", "add_eq_zero_iff_neg_eq", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "norm_num.neg_zero_helper", "add_self_iff_eq_zero", "le_add_of_neg_le_sub_left", "neg_add_eq_iff_eq_add", "lt_add_of_neg_lt_sub_left", "neg_add_cancel_right", "add_sub_add_right_eq_sub", "abs_nonneg", "eq_add_of_add_neg_eq", "neg_le_neg", "neg_add_le_right_of_le_add", "sub_add_cancel", "sub_sub", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "int.le.intro", "add_eq_zero_iff_eq_neg", "neg_le_sub_left_of_le_add", "abs_of_neg", "sub_eq_zero", "add_neg_self", "neg_add_le_left_of_le_add", "lt_of_sub_pos", "linear_ordered_ring", "sub_right_le_of_le_add", "sub_ne_zero", "le_sub_left_of_add_le", "eq_iff_eq_of_sub_eq_sub", "sub_sub_assoc_swap", "neg_of_neg_pos", "eq_zero_of_neg_eq", "sub_lt_self", "sub_eq_of_eq_add", "sub_sub_sub_cancel_left", "int.abs_eq_nat_abs", "sub_sub_self", "sub_eq_of_eq_add'", "neg_comm_of_comm", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "neg_nonpos_of_nonneg", "add_neg_cancel_right", "add_group.add_right_cancel", "sub_lt_of_abs_sub_lt_left", "algebra.sub", "int.add_monoid", "eq_sub_of_add_eq", "sub_zero", "eq_zero_of_abs_eq_zero", "norm_num.nonzero_of_neg_helper", "abs_zero", "neg_le_sub_right_of_le_add", "eq_neg_iff_add_eq_zero", "sub_add_sub_cancel", "add_eq_of_eq_add_neg", "lt_add_of_neg_add_lt", "one_div_neg_eq_neg_one_div", "int.eq_coe_of_zero_le", "neg_sub", "ne_zero_of_abs_ne_zero", "abs_div", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "add_sub_cancel", "sub_left_lt_of_lt_add", "eq_neg_add_of_add_eq", "add_right_neg", "neg_pos_of_neg", "zero_gt_neg_one", "add_lt_of_lt_sub_right", "abs_pos_of_neg", "le_abs_self", "int.le_total", "lt_add_of_neg_lt_sub_right", "add_sub", "abs_of_nonneg", "add_left_neg", "le_sub_right_of_add_le", "ordered_comm_group", "add_neg_cancel_left", "add_add_neg_cancel'_right", "abs_by_cases", "neg_add_rev", "left_inverse_sub_add_left", "neg_add_cancel_left", "neg_eq_iff_add_eq_zero", "le_add_of_neg_add_le_right", "add_left_surjective", "neg_eq_zero", "lt_sub_right_of_add_lt", "sub_add_eq_add_sub", "div_lt_div_of_pos_of_lt_of_pos", "neg_ne_zero", "eq_sub_iff_add_eq", "sub_self_div_two", "abs_pos_of_pos", "eq_of_abs_sub_eq_zero", "nonpos_of_neg_nonneg", "neg_add_lt_left_of_lt_add", "eq_sub_of_add_eq'", "sub_pos_of_lt", "mul_self_eq_mul_self_iff", "pos_of_neg_neg", "neg_div_neg_eq", "sub_nonpos_of_le", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "norm_num.pos_add_neg_helper", "decidable_linear_ordered_comm_ring", "eq_neg_of_add_eq_zero", "sub_le_self", "lt_of_sub_neg", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "div_sub_div_same", "sub_eq_add_neg", "norm_num.neg_add_neg_helper", "neg_add'", "neg_mul_eq_mul_neg", "sub_add_eq_sub_sub", "sub_eq_zero_iff_eq", "eq_neg_add_iff_add_eq", "linear_ordered_field", "lt_add_of_sub_left_lt", "sub_eq_neg_add", "sub_eq_sub_add_sub", "dvd_add_iff_left", "abs_sub_abs_le_abs_sub", "nonneg_of_neg_nonpos", "int.neg_succ_of_nat_lt_zero", "lt_neg_add_of_add_lt", "sub_add_sub_cancel'", "sub_add", "neg_nonneg_of_nonpos", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'", "ring.zero_mul", "ordered_comm_group.le_of_add_le_add_left", "neg_eq_of_add_eq_zero", "sub_self", "neg_lt_sub_right_of_lt_add", "ordered_ring", "le_of_sub_nonpos", "add_eq_of_eq_neg_add", "neg_zero", "decidable_linear_ordered_comm_group", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "sub_neg_of_lt", "sub_add_eq_sub_sub_swap", "le_neg_add_of_add_le", "add_group.add_left_cancel", "neg_neg_of_pos", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "add_sub_assoc", "add_neg_eq_zero", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "lt_sub_left_of_add_lt"]}, {"id": "ordered_comm_group", "parentIds": ["lt_add_of_sub_right_lt", "sub_lt_sub_of_lt_of_le", "neg_add_le_of_le_add", "add_lt_of_lt_neg_add", "sub_right_lt_of_lt_add", "le_add_of_sub_left_le", "neg_add_lt_of_lt_add", "le_add_of_neg_le_sub_right", "decidable_linear_ordered_comm_group.to_ordered_comm_group", "ordered_comm_group.to_add_comm_group", "ordered_comm_group.lt_of_add_lt_add_left", "sub_le_sub_left", "sub_left_le_of_le_add", "add_le_of_le_neg_add", "ordered_ring.to_ordered_comm_group", "le_neg_of_le_neg", "le_of_neg_le_neg", "lt_add_of_neg_add_lt_left", "sub_le_of_sub_le", "neg_lt_neg", "linear_ordered_comm_ring", "le_add_of_neg_le_sub_left", "lt_add_of_neg_lt_sub_left", "neg_le_neg", "neg_add_le_right_of_le_add", "add_le_of_le_sub_left", "add_le_of_le_sub_right", "discrete_linear_ordered_field", "neg_le_sub_left_of_le_add", "neg_add_le_left_of_le_add", "lt_of_sub_pos", "linear_ordered_ring", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "neg_of_neg_pos", "sub_lt_self", "sub_le_sub_right", "le_add_of_neg_add_le", "le_add_of_sub_right_le", "add_le_add_three", "neg_nonpos_of_nonneg", "sub_lt_sub_left", "neg_le_sub_right_of_le_add", "lt_add_of_neg_add_lt", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "sub_left_lt_of_lt_add", "neg_pos_of_neg", "add_lt_of_lt_sub_right", "lt_add_of_neg_lt_sub_right", "lt_neg_of_lt_neg", "le_sub_right_of_add_le", "neg_lt_of_neg_lt", "ordered_comm_group.to_partial_order", "le_add_of_neg_add_le_right", "sub_lt_of_sub_lt", "lt_sub_right_of_add_lt", "nonpos_of_neg_nonneg", "neg_add_lt_left_of_lt_add", "lt_of_neg_lt_neg", "sub_pos_of_lt", "pos_of_neg_neg", "sub_lt_sub_of_le_of_lt", "sub_nonpos_of_le", "sub_le_sub", "decidable_linear_ordered_comm_ring", "sub_le_self", "lt_of_sub_neg", "le_of_sub_nonneg", "neg_lt_sub_left_of_lt_add", "sub_lt_sub_right", "linear_ordered_field", "lt_add_of_sub_left_lt", "nonneg_of_neg_nonpos", "lt_neg_add_of_add_lt", "sub_lt_sub", "neg_nonneg_of_nonpos", "ordered_comm_group.le_of_add_le_add_left", "ordered_comm_group.to_ordered_cancel_comm_monoid", "neg_lt_sub_right_of_lt_add", "ordered_ring", "le_of_sub_nonpos", "sub_neg_of_lt", "le_neg_add_of_add_le", "neg_neg_of_pos", "sub_nonneg_of_le", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "lt_sub_left_of_add_lt", "neg_le_of_neg_le"]}, {"id": "abs_add_le_abs_add_abs", "parentIds": ["abs_add_three", "abs_sub_le", "abs_sub_abs_le_abs_sub"]}, {"id": "has_zero", "parentIds": ["abs_add_le_abs_add_abs", "list.enum", "nat.eq_zero_of_add_eq_zero", "nat.pred_zero", "comm_semiring", "char.val_of_nat_eq_of_is_valid", "add_left_eq_self", "lt_of_one_div_lt_one_div", "nat.zero_ne_one_class", "le_mul_of_div_le", "int.of_nat_ge_zero", "fin.of_nat_zero", "div_zero", "eq_zero_or_eq_zero_of_mul_eq_zero", "parser.eof", "le_add_of_nonneg_right", "ne_zero_of_mul_ne_zero_left", "neg_add_self", "nat.pos_of_ne_zero", "nat.mod_lt", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "nat.eq_zero_or_eq_succ_pred", "add_lt_of_lt_of_nonpos", "nat.div_eq_of_lt", "nat.bitwise_zero", "mul_lt_mul_of_neg_left", "nat.one_ne_zero", "nat.bit_zero", "add_right_eq_self", "add_lt_of_le_of_neg", "one_div_pos_of_pos", "nat.pow_le_pow_of_le_left", "mul_self_sub_one_eq", "ring.mul_zero", "discrete_field", "nat.shiftl_eq_mul_pow", "div_sub_div", "param_info.to_format", "nat.shiftl'_add", "int.nat_abs_bit1_nonneg_step", "tactic.elide.unelide", "nat.one_lt_bit0", "div_pos_of_neg_of_neg", "mul_nonpos_of_nonpos_of_nonneg", "nat.add_one_ne_zero", "add_nonpos", "bit0_zero", "div_lt_of_mul_lt_of_pos", "mul_ne_zero_comm", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "abs_of_pos", "nat.mul_div_mul", "nat.not_succ_le_zero", "nat.eq_zero_of_add_eq_zero_left", "mul_lt_mul_of_pos_left", "unsigned.has_zero", "array.take", "linear_ordered_semiring", "eq_zero_of_zero_dvd", "abs_pos_of_ne_zero", "mul_nonneg_of_nonpos_of_nonpos", "add_sub_add_left_eq_sub", "char.of_nat_eq_of_not_is_valid", "functor.add_const.is_lawful_applicative", "native.rb_map.add", "mul_le_mul_of_nonneg_right", "int.neg_ne_of_pos", "nat.mul_div_assoc", "expr.to_nat", "int.zero_ne_neg_of_ne", "d_array.nil", "zero_le_one", "mul_inv_eq", "add_comm_group", "decidable_linear_ordered_semiring", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "lt_add_of_le_of_pos", "add_monoid_to_is_right_id", "norm_num.pos_bit1_helper", "div_nonneg_of_nonpos_of_neg", "nat.div_def", "nat.sub_eq_zero_of_le", "two_ne_zero", "eq_zero_of_mul_eq_self_right", "nat_add_zero", "nat.test_bit_bitwise", "nat.eq_of_mul_eq_mul_right", "eq_of_sub_eq_zero", "nat.pred_le", "nat.not_lt_zero", "nat.add_div_left", "eq_of_mul_eq_mul_right", "nat.bodd_add_div2", "le_add_of_le_of_nonneg", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "list.length_le_of_sublist", "int.ne_of_nat_ne_nonneg_case", "nat.add_mul_div_right", "nat.bodd_add", "mul_eq_of_eq_div", "add_zero", "int.has_zero", "int.zero_mul", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "nat.gcd_zero_left", "nat.zero_lt_one", "int.neg_of_nat_zero", "nonneg_of_mul_nonneg_left", "int.zero_nonneg", "sub_eq_zero_of_eq", "nat.zero_le", "list.length_append", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "string.iterator.length_next_to_string_next", "nat.pow_lt_pow_of_lt_right", "int.zero_ne_one_class", "one_div_mul_one_div'", "int.neg_ne_zero_of_ne", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "int.add_zero", "nat.zero_lt_one_add", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "le_add_of_nonneg_of_le", "inv_ne_zero", "mul_div_mul_left'", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "int.one_pos", "nat.le_mul_self", "integral_domain", "nat.lt_add_of_pos_left", "list.func.sub", "nat.mul_div_right", "nat.shiftr_eq_div_pow", "semiring", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "nat.mod_one", "char.val_of_nat_eq_of_not_is_valid", "add_lt_of_nonpos_of_lt", "interactive.types.pexpr_list", "mul_zero_class", "nat.binary_rec_eq", "one_div_lt_neg_one", "nat.eq_zero_or_pos", "nat.pred_lt_pred", "nat.nat_zero_eq_zero", "div_two_sub_self", "one_lt_div_of_lt", "lt_add_of_pos_of_le", "sub_ne_zero_of_ne", "int.of_nat_zero", "int.nat_abs_add_neg", "tactic.library_search", "decidable_linear_ordered_cancel_comm_monoid", "nat.mod_two_of_bodd", "add_lt_of_neg_of_lt", "nat.lt_wf", "eq_add_neg_of_add_eq", "div_neg_of_pos_of_neg", "int.nat_abs_pos_of_ne_zero", "eq_of_mul_eq_mul_of_nonzero_right", "nat.binary_rec_zero", "div_lt_of_mul_gt_of_neg", "norm_num.add1_zero", "list.length_drop", "nat.add_mul_div_left", "int.nat_abs_add_nonneg", "nat.add_self_ne_one", "one_div_zero", "div_mul_cancel", "list.length_map", "le_div_of_mul_le", "nat.zero_lt_succ", "mul_ne_zero", "tactic.mllist.enum", "no_zero_divisors", "nat.sub_eq_sub_min", "nat.sub_mul_mod", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "ext_param", "nat.sub_induction", "mul_div_cancel_left", "nat.zero_mul", "int.sign_eq_neg_one_iff_neg", "nat.bit0_inj", "neg_lt_neg", "tactic.constr_to_prop", "div_self", "nat.mod_eq_of_lt", "nat.bitwise_zero_left", "nat.zero_shiftr", "nat.bitwise", "nat.add_comm", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "eq_zero_of_mul_self_eq_zero", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "nat.has_zero", "ne_zero_of_mul_ne_zero_right", "nat.one_le_bit0", "one_div_lt_one_div_of_lt_of_neg", "char.of_nat", "div_helper", "int.add_left_neg", "div_mul_le_div_mul_of_div_le_div_pos", "nat.lt_of_sub_eq_succ", "int.of_nat_nat_abs_of_nonpos", "add_neg_of_nonpos_of_neg", "nat.shiftl'_sub", "mul_lt_mul", "two_gt_one", "nat.one_le_bit1", "lt_of_one_div_lt_one_div_of_neg", "lt_add_of_nonneg_of_lt", "ring", "norm_num.zero_mul", "div_mul_left", "lt_of_mul_lt_mul_right", "int.sub_nat_nat_eq_coe", "mul_pos", "int.of_nat_nonneg", "nat.add_sub_cancel", "division_ring", "nat.mul_zero", "zero_sub", "int.of_nat_sub", "int.coe_nat_zero", "add_monoid_to_is_left_id", "nat.div_le_of_le_mul", "add_eq_zero_iff_neg_eq", "nat.lt_add_of_pos_right", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "nat.sub_pos_of_lt", "int.of_nat_nat_abs_eq_of_nonneg", "division_ring.one_div_one_div", "norm_num.neg_zero_helper", "mul_self_le_mul_self_iff", "add_self_iff_eq_zero", "add_div_eq_mul_add_div", "nat.mul_mod_mul_left", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "int.distrib_left", "tactic.lift", "tactic.abstract", "int.lt_irrefl", "one_div_one", "nat.div2_zero", "nat.bodd_zero", "int.bit1_pos", "nat.mod_le", "tactic.interactive.simp_core_aux", "nat.mk_numeral", "neg_add_cancel_right", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.gcd.induction", "nat.zero_sub", "nat.eq_zero_of_mul_eq_zero", "add_sub_add_right_eq_sub", "nat.pos_of_dvd_of_pos", "nat.div_eq_of_eq_mul_right", "nat.mul_div_cancel'", "mul_one_div_cancel", "int.le_antisymm", "pos_of_mul_pos_right", "int.eq_one_of_mul_eq_self_left", "int.sign_eq_one_iff_pos", "zero_div", "nat.lt_add_of_zero_lt_left", "ordered_semiring", "abs_nonneg", "list.indexes_values", "norm_num.nonneg_bit1_helper", "lt_add_of_pos_left", "buffer.lt_aux_2", "nat.sub_self", "lt_of_one_lt_div", "field.div_div_div_div_eq", "mul_zero_class.to_has_zero", "int.lt_iff_le_and_ne", "abs_mul", "nat.one_ne_bit1", "neg_le_neg", "mul_le_of_le_div", "nat.add_left_cancel", "nat.zero_mod", "le_of_one_div_le_one_div_of_neg", "unsigned.of_nat'", "norm_num.div_add_helper", "nat.succ_pos", "int.zero_lt_one", "nat.digit_char", "list.map_with_index", "add_neg_of_neg_of_nonpos", "tactic.mk_inhabited_instance", "int.bit1_nonneg", "zero_mul", "string.is_empty", "nat.sub_lt_of_pos_le", "discrete_linear_ordered_field", "nat.add_sub_add_right", "add_eq_zero_iff_eq_neg", "abs_of_neg", "nat.bit_decomp", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "nat.add_sub_cancel_left", "nat.bit1_ne_bit0", "int.one_nonneg", "eq_div_of_mul_eq", "sub_eq_zero", "add_neg_self", "nat.gcd_one_left", "nat.eq_zero_of_le_zero", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "comm_ring", "nat.bitwise_swap", "nat.bitwise_zero_right", "nat.shiftr_add", "lt_of_sub_pos", "nat.size", "int.zero", "list.length_take", "nat.mul_pred_left", "add_group", "linear_ordered_ring", "sub_ne_zero", "mul_neg_of_neg_of_pos", "eq_iff_eq_of_sub_eq_sub", "nat.bitwise_bit", "find_cmd", "add_le_of_nonpos_of_le", "nat.zero_ne_bit1", "tactic.mllist.range", "ne_zero_of_one_div_ne_zero", "mul_pos_of_neg_of_neg", "int.eq_neg_succ_of_lt_zero", "add_neg", "neg_of_neg_pos", "unsigned.inhabited", "one_div_ne_zero", "le_of_mul_le_mul_right", "tactic.apply_under_pis", "d_array.of_beq_aux_eq_ff", "eq_zero_of_neg_eq", "zero_ne_one_class.to_has_zero", "field.div_mul_left", "sub_lt_self", "le_of_one_div_le_one_div", "nat.bitwise_bit_aux", "sub_eq_of_eq_add", "mul_lt_of_gt_div_of_neg", "norm_num.nonneg_bit0_helper", "field.div_mul_eq_mul_div_comm", "nat.eq_one_of_dvd_one", "mul_le_mul_of_nonpos_left", "int.abs_eq_nat_abs", "le_of_mul_le_of_ge_one", "nat.case_strong_induction_on", "int.mul_zero", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "sub_eq_of_eq_add'", "expr.replace_with", "one_inv_eq", "nat.sub_self_add", "int.nonneg_of_pos", "mul_eq_zero_iff_eq_zero_or_eq_zero", "nat.discriminate", "nat.mul_lt_mul_of_pos_left", "le_of_mul_le_mul_left", "nat.sub_one_sub_lt", "div_mul_le_div_mul_of_div_le_div_pos'", "list.find_indexes", "nat.succ_add", "neg_nonpos_of_nonneg", "add_neg_cancel_right", "mul_inv_cancel", "add_pos_of_nonneg_of_pos", "add_group.add_right_cancel", "int.sign_zero", "neg_of_mul_neg_right", "sub_lt_of_abs_sub_lt_left", "div_lt_div_of_lt_of_neg", "nat.dvd_of_mul_dvd_mul_right", "int.zero_add", "buffer.lt_aux_3", "norm_num.add_div_helper", "norm_num.pos_bit0_helper", "int.mul_pos", "nat.zero_min", "int.eq_succ_of_zero_lt", "tactic.interactive.generalize", "nat.add_zero", "field.div_mul_div", "tactic.mk_has_reflect_instance", "division_ring.one_div_div", "one_div_mul_cancel", "add_monoid.to_has_zero", "nat.succ_ne_zero", "eq_sub_of_add_eq", "expr.pi_arity", "lt_mul_of_gt_one_right", "native.float.has_zero", "nat.mul_mod_left", "nat.add_div_right", "div_nonpos_of_nonpos_of_pos", "sub_zero", "nat.mul_lt_mul_of_pos_right", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "eq_zero_of_abs_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "norm_num.nonzero_of_neg_helper", "nat.div_lt_self", "int.bit0_pos", "div_mul_right", "nat.mul_mod_right", "abs_zero", "inv_zero", "mul_inv'", "mul_le_of_div_le_of_neg", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "zero_ne_one_class", "nat.div2_val", "nat.mod_zero", "add_self_div_two", "eq_neg_iff_add_eq_zero", "norm_num.nonzero_of_pos_helper", "native.rb_map.zfind", "div_lt_div_of_lt_of_pos", "nat.mul_div_left", "lean.is_release", "list.sum", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "one_div_neg_eq_neg_one_div", "int.eq_coe_of_zero_le", "nat.div_eq_of_lt_le", "neg_sub", "int.nat_abs_bit1_nonneg", "ne_zero_of_abs_ne_zero", "tactic.explode.pad_right", "abs_div", "pos_of_mul_pos_left", "nat.le.dest", "tactic.explode_expr", "nat.one_succ_zero", "buffer.append_array", "mul_self_sub_mul_self_eq", "lt_of_mul_lt_mul_left", "nat.dvd_iff_mod_eq_zero", "nat.one_pos", "int.eq_nat_abs_of_zero_le", "add_right_neg", "nat.bit0_ne_one", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "neg_pos_of_neg", "zero_gt_neg_one", "nat.div_le_self", "bit1_zero", "nat.bodd_bit", "one_div_lt_one_div_of_lt", "nat.pos_pow_of_pos", "nat.sub_mul_div", "add_pos", "nat.pred_lt", "nat.exists_eq_succ_of_ne_zero", "field.div_mul_right", "parser.run", "div_nonpos_of_nonneg_of_neg", "abs_pos_of_neg", "nat.left_distrib", "division_ring.mul_ne_zero", "nat.mod_self", "le_abs_self", "add_comm_monoid", "norm_num.bin_zero_add", "int.sign_eq_zero_iff_zero", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "neg_of_mul_neg_left", "nat.right_distrib", "tactic.interactive.convert_to", "abs_of_nonneg", "nat.zero_lt_bit1", "int.pos_of_sign_eq_one", "add_left_neg", "tactic.fail_if_no_goals", "division_ring.neg_div_neg_eq", "add_nonneg", "nat.zero_ne_one", "eq_zero_of_mul_self_add_mul_self_eq_zero", "nat.sub_sub", "nat.div2_bit", "lt_add_of_pos_of_lt", "nat.not_succ_le_self", "mul_eq_mul_of_div_eq_div", "mk_buffer", "nat.sub_zero", "ordered_comm_group", "nat.mul_sub_right_distrib", "one_div_div", "add_neg_cancel_left", "nat.le_of_sub_eq_zero", "abs_by_cases", "nat.succ_ne_self", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "int.neg_succ_lt_zero", "int.neg_of_sign_eq_neg_one", "neg_add_rev", "zero_add", "div_eq_one_iff_eq", "mul_div_mul_left", "nat.mul_self_lt_mul_self", "nat.zero_ne_bit0", "nat.gcd_zero_right", "neg_add_cancel_left", "neg_eq_iff_add_eq_zero", "nat.bit_val", "nat.div_eq_sub_div", "nat.pow_lt_pow_of_lt_left", "nat.dvd_of_mod_eq_zero", "mul_div_mul_right'", "int.le_refl", "nat.zero_div", "neg_eq_zero", "nat.mod_def_aux", "ordered_ring.mul_lt_mul_of_pos_right", "one_ne_zero", "div_lt_div_of_pos_of_lt_of_pos", "nat.test_bit_zero", "neg_ne_zero", "nat.mod_add_div", "eq_of_mul_eq_mul_left", "field", "int.exists_eq_neg_of_nat", "one_div_one_div", "abs_pos_of_pos", "nat.two_step_induction", "nat.mod_eq_sub_mod", "mul_div_cancel'", "nat.mul_div_cancel_left", "eq_of_abs_sub_eq_zero", "nonpos_of_neg_nonneg", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_div_mul_right", "two_pos", "eq_zero_of_mul_eq_self_left", "nat.dvd_of_mul_dvd_mul_left", "int.nat_abs_of_nonneg", "eq_sub_of_add_eq'", "tactic.interactive.clean", "sub_pos_of_lt", "int.mul_nonneg", "one_div_le_one_div_of_le", "int.to_nat_sub", "environment.inhabited", "mul_self_eq_mul_self_iff", "nat.bit1_ne_zero", "nat.min_zero", "pos_of_neg_neg", "ordered_cancel_comm_monoid", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "neg_div_neg_eq", "mul_div_cancel", "eq_of_div_eq_one", "inv_mul_cancel", "nat.binary_rec", "nat.sub_le", "div_nonneg_of_nonneg_of_pos", "sub_nonpos_of_le", "lt_add_of_pos_right", "nat.zero_shiftl", "nat.succ_mul", "mul_nonpos_of_nonneg_of_nonpos", "list.length_map\u2082", "char.zero_lt_d800", "lt_add_of_lt_of_pos", "tactic.interactive.rw_rules", "division_ring.eq_of_one_div_eq_one_div", "decidable_linear_ordered_comm_ring", "eq_neg_of_add_eq_zero", "division_ring.inv_inv", "nat.div_self", "sub_le_self", "div_mul_eq_mul_div_comm", "lt_of_sub_neg", "tactic.mk_replacer", "nat.div_mul_le_self", "int.eq_one_of_mul_eq_self_right", "eq_of_one_div_eq_one_div", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "nat.bit1_ne_one", "nat.shiftl_zero", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "nat.sub_eq_zero_iff_le", "le_of_sub_nonneg", "nat.pow_zero", "tactic.interactive.mk_paragraph", "int.sign_eq_neg_one_of_neg", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "mul_self_nonneg", "int.ne_neg_of_pos", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_zero", "nonpos_of_mul_nonpos_right", "eq_one_div_of_mul_eq_one", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "nat.mul_comm", "add_pos_of_pos_of_nonneg", "one_div_add_one_div", "int.bit0_nonneg", "nat.gcd_rec", "zero_ne_one", "fin.pred", "nat.sub_lt", "nat.eq_of_mul_eq_mul_left", "nat.add_mul_mod_self_left", "one_div_le_one_div_of_le_of_neg", "nat.pred_inj", "int.coe_succ_pos", "mul_nonneg", "neg_of_one_div_neg", "neg_mul_eq_mul_neg", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "mul_mul_div", "int.sign_eq_one_of_pos", "sub_eq_zero_iff_eq", "norm_num.bin_add_zero", "mul_lt_mul_of_pos_right", "where.format_variable", "no_zero_divisors.to_has_zero", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "nat.zero_pow", "functor.add_const.applicative", "norm_num.div_helper", "nat.can_lift", "linear_ordered_field", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "mul_zero", "sub_eq_sub_add_sub", "list.func.add", "zero_lt_one", "saturate_fun", "tactic.rotate_right", "div_le_of_le_mul", "nat.mod_def", "nat.bit0_ne_zero", "nonneg_of_neg_nonpos", "nat.one_lt_bit1", "int.neg_succ_of_nat_lt_zero", "fin.val_zero", "eq_zero_of_one_div_eq_zero", "nat.le_div_iff_mul_le", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "conv.convert", "int.le_nat_abs", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "nat.decidable_dvd", "neg_nonneg_of_nonpos", "list.length_repeat", "add_monoid", "add_lt_of_lt_of_neg", "list.length_remove_nth", "ring.zero_mul", "ordered_ring.mul_lt_mul_of_pos_left", "fin.elim0", "mul_lt_mul'", "nat.zero_add", "norm_num.mul_div_helper", "tactic.interactive.suggest", "div_neg_of_neg_of_pos", "neg_eq_of_add_eq_zero", "sub_self", "div_mul_div", "nat.bit1_lt_bit0", "array.nil", "ordered_ring", "div_add_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "le_of_sub_nonpos", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "int.eq_zero_of_nat_abs_eq_zero", "nat.div_zero", "four_pos", "div_two_lt_of_pos", "dvd_zero", "neg_zero", "division_ring.one_div_neg_eq_neg_one_div", "le_add_of_nonneg_left", "int.zero_ne_one", "nat.gcd_def", "tactic.done", "decidable_linear_ordered_comm_group", "nat.cond_to_bool_mod_two", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "add_eq_of_eq_sub", "string.to_nat", "mul_self_le_mul_self", "nat.zero_lt_bit0", "one_lt_one_div", "nat.find_x", "sub_neg_of_lt", "nat.div2_one", "expr.of_nat", "eq_div_iff_mul_eq", "nat.div_one", "neg_neg_of_pos", "sub_nonneg_of_le", "fin.has_zero", "add_le_of_le_of_nonpos", "int.coe_zero_le", "nat.succ_pred_eq_of_pos", "nat.mod_eq_zero_of_dvd", "tactic.get_pi_binders_dep", "mul_le_mul", "nat.dvd_antisymm", "add_neg_eq_zero", "int.nat_abs_zero", "nat.add_assoc", "one_div_le_neg_one", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "list.eq_nil_of_length_eq_zero", "mul_le_mul_of_nonpos_right"]}, {"id": "neg_nonneg_of_nonpos", "parentIds": ["abs_add_le_abs_add_abs", "int.of_nat_nat_abs_of_nonpos", "abs_nonneg", "mul_le_mul_of_nonpos_left", "gt_of_mul_lt_mul_neg_left", "int.exists_eq_neg_of_nat", "abs_of_nonpos", "mul_le_mul_of_nonpos_right"]}, {"id": "ge", "parentIds": ["abs_add_le_abs_add_abs", "lt_of_one_div_lt_one_div", "int.of_nat_ge_zero", "le_add_of_nonneg_right", "mul_sub_mul_div_mul_nonpos", "is_strict_weak_order_of_decidable_linear_order", "int.nat_abs_bit1_nonneg_step", "mul_nonpos_of_nonpos_of_nonneg", "unused_arguments", "le_of_not_ge", "nat.lt_or_ge", "norm_num.pos_bit1_helper", "int.ne_of_nat_ne_nonneg_case", "int.zero_nonneg", "ge_of_forall_ge_sub", "div_le_of_mul_le_of_neg", "lt_iff_not_ge", "ge_trans", "nat.lt_ge_by_cases", "lt_of_not_ge", "eq_or_lt_of_not_lt", "int.nat_abs_add_nonneg", "gt_of_ge_of_gt", "char.to_lower", "nat.sub_eq_sub_min", "gt_of_gt_of_ge", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "nat.lt_of_sub_eq_succ", "char.is_lower", "lt_of_one_div_lt_one_div_of_neg", "lt_of_mul_lt_mul_right", "environment.is_refl_app", "int.of_nat_nat_abs_eq_of_nonneg", "int.bit1_pos", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "nat.lt_by_cases", "not_lt_of_ge", "abs_nonneg", "norm_num.nonneg_bit1_helper", "char.decidable_is_digit", "int.bit1_nonneg", "int.one_nonneg", "le_mul_of_ge_one_left", "ge_iff_le", "char.decidable_is_upper", "norm_num.nonneg_bit0_helper", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "char.is_upper", "int.nonneg_of_pos", "neg_of_mul_neg_right", "lt_or_ge", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "gt_of_mul_lt_mul_neg_left", "int.nat_abs_bit1_nonneg", "lt_of_mul_lt_mul_left", "nat.succ_sub", "char.is_digit", "neg_of_mul_neg_left", "abs_of_nonneg", "char.decidable_is_lower", "int.neg_succ_lt_zero", "nat.div_eq_sub_div", "nat.mod_eq_sub_mod", "two_ge_one", "int.nat_abs_of_nonneg", "mul_nonpos_of_nonneg_of_nonpos", "sub_le_self", "mul_self_nonneg", "int.bit0_nonneg", "mul_nonneg", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "tactic.suggest", "nat.le_div_iff_mul_le", "nat.div_lt_iff_lt_mul", "mul_lt_mul'", "nat.sub_add_cancel", "le_add_of_nonneg_left", "dup_namespace", "mul_le_mul_of_nonpos_right"]}, {"id": "or.elim", "parentIds": ["abs_add_le_abs_add_abs", "nat.mod_lt", "abs_pos_of_ne_zero", "nat.mul_div_assoc", "or.by_cases", "list.cons_subset_cons", "max_lt", "classical.cases_true_false", "nat.lt_wf", "mul_ne_zero", "nat.pow_le_pow_of_le_right", "lt_min", "eq_zero_of_mul_self_eq_zero", "ne_iff_lt_or_gt", "exists_or_distrib", "le_of_eq_or_lt", "or.neg_resolve_left", "nat.mul_mod_mul_left", "nat.mod_le", "abs_nonneg", "lt_trichotomy", "or.elim3", "abs_mul", "or.resolve_right", "classical.prop_complete", "mul_eq_zero_iff_eq_zero_or_eq_zero", "list.bex_cons", "not_and_of_not_or_not", "le_abs_self", "or.neg_resolve_right", "abs_by_cases", "decidable.not_and_iff_or_not", "nat.mod_eq_sub_mod", "decidable.not_or_iff_and_not", "one_div_le_one_div_of_le", "mul_self_eq_mul_self_iff", "decidable.ne_iff_lt_or_gt", "mul_self_nonneg", "list.ball_cons", "one_div_le_one_div_of_le_of_neg", "not_or_distrib", "int.le_nat_abs", "classical.em", "or.resolve_left", "is_total_preorder_is_preorder"]}, {"id": "trans_rel_left", "parentIds": ["abs_add_le_abs_add_abs", "mul_sub_mul_div_mul_nonpos", "div_lt_of_mul_lt_of_pos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "one_lt_div_of_lt", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "mul_zero_lt_mul_inv_of_pos", "two_gt_one", "nat.div_le_of_le_mul", "mul_sub_mul_div_mul_neg", "abs_nonneg", "lt_of_one_lt_div", "sub_lt_self", "le_of_mul_le_of_ge_one", "gt_of_mul_lt_mul_neg_left", "eq_zero_of_mul_self_add_mul_self_eq_zero", "sub_le_self", "div_le_of_le_mul", "le_of_one_le_div", "div_two_lt_of_pos", "nat.zero_lt_bit0"]}, {"id": "decidable_linear_ordered_comm_group.to_ordered_comm_group", "parentIds": ["abs_add_le_abs_add_abs", "abs_add_three", "abs_of_pos", "abs_pos_of_ne_zero", "abs_sub_le", "neg_le_abs_self", "abs_nonneg", "abs_of_neg", "eq_zero_of_neg_eq", "eq_zero_of_abs_eq_zero", "abs_zero", "abs_pos_of_neg", "le_abs_self", "abs_of_nonneg", "abs_pos_of_pos", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "abs_lt_of_lt_of_neg_lt", "abs_sub_abs_le_abs_sub", "max_neg_neg", "abs_of_nonpos"]}, {"id": "le_total", "parentIds": ["abs_add_le_abs_add_abs", "exists_ge_of_linear", "lt_of_not_ge'", "le_of_not_ge", "has_le.le.is_total_preorder", "abs_nonneg", "lt_trichotomy", "abs_mul", "le_abs_self", "abs_by_cases", "decidable.le_of_not_lt", "mul_self_nonneg", "int.le_nat_abs", "le_of_not_le"]}, {"id": "decidable_linear_ordered_comm_group.to_add_comm_group", "parentIds": ["abs_add_le_abs_add_abs", "min_neg_neg", "abs_add_three", "abs_of_pos", "abs_pos_of_ne_zero", "abs_sub_le", "neg_le_abs_self", "sub_le_of_abs_sub_le_left", "max_eq_neg_min_neg_neg", "sub_lt_of_abs_sub_lt_right", "abs_nonneg", "abs_mul", "abs", "abs_of_neg", "eq_zero_of_neg_eq", "int.abs_eq_nat_abs", "abs_neg", "sub_lt_of_abs_sub_lt_left", "eq_zero_of_abs_eq_zero", "abs_zero", "ne_zero_of_abs_ne_zero", "abs_div", "abs_pos_of_neg", "le_abs_self", "abs_of_nonneg", "sub_le_of_abs_sub_le_right", "min_eq_neg_max_neg_neg", "abs_by_cases", "abs_pos_of_pos", "eq_of_abs_sub_eq_zero", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "abs_lt_of_lt_of_neg_lt", "abs_sub", "abs_sub_abs_le_abs_sub", "max_neg_neg", "abs_of_nonpos"]}, {"id": "neg_add", "parentIds": ["abs_add_le_abs_add_abs", "int.neg_succ_of_nat_coe'", "norm_num.neg_add_neg_helper", "neg_add'"]}, {"id": "abs", "parentIds": ["abs_add_le_abs_add_abs", "abs_mul_abs_self", "abs_add_three", "abs_of_pos", "abs_pos_of_ne_zero", "abs_sub_le", "neg_le_abs_self", "abs_one_div", "abs_sub_square", "sub_le_of_abs_sub_le_left", "sub_lt_of_abs_sub_lt_right", "abs_nonneg", "abs_mul", "abs_of_neg", "int.abs_eq_nat_abs", "abs_neg", "int.sign_mul_abs", "sub_lt_of_abs_sub_lt_left", "eq_zero_of_abs_eq_zero", "abs_zero", "ne_zero_of_abs_ne_zero", "abs_div", "abs_pos_of_neg", "le_abs_self", "abs_of_nonneg", "sub_le_of_abs_sub_le_right", "abs_by_cases", "abs_abs", "abs_pos_of_pos", "eq_of_abs_sub_eq_zero", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "abs_lt_of_lt_of_neg_lt", "abs_sub", "abs_abs_sub_abs_le_abs_sub", "abs_sub_abs_le_abs_sub", "int.nat_abs_abs", "abs_mul_self", "abs_of_nonpos"]}, {"id": "trans_rel_right", "parentIds": ["abs_add_le_abs_add_abs", "le_mul_of_div_le", "div_lt_of_mul_lt_of_pos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "abs_sub_le", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "div_le_of_mul_le_of_neg", "one_lt_div_of_lt", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "mul_zero_lt_mul_inv_of_pos", "two_gt_one", "sub_lt_self", "gt_of_mul_lt_mul_neg_left", "nat.div_le_self", "sub_le_self", "div_le_of_le_mul", "abs_sub_abs_le_abs_sub"]}, {"id": "add_monoid.to_has_zero", "parentIds": ["abs_add_le_abs_add_abs", "add_left_eq_self", "int.of_nat_ge_zero", "le_add_of_nonneg_right", "neg_add_self", "mul_sub_mul_div_mul_nonpos", "add_lt_of_lt_of_nonpos", "add_right_eq_self", "add_lt_of_le_of_neg", "mul_self_sub_one_eq", "ring.mul_zero", "discrete_field", "add_nonpos", "bit0_zero", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "abs_of_pos", "abs_pos_of_ne_zero", "add_sub_add_left_eq_sub", "functor.add_const.is_lawful_applicative", "add_comm_group", "lt_add_of_le_of_pos", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "le_add_of_le_of_nonneg", "add_zero", "sub_eq_zero_of_eq", "int.neg_ne_zero_of_ne", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "le_add_of_nonneg_of_le", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "integral_domain", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "add_lt_of_nonpos_of_lt", "div_two_sub_self", "lt_add_of_pos_of_le", "sub_ne_zero_of_ne", "add_lt_of_neg_of_lt", "eq_add_neg_of_add_eq", "norm_num.add1_zero", "neg_lt_neg", "add_neg_of_nonpos_of_neg", "lt_add_of_nonneg_of_lt", "ring", "int.sub_nat_nat_eq_coe", "nat.add_sub_cancel", "division_ring", "zero_sub", "add_eq_zero_iff_neg_eq", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "nat.sub_pos_of_lt", "norm_num.neg_zero_helper", "add_self_iff_eq_zero", "int.lt_irrefl", "neg_add_cancel_right", "add_sub_add_right_eq_sub", "nat.mul_div_cancel'", "int.le_antisymm", "abs_nonneg", "lt_add_of_pos_left", "int.lt_iff_le_and_ne", "neg_le_neg", "add_neg_of_neg_of_nonpos", "discrete_linear_ordered_field", "nat.add_sub_add_right", "add_eq_zero_iff_eq_neg", "abs_of_neg", "sub_eq_zero", "add_neg_self", "comm_ring", "lt_of_sub_pos", "add_group", "linear_ordered_ring", "sub_ne_zero", "eq_iff_eq_of_sub_eq_sub", "add_le_of_nonpos_of_le", "add_neg", "neg_of_neg_pos", "eq_zero_of_neg_eq", "sub_lt_self", "sub_eq_of_eq_add", "int.abs_eq_nat_abs", "sub_eq_of_eq_add'", "neg_nonpos_of_nonneg", "add_neg_cancel_right", "add_pos_of_nonneg_of_pos", "add_group.add_right_cancel", "sub_lt_of_abs_sub_lt_left", "eq_sub_of_add_eq", "sub_zero", "eq_zero_of_abs_eq_zero", "norm_num.nonzero_of_neg_helper", "nat.mul_mod_right", "abs_zero", "eq_neg_iff_add_eq_zero", "one_div_neg_eq_neg_one_div", "neg_sub", "ne_zero_of_abs_ne_zero", "abs_div", "mul_self_sub_mul_self_eq", "add_right_neg", "neg_pos_of_neg", "zero_gt_neg_one", "bit1_zero", "add_pos", "abs_pos_of_neg", "le_abs_self", "norm_num.bin_zero_add", "abs_of_nonneg", "add_left_neg", "add_nonneg", "nat.sub_sub", "nat.div2_bit", "lt_add_of_pos_of_lt", "ordered_comm_group", "add_neg_cancel_left", "abs_by_cases", "neg_add_rev", "zero_add", "neg_add_cancel_left", "neg_eq_iff_add_eq_zero", "neg_eq_zero", "div_lt_div_of_pos_of_lt_of_pos", "neg_ne_zero", "field", "abs_pos_of_pos", "eq_of_abs_sub_eq_zero", "nonpos_of_neg_nonneg", "eq_sub_of_add_eq'", "sub_pos_of_lt", "mul_self_eq_mul_self_iff", "pos_of_neg_neg", "neg_div_neg_eq", "sub_nonpos_of_le", "lt_add_of_pos_right", "lt_add_of_lt_of_pos", "decidable_linear_ordered_comm_ring", "eq_neg_of_add_eq_zero", "nat.div_self", "sub_le_self", "lt_of_sub_neg", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "le_of_sub_nonneg", "add_pos_of_pos_of_nonneg", "neg_mul_eq_mul_neg", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "sub_eq_zero_iff_eq", "norm_num.bin_add_zero", "linear_ordered_field", "sub_eq_sub_add_sub", "nonneg_of_neg_nonpos", "int.neg_succ_of_nat_lt_zero", "neg_nonneg_of_nonpos", "add_lt_of_lt_of_neg", "ring.zero_mul", "neg_eq_of_add_eq_zero", "sub_self", "ordered_ring", "le_of_sub_nonpos", "neg_zero", "le_add_of_nonneg_left", "decidable_linear_ordered_comm_group", "add_eq_of_eq_sub", "sub_neg_of_lt", "neg_neg_of_pos", "sub_nonneg_of_le", "add_le_of_le_of_nonpos", "add_neg_eq_zero", "abs_of_nonpos", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel"]}, {"id": "abs_neg", "parentIds": ["abs_add_le_abs_add_abs", "neg_le_abs_self", "eq_zero_of_abs_eq_zero", "abs_pos_of_neg", "abs_sub"]}, {"id": "decidable_linear_ordered_comm_group", "parentIds": ["abs_add_le_abs_add_abs", "min_neg_neg", "abs_add_three", "abs_of_pos", "abs_pos_of_ne_zero", "abs_sub_le", "decidable_linear_ordered_comm_group.to_ordered_comm_group", "neg_le_abs_self", "max_eq_neg_min_neg_neg", "decidable_linear_ordered_comm_group.to_decidable_linear_order", "abs_nonneg", "abs", "abs_of_neg", "eq_zero_of_neg_eq", "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_comm_group", "abs_neg", "eq_zero_of_abs_eq_zero", "abs_zero", "ne_zero_of_abs_ne_zero", "abs_pos_of_neg", "le_abs_self", "abs_of_nonneg", "min_eq_neg_max_neg_neg", "abs_by_cases", "abs_abs", "abs_pos_of_pos", "eq_of_abs_sub_eq_zero", "abs_le_of_le_of_neg_le", "dist_bdd_within_interval", "int.decidable_linear_ordered_comm_group", "abs_lt_of_lt_of_neg_lt", "abs_sub", "abs_sub_abs_le_abs_sub", "max_neg_neg", "decidable_linear_ordered_comm_group.to_add_comm_group", "abs_of_nonpos"]}, {"id": "decidable_linear_ordered_comm_group.to_decidable_linear_order", "parentIds": ["abs_add_le_abs_add_abs", "min_neg_neg", "abs_pos_of_ne_zero", "max_eq_neg_min_neg_neg", "abs_nonneg", "abs", "eq_zero_of_neg_eq", "abs_neg", "le_abs_self", "abs_of_nonneg", "min_eq_neg_max_neg_neg", "abs_by_cases", "dist_bdd_within_interval", "max_neg_neg", "abs_of_nonpos"]}, {"id": "reflected.has_to_tactic_format", "parentIds": []}, {"id": "reflected.to_expr", "parentIds": ["reflected.has_to_tactic_format", "reflected.has_to_format", "reflected.has_to_pexpr", "expr.has_coe"]}, {"id": "expr.has_to_tactic_format", "parentIds": ["reflected.has_to_tactic_format", "infer_type_cmd", "tactic.terminal_goal", "old_conv.conversion", "old_conv.trace_lhs", "tactic.interactive.type_check", "tactic.suggest.tactic_statement", "tactic.interactive.rec.to_tactic_format", "tactic.lift", "tactic.interactive.squeeze_simpa", "conv.interactive.trace_lhs", "tactic.explode", "tactic.eqn_stub", "tactic.list_constructors_hole", "print_item_crawl", "tactic.match_stub", "tactic.interactive.has_to_tactic_format", "binder.has_to_tactic_format", "tactic.interactive.simpa", "tactic.interactive.extract_goal", "where.format_variable", "interactive.param_desc", "tactic.get_lift_prf", "tactic.has_to_tactic_format"]}, {"id": "nat.le_total", "parentIds": ["nat.linear_order", "nat.decidable_linear_ordered_semiring"]}, {"id": "or.imp_left", "parentIds": ["nat.le_total", "or.assoc", "decidable.lt_trichotomy", "or_of_or_of_imp_left"]}, {"id": "nat.le_of_lt", "parentIds": ["nat.le_total", "int.sub_nat_nat_elim", "nat.nat.lt_asymm", "nat.lt_iff_le_not_le", "nat.lt_of_add_lt_add_left"]}, {"id": "nat.has_lt", "parentIds": ["nat.le_total", "char.val_of_nat_eq_of_is_valid", "nat.lt_add_left", "parser.sat", "nat.pos_of_ne_zero", "nat.mod_lt", "is_valid_char_range_1", "nat.div_eq_of_lt", "nat.lt_le_antisymm", "nat.lt.step", "param_info.to_format", "nat.one_lt_bit0", "nat.succ_lt_succ", "nat.mul_div_mul", "tactic.existsi", "array.push_back_idx", "nat.mul_div_assoc", "is_valid_char_range_2", "nat.lt_or_ge", "nat.div_def", "nat.eq_of_mul_eq_mul_right", "nat.not_lt_zero", "nat.add_div_left", "nat.add_mul_div_right", "nat.zero_lt_one", "nat.pow_lt_pow_of_lt_right", "nat.zero_lt_one_add", "fin.le_def", "nat.lt_trichotomy", "nat.bit1_lt", "nat.lt_irrefl", "nat.lt_add_of_pos_left", "nat.mul_div_right", "nat.mod_one", "nat.strong_induction_on", "char.val_of_nat_eq_of_not_is_valid", "nat.eq_zero_or_pos", "nat.pred_lt_pred", "nat.lt_ge_by_cases", "fin.mod_def", "nat.lt_wf", "int.nat_abs_pos_of_ne_zero", "nat.find_min", "nat.add_mul_div_left", "nat.zero_lt_succ", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "nat.mod_eq_of_lt", "int.lt_of_coe_nat_lt_coe_nat", "buffer.read_eq_read'", "char.of_nat", "nat.lt_of_sub_eq_succ", "int.coe_nat_lt_coe_nat_iff", "nat.le_lt_antisymm", "nat.lt_add_of_pos_right", "tactic.unprime", "fin.eq_of_veq", "nat.sub_pos_of_lt", "array.write'", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "tactic.lift", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "tactic.interactive.simp_core_aux", "nat.nat.lt_asymm", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.gcd.induction", "nat.pos_of_dvd_of_pos", "nat.lt_by_cases", "array.pop_back_idx", "nat.div_eq_of_eq_mul_right", "nat.lt_add_of_zero_lt_left", "buffer.lt_aux_2", "nat.zero_mod", "unsigned.of_nat'", "nat.succ_pos", "nat.sub_lt_of_pos_le", "measure", "nat.decidable_lt", "fin.veq_of_eq", "buffer.write_eq_write'", "fin.add_def", "fin.mul_def", "fin", "nat.find", "list.nth_le", "fin.lt", "nat.lt_succ_of_lt", "nat.eq_one_of_dvd_one", "nat.case_strong_induction_on", "list.of_fn_nth_val", "nat.mul_lt_mul_of_pos_left", "nat.sub_one_sub_lt", "array.ext'", "array.read'", "nat.add_lt_add_right", "nat.dvd_of_mul_dvd_mul_right", "buffer.lt_aux_3", "nat.add_div_right", "nat.mul_lt_mul_of_pos_right", "nat.div_lt_self", "nat.lt_iff_le_not_le", "fin.lt_def", "int.coe_nat_lt_coe_nat_of_lt", "nat.div2_val", "nat.mod_zero", "nat.bit0_lt", "nat.mul_div_left", "nat.div_eq_of_lt_le", "buffer.append_array", "nat.eq_or_lt_of_le", "nat.one_pos", "nat.pos_pow_of_pos", "nat.sub_mul_div", "fin.sub_def", "nat.pred_lt", "rsimp.choose", "nat.strong_rec_on", "nat.lt_of_le_and_ne", "nat.zero_lt_bit1", "nat.eq_or_lt_of_not_lt", "nat.le_of_lt_succ", "nat.lt_of_add_lt_add_left", "nat.div2_bit", "nat.bit0_lt_bit1", "nat.lt_of_succ_lt", "list.qsort.F", "nat.lt_succ_of_le", "nat.mul_self_lt_mul_self", "buffer.lt_aux_1", "nat.div_eq_sub_div", "nat.pow_lt_pow_of_lt_left", "nat.lt_of_le_of_lt", "nat.zero_div", "nat.mod_def_aux", "array.read_eq_read'", "nat.mod_add_div", "where.binder_less_important", "nat.mod_eq_sub_mod", "nat.mul_div_cancel_left", "is_valid_char", "d_array.ext'", "nat.dvd_of_mul_dvd_mul_left", "interaction_monad.result.clamp_pos", "char.lt", "measure_wf", "char.zero_lt_d800", "nat.find_spec", "nat.div_self", "instance_priority", "instance_derive_handler", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "nat.mod_two_eq_zero_or_one", "fin.div_def", "nat.sub_lt", "nat.eq_of_mul_eq_mul_left", "nat.lt_of_succ_le", "nat.pred_inj", "unsigned.reflect", "nat.lt_add_right", "nat.succ_le_of_lt", "array.write_eq_write'", "nat.mod_pow_succ", "nat.zero_pow", "nat.add_lt_add_left", "tactic.suggest", "tactic.interactive.case", "nat.mod_def", "nat.one_lt_bit1", "nat.lt_of_lt_of_le", "nat.le_div_iff_mul_le", "nat.div_lt_iff_lt_mul", "nat.lt_succ_self", "nat.lt_of_succ_lt_succ", "list.length_remove_nth", "nat.sub_lt_succ", "nat.bit1_lt_bit0", "nat.div_zero", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "nat.zero_lt_bit0", "nat.find_x", "nat.lt.base", "nat.lt_trans", "nat.succ_pred_eq_of_pos", "nat.le_of_lt", "nat.mul_div_cancel", "nat.le_antisymm"]}, {"id": "nat.lt_or_ge", "parentIds": ["nat.le_total"]}, {"id": "nat.has_le", "parentIds": ["nat.le_total", "d_array.iterate_aux", "nat.mod_lt", "nat.div_eq_of_lt", "nat.lt_le_antisymm", "nat.pow_le_pow_of_le_left", "nat.not_succ_le_zero", "unused_arguments", "array.take", "int.le_of_coe_nat_le_coe_nat", "list.length_take_le", "nat.le_of_succ_le_succ", "nat.le_add_left", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "nat.div_def", "nat.sub_eq_zero_of_le", "buffer.take", "nat.pred_le", "nat.sub_sub_self", "nat.sub_le_sub_left", "list.length_le_of_sublist", "nat.shiftl_sub", "nat.add_le_add_iff_le_right", "nat.zero_le", "int.coe_nat_le_coe_nat_iff", "fin.le_def", "nat.find_min'", "nat.le_mul_self", "nat.le_succ", "nat.lt_ge_by_cases", "nat.le_trans", "nat.sub_eq_iff_eq_add", "nat.le_of_eq", "char.to_lower", "nat.sub_eq_sub_min", "nat.sub_mul_mod", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "nat.mod_eq_of_lt", "nat.mul_self_le_mul_self_iff", "nat.one_le_bit0", "char.is_lower", "nat.shiftl'_sub", "nat.one_le_bit1", "buffer.drop", "int.coe_nat_lt_coe_nat_iff", "nat.mul_le_mul_left", "nat.le_lt_antisymm", "environment.is_refl_app", "nat.add_sub_assoc", "int.of_nat_sub", "nat.div_le_of_le_mul", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "nat.add_le_add_right", "nat.lt_by_cases", "nat.pred_le_pred", "char.decidable_is_digit", "nat.zero_mod", "nat.sub_lt_of_pos_le", "char.le", "nat.le_of_add_le_add_right", "nat.eq_zero_of_le_zero", "buffer.take_right", "nat.le_of_succ_le", "nat.dvd_sub", "d_array.of_beq_aux_eq_ff", "char.decidable_is_upper", "nat.case_strong_induction_on", "array.take_right", "nat.le.intro", "nat.decidable_le", "char.is_upper", "nat.mul_lt_mul_of_pos_left", "nat.mul_le_mul_right", "nat.le_add_right", "list.of_fn_aux", "nat.lt_iff_le_not_le", "nat.mod_zero", "nat.mul_self_le_mul_self", "nat.le_succ_of_pred_le", "array.drop", "nat.div_eq_of_lt_le", "nat.le.dest", "int.coe_nat_sub", "nat.eq_or_lt_of_le", "nat.sub_add_comm", "nat.succ_sub", "nat.div_le_self", "nat.le_of_le_of_sub_le_sub_right", "nat.sub_mul_div", "char.is_digit", "nat.le_succ_of_le", "int.coe_nat_le_coe_nat_of_le", "nat.lt_of_le_and_ne", "char.decidable_is_lower", "nat.le_of_lt_succ", "nat.lt_of_add_lt_add_left", "nat.not_succ_le_self", "nat.bit0_lt_bit1", "nat.add_le_add_left", "nat.le_of_sub_eq_zero", "nat.lt_succ_of_le", "nat.div_eq_sub_div", "nat.sub_le_sub_right_iff", "nat.lt_of_le_of_lt", "nat.zero_div", "nat.mod_def_aux", "nat.succ_le_succ", "nat.mod_add_div", "nat.mod_eq_sub_mod", "char.quote_core", "d_array.rev_iterate_aux", "nat.le_refl", "nat.sub_le", "nat.le_of_add_le_add_left", "nat.sub_le_sub_right", "nat.div_mul_le_self", "nat.sub_eq_zero_iff_le", "nat.le_of_dvd", "nat.lt_of_succ_le", "nat.succ_le_of_lt", "nat.mod_pow_succ", "nat.add_lt_add_left", "tactic.suggest", "nat.mod_def", "nat.add_sub_of_le", "nat.lt_of_lt_of_le", "nat.le_div_iff_mul_le", "nat.add_le_to_le_sub", "nat.sub_add_cancel", "nat.bit1_lt_bit0", "array.slice", "nat.div_zero", "nat.min_succ_succ", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "d_array.beq_aux", "nat.find_x", "dup_namespace", "nat.le_of_lt", "fin.le", "nat.le_antisymm"]}, {"id": "declaration.modifiers.has_to_string", "parentIds": ["print_item_crawl"]}, {"id": "declaration.modifiers", "parentIds": ["declaration.modifiers.has_to_string", "print_item_crawl", "environment.get_modifiers"]}, {"id": "has_to_string", "parentIds": ["declaration.modifiers.has_to_string", "tactic_state.has_to_string", "sigma.has_to_string", "char.has_to_string", "expr.has_to_string", "subtype.has_to_string", "string.has_to_string", "native.has_to_string", "unsigned.has_to_string", "list.to_string", "interaction_monad.result_to_string", "nat.has_to_string", "exceptional.has_to_string", "native.float.has_to_string", "sum.has_to_string", "int.has_to_string", "binder.has_to_string", "to_string", "exceptional.to_string", "bool.has_to_string", "decidable.has_to_string", "prod.has_to_string", "list.to_string_aux", "level.has_to_string", "name.has_to_string", "unit.has_to_string", "my_name_to_string", "interaction_monad.result_has_string", "option.has_to_string", "bool.to_string_python", "fin.has_to_string", "format.has_to_string", "list.has_to_string", "module_info.has_to_string"]}, {"id": "to_string", "parentIds": ["declaration.modifiers.has_to_string", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "where.trace_namespace", "where.mk_flag", "subtype.has_to_string", "tactic.mk_simp_attribute_cmd", "restate_axiom_cmd", "unsigned.has_to_string", "interaction_monad.result_to_string", "where.trace_includes", "tactic.suggest.tactic_statement", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.squeeze_simpa", "pos_line", "loc.to_string_aux", "rsimp_attr", "where.trace_opens", "exceptional.to_string", "print_item_crawl", "tactic.alias.alias_cmd", "tactic.interactive.simp_intros", "tactic.explode.has_to_tactic_format", "tactic.def_replacer", "my_name_to_string", "native.float.has_to_format", "where.format_variable", "tactic.interactive.case", "tactic.replacer_attr", "fin.has_to_string", "tactic.ids_to_simp_arg_list", "tactic.import_private_cmd"]}, {"id": "string", "parentIds": ["declaration.modifiers.has_to_string", "string.pop_back", "tactic.interactive.squeeze_simp", "tactic.add_library_note", "name.has_to_format", "tactic.library_search_hole_cmd", "occurrences_repr", "environment.is_prefix_of_file", "parser.sat", "tactic.strip_prefix", "tactic.interactive.format_names", "get_localized", "smt_tactic.solve1", "vm_decl.olean", "string.quote", "string.popn_back", "string.quote_aux", "file_name", "string.iterator.extract", "infer_type_cmd", "option_to_tactic_format", "print_decls_sorted", "string.over_list", "param_info.to_format", "tactic.explode.args", "to_additive.target_name", "tactic.timetac", "tactic.interactive.trivial", "where.trace_namespace", "int.repr", "tactic.doc_string", "tactic.existsi", "unused_arguments", "lean.githash", "congr_arg_kind.has_to_format", "sigma.has_to_format", "tactic.cc_core", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "string.back", "string_to_format", "where.trace_variables", "where.mk_flag", "hole_command", "string.iterator.next_to_string", "sum_has_to_format", "tactic.interactive.convert", "repr", "tactic.match_or", "to_additive.tokens_dict", "parser.run_string", "string.to_char_buffer", "string.get_rest", "tactic.is_in_mathlib", "tactic.mk_simp_attribute_cmd", "string.has_to_string", "tactic.clear'", "tactic.get_library_notes", "tactic.interactive.unfold", "tactic.interactive.rcases", "incorrect_def_lemma", "lean.parser.with_input", "restate_axiom_cmd", "mk_simple_name", "string.iterator.length_next_to_string_next", "lean.parser.emit_command_here", "tactic.symmetry_hyp", "name_set.has_to_format", "string.empty", "list.repr_aux", "string.str", "localized_attr", "native.rb_map.has_to_tactic_format", "char.repr", "to_additive.proceed_fields", "format.to_string", "string.fold", "to_additive.guess_name", "use_cmd", "string.singleton", "to_additive.value_type", "tactic.left", "tactic.interactive.triv", "tactic.assoc_refl", "print_decls", "ematch_lhs", "char.to_string", "native.has_to_string", "array.has_repr", "print_localized_commands", "tactic.suggest_scripts", "rbtree.has_repr", "nolint_attr", "to_additive.parser", "tactic.library_search", "can_lift_attr", "tactic.terminal_goal", "options.get_string", "smt_tactic.monad_fail", "environment.from_imported_module_name", "simps_add_projection", "where.collect_implicit_names", "tactic.trace_macro", "tactic.interactive.unfold_projs", "occurrences_to_format", "localized_cmd", "string.str_ne_empty", "tactic.choose1", "native.float.to_repr", "nat.repr", "old_conv.conversion", "binder_info.brackets", "list.to_string", "parser.mk_error_msg", "simps_tac", "native.has_to_format", "interaction_monad.result_to_string", "rbmap.has_repr", "tactic.rintro_parse", "module_info.module_id", "string.hash", "name.add_prime", "list.repr", "tactic.try_for", "tactic.suggest.message", "to_additive.value_type.has_reflect", "tactic.match_eq", "tactic.success_if_fail", "congr_arg_kind.to_string", "tactic.get_goal", "expr.has_to_format", "string.popn", "string.map_tokens", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "tactic.returnopt", "tactic.interactive.letI", "trace", "tactic.unsafe.type_context.monad_fail", "tactic.suggest.head_symbol_match.to_string", "environment.in_current_file", "tactic.instance_stub", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.apply_assumption", "tactic.suggest.tactic_statement", "string.reflect", "tactic.constructor_idx", "string.iterator.next_to_string_mk_iterator", "mk_hinst_lemma_attr_from_simp_attr", "tactic.unprime", "tactic.interactive.rw_rule_p", "tactic.interactive.rec.to_tactic_format", "string.inhabited", "tactic.interactive.obtain_parse", "string.split_on", "tactic.interactive.guard_hyp_nums", "tactic.lift", "simps_add_projections", "tactic.abstract", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "tactic.interactive.simp_core_aux", "tactic.right", "tactic.fail_if_success", "string.iterator.zero_lt_length_next_to_string_of_has_next", "string.push", "tactic.trace_error", "tactic.mk_patterns", "expr.to_string", "name.append_suffix", "print_decls_sorted_mathlib", "doc_blame_report_defn", "string.has_sizeof", "pos_line", "string_to_name", "string.str_ne_str_right", "string.to_list", "tactic.match_heq", "loc.to_string_aux", "tactic.get_string_option", "string.intercalate", "to_additive.value_type.inhabited", "tactic.by_cases", "parser.fail", "rsimp_attr", "show_goal_cmd", "tactic.interactive.library_search", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.subobject_names", "string.is_empty", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "linter_attr", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.eqn_stub", "tactic.ac_refl", "string.split", "where.trace_opens", "name.is_private", "simps_attr", "string.backn", "tactic.match_not", "string.empty_ne_str", "name.from_components", "name.deinternalize_field", "has_to_string", "ematch", "smt_tactic.slift_aux", "name", "tactic.iterate1", "tactic.interactive.haveI", "tactic.olean_doc_strings", "string.is_suffix_of", "tactic.match_ne", "rsimp.rsimplify_at", "buffer.has_repr", "tactic.list_constructors_hole", "to_string", "exceptional.to_string", "environment.decl_olean", "name.to_string", "tactic.revert_and_transform", "format.of_string", "parser.one_of", "tactic.local_def_value", "lean.parser.emit_code_here", "lean.parser.tk", "tactic.use", "has_repr", "level.to_string", "tactic.unsafe.type_context.print_mvars", "native.rb_set.has_to_format", "tactic.interactive.obtain", "parser.many_char1", "subsingleton_info_to_format", "where.trace_end", "monad_fail_lift", "tactic.contradiction", "hex_digit_repr", "tactic.rcases_patt_parse", "tactic.mk_has_reflect_instance", "bool.has_to_string", "buffer.append_string", "decidable.has_to_string", "print_item_crawl", "tactic.interactive.success_if_fail_with_msg", "tactic.match_and", "tactic.alias.alias_cmd", "conv.interactive.find", "binder.to_string", "prod.has_to_format", "string.iterator.insert", "tactic.alias.alias_direct", "lint_hole_cmd", "vm.get_line", "string.has_decidable_eq", "lean.special_version_desc", "string.iterator.prev_to_string", "tactic.interactive.simp_intros", "tactic.pformat_macro", "format_macro", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "list.to_string_aux", "option.has_to_format", "tactic.explode.pad_right", "tactic.iff_mpr", "tactic.unfold_projs", "list.as_string", "linter", "interactive.parse_binders", "name.head", "tactic.by_contradiction", "vm.put_str", "tactic.interactive.clear_", "tactic.explode.has_to_tactic_format", "interaction_monad.failed", "tactic.match_iff", "parser.decorate_errors", "tactic.set_string_option", "tactic.match_refl_app", "parser.run", "tactic.fsplit", "undefined_core", "open_locale_cmd", "list.to_format", "simps_parser", "get_linters", "tactic.injection_with", "tactic.interactive.convert_to", "tactic.interactive.congr'", "char_to_hex", "options.set_string", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "string.is_prefix_of", "tactic.interactive.change", "name.last_string", "tactic.match_stub", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "declaration.is_auto_generated", "user_attribute", "string.str_ne_str_left", "tactic.def_replacer", "string.has_append", "string.append", "binder.has_to_tactic_format", "tactic.mk_simp_set_core", "tactic.simp_hyp", "tactic.explode.format_aux", "binder.has_to_format", "linter.doc_blame", "string.has_decidable_lt", "declaration.get_kind_string", "tactic.solve1", "loc.to_string", "tactic.alias.alias_iff", "tactic.interactive.simpa", "tactic.ext1", "tactic.interactive.specialize", "my_name_to_string", "tactic.explode.entry", "tactic.prove_goal_async", "buffer.to_string", "string.has_repr", "environment.for_decl_of_imported_module_name", "parser.failure", "tactic.split", "parse_result", "fold_over_with_cond_sorted", "string.iterator.to_string", "char.quote_core", "impossible_instance", "parser.str", "parser.many_char", "incorrect_type_class_argument", "string.has_lt", "decidable.has_repr", "tactic.iff_mp", "tactic.assumption", "name.to_string_with_sep", "tactic.mk_assoc_instance", "tactic.add_doc_string", "mk_hinst_lemma_attr_set", "string.front", "smt_tactic.by_contradiction", "sformat_macro", "format.bracket", "instance_priority", "bool.has_repr", "smt_tactic.by_cases", "instance_derive_handler", "tactic.interactive.mk_paragraph", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "tactic.get_mathlib_dir", "native.float.has_to_format", "monad_fail", "tactic.delta_instance", "string.join", "where.format_variable", "tactic.interactive.h_generalize", "tactic.unsafe.type_context.failure", "interactive.param_desc", "tactic.alias.make_left_right", "string.length", "tactic.get_lift_prf", "tactic.interactive.case", "tactic.suggest.application", "tactic.injections_and_clear", "dangerous_instance", "mk_hinst_lemma_attr_core", "tactic.interactive.parse_config", "parser.decorate_error", "conv.convert", "tactic.find_private_decl", "string.has_to_format", "where.compile_variable_list", "doc_blame_report_thm", "tactic.rename'", "mk_str_name", "tactic.replacer_attr", "equiv_type_constr", "tactic.interactive.suggest", "pos.has_to_format", "interactive.types.location", "tactic.has_to_tactic_format", "format.dcbrace", "lint_mathlib", "tactic.done", "ge_or_gt_in_statement", "lint_all", "tactic.ids_to_simp_arg_list", "interactive.decl_meta_info", "has_inhabited_instance", "char.has_repr", "tactic.import_private_cmd", "string.to_nat", "name.last", "tactic.success_if_fail_with_msg", "dup_namespace", "timeit", "tactic.congr_core", "unit.has_to_format", "interactive.types.brackets", "vm.obj_to_string", "tactic.fail_macro", "interaction_monad.monad_fail", "tactic.module_doc_strings", "string.mk_iterator", "tactic.note_anon", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "string.has_append", "parentIds": ["declaration.modifiers.has_to_string", "string.quote", "to_additive.target_name", "where.mk_flag", "tactic.mk_simp_attribute_cmd", "restate_axiom_cmd", "to_additive.proceed_fields", "native.has_to_string", "rbtree.has_repr", "tactic.terminal_goal", "localized_cmd", "simps_tac", "interaction_monad.result_to_string", "rbmap.has_repr", "name.add_prime", "tactic.suggest.tactic_statement", "mk_hinst_lemma_attr_from_simp_attr", "rsimp_attr", "tactic.subobject_names", "exceptional.to_string", "tactic.interactive.obtain", "print_item_crawl", "tactic.alias.alias_cmd", "binder.to_string", "tactic.interactive.simp_intros", "char_to_hex", "list_linters", "tactic.def_replacer", "my_name_to_string", "char.quote_core", "impossible_instance", "incorrect_type_class_argument", "tactic.delta_instance", "string.join", "where.format_variable", "tactic.interactive.h_generalize", "tactic.interactive.case", "dangerous_instance", "tactic.replacer_attr", "tactic.ids_to_simp_arg_list", "char.has_repr", "tactic.import_private_cmd", "dup_namespace"]}, {"id": "bool.to_string_python", "parentIds": ["declaration.modifiers.has_to_string"]}, {"id": "int.add_one_le_of_lt", "parentIds": []}, {"id": "int.has_add", "parentIds": ["int.add_one_le_of_lt", "int.decidable_lt", "int.of_nat_ge_zero", "int.lt_of_add_one_le", "int.add_comm", "int.le.dest", "int.coe_nat_add_out", "int.lt.intro", "int.nat_abs_bit1_nonneg_step", "int.le_of_lt_add_one", "int.add_assoc", "int.le_of_coe_nat_le_coe_nat", "int.bit", "int.lt.elim", "int.add_zero", "int.distrib_right", "int.lt_succ", "int.nat_abs_add_neg", "int.lt_add_succ", "int.nat_abs_add_nonneg", "int.add_left_neg", "int.nat_abs_bit0_step", "int.coe_nat_lt_coe_nat_iff", "int.sub_nat_nat_eq_coe", "int.of_nat_sub", "int.distrib_left", "int.lt_irrefl", "int.bit1_pos", "int.add_lt_add_left", "int.coe_nat_add_one_out", "int.le_antisymm", "int.lt_iff_le_and_ne", "int.bit1_nonneg", "int.le.intro", "int.coe_nat_add", "int.le_trans", "int.nat_abs_bit0", "int.zero_add", "int.mul_pos", "int.eq_succ_of_zero_lt", "int.bit0_pos", "int.coe_nat_succ", "int.nat_abs_bit1_nonneg", "int.add_le_add_left", "int.neg_succ_of_nat_eq", "int.coe_nat_le_coe_nat_of_le", "int.mul_nonneg", "int.le.elim", "int.of_nat_add", "int.lt_add_one_of_le", "int.of_nat_succ", "int.lt.dest", "int.bit0_nonneg", "int.lt_iff_add_one_le", "int.neg_succ_of_nat_lt_zero", "int.le_of_lt", "int.lt"]}, {"id": "group.to_has_inv", "parentIds": ["eq_inv_iff_mul_eq_one", "eq_mul_inv_iff_mul_eq", "mul_inv_rev", "mul_eq_one_iff_inv_eq", "one_inv", "mul_inv", "eq_inv_iff_eq_inv", "inv_eq_iff_inv_eq", "mul_right_surjective", "eq_inv_mul_iff_mul_eq", "mul_eq_one_iff_eq_inv", "mul_eq_of_eq_inv_mul", "inv_ne_one", "mul_inv_eq_iff_eq_mul", "mul_inv_cancel_left", "mul_right_inv", "mul_inv_self", "eq_inv_of_eq_inv", "inv_mul_cancel_left", "mul_eq_of_eq_mul_inv", "eq_of_inv_eq_inv", "inv_eq_one", "inv_inj'", "group.mul_left_cancel", "inv_involutive", "inv_inj", "mul_inv_eq_one", "inv_comm_of_comm", "eq_mul_inv_of_mul_eq", "mul_left_surjective", "eq_mul_of_inv_mul_eq", "inv_mul_self", "mul_inv_eq_of_eq_mul", "inv_inv", "inv_eq_of_mul_eq_one", "eq_inv_of_mul_eq_one", "left_inverse_inv", "eq_inv_mul_of_mul_eq", "mul_left_inv", "mul_inv_cancel_right", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "eq_mul_of_mul_inv_eq", "inv_mul_eq_iff_eq_mul", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "group", "parentIds": ["group.to_has_inv", "eq_inv_iff_mul_eq_one", "group.to_left_cancel_semigroup", "mul_right_eq_self", "eq_mul_inv_iff_mul_eq", "mul_inv_rev", "mul_eq_one_iff_inv_eq", "one_inv", "comm_group.to_group", "eq_inv_iff_eq_inv", "mul_self_iff_eq_one", "inv_eq_iff_inv_eq", "mul_right_surjective", "eq_inv_mul_iff_mul_eq", "mul_eq_one_iff_eq_inv", "mul_eq_of_eq_inv_mul", "inv_ne_one", "mul_left_eq_self", "mul_inv_eq_iff_eq_mul", "mul_inv_cancel_left", "group.to_right_cancel_semigroup", "mul_right_inv", "mul_inv_self", "eq_inv_of_eq_inv", "inv_mul_cancel_left", "mul_eq_of_eq_mul_inv", "eq_of_inv_eq_inv", "inv_eq_one", "inv_inj'", "group.mul_left_cancel", "group.to_monoid", "inv_involutive", "inv_inj", "mul_inv_eq_one", "inv_comm_of_comm", "eq_mul_inv_of_mul_eq", "mul_left_surjective", "eq_mul_of_inv_mul_eq", "inv_mul_self", "mul_inv_eq_of_eq_mul", "inv_inv", "inv_eq_of_mul_eq_one", "eq_inv_of_mul_eq_one", "left_inverse_inv", "eq_inv_mul_of_mul_eq", "mul_left_inv", "mul_inv_cancel_right", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "eq_mul_of_mul_inv_eq", "inv_mul_eq_iff_eq_mul", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "has_inv", "parentIds": ["group.to_has_inv", "division_def", "discrete_field", "eq_inv_iff_mul_eq_one", "eq_mul_inv_iff_mul_eq", "mul_inv_rev", "mul_inv_eq", "mul_eq_one_iff_inv_eq", "one_inv", "mul_zero_lt_mul_inv_of_neg", "comm_group", "one_div_eq_inv", "div_mul_eq_mul_div", "inv_ne_zero", "mul_inv", "division_ring.to_has_inv", "one_div_zero", "div_mul_cancel", "div_self", "mul_zero_lt_mul_inv_of_pos", "eq_inv_iff_eq_inv", "inv_eq_iff_inv_eq", "division_ring", "algebra.div", "mul_right_surjective", "eq_inv_mul_iff_mul_eq", "mul_eq_one_iff_eq_inv", "mul_eq_of_eq_inv_mul", "inv_ne_one", "mul_one_div_cancel", "zero_div", "mul_inv_eq_iff_eq_mul", "discrete_linear_ordered_field", "mul_inv_cancel_left", "mul_right_inv", "mul_inv_self", "one_inv_eq", "eq_inv_of_eq_inv", "inv_mul_cancel_left", "group", "mul_inv_cancel", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "mul_eq_of_eq_mul_inv", "eq_of_inv_eq_inv", "inv_eq_one", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "inv_inj'", "div_eq_mul_one_div", "inv_zero", "group.mul_left_cancel", "mul_inv'", "inv_involutive", "mul_div_assoc", "field.div_mul_right", "inv_inj", "mul_inv_eq_one", "inv_comm_of_comm", "eq_mul_inv_of_mul_eq", "mul_left_surjective", "div_eq_one_iff_eq", "eq_mul_of_inv_mul_eq", "inv_mul_self", "field", "div_add_div_same", "mul_inv_eq_of_eq_mul", "inv_inv", "div_one", "inv_eq_of_mul_eq_one", "eq_inv_of_mul_eq_one", "left_inverse_inv", "mul_div_cancel", "inv_mul_cancel", "eq_inv_mul_of_mul_eq", "division_ring.inv_inv", "div_neg_eq_neg_div", "mul_left_inv", "one_div_add_one_div", "mul_mul_div", "linear_ordered_field", "mul_inv_cancel_right", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "eq_mul_of_mul_inv_eq", "inv_eq_one_div", "inv_mul_eq_iff_eq_mul", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "function.bijective_comp", "parentIds": []}, {"id": "function.surjective", "parentIds": ["function.bijective_comp", "function.surjective.of_comp", "function.surj_inv_eq", "function.left_inverse_surj_inv", "function.involutive.surjective", "function.bijective", "add_right_surjective", "function.surjective.has_right_inverse", "function.surjective_of_has_right_inverse", "function.surj_inv", "forall_iff_forall_surj", "mul_right_surjective", "function.right_inverse_surj_inv", "function.injective_surj_inv", "function.inv_fun_surjective", "function.surjective_iff_has_right_inverse", "function.left_inverse_of_surjective_of_right_inverse", "function.surjective_comp", "function.surjective_id", "mul_left_surjective", "function.involutive.bijective", "function.cantor_surjective", "add_left_surjective", "function.bijective_id", "function.right_inverse_inv_fun", "function.bijective_iff_has_inverse"]}, {"id": "function.injective_comp", "parentIds": ["function.bijective_comp"]}, {"id": "function.surjective_comp", "parentIds": ["function.bijective_comp"]}, {"id": "function.bijective", "parentIds": ["function.bijective_comp", "function.left_inverse_surj_inv", "function.involutive.bijective", "function.bijective_id", "function.bijective_iff_has_inverse"]}, {"id": "function.injective", "parentIds": ["function.bijective_comp", "function.injective_of_has_left_inverse", "function.left_inverse_surj_inv", "function.bijective", "function.injective.decidable_eq", "sum.elim_injective", "function.left_inverse_inv_fun", "function.injective.eq_iff", "function.inv_fun_eq_of_injective_of_right_inverse", "function.injective.of_comp", "add_left_injective", "function.injective_of_partial_inv", "function.injective_surj_inv", "function.injective_prod", "function.involutive.injective", "function.inv_fun_surjective", "add_right_injective", "function.injective.ne", "function.partial_inv_left", "function.injective_iff_has_left_inverse", "mul_left_injective", "function.injective_comp", "function.involutive.bijective", "function.injective_of_left_inverse", "function.bijective_id", "function.injective_id", "mul_right_injective", "function.inv_fun_comp", "function.partial_inv_of_injective", "function.right_inverse_of_injective_of_left_inverse", "function.cantor_injective", "function.bijective_iff_has_inverse", "function.injective.has_left_inverse", "function.update_comp"]}, {"id": "int.decidable_lt", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "list.enum", "parentIds": ["instance_derive_handler"]}, {"id": "list.enum_from", "parentIds": ["list.enum"]}, {"id": "nat.has_zero", "parentIds": ["list.enum", "nat.eq_zero_of_add_eq_zero", "nat.pred_zero", "char.val_of_nat_eq_of_is_valid", "nat.zero_ne_one_class", "fin.of_nat_zero", "parser.eof", "nat.pos_of_ne_zero", "nat.mod_lt", "nat.eq_zero_or_eq_succ_pred", "nat.div_eq_of_lt", "nat.bitwise_zero", "nat.one_ne_zero", "nat.bit_zero", "nat.pow_le_pow_of_le_left", "nat.shiftl_eq_mul_pow", "param_info.to_format", "nat.shiftl'_add", "tactic.elide.unelide", "nat.one_lt_bit0", "nat.add_one_ne_zero", "nat.mul_div_mul", "nat.not_succ_le_zero", "nat.eq_zero_of_add_eq_zero_left", "unsigned.has_zero", "array.take", "char.of_nat_eq_of_not_is_valid", "nat.mul_div_assoc", "expr.to_nat", "d_array.nil", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "nat.div_def", "nat.sub_eq_zero_of_le", "nat_add_zero", "nat.test_bit_bitwise", "nat.eq_of_mul_eq_mul_right", "nat.pred_le", "nat.not_lt_zero", "nat.add_div_left", "nat.bodd_add_div2", "list.length_le_of_sublist", "nat.add_mul_div_right", "nat.bodd_add", "nat.gcd_zero_left", "nat.zero_lt_one", "int.neg_of_nat_zero", "nat.zero_le", "list.length_append", "string.iterator.length_next_to_string_next", "nat.pow_lt_pow_of_lt_right", "nat.zero_lt_one_add", "nat.le_mul_self", "nat.lt_add_of_pos_left", "nat.mul_div_right", "nat.shiftr_eq_div_pow", "nat.mod_one", "char.val_of_nat_eq_of_not_is_valid", "interactive.types.pexpr_list", "nat.binary_rec_eq", "nat.eq_zero_or_pos", "nat.pred_lt_pred", "nat.nat_zero_eq_zero", "int.of_nat_zero", "tactic.library_search", "nat.mod_two_of_bodd", "nat.lt_wf", "int.nat_abs_pos_of_ne_zero", "nat.binary_rec_zero", "list.length_drop", "nat.add_mul_div_left", "nat.add_self_ne_one", "list.length_map", "nat.zero_lt_succ", "tactic.mllist.enum", "nat.sub_eq_sub_min", "nat.sub_mul_mod", "nat.div_def_aux", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "nat.sub_induction", "nat.zero_mul", "nat.bit0_inj", "tactic.constr_to_prop", "nat.mod_eq_of_lt", "nat.bitwise_zero_left", "nat.zero_shiftr", "nat.bitwise", "nat.add_comm", "nat.one_le_bit0", "char.of_nat", "int.add_left_neg", "nat.lt_of_sub_eq_succ", "nat.shiftl'_sub", "nat.one_le_bit1", "nat.add_sub_cancel", "nat.mul_zero", "int.of_nat_sub", "int.coe_nat_zero", "nat.div_le_of_le_mul", "nat.lt_add_of_pos_right", "nat.sub_pos_of_lt", "nat.mul_mod_mul_left", "nat.bodd_mul", "norm_num.sub_nat_zero_helper", "int.distrib_left", "tactic.lift", "tactic.abstract", "int.lt_irrefl", "nat.div2_zero", "nat.bodd_zero", "nat.mod_le", "tactic.interactive.simp_core_aux", "nat.mk_numeral", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.gcd.induction", "nat.zero_sub", "nat.eq_zero_of_mul_eq_zero", "nat.pos_of_dvd_of_pos", "nat.div_eq_of_eq_mul_right", "nat.mul_div_cancel'", "int.le_antisymm", "nat.lt_add_of_zero_lt_left", "list.indexes_values", "buffer.lt_aux_2", "nat.sub_self", "int.lt_iff_le_and_ne", "nat.one_ne_bit1", "nat.add_left_cancel", "nat.zero_mod", "unsigned.of_nat'", "nat.succ_pos", "nat.digit_char", "list.map_with_index", "tactic.mk_inhabited_instance", "string.is_empty", "nat.sub_lt_of_pos_le", "nat.add_sub_add_right", "nat.bit_decomp", "nat.add_sub_cancel_left", "nat.bit1_ne_bit0", "nat.gcd_one_left", "nat.eq_zero_of_le_zero", "nat.bitwise_swap", "nat.bitwise_zero_right", "nat.shiftr_add", "nat.size", "int.zero", "list.length_take", "nat.mul_pred_left", "nat.bitwise_bit", "find_cmd", "nat.zero_ne_bit1", "tactic.mllist.range", "tactic.apply_under_pis", "d_array.of_beq_aux_eq_ff", "nat.bitwise_bit_aux", "nat.eq_one_of_dvd_one", "nat.case_strong_induction_on", "expr.replace_with", "nat.sub_self_add", "nat.discriminate", "nat.mul_lt_mul_of_pos_left", "nat.sub_one_sub_lt", "list.find_indexes", "nat.succ_add", "nat.dvd_of_mul_dvd_mul_right", "buffer.lt_aux_3", "nat.zero_min", "tactic.interactive.generalize", "nat.add_zero", "tactic.mk_has_reflect_instance", "nat.succ_ne_zero", "expr.pi_arity", "native.float.has_zero", "nat.mul_mod_left", "nat.add_div_right", "nat.mul_lt_mul_of_pos_right", "nat.div_lt_self", "nat.mul_mod_right", "nat.div2_val", "nat.mod_zero", "nat.mul_div_left", "lean.is_release", "nat.div_eq_of_lt_le", "tactic.explode.pad_right", "nat.le.dest", "tactic.explode_expr", "nat.one_succ_zero", "buffer.append_array", "nat.dvd_iff_mod_eq_zero", "nat.one_pos", "nat.bit0_ne_one", "nat.div_le_self", "nat.bodd_bit", "nat.pos_pow_of_pos", "nat.sub_mul_div", "nat.pred_lt", "nat.exists_eq_succ_of_ne_zero", "parser.run", "nat.left_distrib", "nat.mod_self", "nat.right_distrib", "tactic.interactive.convert_to", "nat.zero_lt_bit1", "int.pos_of_sign_eq_one", "tactic.fail_if_no_goals", "nat.zero_ne_one", "nat.sub_sub", "nat.div2_bit", "nat.not_succ_le_self", "mk_buffer", "nat.sub_zero", "nat.mul_sub_right_distrib", "nat.le_of_sub_eq_zero", "nat.succ_ne_self", "int.neg_of_sign_eq_neg_one", "nat.zero_ne_bit0", "nat.gcd_zero_right", "nat.bit_val", "nat.div_eq_sub_div", "nat.pow_lt_pow_of_lt_left", "nat.dvd_of_mod_eq_zero", "int.le_refl", "nat.zero_div", "nat.mod_def_aux", "nat.test_bit_zero", "nat.mod_add_div", "nat.two_step_induction", "nat.mod_eq_sub_mod", "nat.mul_div_cancel_left", "nat.dvd_of_mul_dvd_mul_left", "tactic.interactive.clean", "int.to_nat_sub", "environment.inhabited", "nat.bit1_ne_zero", "nat.min_zero", "nat.binary_rec", "nat.sub_le", "nat.zero_shiftl", "nat.succ_mul", "list.length_map\u2082", "char.zero_lt_d800", "tactic.interactive.rw_rules", "nat.div_self", "tactic.mk_replacer", "nat.div_mul_le_self", "nat.bit1_ne_one", "nat.shiftl_zero", "nat.sub_eq_zero_iff_le", "nat.pow_zero", "tactic.interactive.mk_paragraph", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "nat.mod_two_eq_zero_or_one", "int.eq_zero_of_sign_eq_zero", "nat.mul_comm", "nat.gcd_rec", "nat.sub_lt", "nat.eq_of_mul_eq_mul_left", "nat.add_mul_mod_self_left", "nat.pred_inj", "int.coe_succ_pos", "where.format_variable", "nat.mod_pow_succ", "nat.zero_pow", "tactic.rotate_right", "nat.mod_def", "nat.bit0_ne_zero", "nat.one_lt_bit1", "fin.val_zero", "nat.le_div_iff_mul_le", "conv.convert", "nat.div_lt_iff_lt_mul", "nat.decidable_dvd", "list.length_repeat", "list.length_remove_nth", "fin.elim0", "nat.zero_add", "tactic.interactive.suggest", "nat.bit1_lt_bit0", "array.nil", "nat.gcd_self", "nat.shiftl'_tt_eq_mul_pow", "int.eq_zero_of_nat_abs_eq_zero", "nat.div_zero", "int.zero_ne_one", "nat.gcd_def", "tactic.done", "nat.cond_to_bool_mod_two", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "string.to_nat", "nat.zero_lt_bit0", "nat.find_x", "nat.div2_one", "expr.of_nat", "nat.div_one", "fin.has_zero", "int.coe_zero_le", "nat.succ_pred_eq_of_pos", "nat.mod_eq_zero_of_dvd", "tactic.get_pi_binders_dep", "int.nat_abs_zero", "nat.add_assoc", "nat.mul_div_cancel", "nat.pow_one", "nat.eq_zero_of_add_eq_zero_right", "list.eq_nil_of_length_eq_zero"]}, {"id": "tactic.clear_lst", "parentIds": ["tactic.interactive.induction", "tactic.interactive.clear"]}, {"id": "lean.parser.many", "parentIds": ["lean.parser.sep_by", "smt_tactic.interactive.induction", "tactic.interactive.guard_tags", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "smt_tactic.interactive.intros", "tactic.interactive.clear_dependent", "interactive.types.with_ident_list", "apply_nolint_cmd", "tactic.interactive.clear'", "tactic.interactive.unfold1", "tactic.ext_parse", "smt_tactic.interactive.add_eqn_lemmas", "tactic.rintro_parse", "interactive.types.without_ident_list", "smt_tactic.interactive.add_eqn_lemmas_for", "tactic.interactive.clear", "tactic.interactive.substs", "tactic.ancestor_attr", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.simp_intros", "open_locale_cmd", "simps_parser", "tactic.interactive.funext", "tactic.interactive.dunfold", "tactic.interactive.clear_except", "tactic.interactive.intros", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "tactic.interactive.introsI", "interactive.types.location", "tactic.interactive.delta", "tactic.interactive.generalize_proofs"]}, {"id": "return", "parentIds": ["lean.parser.sep_by", "tactic.find_if_cond_at", "tactic.replace_at", "tactic.library_search_hole_cmd", "tactic.trace", "tactic.mk_const", "tactic.instance_cache.get", "get_localized", "tactic.delta", "interactive.types.ident_", "tactic.focus1", "infer_type_cmd", "option_to_tactic_format", "tactic.mk_constructor_arg_names", "name_set.mfold", "expr.mk_exists_lst", "interactive.types.opt_pexpr_list", "smt_tactic.definev", "environment.mfold", "smt_tactic.set_goals", "lean.parser.reflectable.optional", "tactic.cases", "unused_arguments", "tactic.cc_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "print_arguments", "tactic.get_constructors_for", "tactic.mk_assumption_set", "tactic.instance_cache.append_typeclasses", "tactic.dsimplify", "tactic.interactive.loc.get_local_pp_names", "old_conv.skip", "interactive.types.only_flag", "tactic.simplify_top_down", "tactic.get_env", "where.mk_flag", "simp_attr.pre_smt", "tactic.is_prop", "using_smt", "conv.lhs", "tactic.match_or", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "tactic.get_pi_binders", "tactic.interactive.get_rule_eqn_lemmas", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "old_conv.trace", "tactic.explode.append_dep", "incorrect_def_lemma", "tactic.interactive.solve_by_elim", "has_dup", "lean.parser.emit_command_here", "old_conv.dsimp", "tactic.interactive.apply_assumption", "tactic.elim_gen_sum", "localized_attr", "native.rb_map.has_to_tactic_format", "old_conv.istep", "tactic.match_app_of", "push_neg.normalize_negations", "old_conv.change", "tactic.non_dep_prop_hyps", "use_cmd", "tactic.mk_simp_attr", "tactic.interactive.have_field", "tactic.mllist.head", "interactive.types.with_ident_list", "smt_tactic.interactive.have", "tactic.mk_dec_eq_instance", "tactic.suggest_scripts", "tactic_format_expr", "to_additive.parser", "tactic.instance_cache.mk_app", "tactic.assoc_rewrite_intl", "tactic.library_search", "can_lift_attr", "tactic.mk_local'", "old_conv.apply_lemmas_core", "tactic.mk_user_fresh_name", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.main_goal", "old_conv.to_tactic", "tactic.rewrite", "tactic.i_to_expr_for_apply", "smt_tactic.classical", "tactic.constr_to_prop", "tactic.local_proof", "interactive.types.without_ident_list", "tactic.solve_aux", "tactic.suggest.message", "tactic.match_eq", "tactic.get_goal", "lint", "tactic.interactive.letI", "tactic.instance_stub", "tactic.in_open_namespaces", "tactic.has_opt_auto_param", "tactic.simp_top_down", "no_rsimp", "tactic.suggest.tactic_statement", "tactic.rintro", "conv.funext", "old_conv.match_pattern", "tactic.constructor_idx", "tactic.constructor_num_fields", "old_conv.funext", "tactic.is_type_app_of", "tactic.dependent_pose_core", "tactic.interactive.obtain_parse", "lean.parser.of_tactic'", "tactic.lift", "tactic.abstract", "conv.dsimp", "tactic.interactive.simp_core_aux", "tactic.get_simp_lemmas_or_default", "monad.whenb", "smt_tactic.focus1", "doc_blame_report_defn", "smt_tactic.get_facts", "tactic.assert", "tactic.match_heq", "tactic.get_string_option", "tactic.explode.may_be_proof", "declaration.in_current_file", "show_goal_cmd", "tactic.add_theorem_by", "tactic.interactive.by_contradiction", "tactic.explode", "tactic.simp_bottom_up", "tactic.subobject_names", "old_conv.find_pattern", "tactic.has_opt_auto_param_for_apply", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.mk_id_eq", "tactic.eqn_stub", "tactic.ac_refl", "tactic.mk_constructors_arg_names", "old_conv.lhs", "tactic.match_not", "well_founded_tactics.is_psigma_mk", "tactic.mk_local_pis_whnf", "smt_tactic.slift_aux", "tactic.decl_mk_const", "parser.eps", "native.rb_set.mfold", "tactic.iterate1", "tactic.interactive.haveI", "smt_tactic.get_refuted_facts", "tactic.match_ne", "old_conv.save_info", "tactic.list_constructors_hole", "smt_tactic.assertv", "simp_attr.functor_norm", "simp_attr.norm", "name_with_opt", "parser.one_of", "tactic.local_def_value", "mnot", "old_conv.congr_core", "where.get_opens", "expr.is_eta_expansion_aux", "tactic.fold_explicit_args", "tactic.simplify_bottom_up", "tactic.apply", "old_conv.apply_propext_lemmas_core", "expr.mfold", "tactic.mk_has_reflect_instance", "parser.sep_by", "tactic.match_and", "conv.interactive.find", "tactic.interactive.to_expr'", "rsimp.to_repr_map", "native.rb_map.mfold", "lint_hole_cmd", "rsimp.collect_implied_eqs", "tactic.relation_lhs_rhs", "tactic.pformat_macro", "tactic.unfold_projs", "tactic.define", "tactic.by_contradiction", "simp_attr.split_if_reduction", "tactic.interactive.clear_", "tactic.interactive.return_cast", "cc_state.mfold_eqc", "tactic.match_iff", "vm.trace", "tactic.match_refl_app", "tactic.rcases", "rsimp.choose", "lean.parser.reflectable.has_reflect", "smt_tactic.get_goals", "tactic.injection_with", "tactic.save_options", "hinst_lemmas.pp", "tactic.match_stub", "lint_aux", "tactic.injection", "tactic.mk_simp_set_core", "linter.doc_blame", "tactic.get_options", "conv.interactive.for", "tactic.with_enable_tags", "smt_tactic.read", "tactic.interactive.refine_one", "tactic.prove_goal_async", "old_conv.whnf", "tactic.get_nat_option", "old_conv.find", "fold_over_with_cond_sorted", "old_conv.top_down", "impossible_instance", "monad.unlessb", "old_conv.bind", "incorrect_type_class_argument", "rsimp.rsimplify", "tactic.new_aux_decl_name", "tactic.decode_simp_arg_list", "conv.interactive.simp", "conv.step", "mwhen", "where.is_variable_name", "tactic.interactive.rw_rules", "old_conv.bottom_up", "instance_priority", "where.fetch_potential_variable_names", "tactic.simp_arg_list", "tactic.get_mathlib_dir", "tactic.simp_arg", "smt_tactic.induction", "old_conv.pure", "environment.mfilter", "tactic.is_prop_decl", "tactic.delta_instance", "get_checks", "tactic.flatten", "tactic.interactive.list_cast_of_aux", "old_conv.seq", "where.format_variable", "interactive.param_desc", "smt_tactic.skip", "has_to_format_to_has_to_tactic_format", "conv.congr", "tactic.suggest", "tactic.get_lift_prf", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "saturate_fun", "where.get_all_in_namespace", "tactic.replace_hyp", "dangerous_instance", "conv.rhs", "conv.convert", "tactic.find_private_decl", "tactic.induction'", "doc_blame_report_thm", "tactic.mk_eq_proof", "old_conv.step", "interactive.types.location", "tactic.has_to_tactic_format", "environment.get_modifiers", "tactic.suggest.library_defs", "tactic.intros1", "tactic.get_bool_option", "tactic.mk_instance_cache", "old_conv.map", "lint_mathlib", "tactic.num_goals", "ge_or_gt_in_statement", "lint_all", "tactic.ids_to_simp_arg_list", "tactic.run_async", "old_conv.lift_tactic", "dup_namespace", "old_conv.mk_match_expr", "tactic.mk_sorry", "old_conv.match_expr"]}, {"id": "smt_tactic.interactive.assume", "parentIds": []}, {"id": "interactive.types.tac_rbp", "parentIds": ["smt_tactic.interactive.assume", "interactive.types.texpr", "tactic.interactive.assume"]}, {"id": "interactive.parse", "parentIds": ["smt_tactic.interactive.assume", "tactic.interactive.squeeze_simp", "where.where_cmd", "tactic.interactive.cases", "smt_tactic.interactive.destruct", "tactic.interactive.field_simp", "tactic.interactive.from", "smt_tactic.interactive.induction", "tactic.interactive.guard_tags", "tactic.interactive.guard_target_strict", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "tactic.interactive.by_contra", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "tactic.interactive.min_tac", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "tactic.interactive.rcases", "tactic.interactive.unfold_coes", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "smt_tactic.interactive.intros", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "tactic.interactive.split_ifs", "tactic.interactive.clear_dependent", "lint_cmd", "smt_tactic.interactive.have", "tactic.interactive.refine", "apply_nolint_cmd", "tactic.interactive.clear'", "tactic.interactive.lift", "tactic.trace_macro", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "localized_cmd", "smt_tactic.interactive.add_eqn_lemmas", "conv.interactive.guard_lhs", "tactic.interactive.abstract", "tactic.interactive.let", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "smt_tactic.interactive.dsimp", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.simp", "tactic.interactive.type_check", "tactic.interactive.refine_struct", "tactic.interactive.elide", "tactic.interactive.guard_hyp_strict", "tactic.interactive.ext1", "tactic.interactive.iterate", "tactic.interactive.rintros", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "tactic.def_replacer_cmd", "lint_all_cmd", "tactic.interactive.clear", "tactic.interactive.injection", "tactic.interactive.exact", "tactic.interactive.existsi", "tactic.interactive.suffices", "conv.interactive.rw", "tactic.interactive.by_contradiction", "tactic.interactive.rename", "smt_tactic.interactive.let", "old_conv.interactive.find", "tactic.interactive.simp_rw", "smt_tactic.interactive.add_lemma", "conv.interactive.change", "tactic.interactive.exactI", "find_cmd", "tactic.interactive.substs", "tactic.interactive.assume", "tactic.interactive.haveI", "tactic.interactive.obtain", "tactic.interactive.guard_hyp", "tactic.interactive.erw", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.interactive.transitivity", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.ext", "tactic.interactive.unelide", "tactic.interactive.show", "tactic.interactive.assoc_rw", "tactic.interactive.simp_intros", "tactic.pformat_macro", "tactic.interactive.erewrite", "format_macro", "tactic.interactive.rintro", "tactic.interactive.guard_target'", "tactic.interactive.replace", "tactic.interactive.find", "tactic.interactive.subst", "tactic.rcases", "tactic.interactive.constructor_matching", "open_locale_cmd", "tactic.interactive.conv", "tactic.interactive.guard_expr_strict", "tactic.interactive.intro", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "tactic.interactive.funext", "tactic.interactive.congr'", "tactic.interactive.assoc_rewrite", "tactic.interactive.exacts", "tactic.interactive.change", "list_linters", "tactic.interactive.conv_rhs", "conv.interactive.erw", "tactic.interactive.match_target", "smt_tactic.interactive.eblast_using", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.mapply", "tactic.interactive.specialize", "tactic.interactive.apply_with", "tactic.interactive.fapply", "conv.interactive.rewrite", "tactic.interactive.guard_expr_eq", "tactic.interactive.casesm", "tactic.interactive.clean", "conv.interactive.simp", "tactic.interactive.guard_expr_eq'", "tactic.interactive.rwa", "tactic.interactive.guard_target", "sformat_macro", "tactic.interactive.introI", "tactic.interactive.dunfold", "tactic.interactive.rw", "smt_tactic.interactive.from", "library_note", "tactic.interactive.extract_goal", "tactic.setup_tactic_parser_cmd", "tactic.interactive.have", "tactic.interactive.field", "smt_tactic.interactive.simp", "tactic.interactive.injections", "tactic.interactive.clear_except", "tactic.interactive.guard_hyp'", "smt_tactic.interactive.change", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "tactic.interactive.apply_rules", "tactic.interactive.destruct", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.ac_change", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "smt_tactic.interactive.by_cases", "tactic.explode_cmd", "tactic.interactive.trace_simp_set", "tactic.interactive.introsI", "tactic.interactive.suggest", "smt_tactic.interactive.add_lhs_lemma", "tactic.interactive.contrapose", "conv.interactive.dsimp", "tactic.interactive.push_neg", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.interactive.rewrite", "old_conv.interactive.change", "tactic.interactive.apply", "tactic.import_private_cmd", "tactic.interactive.delta", "lint_mathlib_cmd", "smt_tactic.interactive.exact", "tactic.fail_macro", "smt_tactic.interactive.fapply", "tactic.interactive.generalize_proofs"]}, {"id": "tactic.interactive.assume", "parentIds": ["smt_tactic.interactive.assume"]}, {"id": "sum.has_reflect", "parentIds": ["smt_tactic.interactive.assume", "tactic.interactive.rcases", "tactic.interactive.rintros", "tactic.interactive.assume", "tactic.interactive.rintro"]}, {"id": "lean.parser.reflectable.has_reflect", "parentIds": ["smt_tactic.interactive.assume", "tactic.interactive.squeeze_simp", "where.where_cmd", "tactic.interactive.cases", "smt_tactic.interactive.destruct", "tactic.interactive.field_simp", "tactic.interactive.from", "smt_tactic.interactive.induction", "tactic.interactive.guard_tags", "tactic.interactive.guard_target_strict", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "tactic.interactive.by_contra", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "tactic.interactive.min_tac", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "tactic.interactive.rcases", "tactic.interactive.unfold_coes", "restate_axiom_cmd", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "smt_tactic.interactive.intros", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "tactic.interactive.split_ifs", "tactic.interactive.clear_dependent", "lint_cmd", "smt_tactic.interactive.have", "tactic.interactive.refine", "apply_nolint_cmd", "tactic.interactive.clear'", "tactic.interactive.lift", "tactic.trace_macro", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "localized_cmd", "smt_tactic.interactive.add_eqn_lemmas", "conv.interactive.guard_lhs", "tactic.interactive.abstract", "tactic.interactive.let", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "smt_tactic.interactive.dsimp", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.simp", "tactic.interactive.type_check", "tactic.interactive.refine_struct", "tactic.interactive.elide", "tactic.interactive.guard_hyp_strict", "tactic.interactive.ext1", "tactic.interactive.iterate", "tactic.interactive.rintros", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "tactic.def_replacer_cmd", "lint_all_cmd", "tactic.interactive.clear", "tactic.interactive.injection", "tactic.interactive.exact", "tactic.interactive.existsi", "tactic.interactive.suffices", "conv.interactive.rw", "tactic.interactive.by_contradiction", "tactic.interactive.rename", "smt_tactic.interactive.let", "old_conv.interactive.find", "tactic.interactive.simp_rw", "smt_tactic.interactive.add_lemma", "conv.interactive.change", "tactic.interactive.exactI", "find_cmd", "tactic.interactive.substs", "tactic.interactive.assume", "tactic.interactive.haveI", "tactic.interactive.obtain", "tactic.interactive.guard_hyp", "tactic.interactive.erw", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.interactive.transitivity", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.ext", "tactic.interactive.unelide", "tactic.interactive.show", "tactic.interactive.assoc_rw", "tactic.interactive.simp_intros", "tactic.pformat_macro", "tactic.interactive.erewrite", "format_macro", "tactic.interactive.rintro", "tactic.interactive.guard_target'", "tactic.interactive.replace", "tactic.interactive.find", "tactic.interactive.subst", "tactic.rcases", "tactic.interactive.constructor_matching", "open_locale_cmd", "tactic.interactive.conv", "tactic.interactive.guard_expr_strict", "tactic.interactive.intro", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "tactic.interactive.funext", "tactic.interactive.congr'", "tactic.interactive.assoc_rewrite", "tactic.interactive.exacts", "tactic.interactive.change", "list_linters", "tactic.interactive.conv_rhs", "conv.interactive.erw", "tactic.interactive.match_target", "smt_tactic.interactive.eblast_using", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.mapply", "tactic.interactive.specialize", "tactic.interactive.apply_with", "tactic.interactive.fapply", "conv.interactive.rewrite", "tactic.interactive.guard_expr_eq", "tactic.interactive.casesm", "tactic.interactive.clean", "conv.interactive.simp", "tactic.interactive.guard_expr_eq'", "tactic.interactive.rwa", "tactic.interactive.guard_target", "sformat_macro", "tactic.interactive.introI", "tactic.interactive.dunfold", "tactic.interactive.rw", "smt_tactic.interactive.from", "library_note", "tactic.interactive.extract_goal", "tactic.setup_tactic_parser_cmd", "tactic.interactive.have", "tactic.interactive.field", "smt_tactic.interactive.simp", "tactic.interactive.injections", "tactic.interactive.clear_except", "tactic.interactive.guard_hyp'", "smt_tactic.interactive.change", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "tactic.interactive.apply_rules", "tactic.interactive.destruct", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.ac_change", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "smt_tactic.interactive.by_cases", "tactic.explode_cmd", "tactic.interactive.trace_simp_set", "tactic.interactive.introsI", "tactic.interactive.suggest", "smt_tactic.interactive.add_lhs_lemma", "tactic.interactive.contrapose", "conv.interactive.dsimp", "tactic.interactive.push_neg", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "tactic.interactive.rewrite", "old_conv.interactive.change", "tactic.interactive.apply", "tactic.import_private_cmd", "tactic.interactive.delta", "lint_mathlib_cmd", "smt_tactic.interactive.exact", "tactic.fail_macro", "smt_tactic.interactive.fapply", "tactic.interactive.generalize_proofs"]}, {"id": "list.reflect", "parentIds": ["smt_tactic.interactive.assume", "interactive.loc.has_reflect", "tactic.interactive.squeeze_simp", "tactic.interactive.cases", "tactic.interactive.field_simp", "smt_tactic.interactive.induction", "tactic.interactive.guard_tags", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "tactic.interactive.rcases", "tactic.interactive.dsimp", "tactic.interactive.cases_matching", "smt_tactic.interactive.intros", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "tactic.interactive.split_ifs", "tactic.interactive.clear_dependent", "tactic.mk_simp_attr", "tactic.interactive.clear'", "tactic.interactive.lift", "tactic.interactive.unfold1", "smt_tactic.interactive.add_eqn_lemmas", "smt_tactic.interactive.add_eqn_lemmas_for", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.interactive.ext1", "tactic.interactive.rintros", "tactic.interactive.squeeze_simpa", "tactic.interactive.clear", "tactic.interactive.injection", "tactic.interactive.existsi", "smt_tactic.interactive.add_lemma", "tactic.interactive.substs", "tactic.interactive.assume", "tactic.interactive.rw_rules_t.has_reflect", "tactic.interactive.obtain", "tactic.interactive.use", "tactic.ancestor_attr", "tactic.interactive.cases_type", "tactic.interactive.ext", "tactic.interactive.simp_intros", "tactic.interactive.rintro", "tactic.interactive.constructor_matching", "tactic.interactive.funext", "tactic.interactive.exacts", "smt_tactic.interactive.eblast_using", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.casesm", "conv.interactive.simp", "mk_hinst_lemma_attr_set", "tactic.interactive.dunfold", "tactic.interactive.extract_goal", "smt_tactic.interactive.simp", "tactic.interactive.injections", "tactic.interactive.clear_except", "smt_tactic.interactive.ematch_using", "tactic.interactive.apply_rules", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "tactic.interactive.trace_simp_set", "tactic.interactive.introsI", "smt_tactic.interactive.add_lhs_lemma", "conv.interactive.dsimp", "tactic.interactive.delta", "tactic.interactive.generalize_proofs"]}, {"id": "interactive.parse_binders", "parentIds": ["smt_tactic.interactive.assume", "tactic.interactive.assume"]}, {"id": "expr.reflect", "parentIds": ["smt_tactic.interactive.assume", "tactic.interactive.squeeze_simp", "tactic.interactive.cases", "tactic.interactive.rw_rule.has_reflect", "smt_tactic.interactive.destruct", "tactic.interactive.from", "smt_tactic.interactive.induction", "tactic.interactive.guard_target_strict", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "tactic.interactive.by_cases", "tactic.interactive.min_tac", "tactic.interactive.induction", "tactic.interactive.rcases", "tactic.interactive.cases_matching", "smt_tactic.interactive.have", "tactic.interactive.refine", "tactic.interactive.lift", "tactic.interactive.generalize_hyp", "conv.interactive.guard_lhs", "tactic.interactive.let", "tactic.interactive.set", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.type_check", "tactic.interactive.refine_struct", "tactic.simp_arg_type.has_reflect", "tactic.interactive.guard_hyp_strict", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "tactic.interactive.injection", "tactic.interactive.exact", "tactic.interactive.existsi", "tactic.interactive.suffices", "smt_tactic.interactive.let", "old_conv.interactive.find", "smt_tactic.interactive.add_lemma", "conv.interactive.change", "tactic.interactive.exactI", "tactic.interactive.assume", "tactic.interactive.haveI", "tactic.interactive.obtain", "tactic.interactive.guard_hyp", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.interactive.transitivity", "tactic.interactive.eapply", "conv.interactive.find", "tactic.interactive.show", "tactic.interactive.guard_target'", "tactic.interactive.replace", "tactic.interactive.find", "tactic.interactive.subst", "tactic.interactive.constructor_matching", "tactic.interactive.conv", "tactic.interactive.guard_expr_strict", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "tactic.interactive.exacts", "tactic.interactive.change", "tactic.interactive.conv_rhs", "tactic.interactive.match_target", "smt_tactic.interactive.eblast_using", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.mapply", "tactic.interactive.specialize", "tactic.interactive.apply_with", "tactic.interactive.fapply", "tactic.interactive.guard_expr_eq", "tactic.interactive.casesm", "tactic.interactive.clean", "tactic.interactive.guard_expr_eq'", "tactic.interactive.guard_target", "smt_tactic.interactive.from", "tactic.interactive.have", "tactic.interactive.guard_hyp'", "smt_tactic.interactive.change", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "tactic.interactive.apply_rules", "tactic.interactive.destruct", "tactic.interactive.h_generalize", "tactic.interactive.ac_change", "tactic.interactive.choose", "smt_tactic.interactive.by_cases", "smt_tactic.interactive.add_lhs_lemma", "smt_tactic.interactive.guard_expr_eq", "tactic.interactive.conv_lhs", "old_conv.interactive.change", "tactic.interactive.apply", "smt_tactic.interactive.exact", "smt_tactic.interactive.fapply"]}, {"id": "interactive.loc.has_reflect", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "tactic.interactive.unfold", "tactic.interactive.unfold_coes", "tactic.interactive.dsimp", "tactic.interactive.split_ifs", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.interactive.change'", "tactic.interactive.simp", "tactic.interactive.elide", "tactic.interactive.simp_rw", "tactic.interactive.erw", "tactic.interactive.unelide", "tactic.interactive.assoc_rw", "tactic.interactive.erewrite", "tactic.interactive.assoc_rewrite", "tactic.interactive.change", "tactic.interactive.rwa", "tactic.interactive.dunfold", "tactic.interactive.rw", "tactic.interactive.push_neg", "tactic.interactive.rewrite", "tactic.interactive.delta"]}, {"id": "name.reflect", "parentIds": ["interactive.loc.has_reflect", "tactic.interactive.squeeze_simp", "tactic.interactive.cases", "tactic.interactive.field_simp", "smt_tactic.interactive.induction", "tactic.interactive.guard_tags", "tactic.interactive.by_contra", "tactic.interactive.by_cases", "tactic.interactive.revert", "tactic.interactive.unfold", "tactic.interactive.induction", "tactic.interactive.rcases", "tactic.interactive.dsimp", "smt_tactic.interactive.intros", "tactic.interactive.rename'", "tactic.interactive.solve_by_elim", "tactic.interactive.split_ifs", "tactic.interactive.clear_dependent", "tactic.mk_simp_attr", "smt_tactic.interactive.have", "tactic.interactive.clear'", "tactic.interactive.lift", "tactic.interactive.unfold1", "tactic.interactive.generalize_hyp", "localized_cmd", "smt_tactic.interactive.add_eqn_lemmas", "tactic.interactive.abstract", "tactic.interactive.let", "to_additive.value_type.has_reflect", "tactic.interactive.set", "smt_tactic.interactive.add_eqn_lemmas_for", "smt_tactic.interactive.dsimp", "tactic.interactive.letI", "tactic.interactive.simp", "mk_hinst_lemma_attr_from_simp_attr", "tactic.simp_arg_type.has_reflect", "tactic.interactive.guard_hyp_strict", "tactic.interactive.squeeze_simpa", "tactic.interactive.clear", "tactic.interactive.injection", "tactic.interactive.suffices", "tactic.interactive.by_contradiction", "tactic.interactive.rename", "smt_tactic.interactive.let", "tactic.interactive.substs", "tactic.interactive.haveI", "tactic.interactive.guard_hyp", "tactic.interactive.generalize", "tactic.ancestor_attr", "tactic.interactive.cases_type", "tactic.interactive.simp_intros", "tactic.interactive.replace", "tactic.rcases", "tactic.interactive.conv", "tactic.interactive.intro", "tactic.interactive.funext", "tactic.def_replacer", "tactic.interactive.conv_rhs", "tactic.interactive.simpa", "conv.interactive.simp", "mk_hinst_lemma_attr_set", "tactic.interactive.introI", "tactic.interactive.dunfold", "tactic.interactive.extract_goal", "tactic.interactive.have", "tactic.interactive.field", "smt_tactic.interactive.simp", "tactic.interactive.injections", "tactic.interactive.clear_except", "tactic.interactive.guard_hyp'", "tactic.interactive.h_generalize", "tactic.interactive.intros", "mk_name_set_attr", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.choose", "mk_hinst_lemma_attr_core", "tactic.interactive.trace_simp_set", "tactic.interactive.introsI", "tactic.interactive.contrapose", "conv.interactive.dsimp", "tactic.interactive.conv_lhs", "tactic.interactive.delta", "tactic.interactive.generalize_proofs"]}, {"id": "interactive.loc", "parentIds": ["interactive.loc.has_reflect", "tactic.find_if_cond_at", "tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "interactive.loc.inhabited", "tactic.interactive.loc.get_local_pp_names", "tactic.interactive.unfold", "tactic.interactive.unfold_coes", "tactic.interactive.dsimp", "tactic.interactive.split_ifs", "interactive.loc.try_apply", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.interactive.set", "smt_tactic.interactive.dsimp", "tactic.interactive.change'", "tactic.interactive.simp", "tactic.interactive.elide", "tactic.lift", "tactic.interactive.simp_rw", "tactic.interactive.loc.get_local_uniq_names", "tactic.interactive.erw", "tactic.split_ifs", "interactive.loc.get_locals", "interactive.loc.include_goal", "tactic.interactive.unelide", "tactic.interactive.assoc_rw", "tactic.interactive.erewrite", "tactic.interactive.assoc_rewrite", "tactic.interactive.change", "tactic.interactive.simp_core", "loc.to_string", "tactic.interactive.simpa", "tactic.interactive.refine_one", "tactic.interactive.rwa", "tactic.interactive.dunfold", "tactic.interactive.rw", "smt_tactic.interactive.simp", "interactive.loc.apply", "smt_tactic.interactive.change", "tactic.interactive.choose", "tactic.split_if1", "interactive.types.location", "tactic.interactive.push_neg", "tactic.interactive.rewrite", "tactic.reduce_ifs_at", "tactic.interactive.delta"]}, {"id": "reflect", "parentIds": ["interactive.loc.has_reflect", "tactic.interactive.rw_rule.has_reflect", "prod.has_reflect", "localized_cmd", "to_additive.value_type.has_reflect", "sum.has_reflect", "tactic.simp_arg_type.has_reflect", "to_additive.map_namespace", "tactic.interactive.rw_rules_t.has_reflect", "tactic.def_replacer", "option.has_reflect", "pos.has_reflect"]}, {"id": "reflected.subst", "parentIds": ["interactive.loc.has_reflect", "tactic.interactive.rw_rule.has_reflect", "prod.has_reflect", "lean.parser.reflectable.optional", "tactic.mk_simp_attr", "localized_cmd", "to_additive.value_type.has_reflect", "sum.has_reflect", "mk_hinst_lemma_attr_from_simp_attr", "tactic.simp_arg_type.has_reflect", "reflected_value.subst", "tactic.interactive.rw_rules_t.has_reflect", "get_attribute_cache_dyn", "mk_hinst_lemma_attr_set", "unsigned.reflect", "option.has_reflect", "mk_name_set_attr", "mk_hinst_lemma_attr_core", "pos.has_reflect"]}, {"id": "has_reflect", "parentIds": ["interactive.loc.has_reflect", "tactic.interactive.rw_rule.has_reflect", "prod.has_reflect", "list.reflect", "bool.has_reflect", "to_additive.value_type.has_reflect", "sum.has_reflect", "tactic.simp_arg_type.has_reflect", "binder_info.has_reflect", "tactic.interactive.rw_rules_t.has_reflect", "lean.parser.reflectable.has_reflect", "user_attribute", "tactic.rcases_patt_inverted.has_reflect", "punit.reflect", "unsigned.reflect", "option.has_reflect", "name.reflect", "pos.has_reflect", "nat.reflect", "tactic.rcases_patt.has_reflect"]}, {"id": "option.has_reflect", "parentIds": ["interactive.loc.has_reflect", "tactic.interactive.cases", "smt_tactic.interactive.induction", "tactic.interactive.convert", "tactic.interactive.by_cases", "tactic.interactive.induction", "tactic.interactive.rcases", "tactic.interactive.lift", "to_additive.value_type.has_reflect", "tactic.interactive.set", "tactic.interactive.rw_rules_t.has_reflect", "tactic.interactive.obtain", "tactic.interactive.contrapose"]}, {"id": "and.elim_right", "parentIds": []}, {"id": "string.pop_back", "parentIds": []}, {"id": "string.iterator.prev", "parentIds": ["string.pop_back", "string.back"]}, {"id": "string.iterator.to_end", "parentIds": ["string.pop_back", "string.popn_back", "string.back", "string.backn"]}, {"id": "string.iterator.prev_to_string", "parentIds": ["string.pop_back", "string.popn_back"]}, {"id": "string.mk_iterator", "parentIds": ["string.pop_back", "tactic.library_search_hole_cmd", "string.popn_back", "string.back", "string.popn", "string.iterator.next_to_string_mk_iterator", "string.split", "string.backn", "name.deinternalize_field", "string.front", "string.to_nat"]}, {"id": "tactic.simplify", "parentIds": ["tactic.interactive.simp_core_aux", "expr.simp", "tactic.simp_hyp", "conv.interactive.simp", "tactic.simp_target"]}, {"id": "simp_lemmas", "parentIds": ["tactic.simplify", "tactic.to_simp_lemmas", "tactic.simplify_top_down", "simp_attr.pre_smt", "simp_lemmas.rewrite", "restate_axiom", "tactic.simp_all_entry", "tactic.interactive.dsimp", "old_conv.dsimp", "tactic.mk_simp_attr", "tactic.dsimp_hyp", "old_conv.apply_propext_lemmas", "old_conv.apply_lemmas_core", "tactic.join_user_simp_lemmas_core", "old_conv.apply_propext_simp_set", "simp_lemmas.add", "tactic.ext_simplify_core", "old_conv.apply_lemmas", "simp_lemmas.add_congr", "simp_lemmas.add_simp", "tactic.interactive.unfold_aux", "tactic.lift", "conv.dsimp", "tactic.interactive.simp_core_aux", "tactic.get_simp_lemmas_or_default", "tactic.simp_intros_aux", "old_conv.find_pattern", "simp_lemmas.mk_default", "old_conv.interactive.find", "simp_attr.functor_norm", "simp_attr.norm", "tactic.simplify_bottom_up", "old_conv.apply_propext_lemmas_core", "simp_lemmas.join", "tactic.simp_intros", "conv.interactive.find", "tactic.interactive.simp_intros", "simp_lemmas.rewrites", "tactic.join_user_simp_lemmas", "simp_attr.split_if_reduction", "simp_lemmas.erase", "expr.simp", "expr.dsimp", "old_conv.apply_simp_set", "tactic.interactive.simp_core", "tactic.mk_simp_set_core", "tactic.simp_hyp", "conv.interactive.for", "old_conv.find", "tactic.dsimp_target", "old_conv.top_down", "tactic.simp_all", "simp_lemmas.append", "conv.interactive.simp", "old_conv.bottom_up", "simp_lemmas.has_to_tactic_format", "tactic.get_lift_prf", "tactic.interactive.trace_simp_set", "tactic.simp_target", "simp_lemmas.pp", "conv.interactive.dsimp", "simp_lemmas.dsimplify", "tactic.get_user_simp_lemmas", "tactic.reduce_ifs_at", "simp_lemmas.drewrite", "tactic.mk_simp_set"]}, {"id": "tactic.simp_config", "parentIds": ["tactic.simplify", "tactic.interactive.field_simp", "tactic.simplify_top_down", "tactic.interactive.unfold", "tactic.interactive.unfold_coes", "push_neg.normalize_negations", "tactic.interactive.unfold1", "tactic.ext_simplify_core", "tactic.interactive.simp", "tactic.simp_top_down", "tactic.simp_config.inhabited", "tactic.simp_intros_config", "tactic.interactive.simp_core_aux", "tactic.simp_bottom_up", "tactic.simp_intros_aux", "old_conv.find_pattern", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.simplify_bottom_up", "tactic.simp_intros", "conv.interactive.find", "tactic.interactive.simp_intros", "expr.simp", "tactic.simp_bottom_up'", "tactic.unfold_config", "tactic.interactive.simp_core", "tactic.simp_hyp", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.refine_one", "old_conv.find", "old_conv.top_down", "tactic.simp_all", "rsimp.rsimplify", "conv.interactive.simp", "old_conv.bottom_up", "smt_tactic.interactive.simp", "tactic.simp_config_ext", "tactic.unfold_config.inhabited", "tactic.interactive.choose", "tactic.interactive.parse_config", "tactic.simp_target", "tactic.simp_intros_config.inhabited", "tactic.interactive.push_neg", "tactic.reduce_ifs_at"]}, {"id": "tactic.failed", "parentIds": ["tactic.simplify", "tactic.delta", "smt_tactic.failed", "tactic.interactive.field_simp", "tactic.simplify_top_down", "old_conv.failed", "tactic.back_chaining_using_hs", "simp_lemmas.rewrite", "tactic.interactive.unfold", "old_conv.apply_propext_lemmas", "old_conv.apply_lemmas", "tactic.interactive.simp", "tactic.case_bash", "old_conv.find_pattern", "old_conv.interactive.find", "tactic.interactive.simp_rw", "well_founded_tactics.is_psigma_mk", "smt_tactic.slift_aux", "tactic.simplify_bottom_up", "conv.interactive.find", "simp_lemmas.rewrites", "tactic.unfold_projs", "expr.simp", "tactic.simp_hyp", "conv.interactive.for", "tactic.interactive.simpa", "old_conv.find", "old_conv.top_down", "tactic.simp_all", "tactic.intro1_aux", "conv.interactive.simp", "old_conv.bottom_up", "smt_tactic.interactive.simp", "tactic.alias.make_left_right", "tactic.interactive.case", "tactic.interactive.choose", "tactic.interactive.parse_config", "tactic.simp_target", "tactic.interactive.push_neg", "tactic.match_fn"]}, {"id": "simp.default_max_steps", "parentIds": ["tactic.simplify", "tactic.delta", "tactic.interactive.field_simp", "tactic.dsimplify", "tactic.simplify_top_down", "restate_axiom", "tactic.interactive.unfold", "tactic.interactive.unfold_coes", "tactic.interactive.dsimp", "tactic.unfold_proj_config.inhabited", "old_conv.dsimp", "push_neg.normalize_negations", "tactic.dsimp_hyp", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.delta_target", "tactic.dsimplify_core", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.simp_top_down", "tactic.simp_config.inhabited", "tactic.interactive.unfold_aux", "tactic.lift", "conv.dsimp", "tactic.simp_bottom_up", "old_conv.find_pattern", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.dunfold_target", "tactic.simplify_bottom_up", "tactic.delta_config.inhabited", "tactic.simp_intros", "conv.interactive.find", "tactic.dsimp_config.inhabited", "tactic.interactive.simp_intros", "tactic.dunfold_hyp", "tactic.unfold_projs", "expr.simp", "expr.dsimp", "tactic.simp_bottom_up'", "tactic.delta_hyp", "well_founded_tactics.unfold_wf_rel", "tactic.simp_hyp", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.refine_one", "tactic.dunfold_config.inhabited", "old_conv.find", "tactic.dsimp_target", "old_conv.top_down", "tactic.unfold_projs_target", "tactic.simp_all", "rsimp.rsimplify", "conv.interactive.simp", "tactic.dunfold", "old_conv.bottom_up", "tactic.interactive.dunfold", "tactic.delta_instance", "smt_tactic.interactive.simp", "tactic.get_lift_prf", "tactic.unfold_config.inhabited", "tactic.interactive.choose", "tactic.interactive.parse_config", "tactic.simp_target", "tactic.simp_intros_config.inhabited", "conv.interactive.dsimp", "tactic.interactive.push_neg", "simp_lemmas.dsimplify", "tactic.reduce_ifs_at", "tactic.interactive.delta", "tactic.unfold_projs_hyp"]}, {"id": "opt_param", "parentIds": ["tactic.simplify", "tactic.get_subsingleton_info", "user_attribute.set_untyped", "tactic.delta", "tactic.change", "tactic.rewrite_core", "tactic.unify", "tactic.mk_mapp", "module_info.of_module_name", "tactic.interactive.field_simp", "tactic.cases", "tactic.mk_has_sizeof_instance_core", "interaction_monad.orelse'", "tactic.simplify_top_down", "where.mk_flag", "simp_lemmas.rewrite", "tactic.set_basic_attribute", "tactic.kdepends_on", "using_smt", "tactic.rcases_patt.format", "tactic.interactive.unfold", "tactic.symm_apply", "tactic.revert_kdependencies", "tactic.interactive.dsimp", "tactic.interactive.solve_by_elim", "rsimp.rsimplify_goal", "tactic.symmetry_hyp", "tactic.note", "tactic.interactive.apply_assumption", "tactic.unsafe.type_context.get_fun_info", "format.to_string", "tactic.dunfold_head", "tactic.interactive.rotate", "tactic.rcases_patt_inverted.format_list", "tactic.mk_simp_attr", "tactic.dsimp_hyp", "interactive.types.pexpr_list", "tactic.match_subexpr", "tactic.suggest_scripts", "tactic.library_search", "tactic.add_inductive", "tactic.match_hypothesis", "environment.from_imported_module_name", "tactic.exact", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "add_interactive", "tactic.unsafe.type_context.run", "tactic.delta_target", "tactic.whnf", "simps_tac", "opt_param_eq", "tactic.rewrite", "smt_tactic.pose", "tactic.interactive.cases_core", "tactic.dsimplify_core", "tactic.match_expr", "lint", "tactic.interactive.letI", "tactic.mk_congr_lemma_simp", "tactic.mk_specialized_congr_lemma", "tactic.interactive.simp", "tactic.simp_top_down", "tactic.apply_assumption", "tactic.kdependencies", "tactic.match_target_subexpr", "tactic.reflexivity", "tactic.lift", "tactic.abstract", "tactic.unsafe.type_context.mk_mvar", "conv.dsimp", "tactic.generalizes", "tactic.rewrite_hyp", "conv.interactive.rw", "smt_tactic.to_expr", "tactic.mk_app", "tactic.simp_bottom_up", "tactic.mk_dec_eq_instance_core", "tactic.apply_heq_congr_core", "find_cmd", "tactic.interactive.haveI", "rsimp.rsimplify_at", "tactic.dunfold_target", "tactic.suggest_core", "tactic.symmetry", "tactic.unsafe.type_context.unify", "tactic.simplify_bottom_up", "tactic.match_target", "tactic.get_spec_subsingleton_info", "tactic.apply", "tactic.interactive.erw", "tactic.split_ifs", "tactic.simp_intros", "smt_tactic.note", "tactic.solve_by_elim", "rsimp.collect_implied_eqs", "tactic.interactive.simp_intros", "tactic.dunfold_hyp", "tactic.interactive.erewrite", "simp_lemmas.rewrites", "tactic.explode_expr", "tactic.unfold_projs", "user_attribute.set", "interactive.parse_binders", "tactic.mk_specialized_congr_lemma_simp", "tactic.by_contradiction", "tactic.destruct", "tactic_state.to_format", "tactic.constructor", "tactic.revert_kdeps", "tactic.type_check", "tactic.assoc_rewrite", "expr.simp", "tactic.assoc_rewrite_hyp", "tactic.rewrite_target", "expr.dsimp", "tactic.induction", "tactic.unfold_proj", "tactic.simp_bottom_up'", "tactic.delta_hyp", "user_attribute", "conv.interactive.erw", "tactic.is_def_eq", "module_info.resolve_module_name", "tactic.interactive.match_target", "tactic.whnf_ginductive", "monad_except.orelse'", "tactic.simp_hyp", "tactic.cases_core", "tactic.interactive.simpa", "tactic.with_enable_tags", "tactic.ext1", "tactic.interactive.swap", "tactic.kabstract", "old_conv.whnf", "environment.for_decl_of_imported_module_name", "tactic.pose", "tactic.match_pattern", "tactic.apply_core", "lean.parser.pexpr", "conv.interactive.rewrite", "tactic.dsimp_target", "tactic.unfold_projs_target", "tactic.simp_all", "rsimp.rsimplify", "tactic.rsimp", "conv.interactive.simp", "where.is_variable_name", "tactic.dunfold", "tactic.interactive.rwa", "tactic.interactive.rw_rules", "tactic.rsimp_at", "tactic.interactive.dunfold", "tactic.interactive.rw", "instance_derive_handler", "tactic.get_fun_info", "tactic.unsafe.type_context.is_def_eq", "smt_tactic.induction", "smt_tactic.interactive.simp", "tactic.mk_hcongr_lemma", "tactic.applyc", "tactic.interactive.apply_rules", "tactic.interactive.h_generalize", "tactic.suggest", "tactic.get_lift_prf", "conv.convert", "tactic.simp_target", "tactic.induction'", "tactic.rename'", "tactic.interactive.suggest", "tactic.get_unused_name", "conv.interactive.dsimp", "tactic.to_expr", "simp_lemmas.dsimplify", "tactic.interactive.rewrite", "lint_mathlib", "lint_all", "tactic.assoc_rewrite_target", "expr", "tactic.transitivity", "simp_lemmas.drewrite", "tactic.unfold_projs_hyp", "tactic.unsafe.type_context.push_local", "tactic.get_spec_prefix_size", "tactic.note_anon", "tactic.mk_congr_lemma", "tactic.generalize"]}, {"id": "native.rb_map.scale", "parentIds": []}, {"id": "native.rb_map", "parentIds": ["native.rb_map.scale", "native.rb_map.of_list", "native.rb_set", "native.rb_set.erase", "name_map", "native.rb_map.add", "transport_multiplicative_to_additive", "to_additive.tokens_dict", "native.rb_map.has_to_tactic_format", "native.has_to_string", "native.has_to_format", "native.rb_map.map", "native.rb_map.insert", "native.rb_map.max", "native.rb_map.values", "native.rb_map.for", "native.rb_map.keys", "native.rb_map.mfilter", "native.rb_map.inhabited", "native.rb_map.mfold", "native.rb_map.zfind", "native.rb_map.empty", "native.rb_map.mmap", "native.rb_map.set_of_list", "native.rb_lmap.insert", "native.rb_lmap.erase", "native.rb_map.size", "native.rb_map.find", "native.mk_rb_set", "native.nat_map", "native.rb_map.contains", "native.rb_set.insert", "native.rb_map.mk_core", "native.rb_map.min", "native.rb_lmap", "native.rb_map.filter", "expr_map", "tactic.local_decls", "native.rb_map.erase", "native.rb_map.find_def", "native.mk_rb_map", "tactic.rename'", "native.rb_map.fold", "native.rb_map.to_list", "native.rb_map.ifind"]}, {"id": "decidable_rel", "parentIds": ["native.rb_map.scale", "native.rb_map.of_list", "is_strict_weak_order_of_is_total_preorder", "decidable.eq_or_lt_of_le", "cmp_using_eq_gt", "cmp_using_eq_lt", "decidable_linear_ordered_semiring", "rbmap_of", "prod.lex.decidable", "decidable_linear_ordered_cancel_comm_monoid", "expr.decidable_rel", "prod_has_decidable_lt", "classical.dec_rel", "decidable_eq", "native.rb_map.map", "rbmap.contains", "lt_of_incomp_of_lt", "rbmap.from_list", "decidable.lt_or_eq_of_le", "rbtree.insert", "decidable_linear_order", "decidable_lt_of_decidable_le", "list.decidable_chain", "discrete_linear_ordered_field", "rbmap.find", "decidable_eq_of_decidable_le", "decidable.le_iff_lt_or_eq", "rbnode.find", "list.lt_eq_not_ge", "list.decidable_chain'", "native.rb_map.for", "rbnode.well_formed", "rbmap.find_entry", "list.has_decidable_le", "native.rb_map.mfilter", "name.lt.decidable_rel", "native.rb_map.inhabited", "rbtree.from_list", "rbtree_of", "native.rb_lmap.of_list", "native.rb_map.mmap", "rbnode.insert", "native.rb_map.set_of_list", "cmp_swap", "rbnode.ins", "rbtree.find", "rbmap.insert", "native.float.decidable_le", "native.rb_set.inhabited", "cmp_using", "native.mk_rb_set", "list.pw_filter", "list.has_decidable_lt", "cmp_using_eq_eq", "native.rb_lmap.inhabited", "cmp", "decidable_linear_ordered_comm_ring", "rbmap.rbmap_lt_dec", "native.rb_map.filter", "lt_of_lt_of_incomp", "native.float.decidable_lt", "nat.decidable_dvd", "native.mk_rb_map", "rbtree.contains", "list.decidable_pairwise", "decidable_linear_ordered_comm_group"]}, {"id": "native.rb_map.map", "parentIds": ["native.rb_map.scale", "native.rb_map.for"]}, {"id": "sub_lt_sub_of_lt_of_le", "parentIds": []}, {"id": "add_lt_add_of_lt_of_le", "parentIds": ["sub_lt_sub_of_lt_of_le", "add_lt_of_lt_of_nonpos", "lt_add_of_pos_of_le", "add_neg_of_neg_of_nonpos", "add_pos_of_pos_of_nonneg", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg"]}, {"id": "neg_le_neg", "parentIds": ["sub_lt_sub_of_lt_of_le", "sub_le_sub_left", "le_neg_of_le_neg", "le_of_neg_le_neg", "neg_nonpos_of_nonneg", "sub_le_sub", "neg_nonneg_of_nonpos", "max_neg_neg", "neg_le_of_neg_le"]}, {"id": "option.guard", "parentIds": ["option.filter"]}, {"id": "tactic.find_if_cond_at", "parentIds": []}, {"id": "coe_sort", "parentIds": ["tactic.find_if_cond_at", "tactic.interactive.squeeze_simp", "tactic.replace_at", "bool.bor_inl", "tactic.strip_prefix", "bool.coe_bool_iff", "tactic.delta", "print_content", "coe_sort_coe_base", "expr.mk_exists_lst", "decidable_of_bool", "tactic.cases", "tactic.existsi", "expr.dedup_size", "unused_arguments", "tactic.cc_core", "tactic.mk_has_sizeof_instance_core", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.mk_assumption_set", "interaction_monad.orelse'", "where.trace_variables", "tactic.rcases_hint", "restate_axiom", "tactic.interactive.convert", "tactic.get_unused_decl_name", "tactic.clear'", "expr.is_napp_of", "tactic.interactive.induction", "incorrect_def_lemma", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "has_dup", "tactic.match_app_of", "expr.list_local_consts", "tactic.non_dep_prop_hyps", "tactic.mk_dec_eq_instance", "interactive.loc.try_apply", "simps_add_projection", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.try_apply_opt_auto_param_for_apply", "tactic.interactive.set", "bor_coe_iff", "tactic.interactive.change'", "lint", "tactic.interactive.simp", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.suggest.tactic_statement", "tactic.interactive.unfold_aux", "bool.of_to_bool_iff", "tactic.lift", "tactic.abstract", "bool.coe_sort_ff", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_core_aux", "nat.mk_numeral", "string.iterator.zero_lt_length_next_to_string_of_has_next", "tactic.mk_patterns", "bool.band_elim_left", "print_all_content", "coe_sort_coe_trans", "tactic.case_bash", "tactic.interactive.library_search", "tactic.intro", "bool.coe_sort_tt", "tactic.try_apply_opt_auto_param", "to_bool_true", "old_conv.find_pattern", "option.eq_some_of_is_some", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "tactic.apply_heq_congr_core", "expr.list_meta_vars", "bool_iff_false", "tactic.suggest.apply_and_solve", "coe_sort_trans", "tactic.apply_eq_congr_core", "tactic.comp_val", "mnot", "old_conv.congr_core", "tactic.fold_explicit_args", "coe_sort_tt", "tactic.mk_has_reflect_instance", "environment.get_trusted_decls", "environment.is_ginductive'", "print_item_crawl", "tactic.interactive.cases_type", "conv.interactive.find", "bool.to_bool_coe", "tactic.solve_by_elim", "tactic.interactive.simp_intros", "tactic.join_user_simp_lemmas", "tactic.explode_expr", "tactic.interactive.clear_", "tactic.interactive.return_cast", "bool.has_to_format", "to_bool_ff_iff", "option.get", "tactic.suggest.process_declaration", "tactic.rcases", "expr.is_bin_arith_app", "tactic.interactive.constructor_matching", "of_to_bool_true", "native.float.has_le", "level.dedup_size", "tactic.injection_with", "hinst_lemmas.pp", "where.is_in_namespace_nonsynthetic", "list_linters", "lint_aux", "declaration.is_auto_generated", "tactic.interactive.simp_core", "tactic.mk_simp_set_core", "monad_except.orelse'", "bool_eq_false", "conv.interactive.for", "tactic.interactive.specialize", "tactic.prove_goal_async", "bool.band_intro", "band_coe_iff", "bool.bor_inr", "tactic.interactive.guard_expr_eq", "incorrect_type_class_argument", "name_set.filter", "tactic.alias.get_alias_target", "list_items", "smt_tactic.by_contradiction", "tactic.suggest.replace_mvars", "instance_priority", "smt_tactic.by_cases", "instance_derive_handler", "bool.coe_to_bool", "tactic.interactive.extract_goal", "environment.mfilter", "bool.band_elim_right", "tactic.local_decls", "tactic.delta_instance", "get_checks", "tactic.interactive.clear_except", "expr.is_eta_expansion_test", "interactive.loc.apply", "native.float.has_lt", "expr.list_constant", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.alias.make_left_right", "tactic.suggest", "tactic.get_lift_prf", "option.eq_none_of_is_none", "tactic.explode.entries.add", "tactic.injections_and_clear", "where.get_all_in_namespace", "tactic.find_private_decl", "native.rb_set.filter", "tactic.mk_eq_proof", "tactic.rename'", "tactic.subst", "tactic.interactive.suggest", "smt_tactic.interactive.guard_expr_eq", "bxor_coe_iff", "lint_mathlib", "tactic.reduce_ifs_at", "ge_or_gt_in_statement", "lint_all", "tactic.ids_to_simp_arg_list", "coe_sort_ff", "dup_namespace", "bool.to_bool_eq", "bool.not_ff", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings"]}, {"id": "list.mmap", "parentIds": ["tactic.find_if_cond_at", "tactic.interactive.squeeze_simp", "unused_arguments", "print_arguments", "tactic.mk_assumption_set", "tactic.interactive.revert", "tactic.get_library_notes", "tactic.interactive.induction", "tactic.interactive.cases_matching", "localized_attr", "to_additive.proceed_fields", "tactic.interactive.clear_dependent", "tactic.interactive.clear'", "tactic.constr_to_prop", "tactic.mk_iff_of_inductive_prop", "tactic.rintro", "tactic.interactive.refine_struct", "tactic.lift", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "tactic.decl_mk_const", "tactic.list_constructors_hole", "tactic.interactive.cases_type", "where.get_variables_core", "monad.mapm", "native.rb_map.mmap", "tactic.interactive.constructor_matching", "get_linters", "tactic.mk_simp_set_core", "list.has_to_tactic_format", "tactic.interactive.refine_one", "where.fetch_potential_variable_names", "tactic.interactive.extract_goal", "tactic.interactive.field", "tactic.interactive.h_generalize", "saturate_fun", "tactic.interactive.source_fields", "where.compile_variable_list", "tactic.interactive.suggest", "derive_struct_ext_lemma", "tactic.ids_to_simp_arg_list", "has_inhabited_instance"]}, {"id": "interactive.loc.include_goal", "parentIds": ["tactic.find_if_cond_at", "interactive.loc.try_apply", "tactic.interactive.generalize_hyp", "tactic.interactive.change'", "tactic.interactive.simp_core", "interactive.loc.apply", "tactic.reduce_ifs_at"]}, {"id": "coe_sort_bool", "parentIds": ["tactic.find_if_cond_at", "tactic.interactive.squeeze_simp", "tactic.replace_at", "bool.bor_inl", "tactic.strip_prefix", "bool.coe_bool_iff", "tactic.delta", "print_content", "expr.mk_exists_lst", "decidable_of_bool", "tactic.cases", "tactic.existsi", "expr.dedup_size", "unused_arguments", "tactic.cc_core", "tactic.mk_has_sizeof_instance_core", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.mk_assumption_set", "interaction_monad.orelse'", "where.trace_variables", "tactic.rcases_hint", "restate_axiom", "tactic.interactive.convert", "tactic.get_unused_decl_name", "tactic.clear'", "expr.is_napp_of", "tactic.interactive.induction", "incorrect_def_lemma", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "has_dup", "tactic.match_app_of", "expr.list_local_consts", "tactic.non_dep_prop_hyps", "tactic.mk_dec_eq_instance", "interactive.loc.try_apply", "simps_add_projection", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.try_apply_opt_auto_param_for_apply", "tactic.interactive.set", "bor_coe_iff", "tactic.interactive.change'", "lint", "tactic.interactive.simp", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.suggest.tactic_statement", "tactic.interactive.unfold_aux", "bool.of_to_bool_iff", "tactic.lift", "tactic.abstract", "bool.coe_sort_ff", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_core_aux", "nat.mk_numeral", "string.iterator.zero_lt_length_next_to_string_of_has_next", "tactic.mk_patterns", "bool.band_elim_left", "print_all_content", "tactic.case_bash", "tactic.interactive.library_search", "tactic.intro", "bool.coe_sort_tt", "tactic.try_apply_opt_auto_param", "to_bool_true", "old_conv.find_pattern", "option.eq_some_of_is_some", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "tactic.apply_heq_congr_core", "expr.list_meta_vars", "bool_iff_false", "tactic.suggest.apply_and_solve", "tactic.apply_eq_congr_core", "tactic.comp_val", "mnot", "old_conv.congr_core", "tactic.fold_explicit_args", "coe_sort_tt", "tactic.mk_has_reflect_instance", "environment.get_trusted_decls", "environment.is_ginductive'", "print_item_crawl", "tactic.interactive.cases_type", "conv.interactive.find", "bool.to_bool_coe", "tactic.solve_by_elim", "tactic.interactive.simp_intros", "tactic.join_user_simp_lemmas", "tactic.explode_expr", "tactic.interactive.clear_", "tactic.interactive.return_cast", "bool.has_to_format", "to_bool_ff_iff", "option.get", "tactic.suggest.process_declaration", "tactic.rcases", "expr.is_bin_arith_app", "tactic.interactive.constructor_matching", "of_to_bool_true", "native.float.has_le", "level.dedup_size", "tactic.injection_with", "hinst_lemmas.pp", "where.is_in_namespace_nonsynthetic", "list_linters", "lint_aux", "declaration.is_auto_generated", "tactic.interactive.simp_core", "tactic.mk_simp_set_core", "monad_except.orelse'", "bool_eq_false", "conv.interactive.for", "tactic.interactive.specialize", "tactic.prove_goal_async", "bool.band_intro", "band_coe_iff", "bool.bor_inr", "tactic.interactive.guard_expr_eq", "incorrect_type_class_argument", "name_set.filter", "tactic.alias.get_alias_target", "list_items", "smt_tactic.by_contradiction", "tactic.suggest.replace_mvars", "instance_priority", "smt_tactic.by_cases", "instance_derive_handler", "bool.coe_to_bool", "tactic.interactive.extract_goal", "environment.mfilter", "bool.band_elim_right", "tactic.local_decls", "tactic.delta_instance", "get_checks", "tactic.interactive.clear_except", "expr.is_eta_expansion_test", "interactive.loc.apply", "native.float.has_lt", "expr.list_constant", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.alias.make_left_right", "tactic.suggest", "tactic.get_lift_prf", "option.eq_none_of_is_none", "tactic.explode.entries.add", "tactic.injections_and_clear", "where.get_all_in_namespace", "tactic.find_private_decl", "native.rb_set.filter", "tactic.mk_eq_proof", "tactic.rename'", "tactic.subst", "tactic.interactive.suggest", "smt_tactic.interactive.guard_expr_eq", "bxor_coe_iff", "lint_mathlib", "tactic.reduce_ifs_at", "ge_or_gt_in_statement", "lint_all", "tactic.ids_to_simp_arg_list", "coe_sort_ff", "dup_namespace", "bool.to_bool_eq", "bool.not_ff", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings"]}, {"id": "tactic.target", "parentIds": ["tactic.find_if_cond_at", "tactic.replace_at", "tactic.admit", "tactic.cc_core", "tactic.apply_instance", "tactic.whnf_target", "tactic.interactive.guard_target_strict", "smt_tactic.interactive.guard_target", "tactic.clear'", "rsimp.rsimplify_goal", "tactic.non_dep_prop_hyps", "use_cmd", "tactic.assoc_refl", "tactic.mk_dec_eq_instance", "tactic.generalize_proofs", "tactic.mk_eq_simp_ext", "conv.update_lhs", "tactic.extract_def", "tactic.delta_target", "tactic.interactive.convert_to_core", "tactic.apply_auto_param", "tactic.change_core", "tactic.interactive.congr_core'", "tactic.instance_stub", "tactic.simp_top_down", "tactic.match_target_subexpr", "tactic.interactive.elide", "tactic.dependent_pose_core", "tactic.interactive.unfold_aux", "tactic.abstract", "tactic.interactive.exact", "tactic.by_cases", "tactic.intro", "tactic.simp_bottom_up", "well_founded_tactics.cancel_nat_add_lt", "tactic.target_lhs_rhs", "tactic.eqn_stub", "tactic.ac_refl", "tactic.apply_heq_congr_core", "tactic.list_constructors_hole", "tactic.dunfold_target", "tactic.revert_and_transform", "tactic.local_def_value", "tactic.comp_val", "tactic.match_target", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.interactive.unelide", "tactic.no_mvars_in_target", "tactic.interactive.guard_target'", "tactic.by_contradiction", "tactic.rewrite_target", "tactic.injection_with", "tactic.interactive.change", "tactic.interactive.simpa", "tactic.ext1", "tactic.interactive.refine_one", "tactic.refine", "tactic.prove_goal_async", "tactic.instantiate_mvars_in_target", "tactic.dsimp_target", "push_neg.push_neg_at_goal", "tactic.interactive.clean", "tactic.unfold_projs_target", "tactic.assumption", "tactic.replace_target", "smt_tactic.by_contradiction", "tactic.interactive.guard_target", "tactic.interactive.extract_goal", "tactic.interactive.h_generalize", "tactic.simp_target", "tactic.assoc_rewrite_target", "tactic.congr_core", "tactic.apply_opt_param", "tactic.interactive.old_conv", "well_founded_tactics.check_target_is_value_lt"]}, {"id": "default", "parentIds": ["tactic.find_if_cond_at", "tactic.explode.entries.inhabited", "pos.inhabited", "function.inv_fun_on_neg", "arbitrary", "environment.projection_info.inhabited", "sum.inhabited_left", "declaration.value_task", "function.inv_fun_on", "function.inv_fun_on_pos", "ulift.inhabited", "psum.inhabited_right", "declaration.to_definition", "sum.inhabited_right", "to_additive.value_type.inhabited", "prod.inhabited", "tactic.rcases_parse", "declaration.value", "tactic.interactive.obtain", "nonempty_of_inhabited", "array.read'", "function.inv_fun_neg", "subsingleton_info.inhabited", "tactic.explode_expr", "unification_constraint.inhabited", "binder.inhabited", "unification_hint.inhabited", "bool.default_bool", "pprod.inhabited", "fun_info.inhabited", "array.read_eq_read'", "expr.to_binder", "default_has_sizeof", "pi.inhabited", "param_info.inhabited", "plift.inhabited", "string_imp.inhabited", "psum.inhabited_left", "string.iterator_imp.inhabited", "sort.inhabited'"]}, {"id": "list.foldr", "parentIds": ["tactic.find_if_cond_at", "list.union", "list.all", "name_set.insert_list", "list.permutations_aux", "tactic.interactive.erase_simp_args", "list.any"]}, {"id": "expr.inhabited", "parentIds": ["tactic.find_if_cond_at", "tactic.constr_to_prop", "declaration.value_task", "declaration.to_definition", "declaration.value", "binder.inhabited", "expr.is_eta_expansion_test"]}, {"id": "interactive.loc.get_locals", "parentIds": ["tactic.find_if_cond_at", "interactive.loc.try_apply", "tactic.interactive.generalize_hyp", "tactic.interactive.loc.get_local_uniq_names", "tactic.interactive.simp_core", "interactive.loc.apply", "tactic.reduce_ifs_at"]}, {"id": "tactic.find_if_cond", "parentIds": ["tactic.find_if_cond_at"]}, {"id": "tactic.infer_type", "parentIds": ["tactic.find_if_cond_at", "tactic.replace_at", "infer_type_cmd", "tactic.get_expl_arity", "expr.mk_exists_lst", "tactic.cases", "tactic.existsi", "tactic.apply_inj_lemma", "tactic.rcases_hint", "tactic.is_prop", "tactic.interactive.induction", "incorrect_def_lemma", "tactic.symmetry_hyp", "tactic.note", "old_conv.change", "tactic.non_dep_prop_hyps", "use_cmd", "tactic.mk_dec_eq_instance", "tactic.assoc_rewrite_intl", "can_lift_attr", "tactic.terminal_goal", "tactic.choose1", "tactic.constr_to_prop", "smt_tactic.pose", "tactic.interactive.set", "tactic.interactive.type_check", "tactic.has_opt_auto_param", "tactic.change_with_at", "tactic.interactive.elide", "tactic.is_type_app_of", "tactic.interactive.guard_hyp_strict", "tactic.lift", "tactic.interactive.simp_core_aux", "tactic.mk_patterns", "tactic.rewrite_hyp", "tactic.explode.may_be_proof", "tactic.subobject_names", "tactic.has_opt_auto_param_for_apply", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.eqn_stub", "rsimp.rsimplify_at", "tactic.list_constructors_hole", "tactic.comp_val", "old_conv.congr_core", "tactic.interactive.guard_hyp", "smt_tactic.note", "tactic.interactive.unelide", "tactic.iff_mpr", "tactic.get_arity", "tactic.interactive.clear_", "tactic.interactive.return_cast", "tactic.rcases", "tactic.assoc_rewrite", "tactic.assoc_rewrite_hyp", "tactic.subsingleton_goal", "tactic.injection_with", "tactic.interactive.change", "tactic.match_stub", "tactic.simp_hyp", "tactic.alias.alias_iff", "tactic.interactive.simpa", "tactic.pose", "expr.is_eta_expansion", "tactic.iff_mp", "tactic.is_proof", "push_neg.push_neg_at_hyp", "tactic.interactive.guard_hyp'", "tactic.get_lift_prf", "tactic.replace_hyp", "tactic.interactive.source_fields", "conv.convert", "tactic.mk_eq_proof", "tactic.subst", "derive_struct_ext_lemma", "tactic.mk_instance_cache", "tactic.get_local_type", "tactic.apply_at"]}, {"id": "bool.decidable_eq", "parentIds": ["tactic.find_if_cond_at", "option.decidable_eq_none", "tactic.interactive.squeeze_simp", "tactic.replace_at", "bool.bxor_comm", "tactic.strip_prefix", "bool.coe_bool_iff", "tactic.delta", "string.quote", "print_content", "expr.mk_exists_lst", "tactic.cases", "tactic.existsi", "expr.dedup_size", "unused_arguments", "tactic.cc_core", "tactic.mk_has_sizeof_instance_core", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.interactive.propagate_tags", "tactic.mk_assumption_set", "interaction_monad.orelse'", "where.trace_variables", "tactic.simplify_top_down", "tactic.rcases_hint", "transport_multiplicative_to_additive", "restate_axiom", "tactic.interactive.convert", "bool.band_comm", "tactic.get_unused_decl_name", "tactic.clear'", "expr.is_napp_of", "tactic.interactive.induction", "incorrect_def_lemma", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "has_dup", "tactic.match_app_of", "expr.list_local_consts", "tactic.non_dep_prop_hyps", "tactic.mk_dec_eq_instance", "smt_tactic.when_tracing", "interactive.loc.try_apply", "simps_add_projection", "expr.decidable_rel", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.try_apply_opt_auto_param_for_apply", "bool.bxor_iff_ne", "tactic.interactive.set", "bor_coe_iff", "tactic.interactive.change'", "lint", "tactic.interactive.simp", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.suggest.tactic_statement", "tactic.interactive.unfold_aux", "tactic.lift", "tactic.abstract", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_core_aux", "nat.mk_numeral", "tactic.mk_patterns", "bool.band_elim_left", "print_all_content", "tactic.case_bash", "tactic.interactive.library_search", "bool.eq_tt_of_bnot_eq_ff", "tactic.when_tracing", "tactic.intro", "list.qsort_cons", "tactic.try_apply_opt_auto_param", "old_conv.find_pattern", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "bool.eq_tt_of_ne_ff", "tactic.apply_heq_congr_core", "expr.list_meta_vars", "bool_iff_false", "bool.eq_ff_of_bnot_eq_tt", "rsimp.rsimplify_at", "tactic.suggest.apply_and_solve", "tactic.apply_eq_congr_core", "tactic.comp_val", "coe_decidable_eq", "mnot", "old_conv.congr_core", "tactic.fold_explicit_args", "bool.eq_ff_of_ne_tt", "tactic.simplify_bottom_up", "tactic.mk_has_reflect_instance", "environment.get_trusted_decls", "environment.is_ginductive'", "bool.bor_assoc", "print_item_crawl", "tactic.interactive.cases_type", "conv.interactive.find", "bool.to_bool_coe", "tactic.solve_by_elim", "d_array.decidable_eq", "tactic.interactive.simp_intros", "tactic.join_user_simp_lemmas", "tactic.explode_expr", "tactic.interactive.clear_", "tactic.interactive.return_cast", "bool.has_to_format", "bool.bxor_bnot_bnot", "tactic.suggest.process_declaration", "tactic.rcases", "expr.is_bin_arith_app", "tactic.interactive.constructor_matching", "level.dedup_size", "tactic.injection_with", "hinst_lemmas.pp", "where.is_in_namespace_nonsynthetic", "list_linters", "lint_aux", "declaration.is_auto_generated", "tactic.interactive.simp_core", "tactic.mk_simp_set_core", "monad_except.orelse'", "tactic.simp_hyp", "decidable_eq_of_bool_pred", "conv.interactive.for", "tactic.interactive.specialize", "tactic.prove_goal_async", "bool.band_intro", "band_coe_iff", "tactic.interactive.guard_expr_eq", "native.float.decidable_le", "incorrect_type_class_argument", "rsimp.rsimplify", "name_set.filter", "tactic.alias.get_alias_target", "list_items", "smt_tactic.by_contradiction", "bool.band_assoc", "bool.bxor_left_comm", "bool.band_left_comm", "tactic.suggest.replace_mvars", "instance_priority", "smt_tactic.by_cases", "instance_derive_handler", "bool.bor_left_comm", "tactic.interactive.extract_goal", "environment.mfilter", "bool.bxor_bnot_right", "bool.band_elim_right", "tactic.local_decls", "tactic.delta_instance", "get_checks", "tactic.interactive.clear_except", "expr.is_eta_expansion_test", "interactive.loc.apply", "expr.list_constant", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.alias.make_left_right", "tactic.suggest", "tactic.get_lift_prf", "tactic.explode.entries.add", "tactic.injections_and_clear", "where.get_all_in_namespace", "native.float.decidable_lt", "tactic.find_private_decl", "native.rb_set.filter", "bool.bor_comm", "tactic.mk_eq_proof", "tactic.rename'", "tactic.replacer_attr", "tactic.subst", "tactic.interactive.suggest", "bool.bxor_bnot_left", "smt_tactic.interactive.guard_expr_eq", "bxor_coe_iff", "lint_mathlib", "tactic.reduce_ifs_at", "ge_or_gt_in_statement", "lint_all", "tactic.ids_to_simp_arg_list", "dup_namespace", "well_founded_tactics.check_target_is_value_lt", "tactic.module_doc_strings", "bool.bxor_assoc"]}, {"id": "except_t.lift", "parentIds": ["except_t.has_monad_lift"]}, {"id": "except_t", "parentIds": ["except_t.lift", "except_t.ext", "except_t.run_pure", "except_t.return", "except_t.run_map", "except_t.bind_cont", "except_t.run_monad_lift", "except_t.monad_map", "except_t.monad_run", "except_t.adapt", "except_t.run_monad_map", "except_t.monad_except", "except_t.monad_functor", "except_t.is_lawful_monad", "except_t.run_bind", "except_t.bind", "except_t.monad", "except_t.catch", "except_t.monad_except_adapter", "except_t.has_monad_lift"]}, {"id": "except", "parentIds": ["except_t.lift", "except_t.ext", "except_t.run_pure", "except_t.return", "except.monad", "except_t.run_map", "except.bind", "except_t.bind_cont", "except_t.run_monad_lift", "except_t.monad_map", "except.to_option", "except_t.monad_run", "except_t.adapt", "except_t.run_monad_map", "except_t.monad_except", "except.map", "except_t.is_lawful_monad", "except_t.run_bind", "except.to_bool", "except_t.bind", "except_t", "except.return", "except_t.catch", "except.map_error"]}, {"id": "vm_decl.to_name", "parentIds": []}, {"id": "vm_decl", "parentIds": ["vm_decl.to_name", "vm_decl.olean", "vm_decl.arity", "vm_decl.idx", "vm_decl.pos", "vm.get_decl", "vm_decl.args_info", "vm_decl.kind"]}, {"id": "nat.has_mod", "parentIds": ["nat.mod_lt", "nat.add_mul_mod_self_right", "nat.gcd_succ", "nat.mod_one", "fin.mod_def", "nat.mod_two_of_bodd", "localized_cmd", "nat.sub_mul_mod", "nat.mod_eq_of_lt", "string.hash", "list.rotate", "nat.div_le_of_le_mul", "nat.mul_mod_mul_left", "nat.mod_le", "nat.gcd.induction", "nat.mul_div_cancel'", "nat.zero_mod", "nat.add_mod_right", "nat.gcd_one_left", "fin.add_def", "fin.mul_def", "nat.dvd_mod_iff", "fin.of_nat", "nat.mul_mod_left", "nat.mul_mod_right", "nat.div2_val", "nat.mod_zero", "nat.dvd_iff_mod_eq_zero", "nat.mod_self", "nat.add_mod_left", "char_to_hex", "nat.gcd_zero_right", "nat.dvd_of_mod_eq_zero", "nat.mod_def_aux", "nat.mod_add_div", "nat.mod_eq_sub_mod", "nat.mod_two_eq_zero_or_one", "nat.gcd_rec", "nat.add_mul_mod_self_left", "nat.mod_pow_succ", "nat.mod_def", "nat.decidable_dvd", "nat.mul_mod_mul_right", "nat.gcd_self", "nat.gcd_def", "nat.cond_to_bool_mod_two", "nat.div_one", "nat.mod_eq_zero_of_dvd"]}, {"id": "has_mod", "parentIds": ["nat.has_mod", "nat.mod_lt", "unsigned.has_mod", "nat.add_mul_mod_self_right", "nat.gcd_succ", "nat.mod_one", "fin.mod_def", "nat.mod_two_of_bodd", "localized_cmd", "nat.sub_mul_mod", "nat.mod_eq_of_lt", "string.hash", "list.rotate", "nat.div_le_of_le_mul", "nat.mul_mod_mul_left", "nat.mod_le", "nat.gcd.induction", "nat.mul_div_cancel'", "nat.zero_mod", "nat.add_mod_right", "nat.gcd_one_left", "fin.add_def", "fin.mul_def", "nat.dvd_mod_iff", "fin.of_nat", "nat.mul_mod_left", "nat.mul_mod_right", "nat.div2_val", "nat.mod_zero", "nat.dvd_iff_mod_eq_zero", "int.has_mod", "int.nat_mod", "nat.mod_self", "nat.add_mod_left", "char_to_hex", "fin.has_mod", "nat.gcd_zero_right", "nat.dvd_of_mod_eq_zero", "nat.mod_def_aux", "nat.mod_add_div", "nat.mod_eq_sub_mod", "nat.mod_two_eq_zero_or_one", "nat.gcd_rec", "nat.add_mul_mod_self_left", "nat.mod_pow_succ", "tactic.rotate_right", "nat.mod_def", "nat.decidable_dvd", "nat.mul_mod_mul_right", "nat.gcd_self", "nat.gcd_def", "nat.cond_to_bool_mod_two", "nat.div_one", "nat.mod_eq_zero_of_dvd"]}, {"id": "nat.mod", "parentIds": ["nat.has_mod"]}, {"id": "int.neg_succ_of_nat_coe'", "parentIds": []}, {"id": "int.has_coe", "parentIds": ["int.neg_succ_of_nat_coe'", "int.of_nat_ge_zero", "int.le.dest", "int.nat_abs_of_nat", "int.coe_nat_add_out", "int.lt.intro", "int.le_of_coe_nat_le_coe_nat", "int.nat_abs_mul_self", "int.le.dest_sub", "int.nat_abs_eq", "int.coe_nat_le_coe_nat_iff", "int.lt.elim", "expr.to_int", "int.lt_add_succ", "int.nat_bitwise", "int.lt_of_coe_nat_lt_coe_nat", "int.eq_coe_or_neg", "int.of_nat_nat_abs_of_nonpos", "int.coe_nat_lt_coe_nat_iff", "int.coe_nat_mul_out", "int.sub_nat_nat_eq_coe", "int.coe_nat_zero", "int.lt_irrefl", "int.coe_nat_add_one_out", "int.le_antisymm", "int.lt_iff_le_and_ne", "int.le.intro", "int.coe_nat_add", "int.le_trans", "int.coe_nat_eq", "int.eq_neg_succ_of_lt_zero", "int.abs_eq_nat_abs", "int.coe_nat_one", "int.sign_mul_abs", "int.mul_pos", "int.eq_succ_of_zero_lt", "int.coe_nat_lt_coe_nat_of_lt", "int.coe_nat_succ", "int.coe_nat_inj", "int.eq_coe_of_zero_le", "int.coe_nat_eq_coe_nat_iff", "int.add_le_add_left", "int.of_nat_eq_coe", "int.coe_nat_sub", "int.eq_nat_abs_of_zero_le", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "int.coe_nat_le_coe_nat_of_le", "int.sign_mul_nat_abs", "int.pos_of_sign_eq_one", "int.neg_succ_lt_zero", "int.neg_of_sign_eq_neg_one", "int.exists_eq_neg_of_nat", "int.nat_abs_of_nonneg", "int.mul_nonneg", "int.to_nat_sub", "int.le.elim", "int.sign_of_succ", "int.le.intro_sub", "int.lt.dest", "int.coe_succ_pos", "int.sign_eq_one_of_pos", "nat.can_lift", "int.neg_succ_of_nat_lt_zero", "int.le_nat_abs", "int.le_of_lt", "int.coe_nat_mul", "int.nat_abs_abs", "int.coe_zero_le"]}, {"id": "int.ring", "parentIds": ["int.neg_succ_of_nat_coe'", "int.le.dest", "int.neg_ne_zero_of_ne", "int.sub_nat_nat_eq_coe", "int.ne_neg_of_ne", "int.lt_irrefl", "int.add_lt_add_left", "int.le_antisymm", "int.le.intro", "int.eq_coe_of_zero_le", "int.sign_mul_nat_abs", "int.le_total", "int.exists_eq_neg_of_nat", "int.distrib", "int.neg_succ_of_nat_lt_zero"]}, {"id": "sub_eq_add_neg", "parentIds": ["int.neg_succ_of_nat_coe'", "sub_eq_sub_iff_sub_eq_sub", "int.le.dest", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "div_sub_div", "add_sub_comm", "abs_sub_le", "add_sub_add_left_eq_sub", "add_midpoint", "neg_add_eq_sub", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "abs_sub_square", "exists_add_lt_and_pos_of_lt", "div_le_div_of_mul_sub_mul_div_nonpos", "norm_num.subst_into_subtr", "neg_sub_neg", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "add_sub_add_right_eq_sub", "sub_sub", "int.le.intro", "sub_sub_assoc_swap", "sub_eq_of_eq_add", "sub_sub_self", "sub_eq_of_eq_add'", "eq_sub_of_add_eq", "sub_zero", "int.eq_coe_of_zero_le", "neg_sub", "mul_self_sub_mul_self_eq", "int.le_total", "add_sub", "mul_sub_right_distrib", "sub_add_eq_add_sub", "eq_sub_of_add_eq'", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "div_sub_div_same", "mul_sub_left_distrib", "sub_add_eq_sub_sub", "sub_eq_sub_add_sub", "sub_add", "add_eq_of_eq_sub", "sub_neg_eq_add", "sub_add_eq_sub_sub_swap", "add_sub_assoc", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "coe_to_lift", "parentIds": ["int.neg_succ_of_nat_coe'", "tactic.add_library_note", "int.of_nat_ge_zero", "tactic.mk_const", "tactic.interactive.cases", "tactic.interactive.format_names", "tactic.delta", "int.le.dest", "smt_tactic.failed", "option_to_tactic_format", "int.nat_abs_of_nat", "coe_sort_coe_base", "print_decls_sorted", "int.coe_nat_add_out", "int.lt.intro", "smt_tactic.definev", "smt_tactic.interactive.destruct", "coe_fn_coe_trans", "where.trace_namespace", "unused_arguments", "congr_arg_kind.has_to_format", "smt_tactic.trace_state", "print_arguments", "int.le_of_coe_nat_le_coe_nat", "expr.mk_or_lst", "where.trace_variables", "where.mk_flag", "int.nat_abs_mul_self", "int.le.dest_sub", "tactic.is_prop", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "int.nat_abs_eq", "tactic.mk_simp_attribute_cmd", "tactic.clear'", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "restate_axiom_cmd", "tactic.interactive.dsimp", "int.coe_nat_le_coe_nat_iff", "int.lt.elim", "localized_attr", "smt_tactic.trace", "expr.to_int", "tactic.mk_iff", "tactic.mk_simp_attr", "tactic.assoc_refl", "print_decls", "user_attribute.parse_reflect", "smt_tactic.interactive.have", "coe_ff", "nolint_attr", "apply_nolint_cmd", "user_attribute.dflt_parser", "to_additive.parser", "can_lift_attr", "int.mk_numeral", "smt_tactic.monad_fail", "int.lt_add_succ", "smt_tactic.when", "localized_cmd", "old_conv.conversion", "simps_tac", "ext_param", "int.nat_bitwise", "tactic.rintro_parse", "smt_tactic.pose", "smt_tactic.add_ematch_lemma_core", "int.lt_of_coe_nat_lt_coe_nat", "int.eq_coe_or_neg", "smt_tactic.interactive.trace", "expr.has_to_format", "int.of_nat_nat_abs_of_nonpos", "smt_tactic.interactive.dsimp", "tactic.interactive.change'", "tactic.interactive.letI", "int.coe_nat_lt_coe_nat_iff", "tactic.instance_stub", "lean.parser.get_includes", "int.coe_nat_mul_out", "smt_tactic.proof_for", "int.sub_nat_nat_eq_coe", "int.coe_nat_zero", "tactic.constructor_num_fields", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "tactic.interactive.rec.to_tactic_format", "user_attribute.dflt_cache_cfg", "tactic.interactive.obtain_parse", "tactic.lift", "int.lt_irrefl", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "nat.mk_numeral", "tactic.def_replacer_cmd", "tactic.mk_patterns", "int.coe_nat_add_one_out", "int.le_antisymm", "print_decls_sorted_mathlib", "doc_blame_report_defn", "int.lt_iff_le_and_ne", "to_additive.map_namespace", "coe_sort_coe_trans", "smt_tactic.to_expr", "tactic.explode", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "int.le.intro", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.apply_heq_congr_core", "int.coe_nat_add", "int.le_trans", "int.coe_nat_eq", "name.deinternalize_field", "smt_tactic.define", "find_cmd", "int.eq_neg_succ_of_lt_zero", "list.choose", "tactic.iterate1", "tactic.interactive.haveI", "smt_tactic.save_info", "tactic.list_constructors_hole", "smt_tactic.assertv", "int.abs_eq_nat_abs", "int.coe_nat_one", "tactic.local_def_value", "tactic.comp_val", "coe_decidable_eq", "smt_tactic.fail", "tactic.unsafe.type_context.print_mvars", "int.sign_mul_abs", "check_unused_arguments", "int.mul_pos", "int.eq_succ_of_zero_lt", "tactic.interactive.generalize", "tactic.rcases_patt_parse", "tactic.alias.alias_cmd", "conv.interactive.find", "expr.mk_and_lst", "smt_tactic.note", "int.coe_nat_lt_coe_nat_of_lt", "int.coe_nat_succ", "int.coe_nat_inj", "rsimp.collect_implied_eqs", "int.eq_coe_of_zero_le", "coe_fn_coe_base", "where.get_variables_core", "tactic.interactive.rintro", "int.coe_nat_eq_coe_nat_iff", "int.add_le_add_left", "tactic.iff_mpr", "copy_decl_using", "int.of_nat_eq_coe", "user_attribute.set", "interactive.parse_binders", "int.coe_nat_sub", "tactic.interactive.replace", "reflected_value.expr", "int.eq_nat_abs_of_zero_le", "tactic.interactive.return_cast", "smt_tactic.assert", "tactic.rcases", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "open_locale_cmd", "int.coe_nat_le_coe_nat_of_le", "list.to_format", "int.sign_mul_nat_abs", "smt_tactic.get_goals", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "tactic.interactive.congr'", "int.pos_of_sign_eq_one", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "tactic.get_decl", "int.neg_succ_lt_zero", "tactic.def_replacer", "int.neg_of_sign_eq_neg_one", "binder.has_to_tactic_format", "binder.has_to_format", "tactic.interactive.simpa", "tactic.ext1", "int.exists_eq_neg_of_nat", "smt_tactic.read", "where.trace_where", "int.nat_abs_of_nonneg", "expr.is_eta_expansion", "int.mul_nonneg", "int.to_nat_sub", "int.le.elim", "rsimp.rsimplify", "tactic.iff_mp", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.mk_assoc_instance", "int.sign_of_succ", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "tactic.mk_replacer", "int.le.intro_sub", "smt_tactic.by_cases", "tactic.interactive.mk_paragraph", "smt_tactic.interactive.rsimp", "tactic.interactive.extract_goal", "tactic.get_mathlib_dir", "int.lt.dest", "tactic.is_prop_decl", "tactic.delta_instance", "smt_tactic.interactive.simp", "int.coe_succ_pos", "smt_tactic.interactive.apply_instance", "smt_tactic.interactive.change", "smt_tactic.interactive.add_fact", "tactic.interactive.list_cast_of_aux", "int.sign_eq_one_of_pos", "tactic.interactive.h_generalize", "tactic.unsafe.type_context.failure", "interactive.param_desc", "nat.can_lift", "tactic.get_lift_prf", "mk_name_set_attr", "smt_tactic.destruct", "mk_hinst_lemma_attr_core", "int.neg_succ_of_nat_lt_zero", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "tactic.explode_cmd", "int.le_nat_abs", "int.le_of_lt", "doc_blame_report_thm", "tactic.rename'", "coe_tt", "tactic.interactive.suggest", "pos.has_to_format", "interactive.types.location", "derive_struct_ext_lemma", "int.coe_nat_mul", "coe_coe", "smt_tactic.refutation_for", "int.nat_abs_abs", "has_inhabited_instance", "tactic.import_private_cmd", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "print_name", "smt_tactic.interactive.fapply", "int.coe_zero_le", "tactic.suggest.apply_declaration", "tactic.note_anon", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "coe_base", "parentIds": ["int.neg_succ_of_nat_coe'", "tactic.add_library_note", "int.of_nat_ge_zero", "tactic.mk_const", "tactic.interactive.format_names", "tactic.delta", "int.le.dest", "smt_tactic.failed", "option_to_tactic_format", "int.nat_abs_of_nat", "coe_sort_coe_base", "print_decls_sorted", "int.coe_nat_add_out", "int.lt.intro", "smt_tactic.definev", "smt_tactic.interactive.destruct", "coe_fn_coe_trans", "where.trace_namespace", "unused_arguments", "congr_arg_kind.has_to_format", "smt_tactic.trace_state", "print_arguments", "int.le_of_coe_nat_le_coe_nat", "expr.mk_or_lst", "where.trace_variables", "where.mk_flag", "int.nat_abs_mul_self", "int.le.dest_sub", "tactic.is_prop", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "int.nat_abs_eq", "tactic.mk_simp_attribute_cmd", "tactic.clear'", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.rcases", "restate_axiom_cmd", "int.coe_nat_le_coe_nat_iff", "int.lt.elim", "localized_attr", "smt_tactic.trace", "expr.to_int", "tactic.mk_iff", "tactic.mk_simp_attr", "print_decls", "user_attribute.parse_reflect", "smt_tactic.interactive.have", "coe_ff", "nolint_attr", "apply_nolint_cmd", "user_attribute.dflt_parser", "to_additive.parser", "can_lift_attr", "int.mk_numeral", "smt_tactic.monad_fail", "int.lt_add_succ", "smt_tactic.when", "localized_cmd", "old_conv.conversion", "simps_tac", "int.nat_bitwise", "tactic.rintro_parse", "smt_tactic.pose", "smt_tactic.add_ematch_lemma_core", "int.lt_of_coe_nat_lt_coe_nat", "int.eq_coe_or_neg", "smt_tactic.interactive.trace", "expr.has_to_format", "int.of_nat_nat_abs_of_nonpos", "smt_tactic.interactive.dsimp", "tactic.interactive.letI", "int.coe_nat_lt_coe_nat_iff", "tactic.instance_stub", "lean.parser.get_includes", "int.coe_nat_mul_out", "smt_tactic.proof_for", "int.sub_nat_nat_eq_coe", "int.coe_nat_zero", "tactic.constructor_num_fields", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "tactic.interactive.rec.to_tactic_format", "user_attribute.dflt_cache_cfg", "tactic.interactive.obtain_parse", "int.lt_irrefl", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "nat.mk_numeral", "tactic.def_replacer_cmd", "tactic.mk_patterns", "int.coe_nat_add_one_out", "int.le_antisymm", "print_decls_sorted_mathlib", "int.lt_iff_le_and_ne", "to_additive.map_namespace", "coe_sort_coe_trans", "smt_tactic.to_expr", "tactic.explode", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "int.le.intro", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "int.coe_nat_add", "int.le_trans", "int.coe_nat_eq", "name.deinternalize_field", "smt_tactic.define", "find_cmd", "int.eq_neg_succ_of_lt_zero", "list.choose", "tactic.iterate1", "tactic.interactive.haveI", "smt_tactic.save_info", "tactic.list_constructors_hole", "smt_tactic.assertv", "int.abs_eq_nat_abs", "int.coe_nat_one", "tactic.local_def_value", "tactic.comp_val", "coe_decidable_eq", "smt_tactic.fail", "tactic.unsafe.type_context.print_mvars", "int.sign_mul_abs", "int.mul_pos", "int.eq_succ_of_zero_lt", "tactic.rcases_patt_parse", "tactic.alias.alias_cmd", "expr.mk_and_lst", "smt_tactic.note", "int.coe_nat_lt_coe_nat_of_lt", "int.coe_nat_succ", "int.coe_nat_inj", "rsimp.collect_implied_eqs", "int.eq_coe_of_zero_le", "coe_fn_coe_base", "where.get_variables_core", "tactic.interactive.rintro", "int.coe_nat_eq_coe_nat_iff", "int.add_le_add_left", "tactic.iff_mpr", "copy_decl_using", "int.of_nat_eq_coe", "user_attribute.set", "interactive.parse_binders", "int.coe_nat_sub", "reflected_value.expr", "int.eq_nat_abs_of_zero_le", "tactic.interactive.return_cast", "smt_tactic.assert", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "open_locale_cmd", "int.coe_nat_le_coe_nat_of_le", "list.to_format", "int.sign_mul_nat_abs", "smt_tactic.get_goals", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "tactic.interactive.congr'", "int.pos_of_sign_eq_one", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "tactic.get_decl", "int.neg_succ_lt_zero", "tactic.def_replacer", "int.neg_of_sign_eq_neg_one", "binder.has_to_tactic_format", "binder.has_to_format", "tactic.interactive.simpa", "tactic.ext1", "int.exists_eq_neg_of_nat", "smt_tactic.read", "where.trace_where", "int.nat_abs_of_nonneg", "expr.is_eta_expansion", "int.mul_nonneg", "int.to_nat_sub", "int.le.elim", "rsimp.rsimplify", "tactic.iff_mp", "where.is_variable_name", "int.sign_of_succ", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "tactic.mk_replacer", "int.le.intro_sub", "smt_tactic.by_cases", "tactic.interactive.mk_paragraph", "smt_tactic.interactive.rsimp", "tactic.interactive.extract_goal", "tactic.get_mathlib_dir", "int.lt.dest", "tactic.is_prop_decl", "tactic.delta_instance", "smt_tactic.interactive.simp", "int.coe_succ_pos", "smt_tactic.interactive.apply_instance", "smt_tactic.interactive.change", "smt_tactic.interactive.add_fact", "int.sign_eq_one_of_pos", "tactic.interactive.h_generalize", "tactic.unsafe.type_context.failure", "interactive.param_desc", "nat.can_lift", "mk_name_set_attr", "smt_tactic.destruct", "mk_hinst_lemma_attr_core", "int.neg_succ_of_nat_lt_zero", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "tactic.explode_cmd", "int.le_nat_abs", "int.le_of_lt", "tactic.rename'", "coe_tt", "tactic.interactive.suggest", "pos.has_to_format", "interactive.types.location", "derive_struct_ext_lemma", "int.coe_nat_mul", "coe_coe", "smt_tactic.refutation_for", "int.nat_abs_abs", "has_inhabited_instance", "tactic.import_private_cmd", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "print_name", "smt_tactic.interactive.fapply", "int.coe_zero_le", "tactic.suggest.apply_declaration", "tactic.note_anon", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "int.has_neg", "parentIds": ["int.neg_succ_of_nat_coe'", "int.neg_ne_of_pos", "int.zero_ne_neg_of_ne", "int.nat_abs_eq", "int.neg_of_nat_zero", "int.neg_ne_zero_of_ne", "expr.to_int", "int.sign_eq_neg_one_iff_neg", "int.eq_coe_or_neg", "int.add_left_neg", "int.of_nat_nat_abs_of_nonpos", "int.sub_nat_nat_eq_coe", "int.ne_neg_of_ne", "int.nat_abs_neg", "int.sign_neg_one", "int.neg_neg_of_nat_succ", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "int.le_total", "int.shiftr", "int.neg_of_sign_eq_neg_one", "int.exists_eq_neg_of_nat", "int.sign_eq_neg_one_of_neg", "int.ne_neg_of_pos", "int.neg_of_nat_of_succ", "int.neg_succ_of_nat_lt_zero"]}, {"id": "coe", "parentIds": ["int.neg_succ_of_nat_coe'", "tactic.add_library_note", "int.of_nat_ge_zero", "tactic.mk_const", "tactic.interactive.cases", "tactic.interactive.format_names", "tactic.delta", "int.le.dest", "smt_tactic.failed", "option_to_tactic_format", "int.nat_abs_of_nat", "coe_sort_coe_base", "print_decls_sorted", "int.coe_nat_add_out", "int.lt.intro", "smt_tactic.definev", "smt_tactic.interactive.destruct", "coe_fn_coe_trans", "where.trace_namespace", "unused_arguments", "congr_arg_kind.has_to_format", "smt_tactic.trace_state", "print_arguments", "int.le_of_coe_nat_le_coe_nat", "expr.mk_or_lst", "where.trace_variables", "where.mk_flag", "int.nat_abs_mul_self", "int.le.dest_sub", "tactic.is_prop", "tactic.interactive.convert", "smt_tactic.interactive.guard_target", "int.nat_abs_eq", "tactic.mk_simp_attribute_cmd", "tactic.clear'", "tactic.interactive.unfold", "tactic.explode.append_dep", "tactic.interactive.induction", "tactic.interactive.rcases", "incorrect_def_lemma", "restate_axiom_cmd", "tactic.interactive.dsimp", "int.coe_nat_le_coe_nat_iff", "int.lt.elim", "localized_attr", "smt_tactic.trace", "expr.to_int", "tactic.mk_iff", "tactic.mk_simp_attr", "tactic.assoc_refl", "print_decls", "user_attribute.parse_reflect", "smt_tactic.interactive.have", "coe_ff", "nolint_attr", "apply_nolint_cmd", "user_attribute.dflt_parser", "to_additive.parser", "can_lift_attr", "int.mk_numeral", "smt_tactic.monad_fail", "lift_fn", "int.lt_add_succ", "smt_tactic.when", "localized_cmd", "old_conv.conversion", "simps_tac", "ext_param", "int.nat_bitwise", "tactic.rintro_parse", "smt_tactic.pose", "smt_tactic.add_ematch_lemma_core", "int.lt_of_coe_nat_lt_coe_nat", "lift_pair\u2081", "int.eq_coe_or_neg", "smt_tactic.interactive.trace", "expr.has_to_format", "int.of_nat_nat_abs_of_nonpos", "smt_tactic.interactive.dsimp", "tactic.interactive.change'", "tactic.interactive.letI", "int.coe_nat_lt_coe_nat_iff", "tactic.instance_stub", "lean.parser.get_includes", "int.coe_nat_mul_out", "smt_tactic.proof_for", "int.sub_nat_nat_eq_coe", "int.coe_nat_zero", "tactic.constructor_num_fields", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.rw_rule_p", "tactic.interactive.rec.to_tactic_format", "user_attribute.dflt_cache_cfg", "tactic.interactive.obtain_parse", "tactic.lift", "int.lt_irrefl", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "nat.mk_numeral", "tactic.def_replacer_cmd", "tactic.mk_patterns", "int.coe_nat_add_one_out", "int.le_antisymm", "print_decls_sorted_mathlib", "doc_blame_report_defn", "lift_pair", "int.lt_iff_le_and_ne", "to_additive.map_namespace", "coe_sort_coe_trans", "smt_tactic.to_expr", "tactic.explode", "tactic.subobject_names", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "smt_tactic.interactive.add_simp_lemmas", "int.le.intro", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.apply_heq_congr_core", "int.coe_nat_add", "int.le_trans", "int.coe_nat_eq", "name.deinternalize_field", "smt_tactic.define", "find_cmd", "int.eq_neg_succ_of_lt_zero", "list.choose", "tactic.iterate1", "tactic.interactive.haveI", "smt_tactic.save_info", "tactic.list_constructors_hole", "smt_tactic.assertv", "int.abs_eq_nat_abs", "int.coe_nat_one", "tactic.local_def_value", "tactic.comp_val", "coe_decidable_eq", "smt_tactic.fail", "tactic.unsafe.type_context.print_mvars", "int.sign_mul_abs", "check_unused_arguments", "int.mul_pos", "int.eq_succ_of_zero_lt", "tactic.interactive.generalize", "tactic.rcases_patt_parse", "tactic.alias.alias_cmd", "conv.interactive.find", "expr.mk_and_lst", "smt_tactic.note", "int.coe_nat_lt_coe_nat_of_lt", "int.coe_nat_succ", "int.coe_nat_inj", "rsimp.collect_implied_eqs", "int.eq_coe_of_zero_le", "coe_fn_coe_base", "where.get_variables_core", "tactic.interactive.rintro", "int.coe_nat_eq_coe_nat_iff", "int.add_le_add_left", "tactic.iff_mpr", "copy_decl_using", "int.of_nat_eq_coe", "user_attribute.set", "interactive.parse_binders", "int.coe_nat_sub", "tactic.interactive.replace", "reflected_value.expr", "int.eq_nat_abs_of_zero_le", "tactic.interactive.return_cast", "lift_fn_dom", "smt_tactic.assert", "tactic.rcases", "int.neg_succ_of_nat_coe", "int.neg_succ_of_nat_eq", "open_locale_cmd", "int.coe_nat_le_coe_nat_of_le", "list.to_format", "int.sign_mul_nat_abs", "smt_tactic.get_goals", "tactic.interactive.convert_to", "smt_tactic.interactive.apply", "tactic.interactive.congr'", "int.pos_of_sign_eq_one", "lift_pair\u2082", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "tactic.get_decl", "int.neg_succ_lt_zero", "tactic.def_replacer", "int.neg_of_sign_eq_neg_one", "binder.has_to_tactic_format", "binder.has_to_format", "tactic.interactive.simpa", "tactic.ext1", "int.exists_eq_neg_of_nat", "smt_tactic.read", "where.trace_where", "int.nat_abs_of_nonneg", "expr.is_eta_expansion", "int.mul_nonneg", "int.to_nat_sub", "int.le.elim", "rsimp.rsimplify", "tactic.iff_mp", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.mk_assoc_instance", "int.sign_of_succ", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "tactic.mk_replacer", "int.le.intro_sub", "smt_tactic.by_cases", "tactic.interactive.mk_paragraph", "smt_tactic.interactive.rsimp", "lift_fn_range", "tactic.interactive.extract_goal", "tactic.get_mathlib_dir", "int.lt.dest", "tactic.is_prop_decl", "tactic.delta_instance", "smt_tactic.interactive.simp", "int.coe_succ_pos", "smt_tactic.interactive.apply_instance", "smt_tactic.interactive.change", "smt_tactic.interactive.add_fact", "tactic.interactive.list_cast_of_aux", "int.sign_eq_one_of_pos", "tactic.interactive.h_generalize", "tactic.unsafe.type_context.failure", "interactive.param_desc", "nat.can_lift", "tactic.get_lift_prf", "mk_name_set_attr", "smt_tactic.destruct", "mk_hinst_lemma_attr_core", "lift_list", "int.neg_succ_of_nat_lt_zero", "tactic.interactive.parse_config", "smt_tactic.interactive.by_cases", "tactic.explode_cmd", "int.le_nat_abs", "int.le_of_lt", "doc_blame_report_thm", "tactic.rename'", "coe_tt", "tactic.interactive.suggest", "pos.has_to_format", "interactive.types.location", "derive_struct_ext_lemma", "int.coe_nat_mul", "coe_coe", "smt_tactic.refutation_for", "int.nat_abs_abs", "has_inhabited_instance", "tactic.import_private_cmd", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "print_name", "smt_tactic.interactive.fapply", "int.coe_zero_le", "tactic.suggest.apply_declaration", "tactic.note_anon", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "has_sizeof_derive_handler", "parentIds": []}, {"id": "instance_derive_handler", "parentIds": ["has_sizeof_derive_handler", "tactic.inhabited_instance", "tactic.decidable_eq_derive_handler", "has_reflect_derive_handler"]}, {"id": "derive_handler", "parentIds": ["has_sizeof_derive_handler", "instance_derive_handler", "tactic.inhabited_instance", "tactic.delta_instance", "tactic.decidable_eq_derive_handler", "has_reflect_derive_handler"]}, {"id": "tactic.mk_has_sizeof_instance", "parentIds": ["has_sizeof_derive_handler"]}, {"id": "tactic.unsafe.type_context.get_env", "parentIds": []}, {"id": "tactic.unsafe.type_context", "parentIds": ["tactic.unsafe.type_context.get_env", "tactic.unsafe.type_context.level.instantiate_mvars", "tactic.unsafe.type_context.bind", "tactic.unsafe.type_context.get_fun_info", "tactic.unsafe.type_context.whnf", "tactic.unsafe.type_context.list_mvars", "tactic.unsafe.type_context.fold_mvars", "tactic.unsafe.type_context.run", "tactic.unsafe.type_context.level.tmp_get_assignment", "tactic.unsafe.type_context.monad_fail", "tactic.unsafe.type_context.mk_mvar", "tactic.unsafe.type_context.assign", "tactic.unsafe.type_context.tmp_mode", "tactic.unsafe.type_context.get_assignment", "tactic.unsafe.type_context.is_stuck", "tactic.unsafe.type_context.is_declared", "tactic.unsafe.type_context.monad", "tactic.unsafe.type_context.print_mvars", "tactic.unsafe.type_context.unify", "tactic.unsafe.type_context.is_regular_mvar", "tactic.unsafe.type_context.infer", "tactic.unsafe.type_context.to_tmp_mvars", "tactic.unsafe.type_context.is_tmp_mvar", "tactic.unsafe.type_context.in_tmp_mode", "tactic.unsafe.type_context.is_assigned", "tactic.unsafe.type_context.instantiate_mvars", "tactic.unsafe.type_context.orelse", "tactic.unsafe.type_context.get_context", "tactic.unsafe.type_context.trace", "tactic.unsafe.type_context.try", "tactic.unsafe.type_context.level.assign", "tactic.unsafe.type_context.tmp_get_assignment", "tactic.unsafe.type_context.is_def_eq", "tactic.unsafe.type_context.tmp_is_assigned", "tactic.unsafe.type_context.failure", "tactic.unsafe.type_context.fail", "tactic.unsafe.type_context.level.tmp_is_assigned", "tactic.unsafe.type_context.pop_local", "tactic.unsafe.type_context.get_local_context", "tactic.unsafe.type_context.push_local", "tactic.unsafe.type_context.pure", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "functor.const.mk'", "parentIds": []}, {"id": "functor.const", "parentIds": ["functor.const.mk'", "functor.const.ext", "functor.const.is_lawful_functor", "functor.const.applicative", "functor.const.is_lawful_applicative", "functor.add_const", "functor.const.functor", "functor.const.run", "functor.const.map"]}, {"id": "punit", "parentIds": ["functor.const.mk'", "put", "punit.decidable_eq", "nat.pow_le_pow_of_le_left", "nat.shiftl_eq_mul_pow", "nat.shiftl'_add", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "nat.bodd_add_div2", "list.length_le_of_sublist", "nat.zero_le", "punit.has_sizeof", "nat.shiftr_eq_div_pow", "list.length_drop", "state_t.put", "expr.mfoldl", "list.filter_append", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "nat.sub_induction", "nat.zero_mul", "nat.bit0_inj", "nat.add_comm", "nat.shiftl'_sub", "punit.inhabited", "nat.zero_sub", "nat.sub_self", "nat.add_left_cancel", "mzip_with'", "tactic.add_theorem_by", "nat.add_sub_add_right", "nat.bit1_ne_bit0", "nat.shiftr_add", "list.length_take", "unit", "d_array.of_beq_aux_eq_ff", "old_conv.congr_core", "nat.succ_add", "nat.le_add_right", "list.length_map_accumr", "nat.le.dest", "punit.subsingleton", "modify", "nat.left_distrib", "list.filter_sublist", "nat.right_distrib", "state_t.run_put", "nat.sub_sub", "nat.mul_sub_right_distrib", "nat.le_of_sub_eq_zero", "nat.succ_ne_self", "state_t.modify", "punit_eq", "punit_eq_punit", "nat.two_step_induction", "punit.reflect", "nat.succ_mul", "nat.sub_le_sub_right", "list.length_map_accumr\u2082", "nat.mul_comm", "unit.star", "sort.inhabited", "list.length_remove_nth", "nat.zero_add", "nat.shiftl'_tt_eq_mul_pow", "list.partition_eq_filter_filter", "sort.inhabited'", "nat.add_assoc"]}, {"id": "name_set.to_list", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.unfold_aux", "tactic.interactive.squeeze_simpa"]}, {"id": "name_set.fold", "parentIds": ["name_set.to_list", "name_set.mfold", "name_set.has_to_format", "name_set.union", "name_set.mfilter", "name_set.mmap", "name_set.filter"]}, {"id": "name_set", "parentIds": ["name_set.to_list", "tactic.interactive.squeeze_simp", "tactic.interactive.with_cases", "name_set.size", "name_set.mfold", "mk_name_set", "name_set.of_list", "has_dup", "name_set.has_to_format", "tactic.non_dep_prop_hyps", "name_set.contains", "name_set.union", "expr.has_local_in", "lint", "no_rsimp", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.unfold_aux", "tactic.interactive.squeeze_simpa", "rsimp_attr", "name_set.mfilter", "name_set.insert_list", "name_set.insert", "name_set.inhabited", "name_set.erase", "lint_hole_cmd", "environment.get_class_attribute_symbols", "tactic.mk_constructor_fresh_names", "lint_aux", "get_name_set_for_attr", "name_set.empty", "name_set.mmap", "name_set.filter", "name_set.fold", "tactic.interactive.erase_simp_args", "tactic.interactive.clear_except", "expr.list_constant", "mk_name_set_attr", "expr.list_names_with_prefix", "lint_mathlib", "lint_all"]}, {"id": "tactic.interactive.constructor", "parentIds": []}, {"id": "tactic.constructor", "parentIds": ["tactic.interactive.constructor", "tactic.mk_has_sizeof_instance_core", "tactic.econstructor", "tactic.mk_inhabited_instance", "tactic.fconstructor", "tactic.inhabited_instance"]}, {"id": "tactic.new_goals", "parentIds": ["tactic.interactive.constructor", "tactic.apply_iff", "tactic.apply_cfg.inhabited", "tactic.rewrite_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "tactic.symm_apply", "tactic.interactive.apply_iff_congr_core", "tactic.left", "tactic.econstructor", "tactic.interactive.generalize_hyp", "tactic.extract_def", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.interactive.convert_to_core", "tactic.apply_assumption", "conv.funext", "tactic.constructor_idx", "tactic.interactive.ext1", "tactic.lift", "tactic.right", "tactic.fapply", "tactic.rewrite_hyp", "conv.interactive.rw", "tactic.rewrite_cfg.inhabited", "tactic.by_cases", "tactic.mk_inhabited_instance", "tactic.new_goals.inhabited", "tactic.apply_heq_congr_core", "tactic.suggest.apply_and_solve", "tactic.apply", "tactic.interactive.erw", "tactic.interactive.use", "tactic.interactive.ext", "tactic.interactive.erewrite", "tactic.apply_congr_core", "tactic.constructor", "tactic.fsplit", "tactic.assoc_rewrite", "tactic.rewrite_target", "tactic.fconstructor", "conv.interactive.erw", "tactic.apply_cfg", "tactic.ext1", "tactic.interactive.mapply", "tactic.apply_core", "tactic.split", "conv.interactive.rewrite", "tactic.interactive.rwa", "smt_tactic.by_contradiction", "tactic.interactive.rw", "tactic.inhabited_instance", "tactic.applyc", "tactic.interactive.h_generalize", "tactic.interactive.rewrite", "tactic.reduce_ifs_at", "tactic.interactive.apply", "tactic.eapply"]}, {"id": "tactic.apply_cfg", "parentIds": ["tactic.interactive.constructor", "tactic.apply_iff", "tactic.apply_cfg.inhabited", "tactic.rewrite_core", "tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "tactic.symm_apply", "tactic.interactive.apply_iff_congr_core", "tactic.left", "tactic.econstructor", "tactic.interactive.generalize_hyp", "tactic.extract_def", "tactic.interactive.apply_field", "tactic.rewrite", "tactic.try_apply_opt_auto_param_for_apply", "tactic.interactive.convert_to_core", "tactic.apply_assumption", "conv.funext", "tactic.constructor_idx", "tactic.interactive.ext1", "tactic.lift", "tactic.right", "tactic.fapply", "tactic.rewrite_hyp", "conv.interactive.rw", "tactic.rewrite_cfg", "tactic.rewrite_cfg.inhabited", "tactic.by_cases", "tactic.mk_inhabited_instance", "tactic.try_apply_opt_auto_param", "tactic.apply_heq_congr_core", "tactic.suggest.apply_and_solve", "tactic.apply", "tactic.interactive.erw", "tactic.interactive.use", "tactic.interactive.ext", "tactic.interactive.erewrite", "tactic.apply_congr_core", "tactic.constructor", "tactic.fsplit", "tactic.assoc_rewrite", "tactic.rewrite_target", "tactic.fconstructor", "conv.interactive.erw", "tactic.ext1", "tactic.interactive.mapply", "tactic.interactive.apply_with", "tactic.apply_core", "tactic.split", "conv.interactive.rewrite", "tactic.interactive.rwa", "smt_tactic.by_contradiction", "tactic.interactive.rw", "tactic.inhabited_instance", "tactic.applyc", "tactic.interactive.h_generalize", "tactic.interactive.rewrite", "tactic.reduce_ifs_at", "tactic.interactive.apply", "tactic.eapply"]}, {"id": "tactic.interactive.concat_tags", "parentIds": ["tactic.interactive.constructor", "tactic.interactive.by_cases", "tactic.interactive.right", "tactic.interactive.econstructor", "tactic.interactive.split", "tactic.interactive.eapply", "tactic.interactive.mapply", "tactic.interactive.apply_with", "tactic.interactive.left", "tactic.interactive.fapply", "tactic.interactive.fconstructor", "tactic.interactive.apply"]}, {"id": "neg_eq_iff_neg_eq", "parentIds": []}, {"id": "eq_neg_iff_eq_neg", "parentIds": ["neg_eq_iff_neg_eq", "add_eq_zero_iff_neg_eq"]}, {"id": "eq_comm", "parentIds": ["neg_eq_iff_neg_eq", "mul_eq_one_iff_inv_eq", "inv_eq_iff_inv_eq", "add_eq_zero_iff_neg_eq", "not_lt_iff_eq_or_lt", "bool.ff_eq_to_bool_iff", "bool.tt_eq_to_bool_iff", "option.mem_to_list", "exists_eq_right'", "forall_eq'", "exists_eq_left'"]}, {"id": "add_group", "parentIds": ["neg_eq_iff_neg_eq", "add_left_eq_self", "neg_add_self", "eq_add_neg_iff_add_eq", "add_right_eq_self", "eq_of_sub_eq_zero", "add_group.to_has_neg", "add_right_surjective", "sub_eq_zero_of_eq", "neg_inj'", "add_neg_eq_of_eq_add", "add_neg_eq_iff_eq_add", "sub_ne_zero_of_ne", "add_group.to_left_cancel_add_semigroup", "eq_add_neg_of_add_eq", "sub_eq_iff_eq_add", "norm_num.subst_into_subtr", "left_inverse_neg_add_add_right", "left_inverse_add_left_sub", "left_inverse_add_right_neg_add", "add_comm_group.to_add_group", "eq_neg_iff_eq_neg", "zero_sub", "add_eq_zero_iff_neg_eq", "norm_num.neg_zero_helper", "add_self_iff_eq_zero", "add_group_has_sub", "neg_add_eq_iff_eq_add", "neg_add_cancel_right", "add_sub_add_right_eq_sub", "eq_add_of_add_neg_eq", "left_inverse_neg", "sub_add_cancel", "add_eq_zero_iff_eq_neg", "sub_eq_zero", "add_neg_self", "sub_ne_zero", "eq_iff_eq_of_sub_eq_sub", "sub_sub_assoc_swap", "sub_eq_of_eq_add", "neg_comm_of_comm", "add_neg_cancel_right", "add_group.add_right_cancel", "algebra.sub", "eq_sub_of_add_eq", "sub_zero", "eq_neg_iff_add_eq_zero", "sub_add_sub_cancel", "add_eq_of_eq_add_neg", "neg_sub", "add_group.to_add_monoid", "add_sub_cancel", "eq_neg_add_of_add_eq", "add_right_neg", "neg_involutive", "add_sub", "add_left_neg", "eq_of_neg_eq_neg", "neg_inj", "add_neg_cancel_left", "neg_add_rev", "left_inverse_sub_add_left", "neg_add_cancel_left", "neg_eq_iff_add_eq_zero", "add_left_surjective", "neg_eq_zero", "neg_ne_zero", "eq_sub_iff_add_eq", "neg_neg", "eq_add_of_neg_add_eq", "sub_sub_sub_cancel_right", "eq_neg_of_add_eq_zero", "eq_add_of_sub_eq", "sub_eq_add_neg", "sub_left_inj", "sub_eq_zero_iff_eq", "eq_neg_add_iff_add_eq", "norm_num.neg_neg_helper", "sub_right_inj", "neg_eq_of_add_eq_zero", "sub_self", "add_eq_of_eq_neg_add", "neg_zero", "add_eq_of_eq_sub", "sub_neg_eq_add", "neg_add_eq_of_eq_add", "eq_neg_of_eq_neg", "sub_add_eq_sub_sub_swap", "add_group.add_left_cancel", "add_sub_assoc", "add_neg_eq_zero", "add_group.to_right_cancel_add_semigroup"]}, {"id": "if_ctx_simp_congr_prop", "parentIds": ["if_simp_congr_prop"]}, {"id": "if_ctx_congr_prop", "parentIds": ["if_ctx_simp_congr_prop", "if_congr_prop"]}, {"id": "not_exists", "parentIds": ["not_forall_not", "not_exists_not", "push_neg.not_exists_eq"]}, {"id": "exists_imp_distrib", "parentIds": ["not_exists", "not_exists_of_forall_not", "bex_imp_distrib"]}, {"id": "tactic.get_subsingleton_info", "parentIds": []}, {"id": "subsingleton_info", "parentIds": ["tactic.get_subsingleton_info", "subsingleton_info.has_to_format", "subsingleton_info_to_format", "tactic.get_spec_subsingleton_info", "subsingleton_info.inhabited"]}, {"id": "nat.eq_zero_of_add_eq_zero", "parentIds": []}, {"id": "nat.eq_zero_of_add_eq_zero_left", "parentIds": ["nat.eq_zero_of_add_eq_zero", "nat.eq_zero_of_mul_eq_zero"]}, {"id": "nat.eq_zero_of_add_eq_zero_right", "parentIds": ["nat.eq_zero_of_add_eq_zero", "nat.eq_zero_of_add_eq_zero_left", "int.le_antisymm"]}, {"id": "nat.pred_zero", "parentIds": ["nat.eq_zero_or_eq_succ_pred", "nat.mul_pred_left"]}, {"id": "nat.pred", "parentIds": ["nat.pred_zero", "nat.sub_succ", "nat.eq_zero_or_eq_succ_pred", "nat.pred_le", "nat.pred_lt_pred", "nat.succ_sub_succ_eq_sub", "nat.zero_sub", "nat.pred_le_pred", "int.lt_iff_le_and_ne", "nat.mul_pred_left", "nat.le_succ_of_pred_le", "nat.mul_pred_right", "nat.sub_mul_div", "nat.pred_lt", "nat.exists_eq_succ_of_ne_zero", "nat.sub_sub", "nat.mul_sub_right_distrib", "nat.sub_le_sub_right", "nat.pred_inj", "nat.sub_one", "nat.zero_pow", "nat.pred_succ", "nat.mul_sub_div", "nat.succ_pred_eq_of_pos"]}, {"id": "function.id_of_left_inverse", "parentIds": []}, {"id": "function.left_inverse", "parentIds": ["function.id_of_left_inverse", "function.injective_of_has_left_inverse", "function.left_inverse_surj_inv", "function.involutive.left_inverse", "function.left_inverse_inv_fun", "left_inverse_neg_add_add_right", "left_inverse_add_left_sub", "left_inverse_add_right_neg_add", "function.injective_surj_inv", "left_inverse_neg", "prod.swap_left_inverse", "function.left_inverse_of_surjective_of_right_inverse", "function.left_inverse.comp_eq_id", "left_inverse_sub_add_left", "sum.swap_left_inverse", "function.right_inverse", "function.injective_of_left_inverse", "left_inverse_inv", "function.left_inverse.comp", "function.right_inverse_of_injective_of_left_inverse", "function.bijective_iff_has_inverse", "function.injective.has_left_inverse", "function.has_left_inverse"]}, {"id": "comm_semiring", "parentIds": ["dvd.intro", "eq_zero_of_zero_dvd", "mul_dvd_mul", "dvd_mul_left", "dvd_of_mul_left_dvd", "int.comm_semiring", "one_dvd", "dvd.trans", "dvd_of_mul_right_dvd", "nat.comm_semiring", "exists_eq_mul_left_of_dvd", "dvd.elim", "exists_eq_mul_right_of_dvd", "dvd.intro_left", "dvd_trans", "dvd_mul_of_dvd_right", "dvd_mul_of_dvd_left", "mul_dvd_mul_left", "comm_ring.to_comm_semiring", "dvd_mul_right", "mul_dvd_mul_right", "dvd_add", "comm_semiring.to_comm_monoid", "comm_semiring_has_dvd", "nat.decidable_linear_ordered_semiring", "dvd.elim_left", "dvd_refl", "dvd_of_mul_left_eq", "comm_semiring.to_semiring", "dvd_zero", "dvd_of_mul_right_eq"]}, {"id": "add_semigroup", "parentIds": ["comm_semiring", "discrete_field", "add_assoc", "linear_ordered_semiring", "add_comm_group", "decidable_linear_ordered_semiring", "add_left_cancel_semigroup", "integral_domain", "semiring", "add_monoid.to_add_semigroup", "decidable_linear_ordered_cancel_comm_monoid", "ring", "division_ring", "linear_ordered_comm_ring", "add_comm_semigroup.to_add_semigroup", "add_semigroup_to_is_eq_associative", "int.add_semigroup", "ordered_semiring", "add_semigroup.to_has_add", "discrete_linear_ordered_field", "add_right_cancel_semigroup", "comm_ring", "add_group", "linear_ordered_ring", "add_left_cancel_semigroup.to_add_semigroup", "add_comm_semigroup", "add_comm_monoid", "ordered_comm_group", "field", "ordered_cancel_comm_monoid", "add_right_cancel_semigroup.to_add_semigroup", "decidable_linear_ordered_comm_ring", "nat.add_semigroup", "linear_ordered_field", "add_monoid", "ordered_ring", "decidable_linear_ordered_comm_group"]}, {"id": "semigroup", "parentIds": ["comm_semiring", "discrete_field", "linear_ordered_semiring", "decidable_linear_ordered_semiring", "comm_group", "integral_domain", "mul_assoc", "semiring", "ring", "division_ring", "linear_ordered_comm_ring", "semigroup.to_has_mul", "ordered_semiring", "discrete_linear_ordered_field", "nat.semigroup", "comm_ring", "linear_ordered_ring", "comm_monoid", "group", "int.semigroup", "comm_semigroup", "semigroup_to_is_associative", "left_cancel_semigroup.to_semigroup", "monoid.to_semigroup", "monoid", "comm_semigroup.to_semigroup", "field", "decidable_linear_ordered_comm_ring", "right_cancel_semigroup", "left_cancel_semigroup", "linear_ordered_field", "ordered_ring", "right_cancel_semigroup.to_semigroup"]}, {"id": "semigroup.to_has_mul", "parentIds": ["comm_semiring", "mul_sub_mul_div_mul_nonpos", "mul_self_sub_one_eq", "discrete_field", "nat.shiftl_eq_mul_pow", "div_sub_div", "nat.add_mul_mod_self_right", "eq_inv_iff_mul_eq_one", "linear_ordered_semiring", "monoid_to_is_left_id", "mul_right_eq_self", "mul_dvd_mul", "eq_mul_inv_iff_mul_eq", "nat.mul_div_assoc", "mul_inv_rev", "decidable_linear_ordered_semiring", "eq_zero_of_mul_eq_self_right", "nat.eq_of_mul_eq_mul_right", "nat.bodd_add_div2", "field.one_div_mul_one_div", "nat.add_mul_div_right", "mul_eq_one_iff_inv_eq", "norm_num.mul_one", "abs_sub_square", "mul_right_cancel", "dvd_of_mul_left_dvd", "comm_group", "nat.pow_lt_pow_of_lt_right", "mul_right_inj", "div_div_eq_div_mul", "div_mul_eq_mul_div", "mul_one", "integral_domain", "mul_assoc", "semiring", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "mul_inv", "one_dvd", "eq_of_mul_eq_mul_of_nonzero_right", "one_mul", "div_mul_cancel", "nat.pow_le_pow_of_le_right", "mul_div_cancel_left", "mul_left_comm", "comm_semigroup_to_is_commutative", "dvd_of_mul_right_dvd", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "mul_self_iff_eq_one", "add_mul_self_eq", "ring", "div_mul_left", "division_ring", "mul_right_surjective", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "eq_inv_mul_iff_mul_eq", "int.distrib_left", "mul_eq_one_iff_eq_inv", "nat.div_mul_cancel", "mul_eq_of_eq_inv_mul", "mul_left_eq_self", "int.eq_one_of_mul_eq_self_left", "mul_right_comm", "ordered_semiring", "mul_inv_eq_iff_eq_mul", "discrete_linear_ordered_field", "dvd.intro_left", "mul_inv_cancel_left", "le_mul_of_ge_one_left", "comm_ring", "mul_left_cancel", "linear_ordered_ring", "mul_right_inv", "field.div_mul_left", "field.div_mul_eq_mul_div_comm", "mul_inv_self", "le_of_mul_le_of_ge_one", "neg_dvd_of_dvd", "one_inv_eq", "comm_monoid", "inv_mul_cancel_left", "group", "nat.mul_le_mul_right", "dvd_trans", "nat.dvd_of_mul_dvd_mul_right", "field.div_mul_div", "mul_eq_of_eq_mul_inv", "mul_right_cancel_iff", "lt_mul_of_gt_one_right", "dvd_mul_of_dvd_right", "nat.mul_mod_left", "nat.mul_lt_mul_of_pos_right", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "nat.div_lt_self", "group.mul_left_cancel", "add_self_div_two", "dvd_mul_of_dvd_left", "nat.mul_div_left", "one_div_neg_one_eq_neg_one", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "functor.const.is_lawful_applicative", "comm_semigroup", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "mul_div_assoc", "field.div_mul_right", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "mul_inv_eq_one", "mul_left_injective", "semigroup_to_is_associative", "inv_comm_of_comm", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "mul_left_surjective", "nat.mul_self_sub_mul_self_eq", "div_eq_one_iff_eq", "mul_div_mul_left", "monoid", "eq_mul_of_inv_mul_eq", "inv_mul_self", "mul_div_mul_right'", "mul_comm", "field", "mul_inv_eq_of_eq_mul", "mul_div_cancel'", "nat.mul_div_cancel_left", "mul_div_mul_right", "eq_zero_of_mul_eq_self_left", "nat.dvd_of_mul_dvd_mul_left", "inv_eq_of_mul_eq_one", "mul_self_eq_mul_self_iff", "eq_inv_of_mul_eq_one", "add_halves", "mul_div_cancel", "eq_inv_mul_of_mul_eq", "decidable_linear_ordered_comm_ring", "int.eq_one_of_mul_eq_self_right", "right_cancel_semigroup", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "nat.le_of_dvd", "mul_left_inv", "eq_one_div_of_mul_eq_one_left", "mul_left_cancel_iff", "eq_one_div_of_mul_eq_one", "left_cancel_semigroup", "monoid_to_is_right_id", "mul_mul_div", "mul_right_injective", "nat.mod_pow_succ", "linear_ordered_field", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "mul_inv_cancel_right", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "mul_left_inj", "division_ring.one_div_mul_one_div", "mul_mul_mul_comm", "eq_mul_of_mul_inv_eq", "ordered_ring", "mul_self_eq_one_iff", "nat.mul_mod_mul_right", "nat.shiftl'_tt_eq_mul_pow", "inv_mul_eq_iff_eq_mul", "division_ring.one_div_neg_eq_neg_one_div", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "group.mul_right_cancel", "div_lt_div_of_mul_sub_mul_div_neg", "inv_mul_cancel_right"]}, {"id": "format.join", "parentIds": ["tactic.interactive.format_names", "tactic.clear'", "tactic.interactive.rec.to_tactic_format", "tactic.mk_patterns", "tactic.eqn_stub", "tactic.list_constructors_hole", "tactic.interactive.rintro", "list.to_format", "tactic.match_stub", "format.intercalate", "interactive.param_desc", "tactic.rename'"]}, {"id": "format.of_string", "parentIds": ["format.join", "string_to_format", "char.has_to_format", "decidable.has_to_format", "bool.has_to_format", "native.float.has_to_format", "string.has_to_format"]}, {"id": "list.foldl", "parentIds": ["format.join", "tactic.interactive.squeeze_simp", "list.prod", "print_decls_sorted", "transport_multiplicative_to_additive", "name_set.of_list", "has_dup", "string.fold", "print_decls", "tactic.revert_all", "rbmap.from_list", "tactic.interactive.squeeze_simpa", "print_decls_sorted_mathlib", "list.sum", "rbtree.from_list", "tactic.explode.pad_right", "tactic.decode_simp_arg_list", "string.join"]}, {"id": "format.compose", "parentIds": ["format.join", "format.has_append"]}, {"id": "char.val_of_nat_eq_of_is_valid", "parentIds": ["char.of_nat_ne_of_ne"]}, {"id": "char.of_nat", "parentIds": ["char.val_of_nat_eq_of_is_valid", "char.of_nat_eq_of_not_is_valid", "to_additive.guess_name", "char.val_of_nat_eq_of_not_is_valid", "char.is_whitespace", "char.to_lower", "parser.mk_error_msg", "tactic.unprime", "char.is_punctuation", "nat.digit_char", "char.decidable_is_punctuation", "name.deinternalize_field", "char.inhabited", "tactic.explode.pad_right", "tactic.interactive.clear_", "char.of_nat_ne_of_ne", "char.decidable_is_whitespace", "char.quote_core", "tactic.alias.make_left_right"]}, {"id": "is_valid_char", "parentIds": ["char.val_of_nat_eq_of_is_valid", "is_valid_char_range_1", "char.of_nat_eq_of_not_is_valid", "is_valid_char_range_2", "char.val_of_nat_eq_of_not_is_valid", "char.of_nat", "char", "char.of_nat_ne_of_ne", "char.eq_of_veq"]}, {"id": "nat.decidable_lt", "parentIds": ["char.val_of_nat_eq_of_is_valid", "parser.sat", "nat.mod_lt", "nat.div_eq_of_lt", "param_info.to_format", "tactic.existsi", "unused_arguments", "nat.div_def", "char.decidable_lt", "char.val_of_nat_eq_of_not_is_valid", "nat.lt_ge_by_cases", "char.to_lower", "nat.div_def_aux", "nat.mod_eq_of_lt", "char.of_nat", "environment.is_refl_app", "tactic.unprime", "array.write'", "tactic.lift", "tactic.interactive.simp_core_aux", "buffer.lt_aux_2", "char.decidable_is_digit", "nat.zero_mod", "unsigned.of_nat'", "char.decidable_is_upper", "nat.eq_one_of_dvd_one", "list.of_fn_nth_val", "array.read'", "fin.decidable_lt", "buffer.lt_aux_3", "nat.div2_val", "nat.mod_zero", "rsimp.choose", "nat.strong_rec_on", "char.decidable_is_lower", "nat.div2_bit", "nat.decidable_linear_ordered_semiring", "nat.div_eq_sub_div", "nat.zero_div", "nat.mod_def_aux", "array.read_eq_read'", "nat.mod_add_div", "where.binder_less_important", "nat.mod_eq_sub_mod", "interaction_monad.result.clamp_pos", "instance_priority", "instance_derive_handler", "nat.mod_two_eq_zero_or_one", "array.write_eq_write'", "tactic.suggest", "tactic.interactive.case", "nat.mod_def", "nat.div_zero", "dup_namespace"]}, {"id": "or.decidable", "parentIds": ["char.val_of_nat_eq_of_is_valid", "tactic.replace_at", "expr.mk_exists_lst", "tactic.mk_assumption_set", "incorrect_def_lemma", "tactic.interactive.solve_by_elim", "prod.lex.decidable", "char.val_of_nat_eq_of_not_is_valid", "prod_has_decidable_lt", "char.of_nat", "bor_coe_iff", "tactic.interactive.simp_core_aux", "tactic.intro", "or_iff_not_and_not", "tactic.suggest.process_declaration", "ordering.or_else_eq_lt", "declaration.is_auto_generated", "char.quote_core", "bool.decidable_exists_bool", "tactic.alias.get_alias_target", "char.decidable_is_alpha", "instance_priority", "bool.to_bool_or", "tactic.alias.make_left_right", "tactic.suggest", "char.decidable_is_alphanum", "has_inhabited_instance", "dup_namespace"]}, {"id": "bit0", "parentIds": ["char.val_of_nat_eq_of_is_valid", "tactic.library_search_hole_cmd", "one_add_one_eq_two", "is_valid_char_range_1", "simp.default_max_steps", "norm_num.bit0_add_bit1", "tactic.interactive.rsimp", "nat.shiftl_eq_mul_pow", "norm_num.mul_bit0", "tactic.injections_with", "nat.one_lt_bit0", "two_mul", "norm_num.mul_bit0_helper", "bit0_zero", "tactic.existsi", "unused_arguments", "norm_num.add1_bit1", "add_midpoint", "int.bit", "is_valid_char_range_2", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "two_ne_zero", "sum_has_to_format", "using_smt", "environment.for_decl_of_imported_module", "smt_pre_config.inhabited", "nat.bodd_add_div2", "tactic.get_unused_decl_name", "rbtree.default_lt", "nat.bit0_val", "exists_add_lt_and_pos_of_lt", "nat.bit1_lt", "to_additive.guess_name", "std.priority.default", "nat.shiftr_eq_div_pow", "char.val_of_nat_eq_of_not_is_valid", "tactic.mk_dec_eq_instance", "div_two_sub_self", "char.is_whitespace", "nat.mod_two_of_bodd", "nat.repr", "old_conv.conversion", "char.to_lower", "parser.mk_error_msg", "interactive.types.tac_rbp", "nat.bit0_inj", "nat.zero_shiftr", "tactic.interactive.convert_to_core", "norm_num.bit1_add_bit0_helper", "string.hash", "rsimp.config.inhabited", "nat.bit", "nat.one_le_bit0", "char.of_nat", "int.nat_abs_bit0_step", "char.is_lower", "nat.one_shiftl", "two_gt_one", "nat.one_le_bit1", "add_mul_self_eq", "environment.is_refl_app", "tactic.has_opt_auto_param", "tactic.unprime", "tactic.lift", "int.bit1_pos", "nat.mk_numeral", "norm_num.bit0_add_bit1_helper", "std.prec.arrow", "char.decidable_is_digit", "char.is_punctuation", "tactic.rcases_parse_depth", "nat.digit_char", "std.prec.max", "tactic.decorate_ex", "char.decidable_is_punctuation", "tactic.has_opt_auto_param_for_apply", "nat.bit_decomp", "well_founded_tactics.cancel_nat_add_lt", "nat.bit1_ne_bit0", "name.deinternalize_field", "std.prec.max_plus", "char.decidable_is_upper", "norm_num.nonneg_bit0_helper", "int.nat_abs_bit0", "norm_num.one_add_bit1", "char.is_upper", "norm_num.add1_bit1_helper", "buffer.lt_aux_3", "norm_num.pos_bit0_helper", "smt_tactic.execute", "int.bit0_pos", "norm_num.bit0_add_bit0_helper", "nat.div2_val", "nat.bit1_val", "char.inhabited", "add_self_div_two", "norm_num.bit1_add_bit0", "nat.bit0_lt", "rsimp.collect_implied_eqs", "int.nat_abs_bit1_nonneg", "option.has_to_format", "tactic.explode.pad_right", "smt_config.inhabited", "nat.bit0_succ_eq", "tactic.interactive.replace", "nat.bit0_ne_one", "tactic.interactive.clear_", "nat.bodd_bit", "nat.bit0_ne_bit1", "expr.is_bin_arith_app", "char.is_digit", "nat.shiftl_succ", "tactic.iterate", "tactic.interactive.convert_to", "nat.zero_lt_bit1", "char.decidable_is_lower", "nat.one_ne_bit0", "nat.bit1_inj", "char_to_hex", "nat.div2_bit", "nat.prio", "nat.bit0_lt_bit1", "where.binder_priority", "smt_tactic.iterate", "norm_num.bit1_add_bit1", "nat.zero_ne_bit0", "nat.bit_val", "norm_num.one_add_one", "nat.bit1_eq_succ_bit0", "tactic.back_chaining_core", "tactic.interactive.swap", "char.decidable_is_whitespace", "sub_self_div_two", "is_valid_char", "two_ge_one", "two_pos", "char.quote_core", "tactic.rsimp", "add_halves", "tactic.alias.get_alias_target", "nat.zero_shiftl", "char.zero_lt_d800", "tactic.rsimp_at", "norm_num.bit1_add_bit1_helper", "nat.bit1_ne_one", "instance_priority", "ematch_config.inhabited", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "lean.version", "tactic.get_mathlib_dir", "nat.mod_two_eq_zero_or_one", "int.bit0_nonneg", "norm_num.one_add_bit1_helper", "nat.div2_two", "tactic.mk_inj_eq", "nat.bit1_succ_eq", "bit1", "norm_num.mul_bit1", "environment.from_imported_module", "tactic.interactive.apply_rules", "tactic.alias.make_left_right", "norm_num.add1_one", "nat.bit0_ne_zero", "norm_num.bit0_add_one", "norm_num.bit0_add_bit0", "tactic.interactive.suggest", "nat.bit0_ne", "nat.bit1_lt_bit0", "tactic.interactive.push_neg", "nat.shiftl'_tt_eq_mul_pow", "four_pos", "div_two_lt_of_pos", "tactic.exact_dec_trivial", "norm_num.one_add_bit0", "nat.cond_to_bool_mod_two", "function.involutive_iff_iter_2_eq_id", "smt_tactic.interactive.executor", "nat.zero_lt_bit0", "dup_namespace", "norm_num.add1_bit0", "nat.bodd_two"]}, {"id": "and.decidable", "parentIds": ["char.val_of_nat_eq_of_is_valid", "nat.div_eq_of_lt", "nat.div_def", "expr.is_napp_of", "prod.lex.decidable", "char.val_of_nat_eq_of_not_is_valid", "tactic.mk_dec_eq_instance", "tactic.interactive.unfold_projs", "char.to_lower", "nat.div_def_aux", "nat.mod_eq_of_lt", "prod_has_decidable_lt", "char.of_nat", "lint", "tactic.lift", "list.decidable_chain", "char.decidable_is_digit", "nat.zero_mod", "char.decidable_is_upper", "bool.to_bool_and", "environment.is_ginductive'", "nat.mod_zero", "and_iff_not_or_not", "char.decidable_is_lower", "ordering.or_else_eq_lt", "where.is_in_namespace_nonsynthetic", "declaration.is_auto_generated", "bool.decidable_forall_bool", "tactic.mk_simp_set_core", "nat.div_eq_sub_div", "nat.zero_div", "nat.mod_def_aux", "nat.mod_add_div", "nat.mod_eq_sub_mod", "band_coe_iff", "list_items", "instance_priority", "instance_derive_handler", "interactive.param_desc", "tactic.suggest", "nat.mod_def", "tactic.find_private_decl", "tactic.mk_eq_proof", "nat.div_zero", "lint_mathlib", "list.decidable_pairwise", "lint_all", "tactic.ids_to_simp_arg_list"]}, {"id": "char", "parentIds": ["char.val_of_nat_eq_of_is_valid", "parser.sat", "string.quote_aux", "char.decidable_eq", "string.over_list", "string.iterator.set_curr", "parser.one_of'", "char.of_nat_eq_of_not_is_valid", "char.has_to_string", "string.back", "string_imp", "string.to_char_buffer", "string.get_rest", "parser.foldl", "format.to_buffer", "string.iterator.length_next_to_string_next", "string.empty", "char.decidable_lt", "string.str", "char.repr", "string.iterator.curr", "string.fold", "string.singleton", "char.val_of_nat_eq_of_not_is_valid", "char.to_string", "char.is_whitespace", "string.str_ne_empty", "char.has_le", "nat.repr", "char.to_lower", "parser.mk_error_msg", "parser.foldr", "string.hash", "char.of_nat", "char.is_lower", "string.map_tokens", "string.iterator.next_to_string_mk_iterator", "tactic.unprime", "string.split_on", "string.iterator.extract_core", "string.iterator.zero_lt_length_next_to_string_of_has_next", "string.push", "string.str_ne_str_right", "string.to_list", "char.has_to_format", "char.decidable_is_digit", "string.intercalate", "char.is_punctuation", "char.veq_of_eq", "nat.digit_char", "char.decidable_is_punctuation", "char.has_sizeof", "char.le", "string.split", "char.ne_of_vne", "string.empty_ne_str", "name.deinternalize_field", "string.is_suffix_of", "char.decidable_is_upper", "parser.one_of", "char.to_nat", "char.is_upper", "char.is_alpha", "parser.many_char1", "buffer.append_string", "char.has_lt", "char.vne_of_ne", "char.inhabited", "string.has_decidable_eq", "list.as_string", "tactic.interactive.clear_", "char.of_nat_ne_of_ne", "char.is_digit", "char.is_alphanum", "char.decidable_le", "char.decidable_is_lower", "parser.ch", "char_to_hex", "parser.remaining", "string.is_prefix_of", "char_buffer", "string.str_ne_str_left", "char.eq_of_veq", "string.has_decidable_lt", "parser.fix", "string.iterator_imp", "buffer.to_string", "char.decidable_is_whitespace", "char.quote_core", "parser.str", "parser.many_char", "string.has_lt", "char.lt", "char.decidable_is_alpha", "string.front", "parser.char_buf", "string_imp.inhabited", "tactic.alias.make_left_right", "char.decidable_is_alphanum", "char.has_repr", "string.iterator_imp.inhabited"]}, {"id": "dif_pos", "parentIds": ["char.val_of_nat_eq_of_is_valid", "nat.binary_rec_eq", "function.update_same", "d_array.read_write", "function.inv_fun_on_pos", "array.read_eq_read'", "array.write_eq_write'", "function.partial_inv_of_injective"]}, {"id": "option.decidable_eq_none", "parentIds": []}, {"id": "option.is_none_iff_eq_none", "parentIds": ["option.decidable_eq_none"]}, {"id": "option.is_none", "parentIds": ["option.decidable_eq_none", "tactic.interactive.cases_matching", "tactic.interactive.set", "environment.in_current_file", "tactic.interactive.simp", "option.is_none_iff_eq_none", "tactic.interactive.cases_type", "interactive.loc.include_goal", "tactic.interactive.constructor_matching", "simps_parser", "option.eq_none_of_is_none", "tactic.ids_to_simp_arg_list", "tactic.module_doc_strings"]}, {"id": "tactic.interactive.squeeze_simp", "parentIds": []}, {"id": "tactic.strip_prefix", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "tactic.list_constructors_hole"]}, {"id": "tactic.simp_config_ext", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "tactic.interactive.simp", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_rw", "tactic.interactive.simpa", "conv.interactive.simp", "smt_tactic.interactive.simp", "tactic.interactive.choose", "tactic.interactive.parse_config", "tactic.interactive.push_neg"]}, {"id": "expr.list_constant", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "string.has_to_format", "parentIds": ["tactic.interactive.squeeze_simp", "name.has_to_format", "smt_tactic.solve1", "infer_type_cmd", "option_to_tactic_format", "print_decls_sorted", "param_info.to_format", "to_additive.target_name", "tactic.interactive.trivial", "where.trace_namespace", "tactic.existsi", "unused_arguments", "sigma.has_to_format", "tactic.cc_core", "print_arguments", "tactic.get_constructors_for", "tactic.apply_instance", "where.trace_variables", "sum_has_to_format", "tactic.match_or", "tactic.clear'", "restate_axiom_cmd", "tactic.symmetry_hyp", "name_set.has_to_format", "native.rb_map.has_to_tactic_format", "to_additive.proceed_fields", "use_cmd", "tactic.left", "tactic.interactive.triv", "tactic.assoc_refl", "print_decls", "ematch_lhs", "print_localized_commands", "tactic.terminal_goal", "smt_tactic.monad_fail", "simps_add_projection", "tactic.interactive.unfold_projs", "occurrences_to_format", "tactic.choose1", "old_conv.conversion", "native.has_to_format", "module_info.has_to_tactic_format", "tactic.try_for", "tactic.match_eq", "tactic.success_if_fail", "tactic.get_goal", "tactic.interactive.congr_core'", "tactic.interactive.change'", "lint", "tactic.returnopt", "tactic.unsafe.type_context.monad_fail", "tactic.instance_stub", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.apply_assumption", "tactic.constructor_idx", "tactic.unprime", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.abstract", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "tactic.interactive.simp_core_aux", "tactic.right", "tactic.fail_if_success", "tactic.trace_error", "tactic.mk_patterns", "print_decls_sorted_mathlib", "tactic.match_heq", "tactic.by_cases", "tactic.interactive.library_search", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.subobject_names", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.eqn_stub", "tactic.ac_refl", "where.trace_opens", "tactic.match_not", "ematch", "smt_tactic.slift_aux", "tactic.match_ne", "rsimp.rsimplify_at", "tactic.list_constructors_hole", "tactic.revert_and_transform", "tactic.local_def_value", "tactic.use", "native.rb_set.has_to_format", "tactic.interactive.obtain", "subsingleton_info_to_format", "where.trace_end", "tactic.contradiction", "tactic.mk_has_reflect_instance", "print_item_crawl", "tactic.match_and", "tactic.alias.alias_cmd", "conv.interactive.find", "prod.has_to_format", "tactic.interactive.simp_intros", "tactic.iterate_at_most_on_subgoals", "option.has_to_format", "tactic.iff_mpr", "tactic.unfold_projs", "tactic.by_contradiction", "interaction_monad.failed", "tactic.match_iff", "tactic.match_refl_app", "tactic.fsplit", "list.to_format", "get_linters", "tactic.injection_with", "tactic.fail_if_no_goals", "hinst_lemmas.pp", "tactic.interactive.change", "tactic.match_stub", "tactic.interactive.has_to_tactic_format", "list_linters", "lint_aux", "tactic.mk_simp_set_core", "tactic.simp_hyp", "tactic.solve1", "tactic.ext1", "tactic.interactive.specialize", "tactic.prove_goal_async", "tactic.split", "tactic.iff_mp", "tactic.assumption", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "format.bracket", "smt_tactic.by_cases", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "tactic.interactive.h_generalize", "interactive.param_desc", "tactic.get_lift_prf", "tactic.interactive.case", "tactic.injections_and_clear", "mk_hinst_lemma_attr_core", "conv.convert", "tactic.find_private_decl", "tactic.replacer_attr", "equiv_type_constr", "tactic.interactive.suggest", "tactic.has_to_tactic_format", "format.dcbrace", "lint_mathlib", "tactic.done", "lint_all", "tactic.ids_to_simp_arg_list", "tactic.success_if_fail_with_msg", "tactic.congr_core", "unit.has_to_format", "interaction_monad.monad_fail", "module_info.has_to_format"]}, {"id": "name_set.mmap", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "interactive.types.with_ident_list", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.cases", "tactic.interactive.field_simp", "smt_tactic.interactive.induction", "tactic.mk_simp_attribute_cmd", "tactic.interactive.induction", "tactic.interactive.dsimp", "tactic.interactive.solve_by_elim", "tactic.interactive.split_ifs", "tactic.interactive.lift", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.interactive.squeeze_simpa", "tactic.interactive.injection", "tactic.interactive.simp_intros", "tactic.interactive.simpa", "conv.interactive.simp", "tactic.interactive.extract_goal", "smt_tactic.interactive.simp", "tactic.interactive.injections", "tactic.interactive.trace_simp_set", "conv.interactive.dsimp"]}, {"id": "loc.to_string", "parentIds": ["tactic.interactive.squeeze_simp"]}, {"id": "has_to_format_to_has_to_tactic_format", "parentIds": ["tactic.interactive.squeeze_simp", "to_additive.target_name", "where.trace_namespace", "smt_tactic.trace_state", "where.trace_variables", "tactic.interactive.rcases", "print_localized_commands", "module_info.has_to_tactic_format", "where.trace_includes", "tactic.trace_result", "tactic.lift", "tactic.interactive.squeeze_simpa", "tactic.interactive.try_for", "tactic.trace_error", "tactic.interactive.library_search", "tactic.explode", "where.trace_opens", "tactic.list_constructors_hole", "tactic.trace_state", "where.trace_end", "print_item_crawl", "tactic.interactive.rintro", "tactic.iterate_at_most_on_subgoals", "list_linters", "tactic.interactive.extract_goal", "tactic.get_lift_prf", "tactic.interactive.parse_config", "tactic.interactive.trace_simp_set", "tactic.interactive.suggest", "tactic.has_to_tactic_format"]}, {"id": "name_set.mfilter", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "tactic.instantiate_mvars", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.apply_instance", "tactic.terminal_goal", "conv.update_lhs", "tactic.extract_def", "tactic.suggest.tactic_statement", "tactic.interactive.guard_hyp_strict", "tactic.abstract", "tactic.interactive.squeeze_simpa", "tactic.add_theorem_by", "tactic.comp_val", "tactic.subsingleton_goal", "tactic.prove_goal_async", "tactic.instantiate_mvars_in_target", "tactic.dsimp_target", "instance_derive_handler", "tactic.delta_instance", "tactic.interactive.guard_hyp'", "conv.convert", "derive_struct_ext_lemma", "conv.discharge_eq_lhs"]}, {"id": "format.has_append", "parentIds": ["tactic.interactive.squeeze_simp", "option_to_tactic_format", "print_decls_sorted", "param_info.to_format", "where.trace_namespace", "unused_arguments", "sigma.has_to_format", "tactic.cc_core", "print_arguments", "where.trace_variables", "sum_has_to_format", "tactic.clear'", "tactic.interactive.rcases", "name_set.has_to_format", "native.rb_map.has_to_tactic_format", "tactic.assoc_refl", "print_decls", "ematch_lhs", "simps_add_projection", "occurrences_to_format", "old_conv.conversion", "native.has_to_format", "tactic.instance_stub", "where.trace_includes", "format.indent", "tactic.unprime", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.guard_hyp_nums", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "print_decls_sorted_mathlib", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.decorate_ex", "tactic.eqn_stub", "where.trace_opens", "ematch", "tactic.list_constructors_hole", "tactic.local_def_value", "tactic.use", "native.rb_set.has_to_format", "where.trace_end", "prod.has_to_format", "tactic.interactive.rintro", "option.has_to_format", "list.to_format", "get_linters", "hinst_lemmas.pp", "tactic.match_stub", "tactic.interactive.has_to_tactic_format", "lint_aux", "binder.has_to_tactic_format", "tactic.interactive.simpa", "tactic.ext1", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "format.bracket", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "interactive.param_desc", "tactic.has_append", "mk_hinst_lemma_attr_core", "tactic.replacer_attr", "equiv_type_constr", "pos.has_to_format", "tactic.has_to_tactic_format", "format.dcbrace", "tactic.success_if_fail_with_msg"]}, {"id": "punit.reflect", "parentIds": ["tactic.interactive.squeeze_simp", "where.where_cmd", "simp_attr.pre_smt", "tactic.interactive.convert", "tactic.mk_simp_attribute_cmd", "restate_axiom_cmd", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "localized_attr", "lint_cmd", "tactic.mk_simp_attr", "ematch_lhs", "nolint_attr", "apply_nolint_cmd", "tactic.alias.alias_attr", "can_lift_attr", "tactic.trace_macro", "tactic.interactive.generalize_hyp", "localized_cmd", "tactic.interactive.set", "tactic.interactive.simp", "no_rsimp", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "lint_all_cmd", "rsimp_attr", "linter_attr", "find_cmd", "ematch", "library_note_attr", "simp_attr.functor_norm", "simp_attr.norm", "tactic.interactive.generalize", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.pformat_macro", "format_macro", "simp_attr.split_if_reduction", "tactic.interactive.constructor_matching", "open_locale_cmd", "list_linters", "debugger.attr", "derive_handler_attr", "tactic.interactive.simpa", "tactic.interactive.casesm", "mk_hinst_lemma_attr_set", "sformat_macro", "library_note", "tactic.setup_tactic_parser_cmd", "smt_tactic.interactive.simp", "tactic.interactive.h_generalize", "tactic.replaceable_attr", "mk_name_set_attr", "mk_hinst_lemma_attr_core", "tactic.explode_cmd", "tactic.replacer_attr", "tactic.interactive.contrapose", "tactic.import_private_cmd", "lint_mathlib_cmd", "tactic.fail_macro"]}, {"id": "list.empty", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.replace_at", "tactic.interactive.propagate_tags", "where.trace_variables", "where.trace_includes", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "tactic.case_bash", "tactic.eqn_stub", "where.trace_opens", "tactic.simp_intros", "tactic.interactive.simp_intros", "tactic.mk_simp_set_core", "tactic.interactive.extract_goal", "tactic.injections_and_clear", "tactic.mk_eq_proof", "tactic.rename'", "tactic.ids_to_simp_arg_list"]}, {"id": "tactic.interactive.has_to_tactic_format", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "optional", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.cases", "lean.parser.reflectable.optional", "smt_tactic.interactive.induction", "tactic.interactive.convert", "tactic.interactive.by_contra", "tactic.interactive.induction", "restate_axiom_cmd", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "smt_tactic.interactive.have", "to_additive.parser", "tactic.interactive.generalize_hyp", "tactic.interactive.abstract", "tactic.interactive.let", "tactic.interactive.set", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.simp", "tactic.interactive.rw_rule_p", "tactic.interactive.obtain_parse", "tactic.interactive.iterate", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "tactic.interactive.suffices", "tactic.rcases_parse_depth", "tactic.interactive.by_contradiction", "tactic.rcases_parse", "smt_tactic.interactive.let", "tactic.interactive.haveI", "tactic.interactive.generalize", "tactic.interactive.transitivity", "tactic.interactive.cases_type", "tactic.interactive.rename'_arg_parser", "tactic.interactive.ext", "tactic.interactive.replace", "tactic.rcases", "tactic.interactive.constructor_matching", "tactic.interactive.conv", "simps_parser", "tactic.interactive.intro", "tactic.interactive.convert_to", "tactic.interactive.congr'", "tactic.interactive.change", "tactic.interactive.conv_rhs", "tactic.using_texpr", "tactic.interactive.simpa", "tactic.interactive.casesm", "tactic.interactive.introI", "tactic.interactive.extract_goal", "tactic.interactive.have", "smt_tactic.interactive.simp", "tactic.interactive.h_generalize", "tactic.interactive.ac_change", "tactic.interactive.case", "tactic.interactive.choose", "interactive.types.using_ident", "tactic.interactive.suggest", "tactic.interactive.contrapose", "tactic.interactive.conv_lhs", "tactic.import_private_cmd"]}, {"id": "tactic.interactive.trace", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.rcases", "tactic.interactive.type_check", "tactic.interactive.squeeze_simpa", "tactic.interactive.library_search", "tactic.interactive.rintro", "tactic.interactive.extract_goal", "tactic.interactive.trace_simp_set", "tactic.interactive.suggest"]}, {"id": "name.has_to_format", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.format_names", "name_set.has_to_format", "print_decls", "ematch_lhs", "simps_add_projection", "tactic.instance_stub", "tactic.unprime", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "tactic.mk_inhabited_instance", "tactic.explode", "ematch", "tactic.list_constructors_hole", "tactic.unsafe.type_context.print_mvars", "where.trace_end", "get_linters", "tactic.interactive.has_to_tactic_format", "tactic.ext1", "mk_hinst_lemma_attr_set", "instance_derive_handler", "tactic.interactive.extract_goal", "mk_hinst_lemma_attr_core", "tactic.rename'", "tactic.replacer_attr", "equiv_type_constr"]}, {"id": "tactic.interactive.simp", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.simp_rw", "tactic.interactive.simpa", "smt_tactic.interactive.simp", "tactic.interactive.choose", "tactic.interactive.push_neg"]}, {"id": "lean.parser.reflectable.optional", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.cases", "smt_tactic.interactive.induction", "tactic.interactive.convert", "tactic.interactive.by_contra", "tactic.interactive.induction", "tactic.interactive.cases_matching", "tactic.interactive.solve_by_elim", "smt_tactic.interactive.have", "tactic.interactive.generalize_hyp", "tactic.interactive.abstract", "tactic.interactive.let", "tactic.interactive.set", "tactic.interactive.change'", "tactic.interactive.letI", "tactic.interactive.simp", "tactic.interactive.iterate", "tactic.interactive.squeeze_simpa", "tactic.interactive.suffices", "tactic.interactive.by_contradiction", "smt_tactic.interactive.let", "tactic.interactive.haveI", "tactic.interactive.generalize", "tactic.interactive.transitivity", "tactic.interactive.cases_type", "tactic.interactive.ext", "tactic.interactive.replace", "tactic.rcases", "tactic.interactive.constructor_matching", "tactic.interactive.conv", "tactic.interactive.intro", "tactic.interactive.convert_to", "tactic.interactive.congr'", "tactic.interactive.change", "tactic.interactive.conv_rhs", "tactic.interactive.simpa", "tactic.interactive.casesm", "tactic.interactive.introI", "tactic.interactive.extract_goal", "tactic.interactive.have", "smt_tactic.interactive.simp", "tactic.interactive.h_generalize", "tactic.interactive.ac_change", "tactic.interactive.case", "tactic.interactive.choose", "tactic.interactive.suggest", "tactic.interactive.contrapose", "tactic.interactive.conv_lhs"]}, {"id": "name.has_to_string", "parentIds": ["tactic.interactive.squeeze_simp", "where.trace_namespace", "where.mk_flag", "tactic.mk_simp_attribute_cmd", "restate_axiom_cmd", "where.trace_includes", "mk_hinst_lemma_attr_from_simp_attr", "tactic.interactive.squeeze_simpa", "loc.to_string_aux", "rsimp_attr", "where.trace_opens", "tactic.alias.alias_cmd", "tactic.interactive.simp_intros", "tactic.def_replacer", "my_name_to_string", "tactic.interactive.case", "tactic.replacer_attr", "tactic.ids_to_simp_arg_list", "tactic.import_private_cmd"]}, {"id": "tactic.simp_arg_list", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "tactic.interactive.dsimp", "tactic.interactive.solve_by_elim", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_intros", "tactic.interactive.simpa", "conv.interactive.simp", "smt_tactic.interactive.simp", "tactic.interactive.trace_simp_set", "conv.interactive.dsimp"]}, {"id": "succeeds", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.replace_at", "tactic.has_attribute'", "tactic.interactive.squeeze_simpa", "tactic.get_classes"]}, {"id": "bool.has_reflect", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.rw_rule.has_reflect", "tactic.interactive.field_simp", "tactic.interactive.dsimp", "tactic.interactive.solve_by_elim", "tactic.interactive.set", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_intros", "tactic.interactive.simpa", "conv.interactive.simp", "smt_tactic.interactive.simp", "mk_hinst_lemma_attr_core", "tactic.interactive.trace_simp_set", "conv.interactive.dsimp"]}, {"id": "tactic.interactive.auto_simp_lemma", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "tactic.main_goal", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa", "tactic.set_main_tag", "tactic.get_main_tag"]}, {"id": "tactic.interactive.parse_config", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "tactic.has_attribute", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.copy_attribute", "tactic.has_attribute'", "tactic.interactive.squeeze_simpa", "tactic.alias.get_alias_target", "instance_priority", "environment.get_modifiers"]}, {"id": "string.join", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa", "loc.to_string"]}, {"id": "tactic.interactive.erase_simp_args", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa"]}, {"id": "interactive.types.location", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "tactic.interactive.unfold", "tactic.interactive.unfold_coes", "tactic.interactive.dsimp", "tactic.interactive.split_ifs", "tactic.interactive.unfold1", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "tactic.interactive.change'", "tactic.interactive.simp", "tactic.interactive.elide", "tactic.interactive.simp_rw", "tactic.interactive.erw", "tactic.interactive.unelide", "tactic.interactive.assoc_rw", "tactic.interactive.erewrite", "tactic.interactive.assoc_rewrite", "tactic.interactive.change", "tactic.interactive.rwa", "tactic.interactive.dunfold", "tactic.interactive.rw", "tactic.interactive.push_neg", "tactic.interactive.rewrite", "tactic.interactive.delta"]}, {"id": "list.has_to_format", "parentIds": ["tactic.interactive.squeeze_simp", "array.has_to_format", "param_info.to_format", "occurrences_to_format", "tactic.interactive.squeeze_simpa", "tactic.unsafe.type_context.print_mvars", "fun_info_to_format", "buffer.has_to_format", "list.has_to_tactic_format", "local_context.to_format"]}, {"id": "list.intersperse", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.format_names", "list.intercalate", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "list.to_format", "loc.to_string", "format.intercalate"]}, {"id": "tactic.simp_arg_type.has_reflect", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "tactic.interactive.dsimp", "tactic.interactive.solve_by_elim", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_intros", "tactic.interactive.simpa", "conv.interactive.simp", "smt_tactic.interactive.simp", "tactic.interactive.trace_simp_set", "conv.interactive.dsimp"]}, {"id": "interactive.types.only_flag", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "tactic.interactive.dsimp", "tactic.interactive.solve_by_elim", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_intros", "tactic.interactive.simpa", "conv.interactive.simp", "smt_tactic.interactive.simp", "tactic.interactive.trace_simp_set", "conv.interactive.dsimp"]}, {"id": "tactic.simp_arg_type", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.field_simp", "tactic.mk_assumption_set", "restate_axiom", "tactic.interactive.unfold", "tactic.interactive.dsimp", "tactic.interactive.solve_by_elim", "smt_tactic.interactive.dsimp", "tactic.interactive.simp", "tactic.simp_arg_type.has_reflect", "tactic.lift", "tactic.interactive.squeeze_simpa", "tactic.interactive.simp_rw", "tactic.suggest.apply_and_solve", "tactic.solve_by_elim", "tactic.interactive.simp_intros", "expr.simp", "expr.dsimp", "tactic.interactive.has_to_tactic_format", "tactic.interactive.simp_core", "tactic.mk_simp_set_core", "tactic.interactive.simpa", "tactic.decode_simp_arg_list", "conv.interactive.simp", "tactic.simp_arg_list", "tactic.simp_arg", "tactic.interactive.erase_simp_args", "smt_tactic.interactive.simp", "tactic.interactive.choose", "tactic.interactive.trace_simp_set", "conv.interactive.dsimp", "tactic.interactive.push_neg", "tactic.ids_to_simp_arg_list", "tactic.mk_simp_set"]}, {"id": "option.is_some", "parentIds": ["tactic.interactive.squeeze_simp", "unused_arguments", "tactic.interactive.convert", "tactic.interactive.solve_by_elim", "tactic.mllist.empty", "rbmap.contains", "tactic.interactive.rw_rule_p", "tactic.lift", "tactic.interactive.squeeze_simpa", "option.eq_some_of_is_some", "environment.is_structure", "option.get", "simps_parser", "declaration.is_auto_generated", "tactic.interactive.h_generalize", "tactic.suggest", "tactic.get_lift_prf", "rbtree.contains", "environment.get_modifiers"]}, {"id": "name_set.erase", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.squeeze_simpa", "name_set.mfilter", "name_set.filter", "tactic.interactive.erase_simp_args"]}, {"id": "list.map", "parentIds": ["tactic.interactive.squeeze_simp", "tactic.interactive.format_names", "tactic.cases", "unused_arguments", "tactic.mk_has_sizeof_instance_core", "tactic.interactive.loc.get_local_pp_names", "where.sort_variable_list", "tactic.clear'", "tactic.interactive.induction", "list.func.neg", "to_additive.proceed_fields", "to_additive.guess_name", "list.sigma", "list.map_append", "tactic.suggest_scripts", "interactive.loc.try_apply", "simps_add_projection", "expr.instantiate_locals", "tactic.interactive.unfold_projs", "nat.repr", "tactic.extract_def", "list.length_map", "simps_tac", "lint", "tactic.instance_stub", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.interactive.rec.to_tactic_format", "tactic.dependent_pose_core", "string.split_on", "tactic.lift", "list.map_id", "tactic.interactive.squeeze_simpa", "copy_decl_updating_type", "tactic.successes", "tactic.mk_patterns", "list.map_cons", "string.intercalate", "tactic.case_bash", "tactic.add_theorem_by", "tactic.mk_dec_eq_instance_core", "where.trace_opens", "environment.structure_fields_full", "tactic.interactive.loc.get_local_uniq_names", "where.get_opens", "tactic.unsafe.type_context.print_mvars", "interactive.loc.include_goal", "tactic.interactive.rintro", "tactic.explode.pad_right", "list.monad", "tactic.explode.has_to_tactic_format", "list.to_format", "list.is_lawful_monad", "declaration.univ_levels", "loc.to_string", "list.nil_bind", "tactic.interactive.refine_one", "tactic.prove_goal_async", "fold_over_with_cond_sorted", "list.map_singleton", "list.product", "where.fetch_potential_variable_names", "instance_derive_handler", "tactic.interactive.field", "list.map_map", "where.format_variable", "tactic.injections_and_clear", "dangerous_instance", "lift_list", "tactic.rename'", "tactic.solve", "derive_struct_ext_lemma", "where.collect_by", "has_inhabited_instance", "list.cons_bind", "tactic.module_doc_strings", "list.bind"]}, {"id": "is_total", "parentIds": ["has_le.le.is_total_preorder", "is_linear_order", "total_of", "is_total_preorder", "is_total_preorder_is_preorder"]}, {"id": "add_left_eq_self", "parentIds": []}, {"id": "zero_add", "parentIds": ["add_left_eq_self", "int.of_nat_ge_zero", "mul_self_sub_one_eq", "add_nonpos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "functor.add_const.is_lawful_applicative", "eq_zero_of_mul_eq_self_right", "eq_of_sub_eq_zero", "nat.bodd_add_div2", "list.length_append", "le_add_of_nonneg_of_le", "div_le_div_of_mul_sub_mul_div_nonpos", "add_lt_of_nonpos_of_lt", "lt_add_of_pos_of_le", "add_lt_of_neg_of_lt", "norm_num.add1_zero", "neg_lt_neg", "add_neg_of_nonpos_of_neg", "lt_add_of_nonneg_of_lt", "nat.add_sub_cancel", "zero_sub", "nat.sub_pos_of_lt", "nat.mul_div_cancel'", "lt_add_of_pos_left", "neg_le_neg", "add_neg_of_neg_of_nonpos", "lt_of_sub_pos", "add_le_of_nonpos_of_le", "add_neg", "add_pos_of_nonneg_of_pos", "int.mul_pos", "nat.mul_mod_right", "mul_self_sub_mul_self_eq", "bit1_zero", "add_pos", "norm_num.bin_zero_add", "add_nonneg", "nat.div2_bit", "lt_add_of_pos_of_lt", "add_neg_cancel_left", "neg_add_rev", "neg_add_cancel_left", "nat.dvd_of_mod_eq_zero", "int.mul_nonneg", "nat.div_self", "lt_of_sub_neg", "le_of_sub_nonneg", "add_pos_of_pos_of_nonneg", "add_lt_of_neg_of_le", "neg_eq_of_add_eq_zero", "le_of_sub_nonpos", "neg_zero", "le_add_of_nonneg_left", "nat.div_one", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel"]}, {"id": "add_right_cancel", "parentIds": ["add_left_eq_self", "eq_of_add_eq_add_right", "add_right_injective", "add_right_inj", "add_right_cancel_iff"]}, {"id": "add_group.to_right_cancel_add_semigroup", "parentIds": ["add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "neg_sub_neg", "add_eq_zero_iff_eq_neg", "sub_sub_assoc_swap", "sub_right_inj"]}, {"id": "add_right_cancel_semigroup.to_add_semigroup", "parentIds": ["add_left_eq_self", "sub_eq_sub_iff_sub_eq_sub", "neg_sub_neg", "add_eq_zero_iff_eq_neg", "add_right_cancel", "sub_sub_assoc_swap", "eq_of_add_eq_add_right", "add_right_injective", "add_right_inj", "add_right_cancel_iff"]}, {"id": "fish", "parentIds": ["fish_pipe", "tactic.list_constructors_hole", "fish_assoc", "fish_pure"]}, {"id": "tactic.add_library_note", "parentIds": ["library_note"]}, {"id": "expr.has_to_pexpr", "parentIds": ["tactic.add_library_note", "tactic.interactive.convert", "old_conv.change", "use_cmd", "smt_tactic.interactive.have", "tactic.mk_dec_eq_instance", "tactic.interactive.let", "tactic.interactive.convert_to_core", "tactic.interactive.set", "tactic.interactive.exact", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "tactic.comp_val", "tactic.interactive.obtain", "tactic.interactive.generalize", "tactic.subsingleton_goal", "tactic.interactive.change", "tactic.interactive.simpa", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.clean", "tactic.interactive.have", "tactic.interactive.h_generalize", "tactic.interactive.source_fields"]}, {"id": "expr.has_coe", "parentIds": ["tactic.add_library_note", "expr.mk_or_lst", "tactic.is_prop", "tactic.mk_iff", "tactic.mk_simp_attr", "user_attribute.parse_reflect", "user_attribute.dflt_parser", "int.mk_numeral", "localized_cmd", "mk_hinst_lemma_attr_from_simp_attr", "user_attribute.dflt_cache_cfg", "nat.mk_numeral", "tactic.def_replacer_cmd", "tactic.mk_patterns", "to_additive.map_namespace", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.local_def_value", "expr.mk_and_lst", "user_attribute.set", "reflected_value.expr", "list_linters", "tactic.def_replacer", "mk_hinst_lemma_attr_set", "tactic.interactive.extract_goal", "mk_name_set_attr", "mk_hinst_lemma_attr_core", "derive_struct_ext_lemma", "has_inhabited_instance"]}, {"id": "expr.has_to_string", "parentIds": ["tactic.add_library_note", "print_item_crawl"]}, {"id": "expr.subst", "parentIds": ["tactic.add_library_note", "tactic.interactive.convert", "tactic.mk_simp_attribute_cmd", "tactic.interactive.min_tac", "old_conv.change", "tactic.mk_iff", "use_cmd", "smt_tactic.interactive.have", "tactic.mk_dec_eq_instance", "int.mk_numeral", "tactic.trace_macro", "tactic.interactive.let", "tactic.interactive.convert_to_core", "tactic.interactive.set", "nat.mk_numeral", "tactic.interactive.exact", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "tactic.comp_val", "tactic.interactive.obtain", "tactic.interactive.generalize", "tactic.pformat_macro", "tactic.subsingleton_goal", "get_attribute_cache_dyn", "tactic.interactive.change", "reflected.subst", "tactic.def_replacer", "tactic.interactive.simpa", "tactic.refine", "tactic.interactive.clean", "tactic.interactive.have", "tactic.interactive.h_generalize", "tactic.interactive.parse_config", "tactic.fail_macro"]}, {"id": "mk_definition", "parentIds": ["tactic.add_library_note", "tactic.delta_instance"]}, {"id": "user_attribute.set", "parentIds": ["tactic.add_library_note", "localized_cmd", "to_additive.map_namespace", "apply_nolint_tac", "tactic.alias.alias_direct", "tactic.alias.alias_iff", "tactic.replaceable_attr"]}, {"id": "to_pexpr", "parentIds": ["tactic.add_library_note", "tactic.interactive.convert", "tactic.mk_simp_attribute_cmd", "tactic.interactive.min_tac", "old_conv.change", "use_cmd", "smt_tactic.interactive.have", "tactic.mk_dec_eq_instance", "tactic.trace_macro", "tactic.interactive.let", "tactic.interactive.convert_to_core", "tactic.interactive.set", "tactic.interactive.exact", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "tactic.comp_val", "tactic.interactive.obtain", "tactic.interactive.generalize", "tactic.pformat_macro", "tactic.subsingleton_goal", "get_attribute_cache_dyn", "tactic.interactive.change", "tactic.interactive.simpa", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.clean", "tactic.interactive.have", "tactic.interactive.h_generalize", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "tactic.fail_macro"]}, {"id": "tactic.add_decl", "parentIds": ["tactic.add_library_note", "tactic.mk_simp_attr", "simps_add_projection", "localized_cmd", "tactic.extract_def", "mk_hinst_lemma_attr_from_simp_attr", "copy_decl_updating_type", "to_additive.map_namespace", "tactic.add_theorem_by", "copy_decl_using", "tactic.prove_goal_async", "tactic.add_meta_definition", "mk_hinst_lemma_attr_set", "instance_derive_handler", "tactic.delta_instance", "mk_hinst_lemma_attr_core", "derive_struct_ext_lemma", "tactic.import_private_cmd"]}, {"id": "library_note_attr", "parentIds": ["tactic.add_library_note"]}, {"id": "tactic.to_expr", "parentIds": ["tactic.add_library_note", "tactic.i_to_expr_strict", "infer_type_cmd", "tactic.mk_simp_attribute_cmd", "tactic.replace", "old_conv.change", "use_cmd", "smt_tactic.interactive.have", "tactic.mk_dec_eq_instance", "to_additive.parser", "tactic.interactive.convert_to_core", "tactic.interactive.set", "tactic.interactive.type_check", "tactic.change_with_at", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.squeeze_simpa", "tactic.def_replacer_cmd", "smt_tactic.to_expr", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "tactic.eqn_stub", "tactic.to_expr_strict", "control_laws_tac", "tactic.comp_val", "tactic.interactive.obtain", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.find_local", "tactic.interactive.guard_expr_strict", "tactic.subsingleton_goal", "get_attribute_cache_dyn", "tactic.match_stub", "tactic.i_to_expr_no_subgoals", "tactic.interactive.refine_one", "tactic.refine", "tactic.interactive.guard_expr_eq", "tactic.interactive.guard_expr_eq'", "tactic.delta_instance", "tactic.interactive.h_generalize", "tactic.interactive.source_fields", "tactic.interactive.parse_config", "order_laws_tac", "tactic.i_to_expr", "tactic.pexpr_to_pattern"]}, {"id": "unit.star", "parentIds": ["tactic.add_library_note", "tactic.trace", "tactic.interactive.cases", "tactic.delta", "smt_tactic.definev", "scope_trace", "tactic.timetac", "smt_tactic.set_goals", "try_for", "tactic.cases", "guard", "tactic.mk_has_sizeof_instance_core", "tactic.dsimplify", "old_conv.skip", "tactic.rcases_hint", "simp_attr.pre_smt", "old_conv.trace", "tactic.interactive.induction", "old_conv.dsimp", "tactic.interactive.apply_assumption", "localized_attr", "old_conv.istep", "push_neg.normalize_negations", "old_conv.change", "smt_tactic.write", "tactic.mk_simp_attr", "tactic.interactive.have_field", "ematch_lhs", "smt_tactic.interactive.have", "tactic.mk_dec_eq_instance", "nolint_attr", "user_attribute.dflt_parser", "tactic.alias.alias_attr", "can_lift_attr", "old_conv.apply_lemmas_core", "tactic.trace_macro", "tactic.interactive.generalize_hyp", "localized_cmd", "tactic.interactive.continue", "interaction_monad.result_to_string", "tactic.success_if_fail", "dlist.lazy_of_list", "trace", "trace_call_stack", "tactic.simp_top_down", "punit.inhabited", "no_rsimp", "conv.funext", "old_conv.match_pattern", "mk_hinst_lemma_attr_from_simp_attr", "old_conv.funext", "user_attribute.dflt_cache_cfg", "tactic.dependent_pose_core", "tactic.interactive.ext1", "tactic.fail_if_success", "monad.whenb", "tactic.trace_error", "tactic.mk_patterns", "tactic.skip", "to_additive.map_namespace", "rsimp_attr", "tactic.interactive.by_contradiction", "tactic.simp_bottom_up", "old_conv.find_pattern", "smt_tactic.interactive.let", "well_founded_tactics.cancel_nat_add_lt", "linter_attr", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "mtry", "find_cmd", "ematch", "parser.eps", "library_note_attr", "tactic.write", "old_conv.save_info", "smt_tactic.assertv", "simp_attr.functor_norm", "simp_attr.norm", "old_conv.congr_core", "apply_nolint_tac", "smt_tactic.try", "old_conv.apply_propext_lemmas_core", "tactic.mk_has_reflect_instance", "tactic.ancestor_attr", "tactic.interactive.ext", "tactic.alias.alias_direct", "interactive.interactive.executor", "tactic.by_contradiction", "simp_attr.split_if_reduction", "vm.trace", "tactic.rcases", "when", "tactic.simp_bottom_up'", "guard_true", "debugger.attr", "derive_handler_attr", "tactic.alias.alias_iff", "tactic.unsafe.type_context.trace", "punit_eq_punit", "old_conv.whnf", "old_conv.find", "old_conv.top_down", "monad.unlessb", "rsimp.rsimplify", "conv.interactive.simp", "conv.step", "mwhen", "punit.reflect", "mk_hinst_lemma_attr_set", "tactic.trace_call_stack", "old_conv.bottom_up", "native.rb_set.insert", "smt_tactic.induction", "interactive.loc.apply", "guard_false", "tactic.mk_inj_eq", "tactic.interactive.h_generalize", "smt_tactic.skip", "conv.congr", "tactic.replaceable_attr", "mk_name_set_attr", "tactic.interactive.introv", "mk_hinst_lemma_attr_core", "parser.decorate_error", "task.delay", "tactic.induction'", "tactic.rename'", "tactic.replacer_attr", "old_conv.step", "tactic.success_if_fail_with_msg", "old_conv.mk_match_expr", "timeit", "tactic.fail_macro", "old_conv.match_expr"]}, {"id": "expr.has_var_idx", "parentIds": []}, {"id": "not_imp_of_and_not", "parentIds": ["not_imp"]}, {"id": "lt_of_one_div_lt_one_div", "parentIds": []}, {"id": "division_ring_has_div", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_zero", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "division_def", "one_div_pos_of_pos", "div_sub_div", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "add_midpoint", "mul_inv_eq", "div_nonneg_of_nonpos_of_neg", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "abs_one_div", "mul_eq_of_eq_div", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "one_div_eq_inv", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_div_eq_div_mul", "div_mul_eq_mul_div", "inv_ne_zero", "mul_div_mul_left'", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "one_div_zero", "div_mul_cancel", "le_div_of_mul_le", "mul_div_cancel_left", "div_self", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "lt_of_one_div_lt_one_div_of_neg", "div_mul_left", "mul_sub_mul_div_mul_neg", "division_ring.one_div_one_div", "add_div_eq_mul_add_div", "one_div_one", "mul_one_div_cancel", "zero_div", "lt_of_one_lt_div", "field.div_div_div_div_eq", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "norm_num.div_add_helper", "eq_div_of_mul_eq", "one_div_neg_of_neg", "one_div_le_of_one_div_le_of_pos", "ne_zero_of_one_div_ne_zero", "one_div_ne_zero", "field.div_mul_left", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "div_mul_le_div_mul_of_div_le_div_pos'", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "div_eq_mul_one_div", "div_mul_right", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "one_div_neg_eq_neg_one_div", "abs_div", "div_mul_eq_div_mul_one_div", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "mul_div_assoc", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "division_ring.neg_div_neg_eq", "mul_eq_mul_of_div_eq_div", "one_div_div", "mul_lt_of_lt_div", "div_eq_one_iff_eq", "mul_div_mul_left", "mul_div_mul_right'", "div_lt_div_of_pos_of_lt_of_pos", "one_div_one_div", "div_add_div_same", "sub_self_div_two", "mul_div_cancel'", "mul_div_mul_right", "div_one", "one_div_le_one_div_of_le", "add_halves", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "neg_div_neg_eq", "mul_div_cancel", "eq_of_div_eq_one", "div_nonneg_of_nonneg_of_pos", "division_ring.eq_of_one_div_eq_one_div", "division_ring.inv_inv", "div_mul_eq_mul_div_comm", "neg_div", "div_div_div_div_eq", "eq_of_one_div_eq_one_div", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "div_sub_div_same", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "one_div_add_one_div", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "mul_mul_div", "norm_num.div_helper", "field.div_div_eq_div_mul", "div_le_of_le_mul", "eq_zero_of_one_div_eq_zero", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "le_of_one_le_div", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_mul_div", "div_add_div", "div_two_lt_of_pos", "inv_eq_one_div", "division_ring.one_div_neg_eq_neg_one_div", "one_lt_one_div", "eq_div_iff_mul_eq", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "linear_ordered_field", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "one_div_pos_of_pos", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "add_midpoint", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "one_div_le_of_one_div_le_of_neg", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "linear_ordered_field.to_field", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "mul_sub_mul_div_mul_neg", "lt_of_one_lt_div", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "discrete_linear_ordered_field.to_linear_ordered_field", "div_lt_div_of_lt_of_neg", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "linear_ordered_field.to_linear_ordered_ring", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "mul_lt_of_lt_div", "div_lt_div_of_pos_of_lt_of_pos", "sub_self_div_two", "two_ge_one", "two_pos", "one_div_le_one_div_of_le", "add_halves", "div_nonneg_of_nonneg_of_pos", "one_div_le_one_div_of_le_of_neg", "div_le_of_le_mul", "le_of_one_le_div", "div_neg_of_neg_of_pos", "four_pos", "div_two_lt_of_pos", "one_lt_one_div", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "not_le_of_gt", "parentIds": ["lt_of_one_div_lt_one_div", "nat.div_eq_of_lt", "int.neg_ne_of_pos", "nonneg_of_mul_nonneg_left", "ge_of_forall_ge_sub", "lt_iff_not_ge", "not_lt_of_le", "nat.mod_eq_of_lt", "lt_of_add_lt_add_left", "lt_of_one_div_lt_one_div_of_neg", "not_lt_of_ge", "decidable.le_imp_le_of_lt_imp_lt", "le_of_mul_le_mul_right", "nonneg_of_mul_nonneg_right", "le_of_mul_le_mul_left", "nonpos_of_mul_nonpos_left", "nat.div_eq_of_lt_le", "nat.zero_div", "nonpos_of_mul_nonpos_right", "add_lt_add_left", "le_imp_le_of_lt_imp_lt", "nonneg_le_nonneg_of_squares_le", "nat.le_div_iff_mul_le", "lt_iff_not_ge'"]}, {"id": "linear_ordered_field.to_field", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "one_div_pos_of_pos", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "add_midpoint", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "one_div_le_of_one_div_le_of_neg", "abs_one_div", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "mul_sub_mul_div_mul_neg", "lt_of_one_lt_div", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "div_mul_le_div_mul_of_div_le_div_pos'", "div_lt_div_of_lt_of_neg", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "abs_div", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "mul_lt_of_lt_div", "div_lt_div_of_pos_of_lt_of_pos", "sub_self_div_two", "two_ge_one", "two_pos", "one_div_le_one_div_of_le", "add_halves", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "div_le_of_le_mul", "le_of_one_le_div", "div_neg_of_neg_of_pos", "four_pos", "div_two_lt_of_pos", "one_lt_one_div", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "zero_ne_one_class.to_has_one", "parentIds": ["lt_of_one_div_lt_one_div", "div_zero", "div_le_div_of_le_of_pos", "nat.eq_zero_or_eq_succ_pred", "one_div_pos_of_pos", "discrete_field", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "add_midpoint", "mul_inv_eq", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "eq_zero_of_mul_eq_self_right", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "abs_one_div", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "one_div_eq_inv", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_div_eq_div_mul", "inv_ne_zero", "one_div_mul_one_div", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "one_div_zero", "div_mul_cancel", "le_div_of_mul_le", "div_self", "le_mul_of_ge_one_right", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "div_mul_left", "division_ring", "division_ring.one_div_one_div", "one_div_one", "mul_one_div_cancel", "lt_of_one_lt_div", "le_of_one_div_le_one_div_of_neg", "discrete_linear_ordered_field", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "ne_zero_of_one_div_ne_zero", "one_div_ne_zero", "field.div_mul_left", "le_of_one_div_le_one_div", "field.div_mul_eq_mul_div_comm", "le_of_mul_le_of_ge_one", "one_inv_eq", "div_mul_le_div_mul_of_div_le_div_pos'", "mul_inv_cancel", "div_lt_div_of_lt_of_neg", "division_ring.one_div_div", "one_div_mul_cancel", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_mul_one_div", "div_mul_right", "add_self_div_two", "div_lt_div_of_lt_of_pos", "one_div_neg_one_eq_neg_one", "one_div_neg_eq_neg_one_div", "div_mul_eq_div_mul_one_div", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "mul_eq_mul_of_div_eq_div", "one_div_div", "div_eq_one_iff_eq", "mul_div_mul_left", "one_ne_zero", "div_lt_div_of_pos_of_lt_of_pos", "field", "one_div_one_div", "sub_self_div_two", "two_ge_one", "two_pos", "eq_zero_of_mul_eq_self_left", "div_one", "one_div_le_one_div_of_le", "add_halves", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "mul_div_cancel", "eq_of_div_eq_one", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "division_ring.eq_of_one_div_eq_one_div", "division_ring.inv_inv", "eq_of_one_div_eq_one_div", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "one_div_add_one_div", "zero_ne_one", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "mul_mul_div", "linear_ordered_field", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "div_le_of_le_mul", "eq_zero_of_one_div_eq_zero", "division_ring.one_div_mul_one_div", "le_of_one_le_div", "div_neg_of_neg_of_pos", "mul_self_eq_one_iff", "four_pos", "div_two_lt_of_pos", "inv_eq_one_div", "division_ring.one_div_neg_eq_neg_one_div", "nat.cond_to_bool_mod_two", "one_lt_one_div", "one_div_le_neg_one"]}, {"id": "linear_ordered_ring.to_linear_order", "parentIds": ["lt_of_one_div_lt_one_div", "one_div_le_of_one_div_le_of_neg", "ge_of_forall_ge_sub", "sub_le_of_abs_sub_le_left", "mul_self_lt_mul_self_iff", "lt_of_one_div_lt_one_div_of_neg", "abs_mul", "le_of_one_div_le_one_div_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "le_of_one_div_le_one_div", "sub_lt_of_abs_sub_lt_left", "int.neg_succ_lt_zero", "mul_self_nonneg", "nonneg_le_nonneg_of_squares_le", "int.le_nat_abs", "pos_and_pos_or_neg_and_neg_of_mul_pos"]}, {"id": "field.to_division_ring", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_zero", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "one_div_pos_of_pos", "div_sub_div", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "add_midpoint", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "abs_one_div", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_div_eq_div_mul", "div_mul_eq_mul_div", "mul_div_mul_left'", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "one_div_zero", "le_div_of_mul_le", "mul_div_cancel_left", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "div_mul_left", "mul_sub_mul_div_mul_neg", "lt_of_one_lt_div", "field.div_div_div_div_eq", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "norm_num.div_add_helper", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "ne_zero_of_one_div_ne_zero", "field.div_mul_left", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "div_mul_le_div_mul_of_div_le_div_pos'", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_mul_right", "inv_zero", "mul_inv'", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "norm_num.div_mul_helper", "one_div_neg_eq_neg_one_div", "abs_div", "div_mul_eq_div_mul_one_div", "one_div_lt_one_div_of_lt", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "eq_of_mul_eq_mul_of_nonzero_left", "mul_eq_mul_of_div_eq_div", "one_div_div", "mul_lt_of_lt_div", "mul_div_mul_left", "mul_div_mul_right'", "div_lt_div_of_pos_of_lt_of_pos", "one_div_one_div", "sub_self_div_two", "mul_div_cancel'", "two_ge_one", "mul_div_mul_right", "two_pos", "one_div_le_one_div_of_le", "add_halves", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "neg_div_neg_eq", "div_nonneg_of_nonneg_of_pos", "div_mul_eq_mul_div_comm", "div_div_div_div_eq", "eq_of_one_div_eq_one_div", "one_div_add_one_div", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "norm_num.div_helper", "field.div_div_eq_div_mul", "div_le_of_le_mul", "eq_zero_of_one_div_eq_zero", "norm_num.nonzero_of_div_helper", "norm_num.div_eq_div_helper", "le_of_one_le_div", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_mul_div", "div_add_div", "four_pos", "div_two_lt_of_pos", "one_lt_one_div", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "linear_ordered_field.to_linear_ordered_ring", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "one_div_pos_of_pos", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "add_midpoint", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "one_div_le_of_one_div_le_of_neg", "abs_one_div", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "mul_sub_mul_div_mul_neg", "lt_of_one_lt_div", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "div_mul_le_div_mul_of_div_le_div_pos'", "div_lt_div_of_lt_of_neg", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "mul_lt_of_lt_div", "div_lt_div_of_pos_of_lt_of_pos", "two_ge_one", "two_pos", "one_div_le_one_div_of_le", "add_halves", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "div_le_of_le_mul", "le_of_one_le_div", "div_neg_of_neg_of_pos", "four_pos", "div_two_lt_of_pos", "one_lt_one_div", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "has_div", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_zero", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "division_ring_has_div", "nat.div_eq_of_lt", "division_def", "one_div_pos_of_pos", "div_sub_div", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "nat.mul_div_mul", "nat.lcm", "nat.mul_div_assoc", "add_midpoint", "int.has_div", "mul_inv_eq", "div_nonneg_of_nonpos_of_neg", "nat.div_def", "nat.add_div_left", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "abs_one_div", "nat.add_mul_div_right", "mul_eq_of_eq_div", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "one_div_eq_inv", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_div_eq_div_mul", "div_mul_eq_mul_div", "inv_ne_zero", "mul_div_mul_left'", "nat.mul_div_right", "nat.shiftr_eq_div_pow", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "nat.mod_two_of_bodd", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "nat.add_mul_div_left", "one_div_zero", "div_mul_cancel", "le_div_of_mul_le", "nat.div_def_aux", "mul_div_cancel_left", "div_self", "nat.zero_shiftr", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "lt_of_one_div_lt_one_div_of_neg", "div_mul_left", "nat.div_le_of_le_mul", "mul_sub_mul_div_mul_neg", "division_ring.one_div_one_div", "add_div_eq_mul_add_div", "one_div_one", "nat.div_mul_cancel", "nat.div_eq_of_eq_mul_right", "nat.mul_div_cancel'", "mul_one_div_cancel", "zero_div", "lt_of_one_lt_div", "field.div_div_div_div_eq", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "norm_num.div_add_helper", "eq_div_of_mul_eq", "one_div_neg_of_neg", "one_div_le_of_one_div_le_of_pos", "ne_zero_of_one_div_ne_zero", "nat.dvd_mod_iff", "one_div_ne_zero", "field.div_mul_left", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "div_mul_le_div_mul_of_div_le_div_pos'", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "norm_num.subst_into_div", "nat.add_div_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "div_eq_mul_one_div", "nat.div_lt_self", "div_mul_right", "native.float.has_div", "mul_le_of_div_le_of_neg", "nat.div2_val", "add_self_div_two", "div_lt_div_of_lt_of_pos", "nat.mul_div_left", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "one_div_neg_eq_neg_one_div", "nat.div_eq_of_lt_le", "abs_div", "div_mul_eq_div_mul_one_div", "nat.has_div", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "nat.div_le_self", "one_div_lt_one_div_of_lt", "mul_div_assoc", "nat.sub_mul_div", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "unsigned.has_div", "char_to_hex", "division_ring.neg_div_neg_eq", "nat.div2_bit", "mul_eq_mul_of_div_eq_div", "one_div_div", "mul_lt_of_lt_div", "div_eq_one_iff_eq", "mul_div_mul_left", "nat.div_eq_sub_div", "nat.dvd_of_mod_eq_zero", "mul_div_mul_right'", "nat.zero_div", "div_lt_div_of_pos_of_lt_of_pos", "nat.mod_add_div", "one_div_one_div", "div_add_div_same", "sub_self_div_two", "mul_div_cancel'", "nat.mul_div_cancel_left", "mul_div_mul_right", "div_one", "one_div_le_one_div_of_le", "add_halves", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "neg_div_neg_eq", "mul_div_cancel", "eq_of_div_eq_one", "div_nonneg_of_nonneg_of_pos", "division_ring.eq_of_one_div_eq_one_div", "division_ring.inv_inv", "nat.div_self", "div_mul_eq_mul_div_comm", "neg_div", "nat.div_mul_le_self", "div_div_div_div_eq", "eq_of_one_div_eq_one_div", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "nat.div_eq_of_eq_mul_left", "div_sub_div_same", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "one_div_add_one_div", "fin.has_div", "fin.div_def", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "mul_mul_div", "nat.mod_pow_succ", "norm_num.div_helper", "field.div_div_eq_div_mul", "div_le_of_le_mul", "eq_zero_of_one_div_eq_zero", "nat.le_div_iff_mul_le", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_mul_div", "div_add_div", "nat.div_zero", "div_two_lt_of_pos", "inv_eq_one_div", "division_ring.one_div_neg_eq_neg_one_div", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "one_lt_one_div", "eq_div_iff_mul_eq", "nat.div_one", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg", "nat.mul_div_cancel"]}, {"id": "one_div_le_one_div_of_le", "parentIds": ["lt_of_one_div_lt_one_div", "one_le_one_div", "one_div_le_of_one_div_le_of_pos"]}, {"id": "lt_of_not_ge", "parentIds": ["lt_of_one_div_lt_one_div", "max_add_add_left", "lt_iff_not_ge", "sub_le_of_abs_sub_le_left", "eq_or_lt_of_not_lt", "nat.mul_self_le_mul_self_iff", "nat.lt_of_sub_eq_succ", "lt_of_one_div_lt_one_div_of_neg", "lt_of_mul_lt_mul_right", "pos_of_mul_pos_right", "min_add_add_left", "neg_of_mul_neg_right", "sub_lt_of_abs_sub_lt_left", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "neg_of_mul_neg_left", "int.neg_succ_lt_zero", "dist_bdd_within_interval"]}, {"id": "zero_ne_one_class.to_has_zero", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "nat.eq_zero_or_eq_succ_pred", "mul_lt_mul_of_neg_left", "one_div_pos_of_pos", "discrete_field", "div_sub_div", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "mul_ne_zero_comm", "mul_nonneg_of_nonpos_of_nonpos", "mul_inv_eq", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "mul_eq_of_eq_div", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "inv_ne_zero", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "div_mul_cancel", "le_div_of_mul_le", "mul_div_cancel_left", "div_self", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "division_ring", "linear_ordered_comm_ring", "mul_sub_mul_div_mul_neg", "division_ring.one_div_one_div", "mul_self_le_mul_self_iff", "add_div_eq_mul_add_div", "one_div_one", "mul_one_div_cancel", "zero_div", "lt_of_one_lt_div", "field.div_div_div_div_eq", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "norm_num.div_add_helper", "discrete_linear_ordered_field", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "eq_div_of_mul_eq", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "linear_ordered_ring", "mul_pos_of_neg_of_neg", "one_div_ne_zero", "field.div_mul_left", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "one_inv_eq", "mul_inv_cancel", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "ordered_ring.mul_le_mul_of_nonneg_right", "norm_num.nonzero_of_neg_helper", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "norm_num.div_mul_helper", "gt_of_mul_lt_mul_neg_left", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "division_ring.neg_div_neg_eq", "mul_eq_mul_of_div_eq_div", "one_div_div", "mul_lt_of_lt_div", "div_eq_one_iff_eq", "mul_div_mul_left", "ordered_ring.mul_lt_mul_of_pos_right", "one_ne_zero", "div_lt_div_of_pos_of_lt_of_pos", "field", "mul_div_cancel'", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_div_mul_right", "two_pos", "one_div_le_one_div_of_le", "field.div_div_eq_mul_div", "mul_div_cancel", "eq_of_div_eq_one", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "division_ring.eq_of_one_div_eq_one_div", "decidable_linear_ordered_comm_ring", "division_ring.inv_inv", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "mul_self_nonneg", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "one_div_add_one_div", "zero_ne_one", "one_div_le_one_div_of_le_of_neg", "mul_mul_div", "nonneg_le_nonneg_of_squares_le", "norm_num.div_helper", "linear_ordered_field", "field.div_div_eq_div_mul", "div_le_of_le_mul", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "le_of_one_le_div", "ordered_ring.mul_lt_mul_of_pos_left", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "ordered_ring", "div_add_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "four_pos", "div_two_lt_of_pos", "division_ring.one_div_neg_eq_neg_one_div", "nat.cond_to_bool_mod_two", "one_lt_one_div", "eq_div_iff_mul_eq", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "division_ring.to_zero_ne_one_class", "parentIds": ["lt_of_one_div_lt_one_div", "le_mul_of_div_le", "div_zero", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "one_div_pos_of_pos", "div_sub_div", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "mul_ne_zero_comm", "add_midpoint", "mul_inv_eq", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "field.one_div_mul_one_div", "one_div_le_of_one_div_le_of_neg", "abs_one_div", "mul_eq_of_eq_div", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "ge_of_forall_ge_sub", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "one_div_eq_inv", "exists_add_lt_and_pos_of_lt", "one_le_one_div", "div_div_eq_div_mul", "inv_ne_zero", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "div_lt_of_mul_gt_of_neg", "one_div_zero", "div_mul_cancel", "le_div_of_mul_le", "mul_div_cancel_left", "div_self", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "lt_of_one_div_lt_one_div_of_neg", "div_mul_left", "mul_sub_mul_div_mul_neg", "division_ring.one_div_one_div", "add_div_eq_mul_add_div", "one_div_one", "mul_one_div_cancel", "zero_div", "lt_of_one_lt_div", "field.div_div_div_div_eq", "mul_le_of_le_div", "le_of_one_div_le_one_div_of_neg", "norm_num.div_add_helper", "eq_div_of_mul_eq", "one_div_neg_of_neg", "le_mul_of_ge_one_left", "one_div_le_of_one_div_le_of_pos", "ne_zero_of_one_div_ne_zero", "one_div_ne_zero", "field.div_mul_left", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "one_inv_eq", "div_mul_le_div_mul_of_div_le_div_pos'", "mul_inv_cancel", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_mul_one_div", "div_mul_right", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "one_div_neg_eq_neg_one_div", "div_mul_eq_div_mul_one_div", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "division_ring.neg_div_neg_eq", "mul_eq_mul_of_div_eq_div", "one_div_div", "mul_lt_of_lt_div", "div_eq_one_iff_eq", "mul_div_mul_left", "div_lt_div_of_pos_of_lt_of_pos", "one_div_one_div", "sub_self_div_two", "mul_div_cancel'", "two_ge_one", "mul_div_mul_right", "two_pos", "div_one", "one_div_le_one_div_of_le", "add_halves", "field.div_div_eq_mul_div", "pos_of_one_div_pos", "mul_div_cancel", "eq_of_div_eq_one", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "division_ring.eq_of_one_div_eq_one_div", "division_ring.inv_inv", "eq_of_one_div_eq_one_div", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "one_div_add_one_div", "one_div_le_one_div_of_le_of_neg", "neg_of_one_div_neg", "mul_mul_div", "norm_num.div_helper", "field.div_div_eq_div_mul", "div_le_of_le_mul", "eq_zero_of_one_div_eq_zero", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "le_of_one_le_div", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_add_div", "four_pos", "div_two_lt_of_pos", "inv_eq_one_div", "division_ring.one_div_neg_eq_neg_one_div", "one_lt_one_div", "eq_div_iff_mul_eq", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "native.float.acosh", "parentIds": []}, {"id": "native.float", "parentIds": ["native.float.acosh", "native.float.infinity", "native.float.pow", "native.float.is_nan", "native.float.sub", "native.float.is_normal", "native.float.sign", "native.float.atan", "native.float.has_one", "native.float.log2", "native.float.atan2", "native.float.of_nat", "native.float.has_add", "native.float.sqrt", "native.float.is_infinite", "native.float.to_repr", "native.float.cos", "native.float.cbrt", "native.float.min", "native.float.cosh", "native.float.exponent", "native.float.sin", "native.float.neg", "native.float.asinh", "native.float.fmod", "native.float.exp", "native.float.has_to_string", "native.float.sinh", "native.float.frexp", "native.float.log", "native.float.pi", "native.float.ceil", "native.float.remainder", "native.float.acos", "native.float.round_error", "native.float.asin", "native.float.of_int_coe", "native.float.log10", "native.float.add", "native.float.has_zero", "native.float.qNaN", "native.float.has_div", "native.float.max", "native.float.atanh", "native.float.has_neg", "native.float.has_le", "native.float.hypot", "native.float.mantissa", "native.float.exp2", "native.float.sNaN", "native.float.has_repr", "native.float.div", "native.float.epsilon", "native.float.has_mul", "native.float.decidable_le", "native.float.has_float_pow", "native.float.mul", "native.float.le", "native.float.modf", "native.float.abs", "native.float.trunc", "native.float.of_nat_coe", "native.float.has_to_format", "native.float.of_int", "native.float.tanh", "native.float.lt", "native.float.has_lt", "native.float.round", "native.float.dec_eq", "native.float.decidable_lt", "native.float.floor", "native.float.has_sub", "native.float.tan", "native.float.is_finite", "native.float.has_nat_pow"]}, {"id": "tactic.replace_at", "parentIds": []}, {"id": "tactic.mk_eq_mp", "parentIds": ["tactic.replace_at", "tactic.interactive.simp_core_aux", "rsimp.rsimplify_at", "tactic.replace_hyp"]}, {"id": "tactic.assert", "parentIds": ["tactic.replace_at", "tactic.exfalso", "tactic.mk_dec_eq_instance", "tactic.local_proof", "tactic.interactive.set", "tactic.interactive.simp_core_aux", "rsimp.rsimplify_at", "tactic.interactive.obtain", "tactic.interactive.generalize", "tactic.apply_congr_core", "tactic.replace_target", "tactic.interactive.have", "tactic.interactive.h_generalize", "tactic.get_lift_prf", "tactic.replace_hyp"]}, {"id": "tactic.clear", "parentIds": ["tactic.replace_at", "tactic.interactive.induction", "tactic.replace", "tactic.interactive.generalize_hyp", "tactic.choose1", "tactic.lift", "tactic.interactive.simp_core_aux", "tactic.mk_patterns", "rsimp.rsimplify_at", "tactic.apply_congr_core", "tactic.interactive.replace", "tactic.interactive.clear_", "tactic.interactive.specialize", "tactic.interactive.clear_except", "tactic.interactive.h_generalize", "tactic.injections_and_clear", "tactic.interactive.choose", "tactic.replace_hyp", "tactic.subst", "tactic.apply_at"]}, {"id": "tactic.exact", "parentIds": ["tactic.replace_at", "tactic.admit", "tactic.cc_core", "tactic.apply_instance", "tactic.clear'", "tactic.assoc_refl", "user_attribute.dflt_parser", "tactic.mk_eq_simp_ext", "conv.update_lhs", "old_conv.conversion", "user_attribute.dflt_cache_cfg", "tactic.dependent_pose_core", "tactic.abstract", "tactic.interactive.simp_core_aux", "tactic.interactive.exact", "tactic.ac_refl", "control_laws_tac", "rsimp.rsimplify_at", "tactic.comp_val", "tactic.apply_congr_core", "tactic.injection_with", "tactic.interactive.simpa", "tactic.interactive.refine_one", "tactic.refine", "tactic.prove_goal_async", "tactic.interactive.clean", "tactic.rexact", "tactic.assumption", "tactic.replace_target", "tactic.triv", "tactic.interactive.h_generalize", "tactic.replace_hyp", "order_laws_tac", "tactic.triv'", "tactic.apply_opt_param"]}, {"id": "decidable.to_bool", "parentIds": ["tactic.replace_at", "print_content", "bool.to_bool_not", "param_info.to_format", "tactic.is_prop", "tactic.clear'", "expr.is_napp_of", "tactic.interactive.solve_by_elim", "tactic.interactive.clear_dependent", "tactic.interactive.clear'", "to_bool_false_eq_ff", "bool.to_bool_false", "expr.is_constant_of", "expr.is_eta_expansion_of", "string.map_tokens", "to_bool_true_eq_tt", "of_to_bool_ff", "bool.to_bool_true", "bool.of_to_bool_iff", "bool.ff_eq_to_bool_iff", "string.is_empty", "to_bool_true", "name.is_private", "to_bool_ff", "tactic.suggest.apply_and_solve", "bool.to_bool_and", "mnot", "environment.is_ginductive'", "to_bool_iff", "bool.cond_to_bool", "bool.to_bool_coe", "tactic.solve_by_elim", "lean.is_release", "cc_state.in_singlenton_eqc", "to_bool_ff_iff", "of_to_bool_true", "bool.tt_eq_to_bool_iff", "where.is_in_namespace_nonsynthetic", "list_linters", "declaration.is_auto_generated", "where.binder_less_important", "incorrect_type_class_argument", "to_bool_congr", "environment.in_current_file'", "to_bool_tt", "instance_derive_handler", "bool.coe_to_bool", "bool.to_bool_or", "tactic.suggest", "dangerous_instance", "tactic.find_private_decl", "tactic.replacer_attr", "nat.cond_to_bool_mod_two", "bool.to_bool_eq"]}, {"id": "expr.local_pp_name", "parentIds": ["tactic.replace_at", "tactic.interactive.loc.get_local_pp_names", "tactic.interactive.induction", "has_dup", "tactic.interactive.unfold_projs", "tactic.mk_iff_of_inductive_prop", "tactic.lift", "tactic.interactive.simp_core_aux", "tactic.mk_patterns", "tactic.interactive.assume", "rsimp.rsimplify_at", "tactic.interactive.clear_", "tactic.interactive.specialize", "tactic.prove_goal_async", "tactic.interactive.clear_except", "tactic.replace_hyp", "tactic.rename'", "tactic.subst", "tactic.interactive.push_neg", "tactic.apply_at"]}, {"id": "tactic.replace_target", "parentIds": ["tactic.replace_at", "rsimp.rsimplify_goal", "tactic.simp_top_down", "tactic.simp_bottom_up", "well_founded_tactics.cancel_nat_add_lt", "tactic.rewrite_target", "push_neg.push_neg_at_goal", "tactic.simp_target", "tactic.assoc_rewrite_target", "tactic.interactive.old_conv"]}, {"id": "ne.decidable", "parentIds": ["tactic.replace_at", "print_content", "expr.mk_exists_lst", "to_additive.target_name", "unused_arguments", "tactic.get_constructors_for", "tactic.mk_assumption_set", "tactic.simplify_top_down", "tactic.clear'", "tactic.mk_dec_eq_instance", "tactic.interactive.unfold_projs", "tactic.interactive.generalize_hyp", "bool.bxor_iff_ne", "lint", "tactic.unprime", "tactic.interactive.unfold_aux", "tactic.lift", "tactic.abstract", "print_all_content", "old_conv.interactive.find", "bool.eq_tt_of_ne_ff", "bool_iff_false", "tactic.suggest.apply_and_solve", "mnot", "bool.eq_ff_of_ne_tt", "tactic.simplify_bottom_up", "environment.is_ginductive'", "conv.interactive.find", "lean.is_release", "tactic.interactive.simp_intros", "tactic.interactive.clear_", "tactic.interactive.return_cast", "tactic.suggest.process_declaration", "where.is_in_namespace_nonsynthetic", "tactic.mk_simp_set_core", "impossible_instance", "rsimp.rsimplify", "lean.parser.parser_orelse", "instance_priority", "tactic.interactive.extract_goal", "tactic.interactive.clear_except", "list.nodup_decidable", "tactic.interactive.h_generalize", "tactic.alias.make_left_right", "tactic.interactive.case", "list.erase_dup", "dangerous_instance", "conv.convert", "tactic.rename'", "derive_struct_ext_lemma", "lint_mathlib", "tactic.done", "lint_all", "dup_namespace"]}, {"id": "list.mmap'", "parentIds": ["tactic.replace_at", "print_content", "tactic.clear'", "tactic.interactive.induction", "tactic.transport_with_prefix_fun", "print_localized_commands", "tactic.terminal_goal", "tactic.try_apply_opt_auto_param_for_apply", "tactic.interactive.change'", "tactic.interactive.simp_core_aux", "tactic.mk_patterns", "print_all_content", "tactic.try_apply_opt_auto_param", "tactic.interactive.simp_rw", "tactic.interactive.substs", "tactic.interactive.assume", "tactic.use", "apply_nolint_tac", "tactic.alias.alias_cmd", "tactic.interactive.concat_tags", "open_locale_cmd", "list_linters", "tactic.prove_goal_async", "parser.str", "monad.mapm'", "parser.char_buf", "tactic.interactive.clear_except", "interactive.loc.apply", "tactic.interactive.h_generalize", "tactic.interactive.push_neg", "derive_struct_ext_lemma", "tactic.reduce_ifs_at"]}, {"id": "tactic.try", "parentIds": ["tactic.replace_at", "tactic.copy_attribute", "tactic.save_const_type_info", "tactic.interactive.induction", "rsimp.rsimplify_goal", "tactic.choose1", "tactic.try_apply_opt_auto_param_for_apply", "tactic.try_apply_opt_auto_param", "conv.solve1", "tactic.apply_heq_congr_core", "rsimp.rsimplify_at", "tactic.suggest.apply_and_solve", "apply_nolint_tac", "tactic.contradiction", "tactic.apply_congr_core", "tactic.subst_vars", "tactic.interactive.try", "tactic.rsimp", "tactic.interactive.rwa", "tactic.rsimp_at", "tactic.replace_hyp", "conv.convert", "tactic.subst", "tactic.interactive.push_neg"]}, {"id": "list.mfilter", "parentIds": ["tactic.replace_at", "monad.filter", "tactic.generalize_proofs", "can_lift_attr", "tactic.interactive.simp_core_aux", "expr.is_eta_expansion_aux", "native.rb_map.mfilter", "print_item_crawl", "tactic.interactive.concat_tags", "incorrect_type_class_argument", "tactic.get_classes", "tactic.apply_at"]}, {"id": "guard", "parentIds": ["tactic.replace_at", "parser.eof", "tactic.delta", "to_additive.target_name", "tactic.existsi", "tactic.simplify_top_down", "tactic.interactive.guard_tags", "to_additive.proceed_fields", "tactic.match_app_of", "tactic.library_search", "tactic.mk_iff_of_inductive_prop", "conv.funext", "old_conv.funext", "tactic.interactive.unfold_aux", "tactic.interactive.guard_hyp_nums", "tactic.interactive.simp_core_aux", "well_founded_tactics.cancel_nat_add_lt", "old_conv.interactive.find", "tactic.apply_heq_congr_core", "tactic.suggest.apply_and_solve", "tactic.apply_eq_congr_core", "tactic.comp_val", "old_conv.congr_core", "tactic.simplify_bottom_up", "old_conv.apply_propext_lemmas_core", "tactic.mk_has_reflect_instance", "conv.interactive.find", "tactic.relation_lhs_rhs", "tactic.interactive.clear_", "tactic.interactive.return_cast", "tactic.interactive.guard_expr_strict", "guard_true", "conv.interactive.for", "tactic.interactive.guard_expr_eq", "rsimp.rsimplify", "instance_priority", "instance_derive_handler", "guard_false", "conv.congr", "tactic.find_private_decl", "tactic.subst", "smt_tactic.interactive.guard_expr_eq", "well_founded_tactics.check_target_is_value_lt"]}, {"id": "list.permutations_aux2", "parentIds": ["list.permutations_aux"]}, {"id": "set.univ", "parentIds": ["function.inv_fun_eq", "function.inv_fun", "function.inv_fun_neg"]}, {"id": "set", "parentIds": ["set.univ", "function.inv_fun_on_eq", "function.inv_fun_on_neg", "function.inv_fun_eq", "set.has_neg", "set.image", "set.subset", "set.sUnion", "set.compl", "set.has_sep", "set.has_subset", "function.inv_fun_on_eq'", "function.inv_fun_on", "function.inv_fun_on_pos", "set.functor", "set.has_emptyc", "function.restrict_eq", "set.has_mem", "set.inter", "set.has_sdiff", "set.powerset", "function.inv_fun_neg", "function.inv_fun_on_mem", "set.mem", "set.has_union", "function.restrict", "set.sep", "set.piecewise", "set.diff", "set_of", "set.has_inter", "set.union", "set.has_insert", "set.is_lawful_functor", "set.insert"]}, {"id": "name.to_string", "parentIds": ["name.has_to_format", "to_additive.target_name", "to_additive.proceed_fields", "localized_cmd", "tactic.subobject_names", "binder.to_string", "list_linters", "name.has_to_string", "binder.has_to_tactic_format", "tactic.interactive.h_generalize", "dup_namespace"]}, {"id": "has_to_format", "parentIds": ["name.has_to_format", "array.has_to_format", "print_decls_sorted", "format.when", "congr_arg_kind.has_to_format", "sigma.has_to_format", "sum_has_to_format", "name_set.has_to_format", "interaction_monad.fail", "subtype.has_to_format", "print_decls", "subsingleton_info.has_to_format", "native.has_to_format", "expr.has_to_format", "local_context.lc_has_to_format", "reflected.has_to_format", "fun_info.has_to_format", "level.has_to_format", "print_decls_sorted_mathlib", "char.has_to_format", "options.has_to_format", "format.has_to_format", "interaction_monad.mk_exception", "list.has_to_format", "tactic.rcases_patt.has_to_format", "decidable.has_to_format", "occurrences.has_to_format", "smt_tactic.fail", "native.rb_set.has_to_format", "prod.has_to_format", "option.has_to_format", "vm.trace", "bool.has_to_format", "tactic.rcases_patt_inverted.has_to_format", "list.to_format", "buffer.has_to_format", "binder.has_to_format", "unsigned.has_to_format", "trace_val", "tactic.unsafe.type_context.trace", "nat.has_to_format", "to_fmt", "native.float.has_to_format", "has_to_format_to_has_to_tactic_format", "string.has_to_format", "pos.has_to_format", "old_conv.fail", "unit.has_to_format", "param_info.has_to_format", "tactic_state.has_to_format", "module_info.has_to_format", "tactic.fail"]}, {"id": "as_false", "parentIds": []}, {"id": "dvd_neg_iff_dvd", "parentIds": []}, {"id": "dvd_of_dvd_neg", "parentIds": ["dvd_neg_iff_dvd"]}, {"id": "comm_semiring_has_dvd", "parentIds": ["dvd_neg_iff_dvd", "dvd.intro", "eq_zero_of_zero_dvd", "mul_dvd_mul", "nat.mul_div_assoc", "dvd_mul_left", "dvd_add_iff_right", "dvd_of_mul_left_dvd", "one_dvd", "dvd.trans", "dvd_of_mul_right_dvd", "exists_eq_mul_left_of_dvd", "dvd.elim", "nat.div_mul_cancel", "nat.pos_of_dvd_of_pos", "nat.mul_div_cancel'", "exists_eq_mul_right_of_dvd", "dvd.intro_left", "nat.dvd_add_iff_right", "nat.dvd_mod_iff", "nat.dvd_sub", "nat.eq_one_of_dvd_one", "neg_dvd_of_dvd", "neg_dvd_iff_dvd", "dvd_trans", "nat.dvd_of_mul_dvd_mul_right", "dvd_mul_of_dvd_right", "dvd_mul_of_dvd_left", "nat.dvd_iff_mod_eq_zero", "dvd_of_neg_dvd", "mul_dvd_mul_left", "dvd_mul_right", "mul_dvd_mul_right", "dvd_add", "dvd_sub", "dvd.elim_left", "nat.dvd_of_mod_eq_zero", "dvd_refl", "dvd_neg_of_dvd", "dvd_of_mul_left_eq", "nat.dvd_of_mul_dvd_mul_left", "nat.le_of_dvd", "dvd_add_iff_left", "nat.decidable_dvd", "dvd_of_dvd_neg", "nat.dvd_add_iff_left", "dvd_zero", "dvd_of_mul_right_eq", "nat.mod_eq_zero_of_dvd", "nat.dvd_antisymm"]}, {"id": "comm_ring", "parentIds": ["dvd_neg_iff_dvd", "mul_self_sub_one_eq", "dvd_add_iff_right", "comm_ring.to_ring", "add_mul_self_eq", "int.comm_ring", "field.to_comm_ring", "neg_dvd_of_dvd", "neg_dvd_iff_dvd", "int.decidable_linear_ordered_comm_ring", "mul_self_sub_mul_self_eq", "dvd_of_neg_dvd", "comm_ring.to_comm_semiring", "dvd_sub", "integral_domain.to_comm_ring", "dvd_neg_of_dvd", "dvd_add_iff_left", "comm_ring.to_comm_semigroup", "dvd_of_dvd_neg"]}, {"id": "dvd_neg_of_dvd", "parentIds": ["dvd_neg_iff_dvd", "dvd_sub", "dvd_of_dvd_neg"]}, {"id": "comm_ring.to_ring", "parentIds": ["dvd_neg_iff_dvd", "int.add_comm_monoid", "mul_self_sub_one_eq", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "int.has_sub", "dvd_add_iff_right", "add_mul_self_eq", "neg_dvd_of_dvd", "neg_dvd_iff_dvd", "mul_eq_zero_iff_eq_zero_or_eq_zero", "int.add_monoid", "mul_self_sub_mul_self_eq", "dvd_of_neg_dvd", "dvd_sub", "eq_of_mul_eq_mul_left", "dvd_neg_of_dvd", "mul_self_eq_mul_self_iff", "int.ring", "int.semiring", "int.monoid", "dvd_add_iff_left", "dvd_of_dvd_neg", "mul_self_eq_one_iff"]}, {"id": "comm_ring.to_comm_semiring", "parentIds": ["dvd_neg_iff_dvd", "dvd_add_iff_right", "int.comm_semiring", "neg_dvd_of_dvd", "neg_dvd_iff_dvd", "dvd_of_neg_dvd", "dvd_sub", "dvd_neg_of_dvd", "int.comm_monoid", "dvd_add_iff_left", "dvd_of_dvd_neg"]}, {"id": "has_dvd", "parentIds": ["dvd_neg_iff_dvd", "dvd.intro", "eq_zero_of_zero_dvd", "mul_dvd_mul", "nat.mul_div_assoc", "dvd_mul_left", "dvd_add_iff_right", "dvd_of_mul_left_dvd", "one_dvd", "dvd.trans", "dvd_of_mul_right_dvd", "exists_eq_mul_left_of_dvd", "dvd.elim", "nat.div_mul_cancel", "nat.pos_of_dvd_of_pos", "nat.mul_div_cancel'", "exists_eq_mul_right_of_dvd", "dvd.intro_left", "nat.dvd_add_iff_right", "nat.dvd_mod_iff", "nat.dvd_sub", "nat.eq_one_of_dvd_one", "neg_dvd_of_dvd", "neg_dvd_iff_dvd", "dvd_trans", "nat.dvd_of_mul_dvd_mul_right", "dvd_mul_of_dvd_right", "dvd_mul_of_dvd_left", "nat.dvd_iff_mod_eq_zero", "dvd_of_neg_dvd", "mul_dvd_mul_left", "dvd_mul_right", "mul_dvd_mul_right", "dvd_add", "dvd_sub", "comm_semiring_has_dvd", "dvd.elim_left", "nat.dvd_of_mod_eq_zero", "dvd_refl", "dvd_neg_of_dvd", "dvd_of_mul_left_eq", "nat.dvd_of_mul_dvd_mul_left", "nat.le_of_dvd", "dvd_add_iff_left", "nat.decidable_dvd", "dvd_of_dvd_neg", "nat.dvd_add_iff_left", "dvd_zero", "dvd_of_mul_right_eq", "nat.mod_eq_zero_of_dvd", "nat.dvd_antisymm"]}, {"id": "nat.zero_ne_one_class", "parentIds": ["nat.eq_zero_or_eq_succ_pred", "nat.cond_to_bool_mod_two"]}, {"id": "nat.zero_ne_one", "parentIds": ["nat.zero_ne_one_class"]}, {"id": "zero_ne_one_class", "parentIds": ["nat.zero_ne_one_class", "nat.eq_zero_or_eq_succ_pred", "discrete_field", "int.zero_ne_one_class", "division_ring", "linear_ordered_comm_ring", "ordered_ring.to_zero_ne_one_class", "discrete_linear_ordered_field", "linear_ordered_ring", "zero_ne_one_class.to_has_zero", "one_inv_eq", "one_ne_zero", "field", "decidable_linear_ordered_comm_ring", "division_ring.to_zero_ne_one_class", "zero_ne_one", "integral_domain.to_zero_ne_one_class", "linear_ordered_field", "ordered_ring", "nat.cond_to_bool_mod_two", "zero_ne_one_class.to_has_one"]}, {"id": "native.rb_map.of_list", "parentIds": ["transport_multiplicative_to_additive", "to_additive.tokens_dict", "tactic.interactive.rename'", "native.rb_map.mfilter", "native.rb_map.mmap"]}, {"id": "tactic.library_search_hole_cmd", "parentIds": []}, {"id": "hole_command", "parentIds": ["tactic.library_search_hole_cmd", "infer_type_cmd", "use_cmd", "tactic.instance_stub", "show_goal_cmd", "tactic.eqn_stub", "tactic.list_constructors_hole", "lint_hole_cmd", "tactic.match_stub"]}, {"id": "tactic.library_search", "parentIds": ["tactic.library_search_hole_cmd", "tactic.interactive.library_search"]}, {"id": "string.iterator.remove", "parentIds": ["tactic.library_search_hole_cmd"]}, {"id": "tactic.done", "parentIds": ["tactic.library_search_hole_cmd", "tactic.interactive.solve_by_elim", "tactic.suggest_scripts", "tactic.library_search", "well_founded_tactics.default_dec_tac'", "conv.interactive.done", "tactic.interactive.library_search", "tactic.suggest.apply_and_solve", "tactic.suggest_core", "tactic.solve_by_elim", "rsimp.collect_implied_eqs", "tactic.interactive.done", "tactic.delta_instance", "tactic.suggest", "tactic.interactive.suggest", "derive_struct_ext_lemma", "conv.discharge_eq_lhs"]}, {"id": "string.iterator.to_string", "parentIds": ["tactic.library_search_hole_cmd"]}, {"id": "list.prod", "parentIds": []}, {"id": "module_info.has_repr", "parentIds": []}, {"id": "module_info", "parentIds": ["module_info.has_repr", "module_info.of_module_name", "module_info.of_module_id", "module_info.id", "module_info.has_to_tactic_format", "environment.import_only", "environment.import_dependencies", "environment.import_only_until_decl", "environment.import'", "environment.import_until_decl", "module_info.has_to_string", "module_info.has_to_format"]}, {"id": "has_repr", "parentIds": ["module_info.has_repr", "repr", "list.repr_aux", "array.has_repr", "rbtree.has_repr", "int.has_repr", "rbmap.has_repr", "list.repr", "environment.has_repr", "unsigned.has_repr", "occurrences.has_repr", "ordering.has_repr", "buffer.has_repr", "fin.has_repr", "list.has_repr", "binder_info.has_repr", "option.has_repr", "subtype.has_repr", "sum.has_repr", "native.float.has_repr", "prod.has_repr", "string.has_repr", "decidable.has_repr", "unit.has_repr", "bool.has_repr", "congr_arg_kind.has_repr", "nat.has_repr", "char.has_repr", "sigma.has_repr"]}, {"id": "module_info.id", "parentIds": ["module_info.has_repr", "module_info.has_to_tactic_format", "module_info.has_to_string", "module_info.has_to_format"]}, {"id": "bin_tree.to_list", "parentIds": ["list.bin_tree_to_list"]}, {"id": "bin_tree", "parentIds": ["bin_tree.to_list", "bin_tree.inhabited", "list.bin_tree_to_list"]}, {"id": "cc_state.mk_using_hs_core", "parentIds": ["cc_state.mk_using_hs", "tactic.cc_core"]}, {"id": "cc_state", "parentIds": ["cc_state.mk_using_hs_core", "cc_state.mk_using_hs", "tactic.cc_core", "cc_state.roots", "cc_state.mt", "rsimp.rsimplify_goal", "cc_state.proof_for", "cc_state.add", "cc_state.refutation_for", "cc_state.pp_eqc", "cc_state.is_cg_root", "smt_tactic.proof_for", "cc_state.eqc_size", "tactic.ematch_all_core", "cc_state.eqc_of", "smt_tactic.get_facts", "cc_state.eqc_of_core", "cc_state.root", "cc_state.mk_core", "tactic.ac_refl", "smt_tactic.get_refuted_facts", "rsimp.rsimplify_at", "cc_state.roots_core", "cc_state.gmt", "tactic.ematch_core", "cc_state.inconsistent", "rsimp.to_repr_map", "tactic.ematch_all", "rsimp.collect_implied_eqs", "cc_state.in_singlenton_eqc", "cc_state.mfold_eqc", "cc_state.pp_core", "cc_state.fold_eqc_core", "rsimp.choose", "tactic.ematch", "cc_state.inc_gmt", "cc_state.has_to_tactic_format", "cc_state.is_not_eqv", "cc_state.next", "rsimp.rsimplify", "tactic.rsimp", "smt_tactic.to_cc_state", "cc_state.proof_for_false", "tactic.rsimp_at", "smt_tactic.interactive.rsimp", "cc_state.internalize", "cc_state.is_eqv", "smt_tactic.refutation_for", "cc_state.eqv_proof", "cc_state.fold_eqc"]}, {"id": "cc_config", "parentIds": ["cc_state.mk_using_hs_core", "tactic.cc_dbg_core", "cc_state.mk_using_hs", "tactic.cc_core", "using_smt", "tactic.cc", "cc_state.mk_core", "tactic.cc_dbg", "smt_tactic.execute", "rsimp.collect_implied_eqs", "smt_config", "smt_config.inhabited", "cc_config.inhabited", "smt_config.set_classical", "smt_tactic.interactive.executor"]}, {"id": "put", "parentIds": ["expr.mfoldl"]}, {"id": "id.monad", "parentIds": ["put", "id.is_comm_applicative", "id.bind_eq", "id.map_eq", "functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "comp.applicative_id_comp", "id.is_lawful_monad", "is_lawful_traversable", "modify", "comp.applicative_comp_id", "id.pure_eq", "id.traversable", "get"]}, {"id": "state_t.put", "parentIds": ["put", "state_t.run_put"]}, {"id": "monad_state", "parentIds": ["put", "smt_tactic.monad_state", "monad_state_trans", "modify", "state_t.monad_state", "get"]}, {"id": "occurrences_repr", "parentIds": ["occurrences.has_repr"]}, {"id": "occurrences", "parentIds": ["occurrences_repr", "tactic.rewrite_core", "occurrences_to_format", "tactic.rewrite", "tactic.interactive.convert_to_core", "occurrences.has_repr", "tactic.lift", "tactic.rewrite_hyp", "conv.interactive.rw", "tactic.rewrite_cfg", "tactic.rewrite_cfg.inhabited", "occurrences.has_to_format", "tactic.interactive.erw", "tactic.interactive.erewrite", "tactic.assoc_rewrite", "tactic.rewrite_target", "occurrences.contains", "conv.interactive.erw", "conv.interactive.rewrite", "tactic.interactive.rwa", "tactic.interactive.rw", "tactic.interactive.h_generalize", "tactic.interactive.rewrite", "occurrences.inhabited"]}, {"id": "binder.decidable_eq", "parentIds": ["unused_arguments"]}, {"id": "binder", "parentIds": ["binder.decidable_eq", "unused_arguments", "tactic.get_pi_binders", "tactic.get_pi_binders_aux", "binder.has_to_string", "binder.to_string", "binder.inhabited", "binder.has_to_tactic_format", "binder.has_to_format", "expr.to_binder", "impossible_instance", "incorrect_type_class_argument", "instance_priority", "dangerous_instance", "expr.pi_binders", "expr.pi_binders_aux", "tactic.get_pi_binders_dep_aux", "tactic.get_pi_binders_dep"]}, {"id": "decidable.by_cases", "parentIds": ["binder.decidable_eq", "max_add_add_left", "classical.by_cases", "one_div_mul_one_div'", "mul_div_mul_left'", "nat.lt_ge_by_cases", "subtype.decidable_eq", "min_add_add_left", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_mul_right", "mul_inv'", "string.has_decidable_eq", "one_div_neg_eq_neg_one_div", "abs_div", "one_div_div", "decidable.em", "one_div_one_div", "neg_div_neg_eq", "div_mul_eq_mul_div_comm", "eq_of_one_div_eq_one_div", "int.decidable_eq", "sum.decidable_eq", "eq_zero_of_one_div_eq_zero", "div_mul_div", "nat.min_succ_succ"]}, {"id": "tactic.binder_info.has_decidable_eq", "parentIds": ["binder.decidable_eq", "where.sort_variable_list", "impossible_instance", "incorrect_type_class_argument", "instance_priority", "dangerous_instance"]}, {"id": "decidable_eq", "parentIds": ["binder.decidable_eq", "punit.decidable_eq", "prod.decidable_eq", "char.decidable_eq", "list.union", "discrete_field", "decidable_eq_inl_refl", "tactic.suggest.head_symbol_match.decidable_eq", "native.rb_map.add", "unsigned.decidable_eq", "array.decidable_eq", "d_array.beq", "ne.decidable", "decidable_linear_ordered_semiring", "function.update_eq_self", "d_array.of_beq_aux_eq_tt", "expr.has_decidable_eq", "empty.decidable_eq", "function.injective.decidable_eq", "list.is_prefix_of", "prod.lex.decidable", "bool.decidable_eq", "list.insert", "function.update", "list.decidable_mem", "vm_obj_kind.decidable_eq", "decidable_linear_ordered_cancel_comm_monoid", "quotient.decidable_eq", "function.update_same", "list.has_sdiff", "prod_has_decidable_lt", "function.decidable_eq_pfun", "ordering.decidable_eq", "list.split_on", "rbnode.color.decidable_eq", "where.collect_by_aux", "list.remove_all", "classical.dec_eq", "pos.decidable_eq", "list.indexes_of", "decidable_linear_order", "list.has_dec_eq", "subtype.decidable_eq", "discrete_linear_ordered_field", "decidable_eq_of_decidable_le", "d_array.of_beq_aux_eq_ff", "nat.decidable_eq", "name.has_decidable_eq", "string.has_decidable_eq", "d_array.decidable_eq", "level.has_decidable_eq", "function.update_noteq", "list.is_suffix_of", "list.count", "tactic.binder_info.has_decidable_eq", "list.has_union", "list.inter", "decidable_eq_of_bool_pred", "list.decidable_eq", "d_array.of_beq_eq_tt", "fin.decidable_eq", "decidable_linear_ordered_comm_ring", "list.bag_inter", "list.index_of", "d_array.of_beq_eq_ff", "list.erase", "list.has_insert", "int.decidable_eq", "sum.decidable_eq", "list.get_rest", "list.nodup_decidable", "decidable_eq_of_subsingleton", "list.erase_dup", "native.float.dec_eq", "decidable_eq_inr_neg", "list.diff", "options.has_decidable_eq", "classical.type_decidable_eq", "where.collect_by", "decidable_linear_ordered_comm_group", "d_array.beq_aux", "pempty.decidable_eq", "list.has_inter", "option.decidable_eq", "where.select_for_which", "function.update_comp"]}, {"id": "name.has_decidable_eq", "parentIds": ["binder.decidable_eq", "expr.is_iff", "tactic.elide.unelide", "to_additive.target_name", "where.trace_namespace", "tactic.interactive.propagate_tags", "tactic.mk_assumption_set", "expr.to_nat", "tactic.suggest.unfold_head_symbol", "tactic.interactive.guard_tags", "expr.is_ne", "to_additive.proceed_fields", "expr.to_int", "expr.is_heq", "tactic.revert_all", "tactic.choose1", "expr.is_constant_of", "expr.is_eq", "tactic.apply_auto_param", "conv.funext", "old_conv.funext", "tactic.lift", "expr.is_false", "tactic.subobject_names", "well_founded_tactics.cancel_nat_add_lt", "well_founded_tactics.is_psigma_mk", "name.deinternalize_field", "expr.is_or", "old_conv.congr_core", "where.get_opens", "old_conv.apply_propext_lemmas_core", "tactic.interactive.use", "tactic.injection_with", "list_linters", "tactic.mk_simp_set_core", "tactic.alias.alias_iff", "tactic.interactive.refine_one", "tactic.interactive.clean", "environment.in_current_file'", "expr.is_not", "where.is_variable_name", "list_items", "where.fetch_potential_variable_names", "tactic.interactive.field", "expr.is_eta_expansion_test", "tactic.interactive.list_cast_of_aux", "tactic.interactive.h_generalize", "interactive.param_desc", "conv.congr", "tactic.interactive.case", "saturate_fun", "tactic.interactive.source_fields", "expr.list_names_with_prefix", "tactic.find_private_decl", "tactic.get_user_simp_lemmas", "ge_or_gt_in_statement", "expr.is_and", "has_inhabited_instance", "dup_namespace", "tactic.apply_opt_param", "well_founded_tactics.check_target_is_value_lt"]}, {"id": "expr.has_decidable_eq", "parentIds": ["binder.decidable_eq", "tactic.revertible_local_context", "unused_arguments", "tactic.is_prop", "where.sort_variable_list", "expr.list_local_consts", "tactic.terminal_goal", "expr.is_eta_expansion_of", "tactic.change_with_at", "well_founded_tactics.cancel_nat_add_lt", "expr.list_meta_vars", "expr.replace_with", "cc_state.in_singlenton_eqc", "tactic.interactive.guard_expr_strict", "tactic.interactive.change", "list_linters", "instance_priority", "tactic.interactive.case", "derive_struct_ext_lemma", "has_inhabited_instance"]}, {"id": "transitive", "parentIds": ["setoid.trans", "equivalence", "mk_equivalence", "eq_equivalence", "inv_image.trans", "setoid.symm", "setoid.refl"]}, {"id": "list.mem_nil_iff", "parentIds": ["list.not_mem_nil", "list.nil_subset"]}, {"id": "sub_eq_sub_iff_sub_eq_sub", "parentIds": []}, {"id": "add_left_comm", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "norm_num.add_comm_four", "norm_num.bit0_add_bit1", "mul_self_sub_one_eq", "add_sub_comm", "norm_num.add1_bit1", "add_sub_add_left_eq_sub", "int.add_assoc", "sub_add_add_cancel", "nat.succ_mul_succ_eq", "abs_sub_square", "list.length_append", "exists_add_lt_and_pos_of_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "norm_num.add_comm_middle", "int.lt_add_succ", "norm_num.bit1_add_bit0_helper", "add_mul_self_eq", "add_add_add_comm", "int.sub_nat_nat_eq_coe", "norm_num.bit0_add_bit1_helper", "sub_sub", "sub_eq_of_eq_add'", "norm_num.one_add_bit1", "norm_num.add1_bit1_helper", "norm_num.bit0_add_bit0_helper", "norm_num.bit1_add_bit0", "mul_self_sub_mul_self_eq", "norm_num.bit1_add_bit1", "sub_add_eq_add_sub", "nat.mod_add_div", "eq_sub_of_add_eq'", "distrib_three_right", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq'", "norm_num.one_add_bit1_helper", "sub_add_eq_sub_sub", "sub_eq_sub_add_sub", "int.neg_succ_of_nat_lt_zero", "sub_add", "norm_num.bit0_add_bit0", "norm_num.one_add_bit0"]}, {"id": "add_comm", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "int.add_comm", "norm_num.add_comm_four", "int.le.dest", "norm_num.bit0_add_bit1", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "add_sub_comm", "le_add_of_sub_left_le", "norm_num.add1_bit1", "add_sub_add_left_eq_sub", "int.add_assoc", "add_midpoint", "neg_add_eq_sub", "sub_add_add_cancel", "nat.add_div_left", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "abs_sub_square", "sub_left_le_of_le_add", "dvd_add_iff_right", "list.length_append", "string.iterator.length_next_to_string_next", "exists_add_lt_and_pos_of_lt", "nat.zero_lt_one_add", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.lt_add_of_pos_left", "nat.mul_div_right", "norm_num.add_comm_middle", "int.sub_nat_nat_elim", "lt_of_add_lt_add_right", "int.lt_add_succ", "neg_sub_neg", "list.length_map", "nat.sub_mul_mod", "lt_add_of_neg_add_lt_left", "norm_num.bit1_add_bit0_helper", "add_le_add_right", "nat.shiftl'_sub", "norm_num.neg_add_pos_eq_of_eq_add", "add_mul_self_eq", "neg_add", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "nat.bodd_mul", "string.iterator.zero_lt_length_next_to_string_of_has_next", "norm_num.bit0_add_bit1_helper", "neg_add_le_right_of_le_add", "sub_sub", "add_le_of_le_sub_left", "int.le.intro", "neg_le_sub_left_of_le_add", "nat.bit_decomp", "neg_add_le_left_of_le_add", "min_add_add_right", "le_sub_left_of_add_le", "add_comm_semigroup_to_is_eq_commutative", "sub_sub_sub_cancel_left", "sub_sub_self", "sub_eq_of_eq_add'", "norm_num.one_add_bit1", "nat.sub_one_sub_lt", "norm_num.add1_bit1_helper", "int.mul_pos", "int.eq_succ_of_zero_lt", "norm_num.bit0_add_bit0_helper", "nat.one_add", "norm_num.bit1_add_bit0", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "sub_left_lt_of_lt_add", "add_right_comm", "nat.bodd_bit", "nat.sub_mul_div", "nat.sub.right_comm", "nat.add_mod_left", "nat.test_bit_succ", "nat.div2_bit", "nat.mul_self_sub_mul_self_eq", "norm_num.bit1_add_bit1", "add_lt_add_right", "le_add_of_neg_add_le_right", "sub_add_eq_add_sub", "nat.mod_add_div", "max_add_add_right", "neg_add_lt_left_of_lt_add", "eq_sub_of_add_eq'", "distrib_three_right", "norm_num.pos_add_neg_helper", "norm_num.bit1_add_bit1_helper", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "neg_lt_sub_left_of_lt_add", "int.lt.dest", "one_div_add_one_div", "norm_num.one_add_bit1_helper", "norm_num.mul_bit1", "sub_add_eq_sub_sub", "nat.mod_pow_succ", "lt_add_of_sub_left_lt", "sub_eq_neg_add", "sub_eq_sub_add_sub", "int.neg_succ_of_nat_lt_zero", "add_left_comm", "nat.le_div_iff_mul_le", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'", "norm_num.bit0_add_bit0", "nat.sub_add_cancel", "nat.dvd_add_iff_left", "nat.div_zero", "norm_num.one_add_bit0", "le_of_add_le_add_right", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "nat.add_sub_add_left", "lt_sub_left_of_add_lt"]}, {"id": "neg_add_cancel_left", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "neg_add_le_of_le_add", "abs_sub_le", "neg_add_lt_of_lt_add", "add_sub_cancel'", "ordered_comm_group.lt_of_add_lt_add_left", "exists_add_lt_and_pos_of_lt", "left_inverse_neg_add_add_right", "neg_add_eq_iff_eq_add", "int.le.intro", "neg_comm_of_comm", "neg_sub", "eq_neg_add_of_add_eq", "eq_neg_add_iff_add_eq", "lt_neg_add_of_add_lt", "ordered_comm_group.le_of_add_le_add_left", "neg_add_eq_of_eq_add", "le_neg_add_of_add_le", "add_group.add_left_cancel"]}, {"id": "eq_add_of_sub_eq", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "eq_zero_of_mul_eq_self_right"]}, {"id": "add_comm_group.to_add_comm_monoid", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "add_eq_of_eq_sub'", "add_sub_comm", "add_sub_add_left_eq_sub", "sub_right_comm", "neg_add_eq_sub", "sub_add_add_cancel", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "neg_sub_neg", "norm_num.neg_add_pos_eq_of_eq_add", "neg_add", "neg_neg_sub_neg", "sub_sub", "sub_sub_sub_cancel_left", "sub_sub_self", "sub_eq_of_eq_add'", "sub_add_eq_add_sub", "eq_sub_of_add_eq'", "norm_num.pos_add_neg_helper", "eq_add_of_sub_eq'", "sub_add_eq_sub_sub", "sub_eq_neg_add", "sub_eq_sub_add_sub", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'"]}, {"id": "add_comm_group", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "add_eq_of_eq_sub'", "ring.to_add_comm_group", "add_sub_comm", "add_sub_add_left_eq_sub", "sub_right_comm", "add_add_sub_cancel", "neg_add_eq_sub", "add_comm_group.to_add_comm_monoid", "sub_add_add_cancel", "ordered_comm_group.to_add_comm_group", "add_sub_cancel'", "add_sub_sub_cancel", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "neg_sub_neg", "norm_num.neg_add_pos_helper1", "sub_sub_cancel", "add_sub_cancel'_right", "add_comm_group.to_add_group", "norm_num.neg_add_pos_eq_of_eq_add", "norm_num.neg_add_pos_helper2", "neg_add", "neg_neg_sub_neg", "linear_ordered_comm_ring", "sub_sub", "discrete_linear_ordered_field", "linear_ordered_ring", "sub_sub_sub_cancel_left", "sub_sub_self", "sub_eq_of_eq_add'", "ordered_comm_group", "add_add_neg_cancel'_right", "sub_add_eq_add_sub", "eq_sub_of_add_eq'", "norm_num.pos_add_neg_helper", "decidable_linear_ordered_comm_ring", "eq_add_of_sub_eq'", "norm_num.neg_add_neg_helper", "neg_add'", "sub_add_eq_sub_sub", "linear_ordered_field", "sub_eq_neg_add", "sub_eq_sub_add_sub", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'", "ordered_ring", "decidable_linear_ordered_comm_group", "decidable_linear_ordered_comm_group.to_add_comm_group"]}, {"id": "add_comm_monoid.to_add_comm_semigroup", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "add_sub_comm", "le_add_of_sub_left_le", "add_sub_add_left_eq_sub", "sub_right_comm", "add_midpoint", "neg_add_eq_sub", "int.add_comm_semigroup", "sub_add_add_cancel", "abs_sub_square", "sub_left_le_of_le_add", "dvd_add_iff_right", "exists_add_lt_and_pos_of_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.lt_add_of_pos_left", "lt_of_add_lt_add_right", "neg_sub_neg", "lt_add_of_neg_add_lt_left", "add_le_add_right", "norm_num.neg_add_pos_eq_of_eq_add", "add_mul_self_eq", "neg_add", "neg_neg_sub_neg", "neg_add_le_right_of_le_add", "sub_sub", "add_le_of_le_sub_left", "neg_le_sub_left_of_le_add", "neg_add_le_left_of_le_add", "min_add_add_right", "le_sub_left_of_add_le", "sub_sub_sub_cancel_left", "sub_sub_self", "sub_eq_of_eq_add'", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "sub_left_lt_of_lt_add", "add_lt_add_right", "le_add_of_neg_add_le_right", "sub_add_eq_add_sub", "nat.add_comm_semigroup", "max_add_add_right", "neg_add_lt_left_of_lt_add", "eq_sub_of_add_eq'", "distrib_three_right", "norm_num.pos_add_neg_helper", "eq_add_of_sub_eq'", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "neg_lt_sub_left_of_lt_add", "one_div_add_one_div", "norm_num.mul_bit1", "sub_add_eq_sub_sub", "lt_add_of_sub_left_lt", "sub_eq_neg_add", "sub_eq_sub_add_sub", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'", "le_of_add_le_add_right", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "lt_sub_left_of_add_lt"]}, {"id": "add_right_inj", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "neg_sub_neg", "add_eq_zero_iff_eq_neg", "sub_sub_assoc_swap", "sub_right_inj"]}, {"id": "add_comm_semigroup.to_add_semigroup", "parentIds": ["sub_eq_sub_iff_sub_eq_sub", "norm_num.add_comm_four", "int.le.dest", "norm_num.bit0_add_bit1", "add_eq_of_eq_sub'", "mul_self_sub_one_eq", "add_sub_comm", "le_add_of_sub_left_le", "norm_num.add1_bit1", "add_sub_add_left_eq_sub", "int.add_assoc", "add_midpoint", "sub_add_add_cancel", "nat.add_div_left", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "abs_sub_square", "sub_left_le_of_le_add", "dvd_add_iff_right", "list.length_append", "string.iterator.length_next_to_string_next", "exists_add_lt_and_pos_of_lt", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "nat.lt_add_of_pos_left", "nat.mul_div_right", "norm_num.add_comm_middle", "int.sub_nat_nat_elim", "lt_of_add_lt_add_right", "int.lt_add_succ", "neg_sub_neg", "list.length_map", "nat.sub_mul_mod", "lt_add_of_neg_add_lt_left", "norm_num.bit1_add_bit0_helper", "add_le_add_right", "nat.shiftl'_sub", "add_mul_self_eq", "add_add_add_comm", "neg_add", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "nat.bodd_mul", "string.iterator.zero_lt_length_next_to_string_of_has_next", "norm_num.bit0_add_bit1_helper", "neg_add_le_right_of_le_add", "sub_sub", "add_le_of_le_sub_left", "int.le.intro", "neg_le_sub_left_of_le_add", "nat.bit_decomp", "neg_add_le_left_of_le_add", "min_add_add_right", "add_comm", "le_sub_left_of_add_le", "add_comm_semigroup_to_is_eq_commutative", "sub_sub_sub_cancel_left", "sub_sub_self", "sub_eq_of_eq_add'", "norm_num.one_add_bit1", "nat.sub_one_sub_lt", "norm_num.add1_bit1_helper", "int.mul_pos", "int.eq_succ_of_zero_lt", "norm_num.bit0_add_bit0_helper", "norm_num.bit1_add_bit0", "lt_add_of_neg_add_lt_right", "le_add_of_neg_add_le_left", "mul_self_sub_mul_self_eq", "sub_left_lt_of_lt_add", "add_right_comm", "nat.bodd_bit", "nat.sub_mul_div", "nat.sub.right_comm", "nat.add_mod_left", "nat.test_bit_succ", "nat.div2_bit", "nat.mul_self_sub_mul_self_eq", "norm_num.bit1_add_bit1", "add_lt_add_right", "le_add_of_neg_add_le_right", "sub_add_eq_add_sub", "nat.mod_add_div", "max_add_add_right", "neg_add_lt_left_of_lt_add", "eq_sub_of_add_eq'", "distrib_three_right", "norm_num.pos_add_neg_helper", "norm_num.bit1_add_bit1_helper", "eq_add_of_sub_eq'", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "neg_lt_sub_left_of_lt_add", "int.lt.dest", "one_div_add_one_div", "norm_num.one_add_bit1_helper", "norm_num.mul_bit1", "sub_add_eq_sub_sub", "nat.mod_pow_succ", "lt_add_of_sub_left_lt", "sub_eq_sub_add_sub", "int.neg_succ_of_nat_lt_zero", "add_left_comm", "nat.le_div_iff_mul_le", "sub_add_sub_cancel'", "sub_add", "sub_eq_iff_eq_add'", "eq_sub_iff_add_eq'", "norm_num.bit0_add_bit0", "nat.sub_add_cancel", "nat.dvd_add_iff_left", "nat.div_zero", "norm_num.one_add_bit0", "le_of_add_le_add_right", "add_lt_of_lt_sub_left", "neg_add_lt_right_of_lt_add", "nat.add_sub_add_left", "lt_sub_left_of_add_lt"]}, {"id": "le_mul_of_div_le", "parentIds": ["mul_le_mul_of_mul_div_le"]}, {"id": "le_of_lt", "parentIds": ["le_mul_of_div_le", "max_add_add_left", "div_le_div_of_le_of_pos", "one_div_pos_of_pos", "abs_of_pos", "zero_le_one", "d_array.of_beq_aux_eq_tt", "min_eq_left_of_lt", "div_nonneg_of_nonpos_of_neg", "one_le_div_of_le", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "lt_of_not_ge", "le_div_of_mul_le", "lt_of_add_lt_add_left", "div_mul_le_div_mul_of_div_le_div_pos", "le_of_eq_or_lt", "nat.sub_pos_of_lt", "norm_num.sub_nat_zero_helper", "nat.mod_le", "norm_num.nonneg_bit1_helper", "mul_le_of_le_div", "abs_of_neg", "one_div_neg_of_neg", "min_add_add_left", "d_array.of_beq_aux_eq_ff", "le_of_not_gt", "div_mul_le_div_mul_of_div_le_div_pos'", "le_of_lt_or_eq", "lt_or_ge", "div_nonpos_of_nonpos_of_pos", "mul_self_lt_mul_self", "mul_le_of_div_le_of_neg", "div_nonpos_of_nonneg_of_neg", "nat.mul_self_lt_mul_self", "nat.pow_lt_pow_of_lt_left", "two_ge_one", "one_div_le_one_div_of_le", "div_nonneg_of_nonneg_of_pos", "lt_iff_le_and_ne", "add_lt_add_left", "one_div_le_one_div_of_le_of_neg", "min_eq_right_of_lt", "abs_abs_sub_abs_le_abs_sub", "div_le_of_le_mul", "le_of_one_le_div", "max_eq_right_of_lt", "max_eq_left_of_lt"]}, {"id": "ne_of_lt", "parentIds": ["le_mul_of_div_le", "two_ne_zero", "one_div_le_of_one_div_le_of_neg", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "div_le_of_mul_le_of_neg", "one_lt_div_of_lt", "div_lt_of_mul_gt_of_neg", "ordering.compares.eq_lt", "le_div_of_mul_le", "mul_zero_lt_mul_inv_of_pos", "ne_iff_lt_or_gt", "lt_of_one_lt_div", "mul_le_of_le_div", "mul_lt_of_gt_div_of_neg", "mul_le_of_div_le_of_neg", "mul_lt_of_lt_div", "pos_of_one_div_pos", "decidable.ne_iff_lt_or_gt", "lt_iff_le_and_ne", "neg_of_one_div_neg", "div_le_of_le_mul", "le_of_one_le_div", "ordering.compares.eq_eq"]}, {"id": "ne.symm", "parentIds": ["le_mul_of_div_le", "int.zero_ne_neg_of_ne", "two_ne_zero", "one_le_div_of_le", "lt_div_of_mul_lt", "one_lt_div_of_lt", "string.str_ne_empty", "le_div_of_mul_le", "mul_zero_lt_mul_inv_of_pos", "ne_comm", "one_div_one", "lt_of_one_lt_div", "nat.one_ne_bit1", "mul_le_of_le_div", "nat.bit1_ne_bit0", "nat.zero_ne_bit1", "field.div_mul_eq_mul_div_comm", "nat.bit0_ne_one", "nat.bit0_ne_bit1", "nat.one_ne_bit0", "mul_lt_of_lt_div", "nat.zero_ne_bit0", "pos_of_one_div_pos", "int.ne_neg_of_pos", "div_le_of_le_mul", "le_of_one_le_div"]}, {"id": "division_ring.to_ring", "parentIds": ["le_mul_of_div_le", "div_zero", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "division_def", "div_sub_div", "div_pos_of_neg_of_neg", "mul_ne_zero_comm", "add_midpoint", "mul_inv_eq", "div_nonneg_of_nonpos_of_neg", "two_ne_zero", "field.one_div_mul_one_div", "mul_eq_of_eq_div", "one_le_div_of_le", "ge_of_forall_ge_sub", "one_div_mul_one_div'", "div_le_div_of_le_of_neg", "field.div_mul_eq_div_mul_one_div", "one_div_eq_inv", "exists_add_lt_and_pos_of_lt", "div_div_eq_div_mul", "div_mul_eq_mul_div", "mul_div_mul_left'", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_lt_neg_one", "div_two_sub_self", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "eq_of_mul_eq_mul_of_nonzero_right", "one_div_zero", "div_mul_cancel", "mul_div_cancel_left", "div_self", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "algebra.div", "mul_sub_mul_div_mul_neg", "add_div_eq_mul_add_div", "mul_one_div_cancel", "zero_div", "lt_of_one_lt_div", "field.div_div_div_div_eq", "mul_le_of_le_div", "norm_num.div_add_helper", "eq_div_of_mul_eq", "one_div_ne_zero", "field.div_mul_left", "mul_lt_of_gt_div_of_neg", "field.div_mul_eq_mul_div_comm", "one_inv_eq", "mul_inv_cancel", "div_lt_div_of_lt_of_neg", "norm_num.add_div_helper", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_mul_one_div", "div_mul_right", "mul_inv'", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "one_div_neg_one_eq_neg_one", "norm_num.div_mul_helper", "one_div_neg_eq_neg_one_div", "abs_div", "div_mul_eq_div_mul_one_div", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "mul_div_assoc", "field.div_mul_right", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "division_ring.neg_div_neg_eq", "mul_eq_mul_of_div_eq_div", "mul_lt_of_lt_div", "div_eq_one_iff_eq", "mul_div_mul_left", "div_lt_div_of_pos_of_lt_of_pos", "div_add_div_same", "sub_self_div_two", "mul_div_cancel'", "two_ge_one", "mul_div_mul_right", "two_pos", "div_one", "add_halves", "field.div_div_eq_mul_div", "neg_div_neg_eq", "mul_div_cancel", "inv_mul_cancel", "div_nonneg_of_nonneg_of_pos", "div_mul_eq_mul_div_comm", "neg_div", "div_div_div_div_eq", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "div_sub_div_same", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "one_div_add_one_div", "neg_of_one_div_neg", "mul_mul_div", "norm_num.div_helper", "field.div_div_eq_div_mul", "div_le_of_le_mul", "norm_num.nonzero_of_div_helper", "division_ring.one_div_mul_one_div", "norm_num.div_eq_div_helper", "le_of_one_le_div", "norm_num.mul_div_helper", "div_neg_of_neg_of_pos", "div_mul_div", "div_add_div", "four_pos", "div_two_lt_of_pos", "division_ring.one_div_neg_eq_neg_one_div", "eq_div_iff_mul_eq", "one_div_le_neg_one", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "gt", "parentIds": ["le_mul_of_div_le", "nat.pos_of_ne_zero", "nat.mod_lt", "mul_lt_mul_of_neg_left", "param_info.to_format", "div_lt_of_mul_lt_of_pos", "abs_of_pos", "nat.mul_div_mul", "lt_or_gt_of_ne", "gt.trans", "abs_pos_of_ne_zero", "int.neg_ne_of_pos", "nat.mul_div_assoc", "norm_num.pos_bit1_helper", "nat.eq_of_mul_eq_mul_right", "nat.add_div_left", "not_lt_of_gt", "one_div_le_of_one_div_le_of_neg", "nat.add_mul_div_right", "one_le_div_of_le", "ge_of_forall_ge_sub", "nat.pow_lt_pow_of_lt_right", "exists_add_lt_and_pos_of_lt", "max_lt", "int.one_pos", "nat.find_min'", "nat.lt_add_of_pos_left", "nat.mul_div_right", "nat.eq_zero_or_pos", "one_lt_div_of_lt", "not_le_of_gt", "ne_of_gt", "int.nat_abs_pos_of_ne_zero", "div_lt_of_mul_gt_of_neg", "nat.add_mul_div_left", "gt_of_ge_of_gt", "nat.pow_le_pow_of_le_right", "lt_min", "gt_of_gt_of_ge", "gt_iff_lt", "mul_le_mul_of_mul_div_le", "mul_lt_mul_of_neg_right", "ordering.compares.eq_gt", "div_mul_le_div_mul_of_div_le_div_pos", "ne_iff_lt_or_gt", "two_gt_one", "mul_pos", "nat.lt_add_of_pos_right", "mul_sub_mul_div_mul_neg", "nat.sub_pos_of_lt", "nat.mul_mod_mul_left", "gt_irrefl", "int.bit1_pos", "nat.mod_le", "tactic.interactive.simp_core_aux", "nat.pos_of_dvd_of_pos", "nat.div_eq_of_eq_mul_right", "lt_add_of_pos_left", "buffer.lt_aux_2", "lt_of_one_lt_div", "le_of_one_div_le_one_div_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "one_div_le_of_one_div_le_of_pos", "mul_neg_of_neg_of_pos", "le_of_mul_le_mul_right", "eq_zero_of_neg_eq", "sub_lt_self", "le_of_one_div_le_one_div", "mul_lt_of_gt_div_of_neg", "nat.eq_one_of_dvd_one", "le_of_not_gt", "int.nonneg_of_pos", "nat.mul_lt_mul_of_pos_left", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "nat.dvd_of_mul_dvd_mul_right", "buffer.lt_aux_3", "norm_num.pos_bit0_helper", "lt_mul_of_gt_one_right", "nat.add_div_right", "nat.mul_lt_mul_of_pos_right", "nonpos_of_mul_nonpos_left", "nat.div_lt_self", "int.bit0_pos", "nat.div2_val", "norm_num.nonzero_of_pos_helper", "nat.mul_div_left", "gt_of_mul_lt_mul_neg_left", "nat.div_eq_of_lt_le", "buffer.append_array", "nat.sub_mul_div", "abs_pos_of_neg", "cmp_compares", "nat.div2_bit", "mul_neg_of_pos_of_neg", "nat.mul_self_lt_mul_self", "nat.div_eq_sub_div", "nat.pow_lt_pow_of_lt_left", "nat.zero_div", "abs_pos_of_pos", "nat.mod_eq_sub_mod", "nat.mul_div_cancel_left", "two_pos", "nat.dvd_of_mul_dvd_mul_left", "lt_add_of_pos_right", "nat.div_self", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "int.ne_neg_of_pos", "nonpos_of_mul_nonpos_right", "nat.mod_two_eq_zero_or_one", "nat.eq_of_mul_eq_mul_left", "nat.pred_inj", "int.coe_succ_pos", "le_imp_le_of_lt_imp_lt", "nonneg_le_nonneg_of_squares_le", "nat.mod_pow_succ", "div_le_of_le_mul", "nat.le_div_iff_mul_le", "nat.div_lt_iff_lt_mul", "le_of_one_le_div", "mul_lt_mul'", "le_or_gt", "pos_and_pos_or_neg_and_neg_of_mul_pos", "four_pos", "div_two_lt_of_pos", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "gt_trans", "nat.succ_pred_eq_of_pos", "nat.mul_div_cancel"]}, {"id": "ordered_ring.to_ordered_semiring", "parentIds": ["le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "mul_lt_mul_of_neg_left", "int.le_of_lt_add_one", "div_lt_of_mul_lt_of_pos", "mul_nonneg_of_nonpos_of_nonpos", "add_midpoint", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "div_le_div_of_mul_sub_mul_div_nonpos", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "two_gt_one", "mul_sub_mul_div_mul_neg", "mul_self_le_mul_self_iff", "int.bit1_pos", "lt_of_one_lt_div", "abs_mul", "mul_le_of_le_div", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "le_mul_of_ge_one_left", "mul_pos_of_neg_of_neg", "mul_lt_of_gt_div_of_neg", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "div_mul_le_div_mul_of_div_le_div_pos'", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "int.bit0_pos", "mul_le_of_div_le_of_neg", "add_self_div_two", "div_lt_div_of_lt_of_pos", "gt_of_mul_lt_mul_neg_left", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "eq_zero_of_mul_self_add_mul_self_eq_zero", "mul_lt_of_lt_div", "div_lt_div_of_pos_of_lt_of_pos", "two_pos", "add_halves", "div_nonneg_of_nonneg_of_pos", "int.lt_add_one_of_le", "mul_self_nonneg", "int.bit0_nonneg", "nonneg_le_nonneg_of_squares_le", "abs_abs_sub_abs_le_abs_sub", "div_le_of_le_mul", "le_of_one_le_div", "div_neg_of_neg_of_pos", "pos_and_pos_or_neg_and_neg_of_mul_pos", "four_pos", "div_two_lt_of_pos", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "mul_le_mul_of_nonneg_right", "parentIds": ["le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_nonpos_of_nonpos_of_nonneg", "one_le_div_of_le", "le_div_of_mul_le", "div_mul_le_div_mul_of_div_le_div_pos", "lt_of_mul_lt_mul_right", "mul_le_of_le_div", "div_mul_le_div_mul_of_div_le_div_pos'", "mul_nonneg", "div_le_of_le_mul", "mul_lt_mul'", "mul_le_mul", "mul_le_mul_of_nonpos_right"]}, {"id": "div_mul_cancel", "parentIds": ["le_mul_of_div_le", "add_div_eq_mul_add_div", "mul_le_of_le_div", "norm_num.div_add_helper", "mul_lt_of_gt_div_of_neg", "mul_le_of_div_le_of_neg", "abs_div", "mul_eq_mul_of_div_eq_div", "mul_lt_of_lt_div", "mul_div_cancel'", "norm_num.div_helper", "norm_num.nonzero_of_div_helper", "eq_div_iff_mul_eq"]}, {"id": "mul_zero_class.to_has_zero", "parentIds": ["le_mul_of_div_le", "div_zero", "ne_zero_of_mul_ne_zero_left", "div_le_div_of_le_of_pos", "one_div_pos_of_pos", "mul_nonpos_of_nonpos_of_nonneg", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "eq_zero_of_zero_dvd", "mul_nonneg_of_nonpos_of_nonpos", "mul_le_mul_of_nonneg_right", "nat.mul_div_assoc", "zero_le_one", "decidable_linear_ordered_semiring", "norm_num.pos_bit1_helper", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "nonneg_of_mul_nonneg_left", "one_div_mul_one_div'", "neg_mul_eq_neg_mul", "mul_div_mul_left'", "nat.mul_div_right", "nat.add_mul_div_left", "one_div_zero", "le_div_of_mul_le", "nat.sub_mul_mod", "mul_zero_lt_mul_inv_of_pos", "ne_zero_of_mul_ne_zero_right", "div_mul_le_div_mul_of_div_le_div_pos", "mul_lt_mul", "two_gt_one", "norm_num.zero_mul", "lt_of_mul_lt_mul_right", "mul_pos", "nat.mul_mod_mul_left", "nat.bodd_mul", "nat.pos_of_dvd_of_pos", "pos_of_mul_pos_right", "zero_div", "ordered_semiring", "norm_num.nonneg_bit1_helper", "abs_mul", "mul_le_of_le_div", "zero_mul", "nat.mul_pred_left", "mul_neg_of_neg_of_pos", "mul_pos_of_neg_of_neg", "one_div_ne_zero", "le_of_mul_le_mul_right", "norm_num.nonneg_bit0_helper", "le_of_mul_le_of_ge_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "neg_of_mul_neg_right", "norm_num.pos_bit0_helper", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_mul_right", "mul_inv'", "norm_num.nonzero_of_pos_helper", "nat.div_eq_of_lt_le", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "zero_gt_neg_one", "nat.sub_mul_div", "div_nonpos_of_nonneg_of_neg", "division_ring.mul_ne_zero", "neg_of_mul_neg_left", "mul_neg_of_pos_of_neg", "nat.mul_self_lt_mul_self", "div_nonneg_of_nonneg_of_pos", "mul_nonpos_of_nonneg_of_nonpos", "div_mul_eq_mul_div_comm", "nat.div_mul_le_self", "mul_self_nonneg", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_zero", "nonpos_of_mul_nonpos_right", "eq_one_div_of_mul_eq_one", "nat.add_mul_mod_self_left", "mul_nonneg", "neg_mul_eq_mul_neg", "mul_lt_mul_of_pos_right", "nat.zero_pow", "abs_abs_sub_abs_le_abs_sub", "mul_zero", "zero_lt_one", "div_le_of_le_mul", "nat.le_div_iff_mul_le", "norm_num.nonzero_of_div_helper", "mul_lt_mul'", "div_mul_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "dvd_zero", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "mul_self_le_mul_self", "mul_le_mul", "nat.dvd_antisymm"]}, {"id": "ordered_semiring.to_semiring", "parentIds": ["le_mul_of_div_le", "div_le_div_of_le_of_pos", "mul_sub_mul_div_mul_nonpos", "nat.semiring", "mul_lt_mul_of_neg_left", "one_div_pos_of_pos", "nat.pow_le_pow_of_le_left", "mul_nonpos_of_nonpos_of_nonneg", "div_lt_of_mul_lt_of_pos", "mul_lt_mul_of_pos_left", "mul_nonneg_of_nonpos_of_nonpos", "mul_le_mul_of_nonneg_right", "add_midpoint", "zero_le_one", "norm_num.pos_bit1_helper", "abs_one_div", "abs_sub_square", "mul_zero_lt_mul_inv_of_neg", "one_le_div_of_le", "nonneg_of_mul_nonneg_left", "lt_div_of_mul_lt", "div_le_of_mul_le_of_neg", "exists_add_lt_and_pos_of_lt", "nat.add_comm_monoid", "div_le_div_of_mul_sub_mul_div_nonpos", "one_lt_div_of_lt", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "nat.bit0_inj", "mul_self_lt_mul_self_iff", "le_mul_of_ge_one_right", "mul_le_mul_of_mul_div_le", "mul_zero_lt_mul_inv_of_pos", "mul_lt_mul_of_neg_right", "one_div_lt_one_div_of_lt_of_neg", "div_mul_le_div_mul_of_div_le_div_pos", "mul_lt_mul", "two_gt_one", "lt_of_mul_lt_mul_right", "mul_pos", "mul_sub_mul_div_mul_neg", "mul_self_le_mul_self_iff", "nat.mul_mod_mul_left", "pos_of_mul_pos_right", "norm_num.nonneg_bit1_helper", "lt_of_one_lt_div", "abs_mul", "mul_le_of_le_div", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "le_mul_of_ge_one_left", "mul_neg_of_neg_of_pos", "mul_pos_of_neg_of_neg", "le_of_mul_le_mul_right", "mul_lt_of_gt_div_of_neg", "norm_num.nonneg_bit0_helper", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "le_of_mul_le_mul_left", "div_mul_le_div_mul_of_div_le_div_pos'", "neg_of_mul_neg_right", "nat.distrib", "norm_num.pos_bit0_helper", "lt_mul_of_gt_one_right", "div_nonpos_of_nonpos_of_pos", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "mul_le_of_div_le_of_neg", "norm_num.nonzero_of_pos_helper", "gt_of_mul_lt_mul_neg_left", "int.nat_abs_bit1_nonneg", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "nat.monoid", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "neg_of_mul_neg_left", "mul_lt_of_lt_div", "mul_neg_of_pos_of_neg", "nat.mul_self_lt_mul_self", "add_halves", "div_nonneg_of_nonneg_of_pos", "mul_nonpos_of_nonneg_of_nonpos", "mul_self_nonneg", "nonpos_of_mul_nonpos_right", "nat.eq_of_mul_eq_mul_left", "mul_nonneg", "mul_lt_mul_of_pos_right", "nonneg_le_nonneg_of_squares_le", "abs_abs_sub_abs_le_abs_sub", "zero_lt_one", "div_le_of_le_mul", "le_of_one_le_div", "mul_lt_mul'", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.div_div_eq_div_mul", "mul_self_le_mul_self", "mul_le_mul", "div_lt_div_of_mul_sub_mul_div_neg", "mul_le_mul_of_nonpos_right"]}, {"id": "int.of_nat_ge_zero", "parentIds": ["int.nat_abs_bit0"]}, {"id": "int.add_monoid", "parentIds": ["int.of_nat_ge_zero", "int.sub_nat_nat_eq_coe", "int.lt_irrefl", "int.add_semigroup", "int.le_antisymm", "int.lt_iff_le_and_ne", "int.mul_pos", "int.eq_coe_of_zero_le", "int.le_refl", "int.mul_nonneg"]}, {"id": "int.has_zero", "parentIds": ["int.of_nat_ge_zero", "int.nat_abs_bit1_nonneg_step", "int.neg_ne_of_pos", "int.zero_ne_neg_of_ne", "int.ne_of_nat_ne_nonneg_case", "int.zero_mul", "int.neg_of_nat_zero", "int.zero_nonneg", "int.zero_ne_one_class", "int.neg_ne_zero_of_ne", "int.add_zero", "int.one_pos", "int.of_nat_zero", "int.nat_abs_add_neg", "int.nat_abs_pos_of_ne_zero", "int.nat_abs_add_nonneg", "int.sign_eq_neg_one_iff_neg", "int.add_left_neg", "int.of_nat_nat_abs_of_nonpos", "int.of_nat_nonneg", "int.coe_nat_zero", "int.of_nat_nat_abs_eq_of_nonneg", "int.lt_irrefl", "int.bit1_pos", "int.le_antisymm", "int.eq_one_of_mul_eq_self_left", "int.sign_eq_one_iff_pos", "int.lt_iff_le_and_ne", "int.zero_lt_one", "int.bit1_nonneg", "int.one_nonneg", "int.eq_neg_succ_of_lt_zero", "int.mul_zero", "int.nonneg_of_pos", "int.sign_zero", "int.zero_add", "int.mul_pos", "int.eq_succ_of_zero_lt", "int.bit0_pos", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "int.eq_coe_of_zero_le", "int.nat_abs_bit1_nonneg", "int.eq_nat_abs_of_zero_le", "int.sign_eq_zero_iff_zero", "int.sign_mul_nat_abs", "int.pos_of_sign_eq_one", "int.neg_succ_lt_zero", "int.neg_of_sign_eq_neg_one", "int.exists_eq_neg_of_nat", "int.nat_abs_of_nonneg", "int.mul_nonneg", "int.eq_one_of_mul_eq_self_right", "int.sign_eq_neg_one_of_neg", "int.ne_neg_of_pos", "int.eq_zero_of_sign_eq_zero", "int.bit0_nonneg", "int.coe_succ_pos", "int.sign_eq_one_of_pos", "nat.can_lift", "int.neg_succ_of_nat_lt_zero", "int.le_nat_abs", "int.eq_zero_of_nat_abs_eq_zero", "int.zero_ne_one", "int.coe_zero_le", "int.nat_abs_zero"]}, {"id": "int.le.intro", "parentIds": ["int.of_nat_ge_zero", "int.lt_add_succ", "int.le_trans", "int.add_le_add_left", "int.coe_nat_le_coe_nat_of_le", "int.le_refl", "int.mul_nonneg", "int.le_of_lt"]}, {"id": "int.coe_nat_eq", "parentIds": ["int.of_nat_ge_zero", "int.lt_add_succ"]}, {"id": "fin.of_nat_zero", "parentIds": []}, {"id": "fin", "parentIds": ["fin.of_nat_zero", "parser.sat", "array.reverse", "d_array.iterate_aux", "fin.has_one", "d_array.read", "unsigned", "fin.vne_of_ne", "unsigned.decidable_eq", "array.decidable_eq", "d_array.beq", "d_array.nil", "array.read_mem", "d_array.of_beq_aux_eq_tt", "fin.mod", "array", "fin.succ", "fin.sub", "fin.has_sub", "buffer.write", "fin.le_def", "array.read_write_of_ne", "list.of_fn", "buffer.iterate", "d_array.map\u2082", "fin.has_lt", "buffer.foreach", "fin.has_le", "fin.mod_def", "array.read", "unsigned.has_to_string", "d_array.rev_iterate", "d_array.read_write", "array.write", "buffer.read_eq_read'", "unsigned.has_repr", "unsigned.to_nat", "fin.mul", "fin.eq_of_veq", "array.write'", "array.read_write", "fin.has_add", "fin.ne_of_vne", "unsigned.of_nat'", "fin.veq_of_eq", "buffer.write_eq_write'", "fin.add_def", "fin.mul_def", "fin.lt", "d_array.of_beq_aux_eq_ff", "d_array.write", "fin.of_nat", "list.of_fn_nth_val", "fin.has_repr", "array.mem", "array.ext'", "array.read'", "fin.decidable_lt", "d_array.map", "d_array.iterate", "list.of_fn_aux", "buffer.rev_iterate", "fin.lt_def", "d_array.decidable_eq", "fin.sub_def", "buffer.read", "fin.div", "mk_buffer", "fin.has_mod", "array.map\u2082", "array.pop_back", "mk_array", "array.read_eq_read'", "d_array.foreach", "d_array.of_beq_eq_tt", "fin.has_mul", "d_array", "array.foreach", "d_array.ext'", "d_array.ext", "fin.decidable_eq", "d_array.rev_iterate_aux", "array.push_back", "array.rev_foldl", "buffer.mem", "fin.add", "fin.decidable_le", "array.iterate", "d_array.of_beq_eq_ff", "fin.has_div", "fin.div_def", "fin.pred", "unsigned.reflect", "array.map", "array.ext", "array.write_eq_write'", "d_array.read_write_of_ne", "array.rev_iterate", "fin.val_zero", "d_array.foldl", "fin.elim0", "fin.has_to_string", "array.nil", "array.slice", "d_array.beq_aux", "array.foldl", "fin.has_zero", "list.to_array", "fin.le"]}, {"id": "fin.of_nat", "parentIds": ["fin.of_nat_zero", "fin.has_one", "unsigned.has_zero", "unsigned.of_nat", "unsigned.has_one"]}, {"id": "fin.has_zero", "parentIds": ["fin.of_nat_zero", "fin.pred", "fin.val_zero"]}, {"id": "vm_core.ret", "parentIds": ["vm_core.monad"]}, {"id": "vm_core", "parentIds": ["vm_core.ret", "vm", "vm_core.map", "vm.trace", "vm_core.monad", "vm_core.bind"]}, {"id": "tactic.trace", "parentIds": ["infer_type_cmd", "to_additive.target_name", "where.trace_namespace", "smt_tactic.trace_state", "where.trace_variables", "old_conv.trace", "smt_tactic.trace", "print_localized_commands", "smt_tactic.interactive.trace", "where.trace_includes", "tactic.trace_result", "tactic.interactive.try_for", "tactic.trace_error", "conv.interactive.trace_lhs", "tactic.explode", "where.trace_opens", "tactic.list_constructors_hole", "tactic.trace_state", "where.trace_end", "print_item_crawl", "tactic.iterate_at_most_on_subgoals", "tactic.interactive.trace", "list_linters", "tactic.interactive.extract_goal"]}, {"id": "trace_fmt", "parentIds": ["tactic.trace", "vm.trace", "tactic.unsafe.type_context.trace"]}, {"id": "lt_of_lt_of_le", "parentIds": ["add_lt_add_of_lt_of_le", "nat.lt_add_left", "d_array.of_beq_aux_eq_tt", "forall_lt_iff_le", "nat.pow_lt_pow_of_lt_right", "gt_of_ge_of_gt", "mul_lt_mul", "nat.mul_mod_mul_left", "nat.zero_mod", "nat.sub_lt_of_pos_le", "d_array.of_beq_aux_eq_ff", "le_of_mul_le_of_ge_one", "nat.sub_one_sub_lt", "nat.mod_add_div", "nat.lt_add_right", "nat.le_div_iff_mul_le"]}, {"id": "add_le_add_left", "parentIds": ["add_lt_add_of_lt_of_le", "max_add_add_left", "le_add_of_nonneg_right", "neg_add_le_of_le_add", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "sub_le_sub_left", "add_le_of_le_neg_add", "lt_of_add_lt_add_left", "add_le_add_right", "neg_le_neg", "add_le_of_le_sub_left", "min_add_add_left", "le_add_of_neg_add_le", "add_le_add", "sub_le_self", "add_lt_add_left", "le_neg_add_of_add_le"]}, {"id": "ordered_cancel_comm_monoid", "parentIds": ["add_lt_add_of_lt_of_le", "le_add_of_nonneg_right", "add_lt_of_lt_of_nonpos", "add_lt_of_le_of_neg", "add_nonpos", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "linear_ordered_semiring", "decidable_linear_ordered_semiring", "lt_add_of_le_of_pos", "le_add_of_le_of_nonneg", "ordered_cancel_comm_monoid.to_add_comm_monoid", "ordered_cancel_comm_monoid.to_add_left_cancel_semigroup", "le_add_of_nonneg_of_le", "add_lt_of_nonpos_of_lt", "lt_add_of_pos_of_le", "lt_of_add_lt_add_right", "add_lt_of_neg_of_lt", "ordered_semiring.to_ordered_cancel_comm_monoid", "lt_of_add_lt_add_left", "add_neg_of_nonpos_of_neg", "add_le_add_right", "lt_add_of_nonneg_of_lt", "ordered_cancel_comm_monoid.to_partial_order", "add_lt_add", "ordered_semiring", "lt_add_of_pos_left", "le_of_add_le_add_left", "add_neg_of_neg_of_nonpos", "add_le_of_nonpos_of_le", "add_neg", "add_pos_of_nonneg_of_pos", "add_le_add_left", "add_pos", "add_nonneg", "lt_add_of_pos_of_lt", "add_lt_add_of_le_of_lt", "add_lt_add_right", "decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid", "add_le_add", "lt_add_of_pos_right", "lt_add_of_lt_of_pos", "add_pos_of_pos_of_nonneg", "add_lt_add_left", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "add_lt_of_lt_of_neg", "ordered_comm_group.to_ordered_cancel_comm_monoid", "le_add_of_nonneg_left", "le_of_add_le_add_right", "ordered_cancel_comm_monoid.to_add_right_cancel_semigroup", "add_le_of_le_of_nonpos"]}, {"id": "rbmap.fold", "parentIds": []}, {"id": "rbtree.fold", "parentIds": ["rbmap.fold"]}, {"id": "true_and", "parentIds": ["and_eq_of_eq_true_left", "if_false_left_eq_and", "if_false_right_eq_and", "and.congr_right_iff"]}, {"id": "and_iff_right", "parentIds": ["true_and"]}, {"id": "bool.bor_inl", "parentIds": []}, {"id": "true_or", "parentIds": ["bool.bor_inl", "imp_or_distrib'", "if_true_right_eq_or", "if_true_left_eq_or", "prod.lex_def", "or_eq_of_eq_true_left"]}, {"id": "bor", "parentIds": ["bool.bor_inl", "nat.test_bit_lor", "bor_ff", "nat.lor_bit", "bor_eq_false_eq_eq_ff_and_eq_ff", "bor_coe_iff", "tactic.has_opt_auto_param", "bor_self", "tactic.try_apply_opt_auto_param", "tactic.has_opt_auto_param_for_apply", "ff_bor", "nat.lor", "bool.bor_assoc", "tt_bor", "bor_tt", "bool.bor_inr", "bool.bor_left_comm", "bool.to_bool_or", "bool.bor_comm", "list.any", "bor_eq_true_eq_eq_tt_or_eq_tt"]}, {"id": "has_coe_to_sort", "parentIds": ["bool.bor_inl", "coe_sort_coe_base", "coe_sort_bool", "bool.coe_sort_ff", "string.iterator.zero_lt_length_next_to_string_of_has_next", "coe_sort_coe_trans", "bool.coe_sort_tt", "coe_sort_trans", "coe_sort_tt", "bool.bor_inr", "coe_sort", "coe_sort_ff", "bool.to_bool_eq"]}, {"id": "bor_coe_iff", "parentIds": ["bool.bor_inl", "bool.bor_inr"]}, {"id": "int.lt_of_add_one_le", "parentIds": []}, {"id": "environment.is_prefix_of_file", "parentIds": ["tactic.is_in_mathlib", "lint_mathlib"]}, {"id": "environment.decl_olean", "parentIds": ["environment.is_prefix_of_file", "environment.in_current_file", "print_item_crawl", "fold_over_with_cond_sorted", "tactic.get_mathlib_dir", "tactic.find_private_decl", "tactic.module_doc_strings"]}, {"id": "string.is_prefix_of", "parentIds": ["environment.is_prefix_of_file"]}, {"id": "option.get_or_else", "parentIds": ["environment.is_prefix_of_file", "tactic.mk_simp_attribute_cmd", "tactic.interactive.by_cases", "tactic.interactive.induction", "to_additive.proceed_fields", "to_additive.guess_name", "smt_tactic.interactive.have", "to_additive.parser", "tactic.interactive.let", "tactic.interactive.squeeze_simpa", "tactic.rcases_parse_depth", "tactic.rcases_parse", "smt_tactic.interactive.let", "tactic.interactive.obtain", "print_item_crawl", "tactic.alias.alias_cmd", "native.rb_map.zfind", "tactic.interactive.replace", "tactic.interactive.extract_goal", "tactic.interactive.have", "tactic.interactive.case", "native.rb_map.find_def", "tactic.rename'", "tactic.interactive.suggest"]}, {"id": "div_zero", "parentIds": ["one_div_mul_one_div'", "mul_div_mul_left'", "div_mul_right", "one_div_neg_eq_neg_one_div", "abs_div", "one_div_div", "one_div_one_div", "pos_of_one_div_pos", "neg_div_neg_eq", "div_mul_eq_mul_div_comm", "eq_of_one_div_eq_one_div", "div_mul_div"]}, {"id": "discrete_field.to_integral_domain", "parentIds": ["div_zero", "one_div_mul_one_div'", "div_div_eq_div_mul", "mul_div_mul_left'", "one_div_mul_one_div", "one_div_zero", "div_helper", "div_mul_left", "ne_zero_of_one_div_ne_zero", "div_mul_le_div_mul_of_div_le_div_pos'", "div_mul_right", "inv_zero", "mul_inv'", "one_div_neg_eq_neg_one_div", "abs_div", "div_mul_eq_div_mul_one_div", "div_div_eq_mul_div", "one_div_div", "mul_div_mul_right'", "one_div_one_div", "pos_of_one_div_pos", "neg_div_neg_eq", "div_mul_eq_mul_div_comm", "div_div_div_div_eq", "eq_of_one_div_eq_one_div", "neg_of_one_div_neg", "eq_zero_of_one_div_eq_zero", "div_mul_div"]}, {"id": "div_eq_mul_one_div", "parentIds": ["div_zero", "div_le_div_of_le_of_pos", "div_pos_of_neg_of_neg", "div_lt_of_mul_lt_of_pos", "div_nonneg_of_nonpos_of_neg", "one_le_div_of_le", "lt_div_of_mul_lt", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "field.div_mul_eq_div_mul_one_div", "div_div_eq_div_mul", "one_lt_div_of_lt", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le", "one_div_lt_one_div_of_lt_of_neg", "div_lt_div_of_lt_of_neg", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "div_lt_div_of_lt_of_pos", "div_mul_eq_div_mul_one_div", "one_div_lt_one_div_of_lt", "div_nonpos_of_nonneg_of_neg", "div_div_eq_mul_div", "div_lt_div_of_pos_of_lt_of_pos", "field.div_div_eq_mul_div", "div_nonneg_of_nonneg_of_pos", "field.div_div_eq_div_mul", "div_le_of_le_mul", "div_neg_of_neg_of_pos"]}, {"id": "discrete_field.to_field", "parentIds": ["div_zero", "one_div_mul_one_div'", "div_div_eq_div_mul", "mul_div_mul_left'", "one_div_mul_one_div", "one_div_zero", "div_helper", "div_mul_left", "ne_zero_of_one_div_ne_zero", "div_mul_le_div_mul_of_div_le_div_pos'", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_mul_right", "inv_zero", "mul_inv'", "one_div_neg_eq_neg_one_div", "abs_div", "div_mul_eq_div_mul_one_div", "div_div_eq_mul_div", "one_div_div", "mul_div_mul_right'", "one_div_one_div", "neg_div_neg_eq", "div_mul_eq_mul_div_comm", "div_div_div_div_eq", "eq_of_one_div_eq_one_div", "neg_of_one_div_neg", "eq_zero_of_one_div_eq_zero", "div_mul_div"]}, {"id": "one_div_zero", "parentIds": ["div_zero", "ne_zero_of_one_div_ne_zero"]}, {"id": "mul_zero", "parentIds": ["div_zero", "ne_zero_of_mul_ne_zero_left", "nat.mul_div_assoc", "mul_zero_lt_mul_inv_of_neg", "one_div_mul_one_div'", "mul_div_mul_left'", "nat.mul_div_right", "nat.add_mul_div_left", "one_div_zero", "nat.sub_mul_mod", "mul_zero_lt_mul_inv_of_pos", "nat.mul_mod_mul_left", "nat.bodd_mul", "one_div_ne_zero", "mul_eq_zero_iff_eq_zero_or_eq_zero", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_mul_right", "mul_inv'", "nat.div_eq_of_lt_le", "nat.sub_mul_div", "mul_neg_of_pos_of_neg", "nat.mod_add_div", "mul_nonpos_of_nonneg_of_nonpos", "div_mul_eq_mul_div_comm", "nat.div_mul_le_self", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_zero", "nat.add_mul_mod_self_left", "neg_mul_eq_mul_neg", "nat.zero_pow", "div_mul_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "dvd_zero", "nat.div_div_eq_div_mul"]}, {"id": "no_zero_divisors.to_has_zero", "parentIds": ["div_zero", "eq_zero_or_eq_zero_of_mul_eq_zero", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "one_div_mul_one_div'", "mul_div_mul_left'", "one_div_zero", "mul_ne_zero", "eq_zero_of_mul_self_eq_zero", "div_helper", "div_mul_left", "ne_zero_of_one_div_ne_zero", "mul_eq_zero_iff_eq_zero_or_eq_zero", "div_mul_le_div_mul_of_div_le_div_pos'", "div_mul_right", "inv_zero", "mul_inv'", "one_div_neg_eq_neg_one_div", "abs_div", "eq_zero_of_mul_self_add_mul_self_eq_zero", "one_div_div", "mul_div_mul_right'", "eq_of_mul_eq_mul_left", "one_div_one_div", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "pos_of_one_div_pos", "neg_div_neg_eq", "div_mul_eq_mul_div_comm", "eq_of_one_div_eq_one_div", "neg_of_one_div_neg", "eq_zero_of_one_div_eq_zero", "div_mul_div"]}, {"id": "integral_domain.to_no_zero_divisors", "parentIds": ["div_zero", "abs_mul_abs_self", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "abs_sub_square", "one_div_mul_one_div'", "div_div_eq_div_mul", "mul_div_mul_left'", "one_div_mul_one_div", "one_div_zero", "mul_ne_zero", "div_helper", "div_mul_left", "int.eq_one_of_mul_eq_self_left", "abs_mul", "ne_zero_of_one_div_ne_zero", "mul_eq_zero_iff_eq_zero_or_eq_zero", "div_mul_le_div_mul_of_div_le_div_pos'", "div_mul_right", "inv_zero", "mul_inv'", "one_div_neg_eq_neg_one_div", "abs_div", "div_mul_eq_div_mul_one_div", "div_div_eq_mul_div", "eq_zero_of_mul_self_add_mul_self_eq_zero", "one_div_div", "mul_div_mul_right'", "eq_of_mul_eq_mul_left", "one_div_one_div", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "pos_of_one_div_pos", "neg_div_neg_eq", "div_mul_eq_mul_div_comm", "div_div_div_div_eq", "int.eq_one_of_mul_eq_self_right", "eq_of_one_div_eq_one_div", "neg_of_one_div_neg", "abs_abs_sub_abs_le_abs_sub", "eq_zero_of_one_div_eq_zero", "div_mul_div", "mul_self_eq_one_iff", "abs_mul_self"]}, {"id": "discrete_field", "parentIds": ["div_zero", "one_div_mul_one_div'", "div_div_eq_div_mul", "mul_div_mul_left'", "one_div_mul_one_div", "one_div_zero", "discrete_field.to_integral_domain", "div_helper", "div_mul_left", "ne_zero_of_one_div_ne_zero", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_mul_right", "inv_zero", "mul_inv'", "one_div_neg_eq_neg_one_div", "abs_div", "div_mul_eq_div_mul_one_div", "div_div_eq_mul_div", "discrete_linear_ordered_field.to_discrete_field", "one_div_div", "mul_div_mul_right'", "discrete_field.to_field", "one_div_one_div", "neg_div_neg_eq", "div_mul_eq_mul_div_comm", "div_div_div_div_eq", "eq_of_one_div_eq_one_div", "eq_zero_of_one_div_eq_zero", "div_mul_div"]}, {"id": "nat.lt_add_left", "parentIds": []}, {"id": "nat.le_add_left", "parentIds": ["nat.lt_add_left", "nat.div_le_of_le_mul", "nat.add_mod_right", "nat.add_div_right"]}, {"id": "nat.ordered_semiring", "parentIds": ["nat.lt_add_left", "nat.div_eq_of_lt", "nat.pow_le_pow_of_le_left", "d_array.of_beq_aux_eq_tt", "nat.sub_le_sub_left", "list.length_le_of_sublist", "nat.pow_lt_pow_of_lt_right", "nat.le_mul_self", "nat.pow_le_pow_of_le_right", "nat.mod_eq_of_lt", "nat.mul_self_le_mul_self_iff", "nat.div_le_of_le_mul", "nat.sub_pos_of_lt", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "nat.mod_le", "nat.pos_of_dvd_of_pos", "nat.zero_mod", "nat.sub_lt_of_pos_le", "d_array.of_beq_aux_eq_ff", "nat.eq_one_of_dvd_one", "nat.sub_one_sub_lt", "buffer.lt_aux_3", "nat.div_lt_self", "nat.mod_zero", "nat.mul_self_le_mul_self", "nat.div_eq_of_lt_le", "nat.sub_mul_div", "nat.mod_self", "nat.strong_rec_on", "nat.le_of_sub_eq_zero", "nat.mul_self_lt_mul_self", "buffer.lt_aux_1", "nat.pow_lt_pow_of_lt_left", "nat.zero_div", "nat.mod_add_div", "d_array.of_beq_eq_tt", "nat.div_mul_le_self", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "nat.pred_inj", "nat.lt_add_right", "nat.le_div_iff_mul_le", "list.length_remove_nth", "nat.div_zero", "nat.div_div_eq_div_mul", "nat.succ_pred_eq_of_pos", "nat.dvd_antisymm"]}, {"id": "ordered_semiring.to_ordered_cancel_comm_monoid", "parentIds": ["nat.lt_add_left", "nat.div_eq_of_lt", "nat.pow_le_pow_of_le_left", "int.le_of_lt_add_one", "mul_nonpos_of_nonpos_of_nonneg", "div_lt_of_mul_lt_of_pos", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "mul_le_mul_of_nonneg_right", "zero_le_one", "decidable_linear_ordered_semiring", "d_array.of_beq_aux_eq_tt", "norm_num.pos_bit1_helper", "nat.sub_le_sub_left", "list.length_le_of_sublist", "one_le_div_of_le", "nonneg_of_mul_nonneg_left", "lt_div_of_mul_lt", "nat.pow_lt_pow_of_lt_right", "exists_add_lt_and_pos_of_lt", "nat.bit1_lt", "nat.le_mul_self", "div_le_div_of_mul_sub_mul_div_nonpos", "one_lt_div_of_lt", "le_div_of_mul_le", "nat.pow_le_pow_of_le_right", "nat.mod_eq_of_lt", "nat.mul_self_le_mul_self_iff", "mul_lt_mul", "two_gt_one", "lt_of_mul_lt_mul_right", "mul_pos", "nat.div_le_of_le_mul", "nat.sub_pos_of_lt", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "int.bit1_pos", "nat.mod_le", "nat.pos_of_dvd_of_pos", "pos_of_mul_pos_right", "norm_num.nonneg_bit1_helper", "nat.zero_mod", "nat.sub_lt_of_pos_le", "mul_neg_of_neg_of_pos", "le_of_mul_le_mul_right", "d_array.of_beq_aux_eq_ff", "norm_num.nonneg_bit0_helper", "nat.eq_one_of_dvd_one", "nonneg_of_mul_nonneg_right", "mul_le_mul_of_nonneg_left", "le_of_mul_le_mul_left", "nat.sub_one_sub_lt", "neg_of_mul_neg_right", "buffer.lt_aux_3", "norm_num.pos_bit0_helper", "nonpos_of_mul_nonpos_left", "mul_self_lt_mul_self", "nat.div_lt_self", "int.bit0_pos", "nat.mod_zero", "add_self_div_two", "norm_num.nonzero_of_pos_helper", "nat.bit0_lt", "nat.div_eq_of_lt_le", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "nat.sub_mul_div", "nat.mod_self", "nat.strong_rec_on", "neg_of_mul_neg_left", "eq_zero_of_mul_self_add_mul_self_eq_zero", "nat.bit0_lt_bit1", "nat.le_of_sub_eq_zero", "mul_neg_of_pos_of_neg", "nat.mul_self_lt_mul_self", "buffer.lt_aux_1", "nat.pow_lt_pow_of_lt_left", "nat.zero_div", "nat.mod_add_div", "d_array.of_beq_eq_tt", "two_pos", "mul_nonpos_of_nonneg_of_nonpos", "nat.div_mul_le_self", "int.lt_add_one_of_le", "nat.le_of_dvd", "d_array.of_beq_eq_ff", "nonpos_of_mul_nonpos_right", "int.bit0_nonneg", "nat.eq_of_mul_eq_mul_left", "nat.pred_inj", "mul_nonneg", "nat.lt_add_right", "mul_lt_mul_of_pos_right", "nonneg_le_nonneg_of_squares_le", "abs_abs_sub_abs_le_abs_sub", "zero_lt_one", "div_le_of_le_mul", "nat.le_div_iff_mul_le", "list.length_remove_nth", "mul_lt_mul'", "nat.bit1_lt_bit0", "nat.div_zero", "four_pos", "div_two_lt_of_pos", "nat.div_div_eq_div_mul", "mul_self_le_mul_self", "nat.succ_pred_eq_of_pos", "mul_le_mul", "nat.dvd_antisymm", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "conv.execute", "parentIds": []}, {"id": "conv", "parentIds": ["conv.execute", "conv.monad", "conv.interactive.itactic", "conv.interactive.conv", "conv.lhs", "conv.alternative", "conv.monad_fail", "conv.interactive.skip", "conv.update_lhs", "conv.funext", "conv.interactive.done", "conv.dsimp", "conv.interactive.trace_lhs", "conv.whnf", "conv.interactive.rw", "conv.solve1", "conv.skip", "conv.interactive.change", "conv.interactive.find", "conv.interactive.whnf", "conv.replace_lhs", "tactic.interactive.conv", "tactic.interactive.conv_rhs", "conv.interactive.erw", "conv.change", "conv.interactive.for", "conv.interactive.rewrite", "conv.interactive.simp", "conv.interactive.congr", "conv.step", "conv.istep", "conv.save_info", "conv.congr", "conv.rhs", "conv.interactive.to_lhs", "conv.convert", "conv.interactive.to_rhs", "conv.interactive.dsimp", "tactic.interactive.conv_lhs", "conv.discharge_eq_lhs", "conv.interactive.funext"]}, {"id": "user_attribute.set_untyped", "parentIds": ["user_attribute.set"]}, {"id": "user_attribute", "parentIds": ["user_attribute.set_untyped", "extensional_attribute", "user_attribute.get_param_untyped", "simp_attr.pre_smt", "localized_attr", "tactic.mk_simp_attr", "user_attribute.parse_reflect", "ematch_lhs", "nolint_attr", "tactic.alias.alias_attr", "can_lift_attr", "no_rsimp", "mk_hinst_lemma_attr_from_simp_attr", "rsimp_attr", "linter_attr", "simps_attr", "ematch", "library_note_attr", "tactic.higher_order_attr", "simp_attr.functor_norm", "simp_attr.norm", "user_attribute.get_cache", "tactic.ancestor_attr", "to_additive.aux_attr", "user_attribute.set", "simp_attr.split_if_reduction", "tactic.def_replacer", "debugger.attr", "derive_handler_attr", "mk_hinst_lemma_attr_set", "to_additive.attr", "tactic.replaceable_attr", "mk_name_set_attr", "mk_hinst_lemma_attr_core", "tactic.replacer_attr", "user_attribute.get_param", "derive_attr"]}, {"id": "not_and_distrib'", "parentIds": []}, {"id": "not_and_of_not_or_not", "parentIds": ["not_and_distrib'", "not_and_distrib"]}, {"id": "parser.sat", "parentIds": ["parser.one_of", "parser.ch", "tactic.alias.make_left_right"]}, {"id": "buffer.size", "parentIds": ["parser.sat", "buffer.take", "parser.foldl", "buffer.write", "buffer.to_array", "buffer.iterate", "buffer.foreach", "parser.foldr", "buffer.read_eq_read'", "buffer.drop", "buffer.reverse", "buffer.take_right", "buffer.write_eq_write'", "buffer.rev_iterate", "buffer.to_list", "buffer.read", "parser.remaining", "parser.fix", "buffer.to_string", "buffer.mem"]}, {"id": "char_buffer", "parentIds": ["parser.sat", "parser.pure", "string.to_char_buffer", "parser.foldl", "parser.orelse", "parser.bind", "parser.mk_error_msg", "parser.foldr", "parser.fail", "parser.decorate_errors", "parser.run", "parser.remaining", "parser.fix", "parser.failure", "parser.char_buf", "parser", "tactic.alias.make_left_right"]}, {"id": "parse_result", "parentIds": ["parser.sat", "parser.pure", "parser.fail", "parser.remaining", "parser.failure", "parser"]}, {"id": "parser", "parentIds": ["parser.sat", "parser.eof", "parser.one_of'", "parser.pure", "parser.run_string", "parser.foldl", "parser.many'", "parser.alternative", "parser.sep_by1", "parser.inhabited", "parser.orelse", "parser.many", "parser.bind", "parser.foldr", "parser.foldl_core", "parser.is_lawful_monad", "parser.monad", "parser.many1", "parser.fail", "parser.fix_core", "parser.eps", "parser.one_of", "parser.many_char1", "parser.sep_by", "parser.monad_fail", "parser.decorate_errors", "parser.run", "parser.ch", "parser.remaining", "parser.fix", "parser.failure", "parser.str", "parser.many_char", "parser.foldr_core", "parser.char_buf", "parser.decorate_error"]}, {"id": "buffer.read", "parentIds": ["parser.sat", "buffer.read_eq_read'", "buffer.mem"]}, {"id": "dlist.empty", "parentIds": ["parser.sat", "dlist.to_list_empty", "parser.failure"]}, {"id": "option.has_sizeof", "parentIds": []}, {"id": "has_sizeof", "parentIds": ["option.has_sizeof", "list.has_sizeof", "sizeof", "punit.has_sizeof", "sigma.has_sizeof", "sizeof_measure", "string.has_sizeof", "char.has_sizeof", "nat.has_sizeof", "prod.has_sizeof", "subtype.has_sizeof", "has_well_founded_of_has_sizeof", "psum.has_sizeof", "sizeof_measure_wf", "default_has_sizeof", "sum.has_sizeof", "psigma.has_sizeof", "bool.has_sizeof"]}, {"id": "eq_zero_or_eq_zero_of_mul_eq_zero", "parentIds": ["eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "mul_ne_zero", "eq_zero_of_mul_self_eq_zero", "mul_eq_zero_iff_eq_zero_or_eq_zero", "eq_of_mul_eq_mul_left", "mul_self_eq_mul_self_iff"]}, {"id": "no_zero_divisors", "parentIds": ["eq_zero_or_eq_zero_of_mul_eq_zero", "eq_zero_of_mul_self_eq_zero", "integral_domain.to_no_zero_divisors", "no_zero_divisors.to_has_mul", "no_zero_divisors.to_has_zero"]}, {"id": "no_zero_divisors.to_has_mul", "parentIds": ["eq_zero_or_eq_zero_of_mul_eq_zero", "abs_mul_abs_self", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "abs_sub_square", "one_div_mul_one_div'", "div_div_eq_div_mul", "mul_div_mul_left'", "one_div_mul_one_div", "one_div_zero", "mul_ne_zero", "eq_zero_of_mul_self_eq_zero", "div_helper", "div_mul_left", "int.eq_one_of_mul_eq_self_left", "abs_mul", "mul_eq_zero_iff_eq_zero_or_eq_zero", "div_mul_le_div_mul_of_div_le_div_pos'", "div_mul_right", "mul_inv'", "abs_div", "div_mul_eq_div_mul_one_div", "div_div_eq_mul_div", "eq_zero_of_mul_self_add_mul_self_eq_zero", "mul_div_mul_right'", "eq_of_mul_eq_mul_left", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "div_mul_eq_mul_div_comm", "div_div_div_div_eq", "int.eq_one_of_mul_eq_self_right", "abs_abs_sub_abs_le_abs_sub", "div_mul_div", "mul_self_eq_one_iff", "abs_mul_self"]}, {"id": "classical.not_exists_not", "parentIds": []}, {"id": "not_exists_not", "parentIds": ["classical.not_exists_not"]}, {"id": "classical.prop_decidable", "parentIds": ["classical.not_exists_not", "classical.forall_or_distrib", "classical.by_cases", "classical.by_contradiction", "function.inv_fun_on_neg", "classical.type_decidable", "classical.or_iff_not_imp_left", "classical.decidable_inhabited", "function.inv_fun_on", "function.inv_fun_on_pos", "classical.dec_rel", "push_neg.not_and_eq", "classical.dec_eq", "classical.not_ball", "classical.exists_cases", "function.partial_inv", "classical.dec_pred", "classical.not_forall", "push_neg.not_forall_eq", "classical.strong_indefinite_description", "classical.or_iff_not_imp_right", "push_neg.classical.implies_iff_not_or", "push_neg.not_implies_eq", "classical.forall_or_distrib_left", "classical.not_and_distrib", "classical.forall_or_distrib_right", "classical.imp_iff_not_or", "classical.iff_iff_not_or_and_or_not", "push_neg.not_not_eq", "classical.dec", "classical.not_imp_not", "function.partial_inv_of_injective", "classical.type_decidable_eq", "classical.not_not"]}, {"id": "declaration.is_theorem", "parentIds": ["incorrect_def_lemma"]}, {"id": "declaration", "parentIds": ["declaration.is_theorem", "tactic.mk_const", "tactic.delta", "print_content", "print_decls_sorted", "environment.mfold", "unused_arguments", "mk_definition", "declaration.type", "transport_multiplicative_to_additive", "restate_axiom", "environment.fold", "incorrect_def_lemma", "restate_axiom_cmd", "environment.is_definition", "tactic.mk_simp_attr", "print_decls", "declaration.to_name", "tactic.instance_cache.mk_app", "simps_add_projection", "where.get_def_variables", "localized_cmd", "tactic.extract_def", "simps_tac", "tactic.constr_to_prop", "declaration.value_task", "declaration.update_value_task", "environment.decl_filter_map", "lint", "tactic.mk_iff_of_inductive_prop", "tactic.constructor_num_fields", "declaration.is_definition", "mk_hinst_lemma_attr_from_simp_attr", "copy_decl_updating_type", "print_decls_sorted_mathlib", "doc_blame_report_defn", "declaration.to_definition", "declaration.update_name", "to_additive.map_namespace", "vm_obj.to_declaration", "print_all_content", "declaration.in_current_file", "tactic.explode", "tactic.mk_theorem", "declaration.instantiate_value_univ_params", "find_cmd", "declaration.map_value", "declaration.update_value", "tactic.decl_mk_const", "declaration.is_axiom", "declaration.value", "environment.contains", "check_unused_arguments", "environment.get_trusted_decls", "print_item_crawl", "declaration.is_constant", "tactic.alias.alias_cmd", "tactic.alias.alias_direct", "copy_decl_using", "fold_over_with_cond", "linter", "environment.get", "tactic.suggest.process_declaration", "declaration.update_with_fun", "tactic.mk_constructor_fresh_names", "list_linters", "lint_aux", "declaration.is_auto_generated", "tactic.get_decl", "declaration.univ_levels", "linter.doc_blame", "declaration.get_kind_string", "tactic.alias.alias_iff", "tactic.prove_goal_async", "environment.add", "fold_over_with_cond_sorted", "impossible_instance", "incorrect_type_class_argument", "tactic.add_decl", "tactic.alias.get_alias_target", "tactic.add_meta_definition", "mk_hinst_lemma_attr_set", "environment.get_decls", "instance_priority", "instance_derive_handler", "declaration.is_trusted", "environment.mfilter", "tactic.is_prop_decl", "tactic.local_decls", "tactic.delta_instance", "tactic.suggest.decl_data", "tactic.replaceable_attr", "tactic.suggest.application", "where.get_all_in_namespace", "dangerous_instance", "mk_hinst_lemma_attr_core", "declaration.update_type", "tactic.find_private_decl", "doc_blame_report_thm", "tactic.replacer_attr", "derive_struct_ext_lemma", "environment.decl_map", "lint_mathlib", "ge_or_gt_in_statement", "lint_all", "declaration.instantiate_type_univ_params", "has_inhabited_instance", "tactic.import_private_cmd", "dup_namespace", "print_name", "tactic.module_doc_strings", "declaration.univ_params"]}, {"id": "reducibility_hints", "parentIds": ["declaration.is_theorem", "mk_definition", "declaration.type", "restate_axiom", "reducibility_hints.inhabited", "environment.is_definition", "tactic.mk_simp_attr", "declaration.to_name", "localized_cmd", "tactic.extract_def", "declaration.value_task", "declaration.update_value_task", "declaration.is_definition", "mk_hinst_lemma_attr_from_simp_attr", "doc_blame_report_defn", "declaration.to_definition", "declaration.update_name", "tactic.explode", "find_cmd", "declaration.map_value", "declaration.update_value", "declaration.is_axiom", "declaration.value", "declaration.is_constant", "tactic.alias.alias_direct", "declaration.get_kind_string", "tactic.add_meta_definition", "mk_hinst_lemma_attr_set", "instance_derive_handler", "declaration.is_trusted", "declaration", "mk_hinst_lemma_attr_core", "declaration.update_type", "doc_blame_report_thm", "tactic.import_private_cmd", "declaration.univ_params"]}, {"id": "task", "parentIds": ["declaration.is_theorem", "declaration.type", "restate_axiom", "task.bind", "environment.is_definition", "declaration.to_name", "simps_add_projection", "task.monad", "declaration.value_task", "declaration.update_value_task", "declaration.is_definition", "doc_blame_report_defn", "declaration.to_definition", "declaration.update_name", "to_additive.map_namespace", "tactic.explode", "task.flatten", "find_cmd", "declaration.map_value", "declaration.update_value", "declaration.is_axiom", "task.pure", "declaration.value", "declaration.is_constant", "tactic.alias.alias_direct", "task.get", "declaration.get_kind_string", "tactic.prove_goal_async", "declaration.is_trusted", "declaration", "task.delay", "declaration.update_type", "doc_blame_report_thm", "task.map", "derive_struct_ext_lemma", "tactic.run_async", "declaration.univ_params"]}, {"id": "tactic.mk_const", "parentIds": ["tactic.save_const_type_info", "tactic.existsi", "tactic.mk_assumption_set", "tactic.get_library_notes", "tactic.symmetry_hyp", "localized_attr", "tactic.left", "tactic.interactive.have_field", "can_lift_attr", "tactic.i_to_expr_for_apply", "tactic.constructor_idx", "tactic.classical", "tactic.right", "tactic.mk_patterns", "tactic.subobject_names", "linter_attr", "tactic.list_constructors_hole", "print_item_crawl", "tactic.fsplit", "get_linters", "tactic.injection_with", "tactic.split", "tactic.eapplyc", "tactic.applyc", "tactic.triv", "saturate_fun", "tactic.triv'"]}, {"id": "exceptional", "parentIds": ["tactic.mk_const", "environment.add_ginductive", "tactic.delta", "exceptional.to_bool", "exceptional.to_option", "environment.is_definition", "environment.add_inductive", "simps_tac", "exceptional.has_to_string", "tactic.updateex_env", "tactic.constructor_num_fields", "copy_decl_updating_type", "exceptional.return", "exceptional.to_string", "exceptional.fail", "environment.contains", "copy_decl_using", "environment.get", "exceptional.monad", "tactic.get_decl", "tactic.ex_to_tac", "environment.add", "tactic.returnex", "exceptional.bind", "tactic.is_prop_decl", "environment.add_defn_eqns", "print_name"]}, {"id": "declaration.univ_params", "parentIds": ["tactic.mk_const", "simps_tac", "tactic.mk_iff_of_inductive_prop", "copy_decl_updating_type", "tactic.decl_mk_const", "declaration.univ_levels", "tactic.alias.alias_iff", "instance_derive_handler", "derive_struct_ext_lemma", "tactic.import_private_cmd"]}, {"id": "tactic.ex_to_tac", "parentIds": ["tactic.mk_const", "tactic.delta", "simps_tac", "tactic.constructor_num_fields", "copy_decl_updating_type", "copy_decl_using", "tactic.get_decl", "tactic.is_prop_decl", "print_name"]}, {"id": "list.length", "parentIds": ["tactic.mk_const", "param_info.to_format", "list.length_cons", "list.length_take_le", "where.mk_flag", "list.length_le_of_sublist", "list.length_append", "string.iterator.length_next_to_string_next", "list.length_drop", "list.ne_nil_of_length_eq_succ", "list.length_map", "tactic.constr_to_prop", "list.rotate", "cc_state.eqc_size", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.interactive.simp_core_aux", "string.iterator.zero_lt_length_next_to_string_of_has_next", "tactic.mk_inhabited_instance", "list.qsort_cons", "list.length_take", "list.nth_le", "list.qsort", "list.length_tail", "tactic.relation_lhs_rhs", "list.length_map_accumr", "lint_aux", "list.qsort.F", "tactic.interactive.refine_one", "expr.is_eta_expansion", "list.length_map\u2082", "list.length_map_accumr\u2082", "instance_priority", "list.qsort_nil", "conv.congr", "tactic.interactive.case", "list.length_repeat", "list.length_remove_nth", "tactic.interactive.suggest", "derive_struct_ext_lemma", "tactic.num_goals", "smt_tactic.num_goals", "list.to_array", "list.eq_nil_of_length_eq_zero"]}, {"id": "environment.get", "parentIds": ["tactic.mk_const", "tactic.delta", "transport_multiplicative_to_additive", "environment.is_definition", "simps_tac", "tactic.constructor_num_fields", "copy_decl_updating_type", "environment.contains", "copy_decl_using", "tactic.get_decl", "tactic.is_prop_decl", "print_name"]}, {"id": "tactic.get_env", "parentIds": ["tactic.mk_const", "tactic.delta", "print_content", "tactic.mk_has_sizeof_instance_core", "tactic.get_constructors_for", "transport_multiplicative_to_additive", "tactic.get_unused_decl_name", "tactic.is_in_mathlib", "tactic.interactive.induction", "tactic.symmetry_hyp", "tactic.mk_dec_eq_instance", "localized_cmd", "simps_tac", "tactic.constr_to_prop", "lint", "tactic.instance_stub", "tactic.in_open_namespaces", "tactic.updateex_env", "tactic.mk_iff_of_inductive_prop", "tactic.constructor_num_fields", "copy_decl_updating_type", "tactic.mk_patterns", "print_all_content", "declaration.in_current_file", "tactic.mk_inhabited_instance", "tactic.subobject_names", "tactic.mk_dec_eq_instance_core", "tactic.mk_constructors_arg_names", "find_cmd", "tactic.list_constructors_hole", "tactic.mk_has_reflect_instance", "tactic.relation_lhs_rhs", "copy_decl_using", "tactic.match_refl_app", "tactic.injection_with", "list_linters", "tactic.prove_goal_async", "fold_over_with_cond_sorted", "expr.is_eta_expansion", "tactic.new_aux_decl_name", "tactic.mk_constructors_fresh_names", "instance_derive_handler", "tactic.get_mathlib_dir", "tactic.is_prop_decl", "tactic.local_decls", "tactic.delta_instance", "tactic.interactive.case", "where.get_all_in_namespace", "tactic.find_private_decl", "tactic.suggest.library_defs", "derive_struct_ext_lemma", "lint_mathlib", "lint_all", "tactic.ids_to_simp_arg_list", "print_name", "tactic.module_doc_strings"]}, {"id": "tactic.mk_num_meta_univs", "parentIds": ["tactic.mk_const"]}, {"id": "list.ball_nil", "parentIds": []}, {"id": "false.elim", "parentIds": ["list.ball_nil", "imp_or_distrib'", "and_not_self_iff", "list.nil_subset", "sum.elim_injective", "imp_eq_of_eq_false_left", "not_and_self_iff", "ordering.compares.eq_lt", "to_bool_false_eq_ff", "ordering.compares.eq_gt", "to_bool_true_eq_tt", "false_implies_iff", "true_eq_false_of_false", "eq_false_of_or_eq_false_right", "ne_self_iff_false", "or_false", "decidable.not_or_iff_and_not", "eq_false_of_or_eq_false_left", "eq_zero_of_one_div_eq_zero", "exists_pempty", "ordering.compares.eq_eq"]}, {"id": "array.reverse", "parentIds": ["buffer.reverse"]}, {"id": "array", "parentIds": ["array.reverse", "array.has_to_format", "array.to_list", "array.take", "array.decidable_eq", "array.read_mem", "buffer.take", "buffer.to_array", "array.read_write_of_ne", "array.has_to_tactic_format", "array.has_repr", "array.read", "array.write", "buffer.read_eq_read'", "buffer.drop", "array.write'", "array.read_write", "buffer.reverse", "buffer.take_right", "buffer.write_eq_write'", "array.take_right", "array.mem", "array.ext'", "array.read'", "array.drop", "buffer.append_array", "mk_buffer", "array.map\u2082", "array.pop_back", "mk_array", "array.read_eq_read'", "array.foreach", "array.push_back", "array.rev_foldl", "buffer", "array.iterate", "array.map", "buffer.size", "array.has_mem", "array.ext", "array.write_eq_write'", "array.rev_iterate", "array.rev_list", "array.nil", "array.to_buffer", "array.slice", "array.foldl", "list.to_array"]}, {"id": "d_array", "parentIds": ["array.reverse", "d_array.iterate_aux", "d_array.read", "array.decidable_eq", "d_array.beq", "d_array.nil", "d_array.of_beq_aux_eq_tt", "array", "d_array.map\u2082", "d_array.rev_iterate", "d_array.read_write", "d_array.of_beq_aux_eq_ff", "d_array.write", "d_array.map", "d_array.iterate", "d_array.decidable_eq", "mk_buffer", "array.pop_back", "mk_array", "d_array.foreach", "d_array.of_beq_eq_tt", "d_array.ext'", "d_array.ext", "d_array.rev_iterate_aux", "array.push_back", "d_array.of_beq_eq_ff", "d_array.read_write_of_ne", "d_array.foldl", "array.slice", "d_array.beq_aux", "list.to_array"]}, {"id": "where.where_cmd", "parentIds": []}, {"id": "interactive.decl_meta_info", "parentIds": ["where.where_cmd", "restate_axiom_cmd", "localized_cmd", "tactic.def_replacer_cmd", "interactive.inductive_decl.parse", "tactic.alias.alias_cmd", "open_locale_cmd"]}, {"id": "where.trace_where", "parentIds": ["where.where_cmd"]}, {"id": "linear_ordered_semiring.to_ordered_semiring", "parentIds": ["nat.semiring", "one_div_pos_of_pos", "zero_le_one", "norm_num.pos_bit1_helper", "abs_one_div", "nonneg_of_mul_nonneg_left", "nat.bit1_lt", "nat.add_comm_monoid", "nat.bit0_inj", "nat.ordered_semiring", "two_gt_one", "lt_of_mul_lt_mul_right", "nat.div_le_of_le_mul", "pos_of_mul_pos_right", "norm_num.nonneg_bit1_helper", "le_of_mul_le_mul_right", "norm_num.nonneg_bit0_helper", "le_of_mul_le_of_ge_one", "nonneg_of_mul_nonneg_right", "le_of_mul_le_mul_left", "neg_of_mul_neg_right", "nat.distrib", "norm_num.pos_bit0_helper", "nonpos_of_mul_nonpos_left", "norm_num.nonzero_of_pos_helper", "nat.bit0_lt", "int.nat_abs_bit1_nonneg", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "nat.monoid", "zero_gt_neg_one", "neg_of_mul_neg_left", "nat.bit0_lt_bit1", "nonpos_of_mul_nonpos_right", "nat.eq_of_mul_eq_mul_left", "zero_lt_one", "nat.bit1_lt_bit0"]}, {"id": "linear_ordered_semiring", "parentIds": ["linear_ordered_semiring.to_ordered_semiring", "linear_ordered_semiring.to_linear_order", "zero_le_one", "norm_num.pos_bit1_helper", "nonneg_of_mul_nonneg_left", "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "lt_of_mul_lt_mul_right", "pos_of_mul_pos_right", "norm_num.nonneg_bit1_helper", "linear_ordered_ring.to_linear_ordered_semiring", "le_of_mul_le_mul_right", "norm_num.nonneg_bit0_helper", "nonneg_of_mul_nonneg_right", "le_of_mul_le_mul_left", "neg_of_mul_neg_right", "norm_num.pos_bit0_helper", "decidable_linear_ordered_semiring.to_linear_ordered_semiring", "nonpos_of_mul_nonpos_left", "norm_num.nonzero_of_pos_helper", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "neg_of_mul_neg_left", "nonpos_of_mul_nonpos_right", "zero_lt_one"]}, {"id": "ordered_semiring", "parentIds": ["linear_ordered_semiring.to_ordered_semiring", "mul_nonpos_of_nonpos_of_nonneg", "mul_lt_mul_of_pos_left", "linear_ordered_semiring", "mul_le_mul_of_nonneg_right", "decidable_linear_ordered_semiring", "ordered_semiring.to_ordered_cancel_comm_monoid", "nat.ordered_semiring", "ordered_semiring.to_semiring", "mul_lt_mul", "mul_pos", "mul_neg_of_neg_of_pos", "mul_le_mul_of_nonneg_left", "mul_self_lt_mul_self", "mul_neg_of_pos_of_neg", "mul_nonpos_of_nonneg_of_nonpos", "mul_nonneg", "ordered_ring.to_ordered_semiring", "mul_lt_mul_of_pos_right", "mul_lt_mul'", "mul_self_le_mul_self", "mul_le_mul"]}, {"id": "coe_base_aux", "parentIds": ["coe_sort_coe_base", "coe_fn_coe_trans", "coe_sort_coe_trans", "coe_fn_coe_base"]}, {"id": "has_coe", "parentIds": ["coe_base_aux", "coe_sort_coe_base", "coe_fn_coe_trans", "string_to_format", "coe_b", "string_to_name", "coe_sort_coe_trans", "int.has_coe", "tactic.opt_to_tac", "native.float.of_int_coe", "has_monad_lift_to_has_coe", "lean.parser.has_coe'", "list.bin_tree_to_list", "coe_fn_coe_base", "coe_trans", "expr.has_coe", "coe_subtype", "lean.parser.has_coe", "tactic.ex_to_tac", "coe_base", "nat_to_format", "native.float.of_nat_coe", "smt_tactic.has_coe", "coe_trans_aux", "coe_bool_to_Prop", "coe_coe"]}, {"id": "coe_b", "parentIds": ["coe_base_aux", "coe_trans", "coe_base", "coe_trans_aux"]}, {"id": "one_add_one_eq_two", "parentIds": ["exists_add_lt_and_pos_of_lt", "two_gt_one", "add_mul_self_eq", "add_halves"]}, {"id": "distrib.to_has_add", "parentIds": ["one_add_one_eq_two", "mul_self_sub_one_eq", "ring.mul_zero", "norm_num.mul_bit0", "div_sub_div", "two_mul", "norm_num.mul_bit0_helper", "add_midpoint", "right_distrib", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "two_ne_zero", "eq_zero_of_mul_eq_self_right", "nat.succ_mul_succ_eq", "abs_sub_square", "dvd_add_iff_right", "ge_of_forall_ge_sub", "nat.bit0_val", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "div_two_sub_self", "two_gt_one", "add_mul_self_eq", "nat.mul_le_mul_left", "add_div_eq_mul_add_div", "norm_num.nonneg_bit1_helper", "left_distrib", "norm_num.div_add_helper", "norm_num.nonneg_bit0_helper", "add_mul", "sub_lt_of_abs_sub_lt_left", "norm_num.add_div_helper", "norm_num.pos_bit0_helper", "add_self_div_two", "mul_self_sub_mul_self_eq", "mul_sub_right_distrib", "eq_zero_of_mul_self_add_mul_self_eq_zero", "dvd_add", "nat.mul_self_sub_mul_self_eq", "nat.mod_add_div", "div_add_div_same", "sub_self_div_two", "two_ge_one", "two_pos", "mul_self_eq_mul_self_iff", "add_halves", "distrib_three_right", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_sub_div_same", "mul_sub_left_distrib", "one_div_add_one_div", "neg_mul_eq_mul_neg", "norm_num.mul_bit1", "abs_abs_sub_abs_le_abs_sub", "dvd_add_iff_left", "ring.zero_mul", "div_add_div", "four_pos", "div_two_lt_of_pos", "div_lt_div_of_mul_sub_mul_div_neg", "mul_add"]}, {"id": "semiring.to_monoid", "parentIds": ["one_add_one_eq_two", "two_mul", "zero_le_one", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "abs_one_div", "nat.bit0_val", "exists_add_lt_and_pos_of_lt", "one_dvd", "dvd_of_mul_right_dvd", "two_gt_one", "add_mul_self_eq", "norm_num.nonneg_bit1_helper", "le_of_mul_le_of_ge_one", "dvd_mul_of_dvd_left", "int.nat_abs_bit1_nonneg", "nat.monoid", "zero_gt_neg_one", "dvd_refl", "add_halves", "norm_num.mul_bit1", "zero_lt_one"]}, {"id": "semiring", "parentIds": ["one_add_one_eq_two", "ne_zero_of_mul_ne_zero_left", "semiring.to_add_comm_monoid", "nat.semiring", "semiring.to_monoid", "two_mul", "linear_ordered_semiring", "semiring.to_mul_zero_class", "decidable_linear_ordered_semiring", "norm_num.mul_bit1_helper", "semiring.to_distrib", "ring.to_semiring", "ordered_semiring.to_semiring", "ne_zero_of_mul_ne_zero_right", "ordered_semiring", "distrib_three_right", "int.semiring", "norm_num.mul_bit1", "comm_semiring.to_semiring"]}, {"id": "semiring.to_distrib", "parentIds": ["one_add_one_eq_two", "two_mul", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "nat.bit0_val", "exists_add_lt_and_pos_of_lt", "add_mul_self_eq", "nat.mul_le_mul_left", "norm_num.nonneg_bit1_helper", "norm_num.nonneg_bit0_helper", "nat.distrib", "norm_num.pos_bit0_helper", "dvd_add", "add_halves", "distrib_three_right", "norm_num.mul_bit1"]}, {"id": "monoid.to_has_one", "parentIds": ["one_add_one_eq_two", "mul_self_sub_one_eq", "nat.shiftl_eq_mul_pow", "div_sub_div", "two_mul", "eq_inv_iff_mul_eq_one", "mul_right_eq_self", "mul_inv_rev", "zero_le_one", "norm_num.pos_bit1_helper", "norm_num.mul_bit1_helper", "eq_zero_of_mul_eq_self_right", "abs_one_div", "mul_eq_one_iff_inv_eq", "one_inv", "norm_num.mul_one", "nat.bit0_val", "comm_group", "nat.pow_lt_pow_of_lt_right", "exists_add_lt_and_pos_of_lt", "div_div_eq_div_mul", "mul_one", "one_dvd", "eq_of_mul_eq_mul_of_nonzero_right", "one_mul", "nat.pow_le_pow_of_le_right", "le_mul_of_ge_one_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "mul_self_iff_eq_one", "two_gt_one", "add_mul_self_eq", "mul_eq_one_iff_eq_inv", "inv_ne_one", "mul_left_eq_self", "int.eq_one_of_mul_eq_self_left", "norm_num.nonneg_bit1_helper", "mul_inv_cancel_left", "mul_right_inv", "field.div_mul_eq_mul_div_comm", "mul_inv_self", "le_of_mul_le_of_ge_one", "one_inv_eq", "inv_mul_cancel_left", "group", "neg_eq_neg_one_mul", "lt_mul_of_gt_one_right", "inv_eq_one", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "add_self_div_two", "one_div_neg_one_eq_neg_one", "int.nat_abs_bit1_nonneg", "functor.const.is_lawful_applicative", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "zero_gt_neg_one", "one_div_lt_one_div_of_lt", "field.div_mul_right", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "mul_inv_eq_one", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "mul_div_mul_left", "inv_mul_self", "dvd_refl", "mul_inv_eq_of_eq_mul", "inv_eq_of_mul_eq_one", "eq_inv_of_mul_eq_one", "add_halves", "neg_div", "int.eq_one_of_mul_eq_self_right", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "nat.le_of_dvd", "mul_left_inv", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "norm_num.mul_bit1", "field.div_div_eq_div_mul", "mul_inv_cancel_right", "zero_lt_one", "inv_eq_iff_mul_eq_one", "division_ring.one_div_mul_one_div", "mul_self_eq_one_iff", "division_ring.one_div_neg_eq_neg_one_div", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "environment.add_ginductive", "parentIds": []}, {"id": "environment.intro_rule", "parentIds": ["environment.add_ginductive"]}, {"id": "options", "parentIds": ["environment.add_ginductive", "format.of_options", "options.get_nat", "tactic_state.get_options", "exceptional.to_bool", "exceptional.to_option", "format.to_buffer", "lean.parser_state.options", "environment.is_definition", "format.to_string", "use_cmd", "options.set_bool", "tactic.terminal_goal", "options.get_string", "options.join", "options.set_nat", "tactic.instance_stub", "level.has_to_format", "options.has_to_format", "options.fold", "tactic.eqn_stub", "options.size", "level.to_format", "tactic.list_constructors_hole", "options.get_bool", "exceptional.to_string", "exceptional.fail", "environment.contains", "exceptional", "lint_hole_cmd", "options.has_add", "vm.get_options", "tactic.save_options", "options.set_string", "tactic.match_stub", "tactic.get_options", "trace_val", "options.contains", "tactic.returnex", "tactic_state.set_options", "options.inhabited", "exceptional.bind", "tactic.add_defn_equations", "environment.add_defn_eqns", "tactic.set_options", "options.has_decidable_eq", "format.has_to_string", "tactic.success_if_fail_with_msg"]}, {"id": "tactic.first", "parentIds": ["tactic.solve"]}, {"id": "classical.inhabited_of_exists", "parentIds": []}, {"id": "classical.inhabited_of_nonempty", "parentIds": ["classical.inhabited_of_exists"]}, {"id": "functor.map_comp_map", "parentIds": ["functor.comp.comp_map"]}, {"id": "is_lawful_functor", "parentIds": ["functor.map_comp_map", "id.is_comm_applicative", "option.is_lawful_monad", "functor.add_const.is_lawful_applicative", "bind_pure", "functor.comp.comp_map", "functor.const.is_lawful_functor", "parser.is_lawful_monad", "reader_t.is_lawful_monad", "functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "functor.add_const.is_lawful_functor", "id.is_lawful_monad", "functor.map_id", "is_lawful_traversable", "functor.const.is_lawful_applicative", "id_map'", "functor.comp.is_lawful_functor", "list.is_lawful_monad", "applicative.ext", "pure_id_seq", "sum.is_lawful_functor", "seq_map_assoc", "comp.applicative_comp_id", "except_t.is_lawful_monad", "set.is_lawful_functor", "functor.comp.id_map", "option_t.is_lawful_monad", "state_t.is_lawful_monad", "functor.ext", "is_lawful_applicative", "map_map"]}, {"id": "bool.bxor_comm", "parentIds": []}, {"id": "bool.decidable_forall_bool", "parentIds": ["bool.bxor_comm", "bool.coe_bool_iff", "bool.band_comm", "bool.bxor_iff_ne", "bool.band_elim_left", "bool.eq_tt_of_bnot_eq_ff", "bool.eq_tt_of_ne_ff", "bool.eq_ff_of_bnot_eq_tt", "bool.eq_ff_of_ne_tt", "bool.bor_assoc", "bool.bxor_bnot_bnot", "bool.band_intro", "bool.band_assoc", "bool.bxor_left_comm", "bool.band_left_comm", "bool.bor_left_comm", "bool.bxor_bnot_right", "bool.band_elim_right", "bool.bor_comm", "bool.bxor_bnot_left", "bool.bxor_assoc"]}, {"id": "of_as_true", "parentIds": ["bool.bxor_comm", "bool.coe_bool_iff", "bool.band_comm", "bool.bxor_iff_ne", "bor_coe_iff", "bool.band_elim_left", "buffer.lt_aux_2", "bool.eq_tt_of_bnot_eq_ff", "bool.eq_tt_of_ne_ff", "bool_iff_false", "bool.eq_ff_of_bnot_eq_tt", "nat.eq_one_of_dvd_one", "bool.eq_ff_of_ne_tt", "buffer.lt_aux_3", "bool.bor_assoc", "nat.div2_val", "bool.bxor_bnot_bnot", "ordering.or_else_eq_lt", "nat.div2_bit", "bool.band_intro", "band_coe_iff", "bool.band_assoc", "bool.bxor_left_comm", "bool.band_left_comm", "bool.bor_left_comm", "nat.mod_two_eq_zero_or_one", "bool.bxor_bnot_right", "bool.band_elim_right", "bool.bor_comm", "bool.bxor_bnot_left", "bxor_coe_iff", "bool.bxor_assoc"]}, {"id": "bxor", "parentIds": ["bool.bxor_comm", "nat.lxor_bit", "nat.bodd_add", "bxor_self", "nat.mod_two_of_bodd", "bool.bxor_iff_ne", "nat.bodd_mul", "nat.test_bit_lxor", "nat.bodd_bit", "bool.bxor_bnot_bnot", "nat.lxor", "bxor_tt", "bxor_ff", "ff_bxor", "bool.bxor_left_comm", "bool.bxor_bnot_right", "bool.bxor_bnot_left", "bxor_coe_iff", "tt_bxor", "bool.bxor_assoc"]}, {"id": "state", "parentIds": ["monad_state", "level.dedup_size_aux", "monad_state_trans", "state_t.monad_state", "expr.dedup_size_aux", "expr.lift"]}, {"id": "state_t", "parentIds": ["state", "state_t.run_bind", "smt_tactic.set_goals", "state_t.monad_map", "expr.dedup_size", "using_smt", "state_t.bind", "state_t.run_map", "smt_tactic.write", "smt_tactic", "state_t.run_monad_map", "state_t.put", "expr.mfoldl", "state_t.run_adapt", "state_t.monad_except", "state_t.adapt", "smt_tactic.alternative", "state_t.run_monad_lift", "state_t.run_get", "state_t.alternative", "state_t.lift", "smt_tactic.slift_aux", "tactic.interactive.collect_struct'", "smt_tactic.try", "state_t.monad_state_adapter", "state_t.ext", "smt_tactic.monad_state", "smt_tactic.istep", "state_t.has_monad_lift", "level.dedup_size", "state_t.run_put", "state_t.orelse", "state_t.monad_state", "state_t.modify", "smt_tactic.monad", "state_t.monad_run", "state_t.pure", "state_t.monad", "state_t.failure", "state_t.is_lawful_monad", "state_t.monad_functor", "tactic.interactive.collect_struct", "state_t.run_pure", "state_t.get", "expr.lift"]}, {"id": "expr.is_sorry", "parentIds": []}, {"id": "lean.parser_state.cur_pos", "parentIds": ["lean.parser.parser_orelse", "lean.parser.cur_pos"]}, {"id": "pos", "parentIds": ["lean.parser_state.cur_pos", "tactic.interactive.rw_rule.has_reflect", "pos.inhabited", "interaction_monad.orelse'", "rbtree.default_lt", "tactic.mk_dec_eq_instance", "tactic.down", "tactic.interactive.continue", "interaction_monad.result_to_string", "interaction_monad.result", "tactic.success_if_fail", "tactic.save_info", "interaction_monad.get_result", "tactic.interactive.rw_rule_p", "lean.parser.of_tactic'", "tactic.lift", "tactic.fail_if_success", "tactic.trace_error", "pos.decidable_eq", "pos_line", "expr.pos", "tactic.decorate_ex", "well_founded_tactics.cancel_nat_add_lt", "interaction_monad.mk_exception", "tactic.lock_tactic_state", "tactic.try_core", "tactic.olean_doc_strings", "tactic.interactive.rw_rule", "smt_tactic.save_info", "old_conv.save_info", "environment.decl_pos", "tactic.interactive.rw_rules_t.has_reflect", "smt_tactic.try", "tactic.save_info_thunk", "tactic.interactive.convert_to", "vm_decl.pos", "interaction_monad_fmap", "interaction_monad_orelse", "tactic.returnex", "interaction_monad.result.clamp_pos", "tactic.up", "lean.parser.parser_orelse", "lean.parser.cur_pos", "tactic.interactive.rw_rules", "tactic.inhabited_instance", "tactic.mk_inj_eq", "conv.save_info", "tactic.interactive.rw_rules_t", "pos.has_to_format", "pos.has_reflect", "interaction_monad_bind", "tactic.interactive.push_neg", "tactic.exact_dec_trivial", "tactic.run_async", "tactic.success_if_fail_with_msg", "tactic.module_doc_strings", "interaction_monad.silent_fail"]}, {"id": "tactic.mk_eq_refl", "parentIds": ["push_neg.normalize_negations"]}, {"id": "parser.eof", "parentIds": ["parser.run"]}, {"id": "parser.alternative", "parentIds": ["parser.eof", "parser.sep_by"]}, {"id": "parser.remaining", "parentIds": ["parser.eof"]}, {"id": "nat.decidable_eq", "parentIds": ["parser.eof", "char.decidable_eq", "tactic.elide.unelide", "unused_arguments", "d_array.of_beq_aux_eq_tt", "tactic.clear'", "expr.is_napp_of", "nat.binary_rec_eq", "tactic.library_search", "nat.binary_rec_zero", "nat.mul_mod_mul_left", "tactic.interactive.guard_hyp_nums", "tactic.abstract", "nat.mk_numeral", "nat.digit_char", "tactic.mk_inhabited_instance", "string.is_empty", "check_unused_arguments", "tactic.mk_has_reflect_instance", "lean.is_release", "tactic.relation_lhs_rhs", "rsimp.choose", "nat.strong_rec_on", "tactic.interactive.convert_to", "tactic.fail_if_no_goals", "nat.decidable_linear_ordered_semiring", "conv.interactive.for", "tactic.interactive.clean", "fin.decidable_eq", "instance_priority", "int.decidable_eq", "where.format_variable", "tactic.suggest", "tactic.rotate_right", "conv.convert", "nat.decidable_dvd", "tactic.interactive.suggest", "nat.gcd_def", "tactic.done", "expr.of_nat"]}, {"id": "parser.monad", "parentIds": ["parser.eof", "parser.one_of'", "parser.many'", "parser.alternative", "parser.sep_by1", "parser.is_lawful_monad", "parser.many1", "parser.eps", "parser.many_char1", "parser.sep_by", "parser.run", "parser.ch", "parser.str", "parser.many_char", "parser.char_buf"]}, {"id": "parser.decorate_error", "parentIds": ["parser.eof", "parser.ch", "parser.str", "parser.char_buf"]}, {"id": "tactic.exfalso", "parentIds": ["tactic.apply_assumption", "tactic.interactive.exfalso"]}, {"id": "tactic.fail_if_no_goals", "parentIds": ["tactic.exfalso", "tactic.abstract", "tactic.solve_by_elim"]}, {"id": "tactic.swap", "parentIds": ["tactic.exfalso", "tactic.mk_dec_eq_instance", "tactic.interactive.letI", "tactic.assert", "tactic.interactive.suffices", "tactic.interactive.haveI", "tactic.interactive.generalize", "tactic.define", "tactic.replace_target", "tactic.get_lift_prf", "conv.interactive.to_lhs"]}, {"id": "tactic.contradiction", "parentIds": ["tactic.exfalso", "tactic.interactive.contradiction", "tactic.interactive.trivial", "tactic.interactive.triv"]}, {"id": "nat.sub_succ", "parentIds": ["nat.sub_mul_div", "nat.sub_sub", "nat.mul_sub_right_distrib"]}, {"id": "nat.has_sub", "parentIds": ["nat.sub_succ", "nat.mod_lt", "nat.div_eq_of_lt", "tactic.existsi", "nat.succ_sub_sub_succ", "unused_arguments", "array.take", "nat.div_def", "nat.sub_eq_zero_of_le", "nat.sub_sub_self", "nat.sub_le_sub_left", "parser.foldl", "nat.shiftl_sub", "tactic.interactive.induction", "string.iterator.length_next_to_string_next", "int.sub_nat_nat_elim", "list.length_drop", "nat.sub_eq_iff_eq_add", "nat.succ_sub_succ_eq_sub", "nat.sub_eq_sub_min", "nat.sub_mul_mod", "nat.div_def_aux", "parser.foldr", "nat.mod_eq_of_lt", "nat.lt_of_sub_eq_succ", "nat.shiftl'_sub", "buffer.drop", "nat.add_sub_assoc", "nat.add_sub_cancel", "int.of_nat_sub", "tactic.constructor_idx", "tactic.constructor_num_fields", "nat.sub_pos_of_lt", "nat.mul_mod_mul_left", "norm_num.sub_nat_zero_helper", "nat.zero_sub", "nat.succ_sub_succ", "buffer.lt_aux_2", "nat.sub_self", "nat.zero_mod", "nat.sub_lt_of_pos_le", "nat.add_mod_right", "nat.add_sub_add_right", "nat.add_sub_cancel_left", "nat.mul_pred_left", "nat.dvd_add_iff_right", "nat.dvd_sub", "array.take_right", "int.sub_nat_nat", "nat.sub_self_add", "nat.sub_one_sub_lt", "buffer.lt_aux_3", "nat.add_div_right", "list.length_tail", "nat.mod_zero", "array.drop", "tactic.explode.pad_right", "int.coe_nat_sub", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "nat.sub_add_comm", "nat.succ_sub", "nat.le_of_le_of_sub_le_sub_right", "nat.sub_mul_div", "fin.sub_def", "nat.sub.right_comm", "nat.mod_self", "norm_num.sub_nat_pos_helper", "tactic.injection_with", "parser.remaining", "tactic.rename", "nat.sub_sub", "nat.sub_zero", "nat.mul_sub_right_distrib", "nat.sub_add_min_cancel", "nat.le_of_sub_eq_zero", "nat.mul_self_sub_mul_self_eq", "nat.div_eq_sub_div", "nat.sub_le_sub_right_iff", "nat.zero_div", "parser.fix", "nat.mod_def_aux", "nat.mod_add_div", "tactic.interactive.swap", "nat.mod_eq_sub_mod", "int.to_nat_sub", "expr.ith_arg", "nat.sub_le", "nat.sub_le_sub_right", "nat.sub_eq_zero_iff_le", "nat.sub_lt", "nat.sub_one", "nat.mod_pow_succ", "tactic.interactive.case", "nat.succ_sub_one", "tactic.rotate_right", "nat.mod_def", "nat.add_sub_of_le", "nat.le_div_iff_mul_le", "nat.add_le_to_le_sub", "list.length_remove_nth", "nat.sub_lt_succ", "nat.sub_add_cancel", "array.slice", "nat.div_zero", "nat.mul_sub_div", "nat.add_sub_add_left"]}, {"id": "name.is_prefix_of", "parentIds": ["tactic.strip_prefix", "tactic.in_open_namespaces", "where.is_in_namespace_nonsynthetic", "tactic.find_private_decl"]}, {"id": "tactic.resolve_name'", "parentIds": ["tactic.strip_prefix"]}, {"id": "name.update_prefix", "parentIds": ["tactic.strip_prefix", "tactic.interactive.refine_one", "tactic.interactive.get_current_field", "tactic.interactive.source_fields", "tactic.find_private_decl", "tactic.import_private_cmd"]}, {"id": "unsigned", "parentIds": ["tactic.strip_prefix", "unsigned.has_mod", "unsigned.has_le", "to_additive.target_name", "unsigned.has_zero", "unsigned.decidable_eq", "unsigned.of_nat", "unsigned.has_lt", "to_additive.proceed_fields", "unsigned.has_to_string", "unsigned.has_mul", "ext_param", "name.add_prime", "unsigned.has_repr", "unsigned.to_nat", "tactic.unprime", "unsigned.of_nat'", "name.deinternalize_field", "name", "unsigned.inhabited", "unsigned.has_one", "tactic.interactive.clear_", "unsigned.has_div", "unsigned.has_to_format", "unsigned.has_add", "unsigned.reflect", "tactic.alias.make_left_right", "expr.is_internal_cnstr", "saturate_fun", "unsigned.has_sub", "name.last"]}, {"id": "tactic.interactive.cases", "parentIds": []}, {"id": "tactic.get_local", "parentIds": ["tactic.interactive.cases", "tactic.cases", "tactic.mk_has_sizeof_instance_core", "tactic.mk_brec_on_rec_value", "tactic.rcases_hint", "tactic.interactive.revert", "tactic.interactive.induction", "tactic.replace", "tactic.interactive.clear_dependent", "tactic.interactive.clear'", "tactic.interactive.set", "tactic.interactive.change'", "tactic.change_with_at", "tactic.interactive.guard_hyp_strict", "tactic.lift", "tactic.mk_patterns", "tactic.mk_dec_eq_instance_core", "tactic.interactive.substs", "tactic.interactive.guard_hyp", "tactic.mk_has_reflect_instance", "interactive.loc.get_locals", "tactic.apply_congr_core", "tactic.interactive.replace", "tactic.rcases", "tactic.rename", "tactic.interactive.change", "tactic.interactive.simpa", "tactic.replace_target", "push_neg.push_neg_at_hyp", "tactic.interactive.guard_hyp'", "tactic.interactive.h_generalize", "tactic.interactive.choose", "tactic.get_local_type"]}, {"id": "tactic.get_unused_name", "parentIds": ["tactic.interactive.cases", "tactic.cases", "tactic.interactive.induction", "tactic.interactive.generalize_hyp", "tactic.interactive.letI", "tactic.classical", "tactic.lift", "tactic.mk_patterns", "tactic.interactive.haveI", "tactic.rcases", "smt_tactic.interactive.add_fact", "tactic.interactive.h_generalize", "tactic.get_lift_prf", "tactic.note_anon"]}, {"id": "coe_option", "parentIds": ["tactic.interactive.cases", "tactic.interactive.induction", "incorrect_def_lemma", "tactic.interactive.dsimp", "tactic.assoc_refl", "ext_param", "tactic.interactive.change'", "tactic.lift", "doc_blame_report_defn", "tactic.apply_heq_congr_core", "check_unused_arguments", "tactic.interactive.generalize", "conv.interactive.find", "tactic.interactive.replace", "tactic.interactive.return_cast", "tactic.rcases", "tactic.interactive.convert_to", "tactic.alias.get_alias_target", "where.is_variable_name", "tactic.mk_assoc_instance", "tactic.interactive.list_cast_of_aux", "tactic.interactive.h_generalize", "tactic.get_lift_prf", "doc_blame_report_thm", "tactic.interactive.suggest", "derive_struct_ext_lemma", "has_inhabited_instance"]}, {"id": "prod.has_reflect", "parentIds": ["tactic.interactive.cases", "smt_tactic.interactive.induction", "tactic.interactive.by_cases", "tactic.interactive.induction", "tactic.interactive.rcases", "tactic.interactive.rename'", "tactic.interactive.generalize_hyp", "tactic.interactive.set", "tactic.interactive.obtain", "tactic.interactive.generalize", "tactic.interactive.h_generalize", "tactic.interactive.contrapose"]}, {"id": "tactic.interactive.cases_arg_p", "parentIds": ["tactic.interactive.cases", "smt_tactic.interactive.induction", "tactic.interactive.by_cases", "tactic.interactive.induction"]}, {"id": "tactic.interactive.generalize", "parentIds": ["tactic.interactive.cases", "tactic.interactive.induction", "tactic.interactive.generalize_hyp", "tactic.rcases", "tactic.interactive.h_generalize"]}, {"id": "tactic.interactive.cases_core", "parentIds": ["tactic.interactive.cases", "tactic.interactive.cases_matching"]}, {"id": "tactic.i_to_expr", "parentIds": ["tactic.interactive.cases", "tactic.rcases_hint", "tactic.interactive.induction", "localized_cmd", "tactic.interactive.let", "tactic.i_to_expr_for_apply", "tactic.interactive.change'", "tactic.lift", "tactic.interactive.injection", "conv.interactive.change", "tactic.interactive.generalize", "tactic.interactive.transitivity", "tactic.interactive.to_expr'", "tactic.interactive.subst", "tactic.rcases", "tactic.interactive.change", "tactic.interactive.simpa", "tactic.interactive.specialize", "tactic.interactive.have", "tactic.interactive.destruct", "tactic.get_lift_prf"]}, {"id": "max_add_add_left", "parentIds": ["max_add_add_right"]}, {"id": "le_max_right", "parentIds": ["max_add_add_left", "max_comm", "max_assoc", "eq_max"]}, {"id": "eq_max", "parentIds": ["max_add_add_left", "max_comm", "max_assoc", "max_eq_left", "max_neg_neg"]}, {"id": "decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid", "parentIds": ["max_add_add_left", "min_add_add_right", "min_add_add_left", "max_add_add_right"]}, {"id": "le_max_left", "parentIds": ["max_add_add_left", "max_comm", "max_assoc", "eq_max"]}, {"id": "max_eq_right", "parentIds": ["max_add_add_left", "max_eq_right_of_lt", "abs_of_nonpos"]}, {"id": "has_le.le.decidable", "parentIds": ["max_add_add_left", "is_strict_weak_order_of_decidable_linear_order", "max_self", "max_lt", "sub_le_of_abs_sub_le_left", "le_min", "le_max_left", "lt_min", "decidable.lt_or_le", "max", "max_le", "min_add_add_left", "min_le_right", "sub_lt_of_abs_sub_lt_left", "decidable.lt_trichotomy", "min", "dist_bdd_within_interval", "decidable.le_of_not_lt", "min_self", "min_le_left", "nat.min_succ_succ", "le_max_right"]}, {"id": "max_eq_left", "parentIds": ["max_add_add_left", "max_eq_right", "abs_of_nonneg", "max_eq_left_of_lt"]}, {"id": "decidable_linear_ordered_cancel_comm_monoid", "parentIds": ["max_add_add_left", "min_add_add_right", "min_add_add_left", "decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid", "max_add_add_right", "nat.decidable_linear_ordered_cancel_comm_monoid", "decidable_linear_ordered_cancel_comm_monoid.to_decidable_linear_order"]}, {"id": "decidable_linear_ordered_cancel_comm_monoid.to_decidable_linear_order", "parentIds": ["max_add_add_left", "min_add_add_right", "min_add_add_left", "max_add_add_right"]}, {"id": "max", "parentIds": ["max_add_add_left", "min_neg_neg", "max_self", "max_comm", "max_lt", "max_assoc", "max_eq_right", "le_max_left", "max_eq_neg_min_neg_neg", "abs", "max_le", "abs_neg", "max_eq_left", "tactic.explode.pad_right", "min_eq_neg_max_neg_neg", "max_add_add_right", "max_left_comm", "eq_max", "max_eq_right_of_lt", "max_neg_neg", "le_max_right", "max_eq_left_of_lt"]}, {"id": "tactic.interactive.format_names", "parentIds": []}, {"id": "string_to_format", "parentIds": ["tactic.interactive.format_names", "option_to_tactic_format", "print_decls_sorted", "unused_arguments", "congr_arg_kind.has_to_format", "print_arguments", "tactic.interactive.convert", "tactic.clear'", "tactic.interactive.rcases", "print_decls", "old_conv.conversion", "tactic.rintro_parse", "expr.has_to_format", "tactic.instance_stub", "tactic.interactive.rw_rule_p", "tactic.interactive.rec.to_tactic_format", "tactic.interactive.obtain_parse", "tactic.interactive.squeeze_simpa", "tactic.mk_patterns", "print_decls_sorted_mathlib", "tactic.explode", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "tactic.iterate1", "tactic.list_constructors_hole", "tactic.unsafe.type_context.print_mvars", "tactic.rcases_patt_parse", "tactic.interactive.rintro", "interactive.parse_binders", "list.to_format", "tactic.interactive.convert_to", "tactic.interactive.congr'", "tactic.interactive.has_to_tactic_format", "lint_aux", "binder.has_to_tactic_format", "binder.has_to_format", "tactic.interactive.simpa", "tactic.interactive.mk_paragraph", "tactic.interactive.extract_goal", "tactic.unsafe.type_context.failure", "interactive.param_desc", "tactic.interactive.parse_config", "tactic.rename'", "tactic.interactive.suggest", "pos.has_to_format", "interactive.types.location", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "bool.coe_bool_iff", "parentIds": []}, {"id": "iff.decidable", "parentIds": ["bool.coe_bool_iff", "incorrect_def_lemma", "bool.bxor_iff_ne", "bor_coe_iff", "bool_iff_false", "ordering.or_else_eq_lt", "band_coe_iff", "bxor_coe_iff"]}, {"id": "le_iff_lt_or_eq", "parentIds": ["le_iff_eq_or_lt"]}, {"id": "lt_or_eq_of_le", "parentIds": ["le_iff_lt_or_eq", "lt_of_le_of_ne", "nat.pow_le_pow_of_le_right", "lt_trichotomy", "cmp_compares", "one_div_le_one_div_of_le", "one_div_le_one_div_of_le_of_neg", "eq_or_lt_of_le"]}, {"id": "le_of_lt_or_eq", "parentIds": ["le_iff_lt_or_eq", "decidable.le_iff_lt_or_eq"]}, {"id": "tactic.instance_cache.get", "parentIds": ["tactic.instance_cache.append_typeclasses"]}, {"id": "tactic.instance_cache", "parentIds": ["tactic.instance_cache.get", "tactic.instance_cache.append_typeclasses", "tactic.instance_cache.mk_app", "tactic.mk_instance_cache"]}, {"id": "native.rb_map.insert", "parentIds": ["tactic.instance_cache.get", "native.rb_map.add", "native.rb_map.map", "rsimp.to_repr_map", "native.rb_lmap.insert", "native.rb_set.insert", "native.rb_map.filter", "tactic.local_decls", "tactic.explode.entries.add"]}, {"id": "native.rb_map.find", "parentIds": ["tactic.instance_cache.get", "to_additive.target_name", "native.rb_lmap.find", "to_additive.guess_name", "tactic.transport_with_prefix_dict", "tactic.explode.entries.find", "native.rb_map.zfind", "native.rb_lmap.insert", "tactic.ext1", "rsimp.rsimplify", "native.rb_map.find_def", "tactic.rename'", "native.rb_map.ifind"]}, {"id": "tactic.mk_instance", "parentIds": ["tactic.instance_cache.get", "tactic.apply_instance", "tactic.lift", "tactic.by_cases", "tactic.subsingleton_goal", "tactic.mk_assoc_instance", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "tactic.get_classes"]}, {"id": "tactic_state.has_to_string", "parentIds": []}, {"id": "tactic_state.has_to_format", "parentIds": ["tactic_state.has_to_string", "tactic.trace_state", "tactic.inhabited_instance"]}, {"id": "tactic_state.get_options", "parentIds": ["tactic_state.has_to_string", "tactic.get_string_option", "tactic.set_nat_option", "tactic.set_string_option", "tactic.get_options", "tactic.get_nat_option", "tactic.set_bool_option", "tactic.get_bool_option"]}, {"id": "format.to_string", "parentIds": ["tactic_state.has_to_string", "use_cmd", "tactic.terminal_goal", "tactic.instance_stub", "tactic.eqn_stub", "tactic.list_constructors_hole", "lint_hole_cmd", "tactic.match_stub", "trace_val", "format.has_to_string", "tactic.success_if_fail_with_msg"]}, {"id": "get_localized", "parentIds": ["print_localized_commands", "open_locale_cmd"]}, {"id": "native.rb_lmap", "parentIds": ["get_localized", "native.rb_lmap.find", "localized_attr", "localized_cmd", "native.rb_lmap.contains", "native.rb_lmap.of_list", "native.rb_lmap.insert", "native.rb_lmap.erase", "fold_over_with_cond_sorted", "native.rb_lmap.inhabited"]}, {"id": "list.bind", "parentIds": ["get_localized", "list.sigma", "list.monad", "list.is_lawful_monad", "list.append_bind", "list.nil_bind", "list.product", "list.cons_bind"]}, {"id": "native.rb_lmap.find", "parentIds": ["get_localized"]}, {"id": "user_attribute.get_cache", "parentIds": ["get_localized", "tactic.lift", "tactic.ext1"]}, {"id": "localized_attr", "parentIds": ["get_localized", "localized_cmd"]}, {"id": "punit.decidable_eq", "parentIds": []}, {"id": "punit_eq", "parentIds": ["punit.decidable_eq", "punit.subsingleton", "punit_eq_punit"]}, {"id": "heq_of_eq_rec_left", "parentIds": []}, {"id": "smt_tactic.solve1", "parentIds": []}, {"id": "smt_tactic.set_goals", "parentIds": ["smt_tactic.solve1", "smt_tactic.seq", "smt_tactic.swap", "smt_tactic.focus1"]}, {"id": "smt_tactic.monad", "parentIds": ["smt_tactic.solve1", "smt_tactic.definev", "smt_tactic.interactive.destruct", "smt_tactic.trace_state", "smt_tactic.add_lemmas_from_facts", "smt_tactic.seq", "using_smt", "smt_tactic.interactive.guard_target", "smt_tactic.swap", "smt_tactic.interactive.have", "smt_tactic.slift", "smt_tactic.classical", "smt_tactic.pose", "smt_tactic.add_ematch_lemma_core", "smt_tactic.proof_for", "smt_tactic.focus1", "smt_tactic.get_facts", "smt_tactic.interactive.add_simp_lemmas", "smt_tactic.interactive.let", "smt_tactic.all_goals", "smt_tactic.define", "smt_tactic.get_refuted_facts", "smt_tactic.save_info", "smt_tactic.assertv", "smt_tactic.note", "smt_tactic.istep", "rsimp.collect_implied_eqs", "smt_tactic.assert", "smt_tactic.get_goals", "smt_tactic.eblast", "smt_tactic.interactive.eblast_using", "smt_tactic.read", "smt_tactic.step", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "smt_tactic.interactive.rsimp", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "smt_tactic.skip", "smt_tactic.add_ematch_eqn_lemmas_for_core", "smt_tactic.interactive.by_cases", "smt_tactic.interactive.guard_expr_eq", "smt_tactic.refutation_for", "smt_tactic.interactive.executor", "smt_tactic.add_ematch_lemma_from_decl_core", "smt_tactic.num_goals"]}, {"id": "smt_goal", "parentIds": ["smt_tactic.solve1", "smt_tactic.set_goals", "smt_tactic.seq", "smt_tactic.swap", "smt_state.has_append", "smt_tactic.focus1", "smt_tactic.all_goals", "smt_state", "smt_tactic.slift_aux", "smt_tactic.get_goals", "smt_tactic.num_goals"]}, {"id": "smt_tactic.get_goals", "parentIds": ["smt_tactic.solve1", "smt_tactic.seq", "smt_tactic.swap", "smt_tactic.focus1", "smt_tactic.all_goals"]}, {"id": "smt_tactic", "parentIds": ["smt_tactic.solve1", "smt_tactic.iterate_exactly", "smt_tactic.failed", "smt_tactic.add_lemmas_from_facts_core", "smt_tactic.interactive.by_contradiction", "smt_tactic.definev", "smt_tactic.interactive.ematch", "smt_tactic.interactive.destruct", "smt_tactic.set_goals", "smt_tactic.execute_with", "smt_tactic.ematch_using", "smt_tactic.get_config", "smt_tactic.trace_state", "smt_tactic.ematch_core", "smt_tactic.interactive.induction", "smt_tactic.add_lemmas_from_facts", "smt_tactic.add_ematch_lhs_lemma_from_decl", "smt_tactic.add_ematch_lemma_from_decl", "smt_tactic.seq", "using_smt", "smt_tactic.interactive.guard_target", "smt_tactic.interactive.intros", "smt_tactic.intron", "smt_tactic.trace", "smt_tactic.write", "smt_tactic.swap", "smt_tactic.interactive.have", "smt_tactic.when_tracing", "smt_tactic.monad_fail", "smt_tactic.when", "smt_tactic.slift", "smt_tactic.interactive.add_eqn_lemmas", "smt_tactic.classical", "smt_tactic.pose", "smt_tactic.interactive.itactic", "smt_tactic.intros", "smt_tactic.add_ematch_lemma_core", "smt_tactic.interactive.trace", "smt_tactic.interactive.add_eqn_lemmas_for", "smt_tactic.interactive.dsimp", "smt_tactic.close", "smt_tactic.interactive.trace_state", "smt_tactic.proof_for", "smt_tactic.add_ematch_lhs_lemma", "smt_tactic.focus1", "smt_tactic.mk_ematch_eqn_lemmas_for_core", "smt_tactic.alternative", "smt_tactic.get_facts", "smt_tactic.ematch", "smt_tactic.interactive.eblast", "smt_tactic.has_andthen", "smt_tactic.to_expr", "smt_tactic.interactive.add_simp_lemmas", "smt_tactic.add_ematch_eqn_lemmas_for", "smt_tactic.interactive.let", "smt_tactic.interactive.try", "smt_tactic.interactive.iterate", "smt_tactic.all_goals", "smt_tactic.interactive.add_lemma", "smt_tactic.define", "smt_tactic.slift_aux", "smt_tactic.add_ematch_lemma", "smt_tactic.get_refuted_facts", "smt_tactic.save_info", "smt_tactic.assertv", "smt_tactic.add_lemmas", "smt_tactic.fail", "smt_tactic.try", "smt_tactic.to_em_state", "smt_tactic.execute", "smt_tactic.monad_state", "smt_tactic.note", "smt_tactic.istep", "rsimp.collect_implied_eqs", "smt_tactic.assert", "smt_tactic.get_lemmas", "smt_tactic.has_monad_lift", "smt_tactic.get_goals", "smt_tactic.interactive.apply", "smt_tactic.interactive.close", "smt_tactic.iterate_at_most", "smt_tactic.iterate", "smt_tactic.eblast", "smt_tactic.intro_lst", "smt_tactic.interactive.eblast_using", "smt_tactic.monad", "smt_tactic.read", "smt_tactic.to_cc_state", "smt_tactic.step", "smt_tactic.interactive.by_contra", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "smt_tactic.interactive.from", "smt_tactic.interactive.rsimp", "smt_tactic.induction", "using_smt_with", "tactic_to_smt_tactic", "smt_tactic.interactive.simp", "smt_tactic.interactive.apply_instance", "smt_tactic.interactive.change", "smt_tactic.interactive.ematch_using", "smt_tactic.interactive.add_fact", "smt_tactic.has_coe", "smt_tactic.set_lemmas", "smt_tactic.skip", "smt_tactic.destruct", "smt_tactic.add_ematch_eqn_lemmas_for_core", "smt_tactic.interactive.by_cases", "smt_tactic.interactive.all_goals", "smt_tactic.interactive.add_lhs_lemma", "smt_tactic.interactive.guard_expr_eq", "smt_tactic.refutation_for", "smt_tactic.interactive.executor", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "smt_tactic.interactive.fapply", "smt_tactic.num_goals", "smt_tactic.preprocess", "smt_tactic.solve_goals"]}, {"id": "smt_tactic.fail", "parentIds": ["smt_tactic.solve1", "smt_tactic.by_contradiction", "smt_tactic.by_cases"]}, {"id": "int.add_comm", "parentIds": ["int.add_assoc", "int.comm_ring", "int.distrib_left", "int.zero_add"]}, {"id": "nat.add_comm_semigroup", "parentIds": ["int.add_comm", "int.add_assoc", "nat.add_div_left", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "list.length_append", "string.iterator.length_next_to_string_next", "nat.zero_lt_one_add", "nat.mul_div_right", "int.sub_nat_nat_elim", "list.length_map", "nat.sub_mul_mod", "nat.shiftl'_sub", "nat.add_sub_assoc", "int.sub_nat_nat_eq_coe", "nat.bodd_mul", "string.iterator.zero_lt_length_next_to_string_of_has_next", "nat.bit_decomp", "nat.sub_one_sub_lt", "int.mul_pos", "int.eq_succ_of_zero_lt", "nat.one_add", "nat.bodd_bit", "nat.sub_mul_div", "nat.sub.right_comm", "nat.add_mod_left", "nat.test_bit_succ", "nat.div2_bit", "nat.mul_self_sub_mul_self_eq", "nat.mod_add_div", "nat.mod_pow_succ", "nat.le_div_iff_mul_le", "nat.sub_add_cancel", "nat.dvd_add_iff_left", "nat.div_zero", "nat.add_sub_add_left"]}, {"id": "commutative", "parentIds": ["right_comm", "left_comm"]}, {"id": "dlist.to_list_empty", "parentIds": []}, {"id": "id.def", "parentIds": ["dlist.to_list_empty", "mjoin_map_map", "list.map_id", "mjoin_map_pure", "mjoin_map_mjoin", "functor.comp.id_map", "state_t.is_lawful_monad"]}, {"id": "dlist.to_list", "parentIds": ["dlist.to_list_empty", "dlist.to_list_concat", "dlist.to_list_cons", "dlist.of_list_to_list", "parser.mk_error_msg", "dlist.to_list_append", "tactic.enum_assoc_subexpr", "tactic.mk_assoc_pattern", "dlist.to_list_of_list", "tactic.expanded_field_list", "dlist.to_list_singleton"]}, {"id": "vm_decl.olean", "parentIds": []}, {"id": "tactic.cc_dbg_core", "parentIds": ["tactic.cc_dbg"]}, {"id": "has_bind.and_then", "parentIds": ["tactic.cc_dbg_core", "smt_tactic.definev", "parser.one_of'", "smt_tactic.set_goals", "tactic.mk_has_sizeof_instance_core", "transport_multiplicative_to_additive", "old_conv.trace", "tactic.interactive.induction", "tactic.symm_apply", "parser.many'", "old_conv.istep", "to_additive.proceed_fields", "tactic.match_app_of", "tactic.interactive.have_field", "tactic.independent_goal", "ematch_lhs", "smt_tactic.interactive.have", "tactic.generalize_proofs", "parser.sep_by1", "simps_add_projection", "tactic.interactive.unfold_projs", "tactic.interactive.let", "tactic.try_apply_opt_auto_param_for_apply", "tactic.constr_to_prop", "tactic.rintro_parse", "tactic.interactive.set", "well_founded_tactics.default_dec_tac'", "tactic.interactive.letI", "tactic.apply_assumption", "old_conv.match_pattern", "tactic.interactive.obtain_parse", "tactic.interactive.try_for", "tactic.interactive.simp_core_aux", "tactic.trace_error", "doc_blame_report_defn", "tactic.interactive.suffices", "tactic.case_bash", "tactic.by_cases", "tactic.interactive.by_contradiction", "tactic.intro", "tactic.try_apply_opt_auto_param", "old_conv.find_pattern", "conv.solve1", "smt_tactic.interactive.let", "tactic.mk_dec_eq_instance_core", "old_conv.interactive.find", "tactic.interactive.exactI", "smt_tactic.define", "tactic.interactive.substs", "ematch", "control_laws_tac", "tactic.interactive.haveI", "old_conv.save_info", "smt_tactic.assertv", "tactic.suggest.apply_and_solve", "name_with_opt", "tactic.local_def_value", "well_founded_tactics.unfold_sizeof", "tactic.interactive.generalize", "tactic.interactive.use", "tactic.mk_has_reflect_instance", "tactic.interactive.transitivity", "tactic.alias.alias_cmd", "conv.interactive.find", "smt_tactic.istep", "rsimp.collect_implied_eqs", "tactic.interactive.simp_intros", "tactic.interactive.concat_tags", "tactic.by_contradiction", "tactic.interactive.replace", "tactic.interactive.subst", "smt_tactic.assert", "tactic.assertv", "tactic.fsplit", "tactic.subsingleton_goal", "tactic.interactive.intro", "tactic.interactive.convert_to", "tactic.interactive.funext", "parser.ch", "tactic.subst_vars", "tactic.interactive.simp_core", "tactic.interactive.conv_rhs", "tactic.interactive.match_target", "smt_tactic.eblast", "smt_tactic.interactive.eblast_using", "tactic.alias.alias_iff", "conv.interactive.for", "tactic.interactive.simpa", "tactic.interactive.specialize", "smt_tactic.step", "conv.step", "tactic.interactive.rwa", "mk_hinst_lemma_attr_set", "tactic.interactive.introI", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.extract_goal", "smt_tactic.induction", "tactic.interactive.have", "tactic.definev", "tactic.delta_instance", "tactic.mk_inj_eq", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.introv", "tactic.injections_and_clear", "mk_hinst_lemma_attr_core", "conv.interactive.to_lhs", "order_laws_tac", "conv.interactive.to_rhs", "tactic.induction'", "doc_blame_report_thm", "tactic.interactive.introsI", "tactic.interactive.suggest", "old_conv.step", "environment.get_modifiers", "tactic.interactive.conv_lhs", "derive_struct_ext_lemma", "tactic.reduce_ifs_at", "old_conv.mk_match_expr", "conv.discharge_eq_lhs", "well_founded_tactics.default_dec_tac", "transport_with_dict", "old_conv.match_expr"]}, {"id": "tactic.set_bool_option", "parentIds": ["tactic.cc_dbg_core"]}, {"id": "tactic.save_options", "parentIds": ["tactic.cc_dbg_core"]}, {"id": "tactic.cc_core", "parentIds": ["tactic.cc_dbg_core", "tactic.cc"]}, {"id": "le_add_of_nonneg_right", "parentIds": ["eq_zero_of_mul_self_add_mul_self_eq_zero"]}, {"id": "add_zero", "parentIds": ["le_add_of_nonneg_right", "add_lt_of_lt_of_nonpos", "add_right_eq_self", "add_lt_of_le_of_neg", "ring.mul_zero", "bit0_zero", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "add_sub_add_left_eq_sub", "functor.add_const.is_lawful_applicative", "lt_add_of_le_of_pos", "le_add_of_le_of_nonneg", "nat.bodd_add", "add_neg_eq_of_eq_add", "eq_add_neg_of_add_eq", "nat.add_mul_div_left", "nat.bit0_inj", "two_gt_one", "int.sub_nat_nat_eq_coe", "add_self_iff_eq_zero", "int.lt_irrefl", "neg_add_cancel_right", "add_sub_add_right_eq_sub", "int.le_antisymm", "nat.lt_add_of_zero_lt_left", "int.lt_iff_le_and_ne", "nat.add_sub_add_right", "sub_lt_self", "sub_eq_of_eq_add", "sub_eq_of_eq_add'", "add_neg_cancel_right", "add_group.add_right_cancel", "eq_sub_of_add_eq", "sub_zero", "int.eq_coe_of_zero_le", "nat.sub_sub", "int.le_refl", "nat.mod_add_div", "eq_sub_of_add_eq'", "lt_add_of_pos_right", "lt_add_of_lt_of_pos", "sub_le_self", "eq_add_of_sub_eq", "eq_add_of_sub_eq'", "nat.add_mul_mod_self_left", "lt_add_of_lt_of_nonneg", "norm_num.bin_add_zero", "sub_eq_sub_add_sub", "add_lt_of_lt_of_neg", "ring.zero_mul", "neg_eq_of_add_eq_zero", "add_eq_of_eq_sub", "add_le_of_le_of_nonpos"]}, {"id": "tactic.delta", "parentIds": ["tactic.delta_target", "tactic.delta_hyp"]}, {"id": "match_failed", "parentIds": ["tactic.delta", "tactic.focus1", "expr.mk_exists_lst", "tactic.apply_inj_lemma", "smt_tactic.seq", "tactic.seq_focus", "conv.interactive.conv", "tactic.interactive.by_cases", "incorrect_def_lemma", "tactic.mk_dec_eq_instance", "tactic.terminal_goal", "tactic.main_goal", "tactic.choose1", "tactic.constr_to_prop", "tactic.local_proof", "tactic.propositional_goal", "tactic.resolve_constant", "tactic.apply_auto_param", "tactic.change_core", "conv.funext", "old_conv.funext", "tactic.dependent_pose_core", "smt_tactic.focus1", "tactic.explode.may_be_proof", "tactic.rcases_parse", "well_founded_tactics.cancel_nat_add_lt", "old_conv.congr_core", "tactic.interactive.obtain", "tactic.interactive.use", "tactic.relation_lhs_rhs", "tactic.interactive.clear_", "tactic.subsingleton_goal", "tactic.seq", "tactic.interactive.field", "tactic.interactive.get_current_field", "tactic.alias.make_left_right", "conv.congr", "tactic.interactive.case", "tactic.subst", "tactic.apply_opt_param", "well_founded_tactics.check_target_is_value_lt", "tactic.apply_at"]}, {"id": "interaction_monad.monad_fail", "parentIds": ["tactic.delta", "tactic.focus1", "expr.mk_exists_lst", "tactic.apply_inj_lemma", "tactic.seq_focus", "conv.monad_fail", "tactic.interactive.by_cases", "incorrect_def_lemma", "tactic.mk_dec_eq_instance", "tactic.terminal_goal", "tactic.main_goal", "tactic.choose1", "tactic.constr_to_prop", "tactic.local_proof", "tactic.propositional_goal", "tactic.resolve_constant", "tactic.apply_auto_param", "tactic.change_core", "conv.funext", "old_conv.funext", "tactic.dependent_pose_core", "tactic.explode.may_be_proof", "tactic.rcases_parse", "well_founded_tactics.cancel_nat_add_lt", "old_conv.congr_core", "tactic.interactive.obtain", "tactic.interactive.use", "tactic.relation_lhs_rhs", "tactic.interactive.clear_", "tactic.subsingleton_goal", "tactic.seq", "tactic.interactive.field", "tactic.interactive.get_current_field", "tactic.alias.make_left_right", "tactic.interactive.case", "tactic.subst", "tactic.apply_opt_param", "well_founded_tactics.check_target_is_value_lt", "tactic.apply_at"]}, {"id": "tactic.delta_config", "parentIds": ["tactic.delta", "tactic.delta_target", "tactic.delta_config.inhabited", "tactic.delta_hyp", "tactic.delta_instance", "tactic.interactive.delta"]}, {"id": "expr.mk_app", "parentIds": ["tactic.delta", "tactic.instance_cache.mk_app", "tactic.choose1", "expr.is_eta_expansion_of", "tactic.mk_iff_of_inductive_prop", "tactic.dependent_pose_core", "tactic.list_constructors_hole", "tactic.assoc_rewrite", "instance_derive_handler", "conv.congr", "saturate_fun", "derive_struct_ext_lemma"]}, {"id": "expr.get_app_fn", "parentIds": ["tactic.delta", "unused_arguments", "tactic.apply_inj_lemma", "tactic.get_constructors_for", "tactic.interactive.get_rule_eqn_lemmas", "tactic.interactive.induction", "tactic.symmetry_hyp", "tactic.mk_dec_eq_instance", "tactic.instance_stub", "environment.is_refl_app", "tactic.is_type_app_of", "tactic.mk_patterns", "tactic.apply_heq_congr_core", "tactic.list_constructors_hole", "tactic.fold_explicit_args", "tactic.relation_lhs_rhs", "tactic.injection_with", "tactic.interactive.specialize", "tactic.interactive.refine_one", "incorrect_type_class_argument", "expr.is_eta_expansion", "tactic.alias.get_alias_target", "instance_priority", "expr.is_app_of", "tactic.interactive.erase_simp_args", "expr.is_eta_expansion_test", "environment.is_constructor_app", "conv.congr", "tactic.interactive.source_fields", "has_inhabited_instance"]}, {"id": "tactic.dsimplify_core", "parentIds": ["tactic.delta", "tactic.dsimplify", "tactic.unfold_projs"]}, {"id": "expr.get_app_args", "parentIds": ["tactic.delta", "tactic.interactive.induction", "tactic.match_app_of", "tactic.constr_to_prop", "tactic.list_constructors_hole", "tactic.fold_explicit_args", "tactic.relation_lhs_rhs", "expr.is_eta_expansion", "expr.is_eta_expansion_test", "conv.congr"]}, {"id": "tactic.dsimp_config", "parentIds": ["tactic.delta", "tactic.dsimplify", "restate_axiom", "tactic.interactive.dsimp", "tactic.unfold_proj_config.inhabited", "old_conv.dsimp", "tactic.dsimp_hyp", "tactic.interactive.unfold_projs", "tactic.dsimplify_core", "smt_tactic.interactive.dsimp", "tactic.interactive.unfold_aux", "tactic.lift", "conv.dsimp", "tactic.unfold_proj_config", "tactic.dunfold_target", "tactic.dsimp_config.inhabited", "tactic.dunfold_hyp", "tactic.unfold_projs", "expr.dsimp", "well_founded_tactics.unfold_wf_rel", "tactic.dunfold_config.inhabited", "tactic.dsimp_target", "tactic.unfold_projs_target", "tactic.dunfold", "tactic.interactive.dunfold", "tactic.dunfold_config", "tactic.get_lift_prf", "conv.interactive.dsimp", "simp_lemmas.dsimplify", "tactic.unfold_projs_hyp"]}, {"id": "declaration.instantiate_value_univ_params", "parentIds": ["tactic.delta"]}, {"id": "tactic.head_beta", "parentIds": ["tactic.delta", "tactic.choose1", "tactic.suggest.tactic_statement"]}, {"id": "tactic.opt_to_tac", "parentIds": ["tactic.delta", "tactic.explode.append_dep", "tactic.constructor_num_fields", "tactic.interactive.rec.to_tactic_format", "tactic.subobject_names", "tactic.comp_val", "tactic.iff_mpr", "tactic.interactive.return_cast", "tactic.ext1", "expr.is_eta_expansion", "rsimp.rsimplify", "tactic.iff_mp", "tactic.mk_replacer", "tactic.get_mathlib_dir", "tactic.interactive.h_generalize", "derive_struct_ext_lemma", "tactic.suggest.apply_declaration"]}, {"id": "string.quote", "parentIds": ["print_item_crawl", "string.has_repr"]}, {"id": "string.is_empty", "parentIds": ["string.quote"]}, {"id": "string.to_list", "parentIds": ["string.quote", "string.over_list", "string.get_rest", "string.fold", "string.split_on", "string.intercalate", "string.is_suffix_of", "buffer.append_string", "tactic.pformat_macro", "format_macro", "string.is_prefix_of", "parser.str", "sformat_macro", "tactic.alias.make_left_right"]}, {"id": "string.quote_aux", "parentIds": ["string.quote"]}, {"id": "interactive.types.ident_", "parentIds": ["interactive.types.with_ident_list", "apply_nolint_cmd", "tactic.interactive.generalize", "tactic.alias.alias_cmd", "tactic.interactive.simp_intros", "tactic.interactive.intro", "tactic.interactive.funext", "tactic.interactive.introI", "tactic.rcases_patt_parse_core", "tactic.interactive.h_generalize", "tactic.interactive.intros", "tactic.interactive.case", "tactic.interactive.introv", "tactic.interactive.introsI", "tactic.interactive.generalize_proofs"]}, {"id": "bnot_eq_true_eq_eq_ff", "parentIds": []}, {"id": "eq_false_intro", "parentIds": ["bnot_eq_true_eq_eq_ff", "cmp_using_eq_gt", "bnot_eq_ff_eq_eq_tt", "eq_ff_eq_not_eq_tt", "cmp_using_eq_lt", "band_eq_true_eq_eq_tt_and_eq_tt", "d_array.of_beq_aux_eq_tt", "coe_ff", "bor_eq_false_eq_eq_ff_and_eq_ff", "bool.dichotomy", "bool.coe_sort_ff", "eq_tt_eq_not_eq_ff", "eq_false_of_or_eq_false_right", "classical.prop_complete", "d_array.of_beq_aux_eq_ff", "eq_false_of_not_eq_true", "option.mem_to_list", "cmp_swap", "cmp_using_eq_eq", "eq_false_of_or_eq_false_left", "coe_sort_ff", "bor_eq_true_eq_eq_tt_or_eq_tt", "band_eq_false_eq_eq_ff_or_eq_ff"]}, {"id": "bnot", "parentIds": ["bnot_eq_true_eq_eq_ff", "expr.is_arrow", "bool.to_bool_not", "nat.test_bit_ldiff", "bnot_eq_ff_eq_eq_tt", "tactic.interactive.propagate_tags", "nat.bodd_add_div2", "nat.bodd_add", "tactic.clear'", "nat.bodd_succ", "nat.ldiff_bit", "nat.mod_two_of_bodd", "tactic.try_apply_opt_auto_param_for_apply", "int.nat_bitwise", "lint", "nat.bodd_mul", "tactic.explode.may_be_proof", "bool.eq_tt_of_bnot_eq_ff", "tactic.try_apply_opt_auto_param", "bool.eq_ff_of_bnot_eq_tt", "expr.is_eta_expansion_aux", "tactic.simp_intros", "tactic.interactive.cases_type", "tactic.no_mvars_in_target", "bool.bnot_false", "tactic.interactive.concat_tags", "nat.bodd_bit", "bool.bxor_bnot_bnot", "bxor_tt", "nat.ldiff", "linter.doc_blame", "incorrect_type_class_argument", "bool.bnot_true", "ff_bxor", "bool.bxor_bnot_right", "dangerous_instance", "bool.bxor_bnot_left", "bnot_bnot", "lint_mathlib", "lint_all", "tt_bxor"]}, {"id": "if_t_t", "parentIds": []}, {"id": "ne_zero_of_mul_ne_zero_left", "parentIds": ["mul_ne_zero_comm"]}, {"id": "neg_add_le_of_le_add", "parentIds": []}, {"id": "tactic.to_simp_lemmas", "parentIds": ["simp_attr.pre_smt", "tactic.mk_simp_attr", "simp_attr.functor_norm", "simp_attr.norm", "simp_attr.split_if_reduction"]}, {"id": "tactic.interactive.skip", "parentIds": ["tactic.interactive.let", "tactic.interactive.set", "tactic.interactive.library_search", "tactic.interactive.use", "tactic.interactive.transitivity", "tactic.interactive.replace", "tactic.interactive.funext", "tactic.interactive.match_target", "tactic.interactive.swap", "tactic.interactive.have", "tactic.interactive.suggest"]}, {"id": "tactic.skip", "parentIds": ["tactic.interactive.skip", "where.trace_variables", "tactic.back_chaining_using_hs", "transport_multiplicative_to_additive", "tactic.interactive.revert", "ematch_lhs", "tactic.generalize_proofs", "smt_tactic.when", "where.trace_includes", "tactic.mk_iff_of_inductive_prop", "tactic.apply_assumption", "tactic.lift", "tactic.case_bash", "tactic.by_cases", "where.trace_opens", "find_cmd", "ematch", "tactic.back_chaining", "tactic.interactive.generalize", "tactic.try", "tactic.explode_expr", "tactic.interactive.concat_tags", "tactic.by_contradiction", "tactic.fsplit", "tactic.subsingleton_goal", "tactic.interactive.intro", "tactic.back_chaining_using", "tactic.alias.alias_iff", "tactic.swap", "tactic.eapplyc", "mk_hinst_lemma_attr_set", "smt_tactic.by_contradiction", "push_neg.push_neg_at_hyp", "tactic.inhabited_instance", "tactic.applyc", "tactic.interactive.intros", "tactic.rotate_right", "mk_hinst_lemma_attr_core", "derive_struct_ext_lemma", "tactic.reduce_ifs_at", "tactic.import_private_cmd"]}, {"id": "d_array.iterate_aux", "parentIds": ["d_array.iterate"]}, {"id": "norm_num.add_comm_four", "parentIds": []}, {"id": "add_comm_semigroup", "parentIds": ["norm_num.add_comm_four", "norm_num.bit0_add_bit1", "norm_num.add1_bit1", "int.add_comm_semigroup", "norm_num.add_comm_middle", "norm_num.bit1_add_bit0_helper", "add_add_add_comm", "add_comm_semigroup.to_add_semigroup", "norm_num.bit0_add_bit1_helper", "add_comm", "add_comm_semigroup_to_is_eq_commutative", "norm_num.one_add_bit1", "norm_num.add1_bit1_helper", "norm_num.bit0_add_bit0_helper", "norm_num.bit1_add_bit0", "add_right_comm", "norm_num.bit1_add_bit1", "nat.add_comm_semigroup", "norm_num.bit1_add_bit1_helper", "norm_num.one_add_bit1_helper", "add_left_comm", "add_comm_monoid.to_add_comm_semigroup", "norm_num.bit0_add_bit0", "norm_num.one_add_bit0"]}, {"id": "neg_add_self", "parentIds": []}, {"id": "add_left_neg", "parentIds": ["neg_add_self", "neg_lt_neg", "int.sub_nat_nat_eq_coe", "neg_add_cancel_right", "neg_le_neg", "add_eq_zero_iff_eq_neg", "add_right_neg", "neg_add_cancel_left", "neg_neg", "eq_add_of_sub_eq", "neg_eq_of_add_eq_zero", "add_eq_of_eq_sub"]}, {"id": "eq_add_neg_iff_add_eq", "parentIds": ["eq_sub_iff_add_eq"]}, {"id": "add_neg_cancel_right", "parentIds": ["eq_add_neg_iff_add_eq", "sub_right_lt_of_lt_add", "sub_left_le_of_le_add", "add_neg_eq_iff_eq_add", "neg_lt_neg", "neg_le_neg", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "neg_comm_of_comm", "add_sub_cancel", "sub_left_lt_of_lt_add", "le_sub_right_of_add_le", "lt_sub_right_of_add_lt", "lt_sub_left_of_add_lt"]}, {"id": "neg_add_cancel_right", "parentIds": ["eq_add_neg_iff_add_eq", "int.le.dest", "eq_of_sub_eq_zero", "add_right_surjective", "div_le_div_of_mul_sub_mul_div_nonpos", "add_neg_eq_iff_eq_add", "eq_add_of_add_neg_eq", "sub_add_cancel", "add_eq_of_eq_add_neg", "int.neg_succ_of_nat_lt_zero", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "list.join", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.mk_assumption_set", "list.intercalate", "tactic.interactive.refine_struct", "tactic.mk_has_reflect_instance", "tactic.mk_simp_set_core", "list.nil_bind", "tactic.interactive.refine_one", "where.fetch_potential_variable_names", "list.cons_bind", "tactic.module_doc_strings", "list.bind"]}, {"id": "expr.is_annotation", "parentIds": []}, {"id": "tactic.unsafe.type_context.level.instantiate_mvars", "parentIds": []}, {"id": "id.is_comm_applicative", "parentIds": []}, {"id": "is_lawful_applicative", "parentIds": ["id.is_comm_applicative", "comp.map_pure", "option.is_lawful_monad", "applicative_transformation.preserves_map", "applicative.map_seq_map", "functor.add_const.is_lawful_applicative", "bind_pure", "applicative_transformation", "sum.is_lawful_monad", "is_comm_applicative", "parser.is_lawful_monad", "reader_t.is_lawful_monad", "is_comm_applicative.commutative_map", "functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "applicative_transformation.preserves_seq", "comp.applicative_id_comp", "id.is_lawful_monad", "map_seq", "comp.is_comm_applicative", "is_lawful_traversable", "comp.pure_seq_eq_map", "applicative_transformation.has_coe_to_fun", "functor.const.is_lawful_applicative", "applicative.pure_seq_eq_map'", "list.is_lawful_monad", "applicative.ext", "pure_id_seq", "is_lawful_applicative.map_comp_pure", "seq_map_assoc", "comp.applicative_comp_id", "except_t.is_lawful_monad", "pure_id'_seq", "applicative_transformation.preserves_pure", "is_lawful_monad", "comp.is_lawful_applicative", "option_t.is_lawful_monad", "comp.seq_pure", "state_t.is_lawful_monad", "comp.seq_assoc"]}, {"id": "is_comm_applicative", "parentIds": ["id.is_comm_applicative", "is_comm_applicative.commutative_map", "comp.is_comm_applicative"]}, {"id": "function.const", "parentIds": ["id.is_comm_applicative", "comp.applicative", "option.is_lawful_monad", "functor.add_const.is_lawful_applicative", "ulift.functor", "is_lawful_functor", "functor.comp.functor", "parser.alternative", "functor.const.is_lawful_functor", "task.monad", "monad_from_pure_bind", "parser.is_lawful_monad", "sum.monad", "parser.monad", "reader_t.is_lawful_monad", "set.functor", "functor.const.applicative", "except.monad", "state_t.alternative", "tactic.unsafe.type_context.monad", "interaction_monad.monad", "id.is_lawful_monad", "list.monad", "functor.const.is_lawful_applicative", "old_conv.monad", "option.alternative", "exceptional.monad", "list.is_lawful_monad", "applicative.ext", "vm_core.monad", "function.comp_const_right", "id.monad", "reader_t.alternative", "except_t.is_lawful_monad", "except_t.monad", "state_t.monad", "functor.const.functor", "option.monad", "set.is_lawful_functor", "functor.add_const.applicative", "option_t.is_lawful_monad", "option_t.monad", "reader_t.monad", "state_t.is_lawful_monad", "functor.ext", "is_lawful_applicative", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "id_bind", "parentIds": ["id.is_comm_applicative", "id.is_lawful_monad", "id.monad"]}, {"id": "nat.pos_of_ne_zero", "parentIds": ["nat.mul_mod_mul_left", "nat.pos_of_dvd_of_pos", "int.lt_iff_le_and_ne"]}, {"id": "nat.eq_zero_or_pos", "parentIds": ["nat.pos_of_ne_zero", "nat.mul_div_assoc", "int.nat_abs_pos_of_ne_zero", "nat.mod_le", "nat.div_eq_of_lt_le", "nat.sub_mul_div", "nat.mod_eq_sub_mod", "nat.div_div_eq_div_mul", "nat.mul_sub_div"]}, {"id": "comp.applicative", "parentIds": ["comp.applicative_id_comp", "comp.is_comm_applicative", "is_lawful_traversable", "comp.applicative_comp_id", "comp.is_lawful_applicative"]}, {"id": "comp.seq", "parentIds": ["comp.applicative", "comp.has_seq"]}, {"id": "comp.has_pure", "parentIds": ["comp.applicative", "comp.run_pure", "comp.map_pure", "comp.pure_seq_eq_map", "comp.seq_pure"]}, {"id": "functor.comp.map", "parentIds": ["comp.applicative", "functor.comp.functor", "functor.comp.comp_map", "functor.comp.id_map"]}, {"id": "functor.comp", "parentIds": ["comp.applicative", "comp.run_pure", "comp.map_pure", "functor.comp.ext", "functor.comp.functor", "functor.comp.comp_map", "functor.comp.map_mk", "comp.seq_mk", "comp.seq", "comp.has_seq", "functor.comp.map", "comp.run_seq", "functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "comp.applicative_id_comp", "comp.has_pure", "comp.is_comm_applicative", "is_lawful_traversable", "comp.pure_seq_eq_map", "functor.comp.run", "functor.comp.is_lawful_functor", "functor.comp.run_map", "comp.applicative_comp_id", "functor.comp.id_map", "comp.is_lawful_applicative", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "level.occurs", "parentIds": []}, {"id": "nat.mod_lt", "parentIds": ["nat.mod_one", "nat.mod_le", "nat.gcd.induction", "nat.mod_two_eq_zero_or_one"]}, {"id": "nat.linear_order", "parentIds": ["nat.mod_lt", "nat.find_min'", "nat.sub_eq_sub_min", "nat.mul_self_le_mul_self_iff", "nat.lt_of_sub_eq_succ", "nat.mul_mod_mul_left", "nat.mul_self_lt_mul_self_iff", "nat.mod_le", "nat.eq_zero_of_le_zero", "nat.mod_pow_succ", "nat.le_div_iff_mul_le", "nat.div_lt_iff_lt_mul"]}, {"id": "nat.mod_eq_of_lt", "parentIds": ["nat.mod_lt", "nat.mul_mod_mul_left", "nat.mod_le", "nat.mod_pow_succ"]}, {"id": "nat.sub_lt", "parentIds": ["nat.mod_lt", "nat.mul_mod_mul_left", "buffer.lt_aux_2", "nat.sub_lt_of_pos_le", "nat.sub_one_sub_lt", "buffer.lt_aux_3", "nat.mod_add_div"]}, {"id": "nat.succ_pos", "parentIds": ["nat.mod_lt", "nat.le_mul_self", "nat.mod_one", "nat.eq_zero_or_pos", "nat.gcd.induction", "int.pos_of_sign_eq_one", "nat.mul_self_lt_mul_self", "nat.div_mul_le_self", "nat.le_of_dvd", "int.coe_succ_pos", "fin.has_zero", "nat.dvd_antisymm"]}, {"id": "decidable.em", "parentIds": ["nat.mod_lt", "dec_em", "nat.mod_add_div", "dist_bdd_within_interval"]}, {"id": "le_of_not_gt", "parentIds": ["nat.mod_lt", "one_div_le_of_one_div_le_of_neg", "nonneg_of_mul_nonneg_left", "ge_of_forall_ge_sub", "nat.find_min'", "le_of_one_div_le_one_div_of_neg", "not_lt", "le_of_mul_le_mul_right", "le_of_one_div_le_one_div", "nonneg_of_mul_nonneg_right", "le_of_mul_le_mul_left", "nonpos_of_mul_nonpos_left", "cmp_compares", "nonpos_of_mul_nonpos_right", "le_imp_le_of_lt_imp_lt", "nonneg_le_nonneg_of_squares_le"]}, {"id": "nat.le_of_lt_succ", "parentIds": ["nat.mod_lt", "array.push_back_idx", "d_array.of_beq_aux_eq_tt", "nat.mod_one", "nat.pow_le_pow_of_le_right", "nat.div_eq_of_lt_le", "nat.bit1_lt_bit0"]}, {"id": "nat.zero_mod", "parentIds": ["nat.mod_lt", "nat.mul_mod_right", "nat.mod_self", "nat.gcd_zero_right"]}, {"id": "nat.case_strong_induction_on", "parentIds": ["nat.mod_lt"]}, {"id": "nat.mod_eq_sub_mod", "parentIds": ["nat.mod_lt", "nat.sub_mul_mod", "nat.mul_mod_mul_left", "nat.add_mod_right", "nat.mod_self", "nat.mod_pow_succ"]}, {"id": "pempty.elim", "parentIds": ["subsingleton_pempty", "not_nonempty_pempty"]}, {"id": "pempty", "parentIds": ["pempty.elim", "subsingleton_pempty", "not_nonempty_pempty", "forall_pempty", "exists_pempty", "pempty.decidable_eq"]}, {"id": "format.of_options", "parentIds": ["options.has_to_format"]}, {"id": "list.not_bex_nil", "parentIds": []}, {"id": "tactic.i_to_expr_strict", "parentIds": ["tactic.interactive.try_for", "tactic.interactive.exact", "tactic.interactive.simpa", "tactic.interactive.clean", "tactic.interactive.choose"]}, {"id": "not_not_em", "parentIds": []}, {"id": "non_contradictory_em", "parentIds": ["not_not_em"]}, {"id": "is_valid_char_range_1", "parentIds": []}, {"id": "div_le_div_of_le_of_pos", "parentIds": []}, {"id": "one_div_pos_of_pos", "parentIds": ["div_le_div_of_le_of_pos", "div_lt_of_mul_lt_of_pos", "one_le_div_of_le", "lt_div_of_mul_lt", "one_lt_div_of_lt", "le_div_of_mul_le", "div_mul_le_div_mul_of_div_le_div_pos", "one_div_le_of_one_div_le_of_pos", "div_mul_le_div_mul_of_div_le_div_pos'", "div_nonpos_of_nonpos_of_pos", "div_pos_of_pos_of_pos", "div_lt_div_of_lt_of_pos", "pos_of_one_div_pos", "div_nonneg_of_nonneg_of_pos", "div_le_of_le_mul", "div_neg_of_neg_of_pos"]}, {"id": "mul_sub_mul_div_mul_nonpos", "parentIds": []}, {"id": "div_sub_div", "parentIds": ["mul_sub_mul_div_mul_nonpos", "div_le_div_of_mul_sub_mul_div_nonpos", "mul_sub_mul_div_mul_neg", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "comm_semigroup.to_semigroup", "parentIds": ["mul_sub_mul_div_mul_nonpos", "mul_self_sub_one_eq", "div_sub_div", "nat.add_mul_mod_self_right", "mul_dvd_mul", "nat.eq_of_mul_eq_mul_right", "nat.bodd_add_div2", "field.one_div_mul_one_div", "nat.add_mul_div_right", "abs_sub_square", "dvd_of_mul_left_dvd", "div_mul_eq_mul_div", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "mul_inv", "one_dvd", "mul_div_cancel_left", "mul_left_comm", "comm_semigroup_to_is_commutative", "mul_le_mul_of_mul_div_le", "one_div_lt_one_div_of_lt_of_neg", "add_mul_self_eq", "div_mul_left", "mul_sub_mul_div_mul_neg", "int.distrib_left", "nat.div_mul_cancel", "mul_right_comm", "dvd.intro_left", "le_mul_of_ge_one_left", "field.div_mul_left", "neg_dvd_of_dvd", "nat.mul_le_mul_right", "dvd_trans", "nat.dvd_of_mul_dvd_mul_right", "field.div_mul_div", "dvd_mul_of_dvd_right", "nat.mul_mod_left", "nat.mul_lt_mul_of_pos_right", "nat.div_lt_self", "nat.mul_div_left", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "one_div_lt_one_div_of_lt", "field.div_mul_right", "mul_eq_mul_of_div_eq_div", "nat.mul_self_sub_mul_self_eq", "mul_div_mul_right'", "mul_comm", "mul_div_cancel'", "nat.mul_div_cancel_left", "mul_div_mul_right", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "nat.mod_pow_succ", "mul_mul_mul_comm", "nat.mul_mod_mul_right", "nat.shiftl'_tt_eq_mul_pow", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "mul_comm", "parentIds": ["mul_sub_mul_div_mul_nonpos", "mul_self_sub_one_eq", "nat.shiftl_eq_mul_pow", "div_sub_div", "nat.add_mul_mod_self_right", "mul_dvd_mul", "dvd_mul_left", "nat.eq_of_mul_eq_mul_right", "nat.bodd_add_div2", "field.one_div_mul_one_div", "nat.add_mul_div_right", "abs_sub_square", "dvd_of_mul_left_dvd", "div_mul_eq_mul_div", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "mul_inv", "one_dvd", "mul_div_cancel_left", "mul_left_comm", "comm_semigroup_to_is_commutative", "mul_le_mul_of_mul_div_le", "one_div_lt_one_div_of_lt_of_neg", "add_mul_self_eq", "div_mul_left", "exists_eq_mul_left_of_dvd", "mul_sub_mul_div_mul_neg", "int.distrib_left", "nat.div_mul_cancel", "mul_right_comm", "dvd.intro_left", "le_mul_of_ge_one_left", "field.div_mul_left", "neg_dvd_of_dvd", "nat.mul_le_mul_right", "dvd_trans", "nat.dvd_of_mul_dvd_mul_right", "field.div_mul_div", "dvd_mul_of_dvd_right", "nat.mul_mod_left", "nat.mul_lt_mul_of_pos_right", "nat.div_lt_self", "nat.mul_div_left", "mul_self_sub_mul_self_eq", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "nat.bodd_bit", "one_div_lt_one_div_of_lt", "field.div_mul_right", "mul_eq_mul_of_div_eq_div", "nat.mul_self_sub_mul_self_eq", "mul_div_mul_right'", "mul_div_cancel'", "nat.mul_div_cancel_left", "mul_div_mul_right", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "nat.mod_pow_succ", "nat.mul_mod_mul_right", "nat.shiftl'_tt_eq_mul_pow", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "comm_ring.to_comm_semigroup", "parentIds": ["mul_sub_mul_div_mul_nonpos", "mul_self_sub_one_eq", "div_sub_div", "field.one_div_mul_one_div", "abs_sub_square", "div_mul_eq_mul_div", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "mul_div_cancel_left", "mul_le_mul_of_mul_div_le", "one_div_lt_one_div_of_lt_of_neg", "add_mul_self_eq", "div_mul_left", "mul_sub_mul_div_mul_neg", "le_mul_of_ge_one_left", "field.div_mul_left", "neg_dvd_of_dvd", "field.div_mul_div", "mul_self_sub_mul_self_eq", "one_div_lt_one_div_of_lt", "field.div_mul_right", "mul_eq_mul_of_div_eq_div", "mul_div_mul_right'", "mul_div_cancel'", "mul_div_mul_right", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "int.comm_semigroup", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "sub_self", "parentIds": ["mul_sub_mul_div_mul_nonpos", "sub_eq_zero_of_eq", "div_two_sub_self", "mul_sub_mul_div_mul_neg", "sub_eq_zero", "mul_self_eq_mul_self_iff"]}, {"id": "sub_le_sub_right", "parentIds": ["mul_sub_mul_div_mul_nonpos"]}, {"id": "field.to_comm_ring", "parentIds": ["mul_sub_mul_div_mul_nonpos", "div_sub_div", "field.one_div_mul_one_div", "div_mul_eq_mul_div", "div_le_div_of_mul_sub_mul_div_nonpos", "one_div_mul_one_div", "mul_div_cancel_left", "mul_le_mul_of_mul_div_le", "one_div_lt_one_div_of_lt_of_neg", "div_mul_left", "mul_sub_mul_div_mul_neg", "le_mul_of_ge_one_left", "field.div_mul_left", "field.div_mul_div", "one_div_lt_one_div_of_lt", "field.div_mul_right", "mul_eq_mul_of_div_eq_div", "mul_div_mul_right'", "mul_div_cancel'", "mul_div_mul_right", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "nat.eq_zero_or_eq_succ_pred", "parentIds": ["nat.exists_eq_succ_of_ne_zero"]}, {"id": "zero_ne_one", "parentIds": ["nat.eq_zero_or_eq_succ_pred", "one_div_one", "one_div_ne_zero", "field.div_mul_eq_mul_div_comm", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "division_ring.one_div_neg_eq_neg_one_div", "nat.cond_to_bool_mod_two"]}, {"id": "or_true", "parentIds": ["nat.eq_zero_or_eq_succ_pred", "or_eq_of_eq_true_right", "bool.bor_inr", "prod.lex_def"]}, {"id": "nat.pred_succ", "parentIds": ["nat.eq_zero_or_eq_succ_pred", "nat.mul_pred_left", "nat.sub_mul_div"]}, {"id": "or_false", "parentIds": ["nat.eq_zero_or_eq_succ_pred", "false_or", "bool.dichotomy", "or_eq_of_eq_false_right", "option.mem_to_list", "bool.to_bool_or", "bor_eq_true_eq_eq_tt_or_eq_tt", "band_eq_false_eq_eq_ff_or_eq_ff"]}, {"id": "nat.nat_zero_eq_zero", "parentIds": ["nat.eq_zero_or_eq_succ_pred", "nat.test_bit_bitwise", "nat.bodd_add", "nat.mul_div_right", "nat.add_mul_div_left", "nat.sub_mul_mod", "nat.bodd_mul", "nat.sub_mul_div", "nat.gcd_zero_right", "nat.gcd_rec", "nat.add_mul_mod_self_left", "nat.le_div_iff_mul_le", "list.length_repeat", "nat.gcd_self", "nat.gcd_def"]}, {"id": "string.popn_back", "parentIds": ["tactic.get_mathlib_dir"]}, {"id": "string.iterator.prevn", "parentIds": ["string.popn_back", "string.backn"]}, {"id": "tactic.focus1", "parentIds": ["tactic.rintro_hint", "tactic.interactive.with_cases", "tactic.cases", "tactic.interactive.propagate_tags", "tactic.rcases_hint", "tactic.interactive.focus", "tactic.interactive.induction", "tactic.interactive.cases_matching", "tactic.local_proof", "tactic.interactive.cases_core", "tactic.rintro", "tactic.use", "tactic.interactive.use", "tactic.interactive.cases_type", "tactic.solve_by_elim", "rsimp.collect_implied_eqs", "tactic.iterate_at_most_on_subgoals", "tactic.rcases", "tactic.interactive.constructor_matching", "tactic.subst_vars"]}, {"id": "tactic.set_goals", "parentIds": ["tactic.focus1", "tactic.rintro_hint", "tactic.interactive.recover", "smt_tactic.set_goals", "tactic.rcases_hint", "tactic.cleanup", "tactic.seq_focus", "tactic.interactive.convert", "conv.interactive.conv", "tactic.clear'", "tactic.elim_gen_sum", "tactic.try_apply_opt_auto_param_for_apply", "tactic.local_proof", "tactic.solve_aux", "tactic.rintro", "tactic.interactive.refine_struct", "tactic.dependent_pose_core", "tactic.abstract", "tactic.try_apply_opt_auto_param", "smt_tactic.slift_aux", "tactic.interactive.obtain", "tactic.rcases", "tactic.solve1", "tactic.interactive.refine_one", "tactic.interactive.swap", "tactic.prove_goal_async", "tactic.swap", "tactic.seq", "tactic.interactive.field", "conv.congr", "tactic.interactive.case", "conv.convert", "tactic.resolve_name'", "conv.discharge_eq_lhs", "tactic.apply_at"]}, {"id": "tactic.get_goals", "parentIds": ["tactic.focus1", "tactic.focus", "tactic.interactive.propagate_tags", "tactic.cleanup", "tactic.seq_focus", "tactic.interactive.convert", "conv.interactive.conv", "tactic.interactive.by_cases", "tactic.clear'", "tactic.elim_gen_sum", "tactic.terminal_goal", "tactic.main_goal", "tactic.try_apply_opt_auto_param_for_apply", "tactic.local_proof", "tactic.solve_aux", "tactic.propositional_goal", "tactic.get_goal", "tactic.interactive.refine_struct", "tactic.dependent_pose_core", "tactic.abstract", "tactic.try_apply_opt_auto_param", "smt_tactic.slift_aux", "tactic.interactive.obtain", "tactic.all_goals", "tactic.interactive.show", "smt_tactic.get_goals", "tactic.subsingleton_goal", "tactic.repeat", "tactic.solve1", "tactic.interactive.refine_one", "tactic.interactive.swap", "tactic.swap", "tactic.seq", "tactic.interactive.field", "conv.congr", "tactic.interactive.case", "conv.convert", "tactic.any_goals", "tactic.resolve_name'", "tactic.num_goals", "tactic.apply_at"]}, {"id": "ne_of_eq_of_ne", "parentIds": []}, {"id": "eq.subst", "parentIds": ["ne_of_eq_of_ne", "add_lt_of_lt_of_nonpos", "ne_of_mem_of_not_mem", "add_lt_of_le_of_neg", "le_of_eq", "int.lt.intro", "add_nonpos", "nat.eq_zero_of_add_eq_zero_left", "eq.symm", "not_imp_eq_of_eq_false_right", "nat.le_add_left", "nat.lt_or_ge", "lt_add_of_le_of_pos", "neg_le_abs_self", "le_add_of_le_of_nonneg", "and_eq_of_eq_true_left", "int.zero_mul", "and_eq_of_eq_true_right", "congr_fun", "ne_false_of_self", "imp_eq_of_eq_false_right", "imp_eq_of_eq_false_left", "ne_true_of_not", "le_add_of_nonneg_of_le", "add_lt_of_nonpos_of_lt", "classical.cases_true_false", "lt_add_of_pos_of_le", "right_comm", "max_eq_right", "lt_of_not_ge", "ne_of_gt", "add_lt_of_neg_of_lt", "false_ne_true", "nat.add_self_ne_one", "nat.le_of_eq", "neg_lt_neg", "nat.add_comm", "nat.one_le_bit0", "sub_lt_of_abs_sub_lt_right", "eq.substr", "add_neg_of_nonpos_of_neg", "add_le_add_right", "iff_eq_true_of_eq", "lt_add_of_nonneg_of_lt", "imp_eq_true_of_eq", "trans_rel_right", "not_of_eq_false", "option.is_none_iff_eq_none", "string.str_ne_str_right", "neg_le_neg", "mul_le_of_le_div", "false_of_true_eq_false", "add_neg_of_neg_of_nonpos", "and_eq_of_eq_false_right", "iff_subst", "nat.bit1_ne_bit0", "ne_of_ne_of_eq", "int.one_mul", "not_eq_of_eq_false", "add_le_of_nonpos_of_le", "add_neg", "forall_eq", "exists_eq_left", "eq_zero_of_neg_eq", "incomp_iff_eq", "list.lt_eq_not_ge", "mul_lt_of_gt_div_of_neg", "or_eq_of_eq_true_right", "nat.le.intro", "iff_of_eq", "le_of_not_gt", "nat.mul_lt_mul_of_pos_left", "le_of_lt_or_eq", "nat.mul_le_mul_right", "add_pos_of_nonneg_of_pos", "nat.add_lt_add_right", "int.zero_add", "imp_eq_of_eq_true_left", "and_eq_of_eq_false_left", "lt_or_ge", "or_eq_of_eq_false_left", "nat.mul_lt_mul_of_pos_right", "eq_zero_of_abs_eq_zero", "mul_le_of_div_le_of_neg", "nat.lt_iff_le_not_le", "function.left_inverse_of_surjective_of_right_inverse", "ne_zero_of_abs_ne_zero", "nat.le.dest", "of_eq_true", "ne_of_lt", "nat.bit0_ne_one", "add_pos", "abs_pos_of_neg", "neq_of_not_iff", "eq_iff_le_not_lt", "int.le_total", "sub_le_of_abs_sub_le_right", "or_eq_of_eq_false_right", "add_nonneg", "lt_add_of_pos_of_lt", "eq_true", "and_eq_of_eq", "or_eq_of_eq", "abs_by_cases", "trans_rel_left", "mul_lt_of_lt_div", "iff_eq_of_eq_true_left", "heq_of_eq_rec_right", "lt_of_neg_lt_neg", "iff_eq_of_eq_true_right", "imp_eq_of_eq_true_right", "pos_of_one_div_pos", "lt_add_of_lt_of_pos", "eq_of_one_div_eq_one_div", "min_eq_right", "add_pos_of_pos_of_nonneg", "nat.sub_lt", "list.ball_cons", "neg_of_one_div_neg", "add_lt_of_neg_of_le", "lt_add_of_lt_of_nonneg", "nat.add_lt_add_left", "decidable_eq_inr_neg", "eq_false", "function.partial_inv_of_injective", "add_lt_of_lt_of_neg", "eq.trans", "not_eq_of_eq_true", "function.cantor_injective", "or_eq_of_eq_true_left", "congr", "function.funext_iff", "heq_of_eq", "add_le_of_le_of_nonpos", "left_comm"]}, {"id": "add_lt_of_lt_of_nonpos", "parentIds": []}, {"id": "min_neg_neg", "parentIds": ["max_eq_neg_min_neg_neg"]}, {"id": "min", "parentIds": ["min_neg_neg", "list.length_take_le", "min_eq_left_of_lt", "le_min", "max_eq_neg_min_neg_neg", "eq_min", "nat.sub_eq_sub_min", "lt_min", "min_eq_left", "min_comm", "min_add_add_right", "list.length_take", "min_add_add_left", "min_le_right", "nat.zero_min", "min_assoc", "min_left_comm", "min_eq_neg_max_neg_neg", "nat.sub_add_min_cancel", "nat.min_zero", "list.length_map\u2082", "list.length_map_accumr\u2082", "min_self", "min_eq_right", "min_eq_right_of_lt", "min_le_left", "nat.min_succ_succ", "max_neg_neg"]}, {"id": "neg_neg", "parentIds": ["min_neg_neg", "abs_sub_square", "neg_inj'", "le_neg_of_le_neg", "le_of_neg_le_neg", "max_eq_neg_min_neg_neg", "neg_sub_neg", "neg_neg_sub_neg", "left_inverse_neg", "sub_sub_assoc_swap", "sub_sub_self", "neg_dvd_of_dvd", "abs_neg", "add_right_neg", "dvd_of_neg_dvd", "neg_involutive", "int.le_total", "lt_neg_of_lt_neg", "division_ring.neg_div_neg_eq", "min_eq_neg_max_neg_neg", "neg_lt_of_neg_lt", "neg_inj", "norm_num.neg_mul_neg_helper", "lt_of_neg_lt_neg", "eq_neg_of_add_eq_zero", "norm_num.neg_add_neg_helper", "neg_mul_neg", "norm_num.neg_neg_helper", "sub_add", "dvd_of_dvd_neg", "division_ring.one_div_neg_eq_neg_one_div", "sub_neg_eq_add", "eq_neg_of_eq_neg", "add_neg_eq_zero", "neg_le_of_neg_le"]}, {"id": "min_eq_neg_max_neg_neg", "parentIds": ["min_neg_neg"]}, {"id": "int.le.dest", "parentIds": ["int.eq_succ_of_zero_lt", "int.le.elim"]}, {"id": "int.add_comm_semigroup", "parentIds": ["int.le.dest", "int.lt_add_succ", "int.sub_nat_nat_eq_coe", "int.le.intro", "int.lt.dest", "int.neg_succ_of_nat_lt_zero"]}, {"id": "int.le.dest_sub", "parentIds": ["int.le.dest", "int.eq_coe_of_zero_le"]}, {"id": "exists.intro", "parentIds": ["int.le.dest", "dvd.intro", "array.read_mem", "exists_add_lt_and_pos_of_lt", "exists_unique.intro", "exists_eq_mul_left_of_dvd", "function.surjective_comp", "int.lt.dest"]}, {"id": "array.has_to_format", "parentIds": []}, {"id": "array.to_list", "parentIds": ["array.has_to_format", "array.has_to_tactic_format", "array.has_repr", "buffer.to_list", "buffer.to_string"]}, {"id": "print_content", "parentIds": []}, {"id": "environment.fold", "parentIds": ["print_content", "environment.mfold", "environment.decl_filter_map", "print_all_content", "tactic.local_decls", "where.get_all_in_namespace", "tactic.module_doc_strings"]}, {"id": "name.is_internal", "parentIds": ["print_content", "lint", "print_all_content", "tactic.suggest.process_declaration", "lint_mathlib", "lint_all"]}, {"id": "environment.in_current_file'", "parentIds": ["print_content", "lint", "declaration.in_current_file", "tactic.local_decls"]}, {"id": "declaration.to_name", "parentIds": ["print_content", "incorrect_def_lemma", "print_decls", "simps_tac", "lint", "print_all_content", "declaration.in_current_file", "tactic.decl_mk_const", "environment.get_decl_names", "print_item_crawl", "tactic.suggest.process_declaration", "list_linters", "declaration.is_auto_generated", "linter.doc_blame", "tactic.alias.alias_iff", "fold_over_with_cond_sorted", "impossible_instance", "instance_priority", "tactic.local_decls", "where.get_all_in_namespace", "dangerous_instance", "tactic.find_private_decl", "lint_mathlib", "lint_all", "has_inhabited_instance", "dup_namespace", "tactic.module_doc_strings"]}, {"id": "print_item_crawl", "parentIds": ["print_content", "print_all_content", "print_name"]}, {"id": "band", "parentIds": ["print_content", "tt_band", "nat.test_bit_ldiff", "band_eq_true_eq_eq_tt_and_eq_tt", "bool.band_comm", "tactic.clear'", "list.all", "nat.ldiff_bit", "nat.mod_two_of_bodd", "environment.in_current_file", "tactic.in_open_namespaces", "nat.bodd_mul", "bool.band_elim_left", "bool.to_bool_and", "nat.land", "nat.land_bit", "band_self", "nat.bodd_bit", "nat.ldiff", "list_linters", "bool.band_intro", "nat.test_bit_land", "band_coe_iff", "environment.in_current_file'", "bool.band_assoc", "bool.band_left_comm", "bool.band_elim_right", "environment.is_constructor_app", "band_ff", "ff_band", "dangerous_instance", "band_tt", "band_eq_false_eq_eq_ff_or_eq_ff"]}, {"id": "list.filter", "parentIds": ["print_content", "unused_arguments", "tactic.mk_assumption_set", "tactic.non_dep_prop_hyps", "list.filter_cons_of_neg", "list.filter_append", "list.filter_nil", "list.remove_all", "tactic.mk_patterns", "print_all_content", "check_unused_arguments", "list.filter_sublist", "tactic.mk_simp_set_core", "list.inter", "list.filter_cons_of_pos", "tactic.interactive.refine_one", "impossible_instance", "get_checks", "tactic.interactive.case", "tactic.interactive.source_fields", "tactic.rename'", "has_inhabited_instance", "list.partition_eq_filter_filter"]}, {"id": "tactic.rintro_hint", "parentIds": ["tactic.interactive.rintro"]}, {"id": "tactic.rcases_hint.continue", "parentIds": ["tactic.rintro_hint"]}, {"id": "tactic.goals", "parentIds": ["tactic.rintro_hint", "tactic.rcases_hint.process_constructors", "tactic.rcases_hint", "tactic.rintro", "tactic.rcases_hint_core", "tactic.rcases_hint.continue", "tactic.rcases.continue", "tactic.rcases", "tactic.rcases_core"]}, {"id": "tactic.intros", "parentIds": ["tactic.rintro_hint", "tactic.cc_core", "control_laws_tac", "instance_derive_handler", "tactic.delta_instance", "tactic.interactive.intros", "order_laws_tac"]}, {"id": "algebra.div", "parentIds": ["division_ring_has_div"]}, {"id": "division_ring", "parentIds": ["division_ring_has_div", "division_def", "mul_ne_zero_comm", "mul_inv_eq", "mul_eq_of_eq_div", "one_div_eq_inv", "inv_ne_zero", "division_ring.to_has_inv", "div_mul_cancel", "div_self", "algebra.div", "division_ring.one_div_one_div", "add_div_eq_mul_add_div", "one_div_one", "mul_one_div_cancel", "zero_div", "eq_div_of_mul_eq", "one_div_ne_zero", "one_inv_eq", "mul_inv_cancel", "field.to_division_ring", "division_ring.one_div_div", "one_div_mul_cancel", "div_eq_mul_one_div", "one_div_neg_one_eq_neg_one", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "mul_div_assoc", "division_ring.mul_ne_zero", "division_ring.neg_div_neg_eq", "division_ring.to_ring", "div_eq_one_iff_eq", "div_add_div_same", "div_one", "mul_div_cancel", "eq_of_div_eq_one", "inv_mul_cancel", "division_ring.eq_of_one_div_eq_one_div", "division_ring.inv_inv", "neg_div", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_neg_eq_neg_div", "div_sub_div_same", "eq_one_div_of_mul_eq_one_left", "division_ring.to_zero_ne_one_class", "eq_one_div_of_mul_eq_one", "mul_mul_div", "division_ring.one_div_mul_one_div", "inv_eq_one_div", "division_ring.one_div_neg_eq_neg_one_div", "eq_div_iff_mul_eq"]}, {"id": "local_context.is_subset", "parentIds": []}, {"id": "local_context", "parentIds": ["local_context.is_subset", "local_context.mk_local", "local_context.get_local_decl", "local_context.lc_has_to_format", "tactic.unsafe.type_context.mk_mvar", "local_context.to_list", "tactic.unsafe.type_context.get_context", "local_context.to_format", "local_context.fold", "local_context.get_local", "tactic.unsafe.type_context.get_local_context"]}, {"id": "tactic.flat_assoc", "parentIds": []}, {"id": "is_strict_weak_order_of_is_total_preorder", "parentIds": ["is_strict_weak_order_of_decidable_linear_order"]}, {"id": "refl_of", "parentIds": ["is_strict_weak_order_of_is_total_preorder"]}, {"id": "is_total_preorder", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "has_le.le.is_total_preorder", "is_total_preorder_is_preorder"]}, {"id": "is_strict_weak_order", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "is_strict_weak_order_of_decidable_linear_order", "strict_weak_order.etrans", "lt_of_incomp_of_lt", "strict_weak_order.is_equiv", "strict_weak_order.esymm", "strict_weak_order.erefl", "is_strict_total_order", "lt_of_lt_of_incomp", "strict_weak_order.not_lt_of_equiv'", "strict_weak_order.not_lt_of_equiv"]}, {"id": "trans_of", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "lt_of_incomp_of_lt", "not_lt_of_lt", "lt_of_lt_of_incomp"]}, {"id": "not_iff_not_of_iff", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "if_ctx_congr_prop", "if_ctx_congr", "mul_self_lt_mul_self_iff", "nat.mul_self_lt_mul_self_iff", "dif_ctx_congr", "dif_ctx_simp_congr", "nat.div_lt_iff_lt_mul"]}, {"id": "is_total_preorder_is_preorder", "parentIds": ["is_strict_weak_order_of_is_total_preorder"]}, {"id": "is_strict_order", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "cmp_using_eq_gt", "lt_of_incomp_of_lt", "is_strict_weak_order", "not_lt_of_lt", "strict_weak_order.erefl", "lt_of_lt_of_incomp"]}, {"id": "decidable.of_not_not", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "decidable.not_not_iff"]}, {"id": "is_preorder", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "strict_weak_order.is_equiv", "eq_is_equiv", "is_partial_order", "is_equiv", "is_total_preorder_is_preorder"]}, {"id": "is_irrefl", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "eqv_lt_iff_eq", "irrefl_of", "is_asymm_of_is_trans_of_is_irrefl", "incomp_iff_eq", "irrefl", "is_strict_order"]}, {"id": "is_trans", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "is_preorder", "is_asymm_of_is_trans_of_is_irrefl", "has_le.le.is_total_preorder", "trans", "strict_weak_order.is_equiv", "is_per", "is_strict_order", "eq_is_equiv", "is_total_preorder", "trans_of", "is_total_preorder_is_preorder"]}, {"id": "total_of", "parentIds": ["is_strict_weak_order_of_is_total_preorder"]}, {"id": "is_incomp_trans", "parentIds": ["is_strict_weak_order_of_is_total_preorder", "is_strict_weak_order", "incomp_trans", "incomp_trans_of"]}, {"id": "nat.div_eq_of_lt", "parentIds": ["nat.div2_bit", "nat.le_div_iff_mul_le"]}, {"id": "nat.decidable_le", "parentIds": ["nat.div_eq_of_lt", "nat.div_def", "buffer.take", "char.to_lower", "nat.sub_eq_sub_min", "nat.div_def_aux", "nat.mod_eq_of_lt", "nat.mul_self_le_mul_self_iff", "buffer.drop", "char.decidable_is_digit", "nat.zero_mod", "nat.decidable_lt", "buffer.take_right", "char.decidable_is_upper", "nat.mod_zero", "char.decidable_le", "char.decidable_is_lower", "nat.decidable_linear_ordered_semiring", "nat.div_eq_sub_div", "nat.zero_div", "nat.mod_def_aux", "nat.mod_add_div", "nat.mod_eq_sub_mod", "char.quote_core", "fin.decidable_le", "tactic.suggest", "nat.mod_def", "nat.div_zero", "nat.min_succ_succ"]}, {"id": "if_neg", "parentIds": ["nat.div_eq_of_lt", "max_self", "max_lt", "le_min", "le_max_left", "list.filter_cons_of_neg", "lt_min", "nat.mod_eq_of_lt", "nat.zero_mod", "max_le", "min_le_right", "nat.mod_zero", "if_false", "if_eq_of_eq_false", "nat.zero_div", "nat.mod_add_div", "min_self", "min_le_left", "implies_of_if_neg", "nat.min_succ_succ", "le_max_right"]}, {"id": "nat.has_div", "parentIds": ["nat.div_eq_of_lt", "nat.mul_div_mul", "nat.lcm", "nat.mul_div_assoc", "nat.div_def", "nat.add_div_left", "nat.add_mul_div_right", "nat.mul_div_right", "nat.shiftr_eq_div_pow", "nat.mod_two_of_bodd", "nat.add_mul_div_left", "nat.div_def_aux", "nat.zero_shiftr", "nat.div_le_of_le_mul", "nat.div_mul_cancel", "nat.div_eq_of_eq_mul_right", "nat.mul_div_cancel'", "nat.dvd_mod_iff", "nat.add_div_right", "nat.div_lt_self", "nat.div2_val", "nat.mul_div_left", "nat.div_eq_of_lt_le", "nat.div_le_self", "nat.sub_mul_div", "char_to_hex", "nat.div2_bit", "nat.div_eq_sub_div", "nat.dvd_of_mod_eq_zero", "nat.zero_div", "nat.mod_add_div", "nat.mul_div_cancel_left", "nat.div_self", "nat.div_mul_le_self", "nat.div_eq_of_eq_mul_left", "fin.div_def", "nat.mod_pow_succ", "nat.le_div_iff_mul_le", "nat.div_lt_iff_lt_mul", "nat.div_zero", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "nat.div_one", "nat.mul_div_cancel"]}, {"id": "nat.div_def", "parentIds": ["nat.div_eq_of_lt", "nat.div_eq_sub_div", "nat.zero_div", "nat.mod_add_div", "nat.div_zero"]}, {"id": "old_conv", "parentIds": ["old_conv.interactive.trace_state", "old_conv.skip", "old_conv.failed", "old_conv.repeat", "old_conv.execute", "old_conv.trace", "old_conv.findp", "old_conv.first", "old_conv.dsimp", "old_conv.istep", "old_conv.change", "old_conv.apply_propext_lemmas", "old_conv.apply_lemmas_core", "old_conv.orelse", "old_conv.to_tactic", "old_conv.conversion", "old_conv.apply_propext_simp_set", "old_conv.apply_lemmas", "old_conv.trace_lhs", "old_conv.match_pattern", "old_conv.funext", "old_conv.find_pattern", "old_conv.interactive.find", "old_conv.interactive.whnf", "old_conv.lhs", "old_conv.save_info", "old_conv.alternative", "old_conv.congr_core", "old_conv.apply_propext_lemmas_core", "old_conv.monad", "old_conv.apply_simp_set", "old_conv.whnf", "old_conv.find", "old_conv.top_down", "old_conv.bind", "old_conv.bottom_up", "old_conv.pure", "old_conv.seq", "old_conv.step", "old_conv.congr", "old_conv.interactive.dsimp", "old_conv.fail", "old_conv.map", "old_conv.interactive.change", "old_conv.lift_tactic", "old_conv.mk_match_expr", "old_conv.interactive.itactic", "old_conv.match_expr"]}, {"id": "old_conv_result", "parentIds": ["old_conv", "old_conv.failed", "old_conv.trace", "old_conv.findp", "old_conv.dsimp", "old_conv.istep", "old_conv.change", "old_conv.apply_lemmas_core", "old_conv.orelse", "old_conv.to_tactic", "old_conv.match_pattern", "old_conv.funext", "old_conv.find_pattern", "old_conv.interactive.find", "old_conv.lhs", "old_conv.save_info", "old_conv.congr_core", "old_conv.apply_propext_lemmas_core", "old_conv.whnf", "old_conv.find", "old_conv.top_down", "old_conv.bind", "old_conv.bottom_up", "old_conv.pure", "old_conv.seq", "old_conv.fail", "old_conv.map", "old_conv.lift_tactic", "old_conv.mk_match_expr", "old_conv.match_expr"]}, {"id": "ne_of_mem_of_not_mem", "parentIds": []}, {"id": "mt", "parentIds": ["ne_of_mem_of_not_mem", "not_and_of_not_left", "int.nat_abs_pos_of_ne_zero", "lt_of_add_lt_add_left", "function.inv_fun_neg", "function.injective.ne", "iff_false_left", "not_not_of_not_imp", "exists_prop_of_false", "not_imp_not", "to_bool_congr", "lt_of_le_of_ne'", "add_lt_add_left", "not.imp", "classical.em", "not_of_not_imp", "not_and_of_not_right"]}, {"id": "semiring.to_add_comm_monoid", "parentIds": ["int.add_comm_monoid", "mul_self_sub_one_eq", "add_midpoint", "abs_sub_square", "dvd_add_iff_right", "exists_add_lt_and_pos_of_lt", "nat.lt_add_of_pos_left", "nat.add_comm_monoid", "nat.bit0_inj", "add_mul_self_eq", "mul_self_sub_mul_self_eq", "distrib_three_right", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "one_div_add_one_div", "norm_num.mul_bit1"]}, {"id": "add_comm_monoid", "parentIds": ["semiring.to_add_comm_monoid", "int.add_comm_monoid", "linear_ordered_semiring", "decidable_linear_ordered_semiring", "add_comm_group.to_add_comm_monoid", "ordered_cancel_comm_monoid.to_add_comm_monoid", "nat.add_comm_monoid", "decidable_linear_ordered_cancel_comm_monoid", "add_comm_monoid.to_add_monoid", "ordered_semiring", "ordered_cancel_comm_monoid", "add_comm_monoid.to_add_comm_semigroup"]}, {"id": "tactic.interactive.with_cases", "parentIds": []}, {"id": "tactic.all_goals", "parentIds": ["tactic.interactive.with_cases", "tactic.cases", "conv.interactive.conv", "tactic.interactive.induction", "tactic.mk_dec_eq_instance_core", "tactic.interactive.all_goals", "tactic.apply_congr_core", "tactic.instantiate_mvars_in_goals", "tactic.inhabited_instance", "tactic.seq"]}, {"id": "tactic.interactive.itactic", "parentIds": ["tactic.interactive.with_cases", "tactic.interactive.any_goals", "tactic.interactive.focus", "tactic.interactive.continue", "tactic.interactive.abstract", "tactic.interactive.success_if_fail", "tactic.interactive.repeat", "tactic.interactive.iterate", "tactic.interactive.try_for", "tactic.interactive.all_goals", "tactic.interactive.success_if_fail_with_msg", "tactic.interactive.async", "tactic.interactive.try", "tactic.interactive.field", "tactic.interactive.fail_if_success", "tactic.interactive.case", "tactic.interactive.solve1"]}, {"id": "tactic.with_enable_tags", "parentIds": ["tactic.interactive.with_cases", "tactic.interactive.propagate_tags", "tactic.interactive.refine_one"]}, {"id": "division_def", "parentIds": ["mul_inv_eq", "div_mul_eq_mul_div", "one_div_zero", "div_mul_cancel", "div_self", "mul_one_div_cancel", "zero_div", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "div_eq_mul_one_div", "mul_div_assoc", "div_eq_one_iff_eq", "div_one", "mul_div_cancel", "div_neg_eq_neg_div", "one_div_add_one_div", "mul_mul_div"]}, {"id": "division_ring.to_has_inv", "parentIds": ["division_def", "mul_inv_eq", "mul_zero_lt_mul_inv_of_neg", "one_div_eq_inv", "div_mul_eq_mul_div", "inv_ne_zero", "one_div_zero", "div_mul_cancel", "div_self", "mul_zero_lt_mul_inv_of_pos", "algebra.div", "mul_one_div_cancel", "zero_div", "one_inv_eq", "mul_inv_cancel", "field.div_mul_div", "division_ring.one_div_div", "one_div_mul_cancel", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_mul_one_div", "inv_zero", "mul_inv'", "mul_div_assoc", "field.div_mul_right", "div_eq_one_iff_eq", "div_add_div_same", "div_one", "mul_div_cancel", "inv_mul_cancel", "division_ring.inv_inv", "div_neg_eq_neg_div", "one_div_add_one_div", "mul_mul_div", "inv_eq_one_div"]}, {"id": "nat.semiring", "parentIds": ["nat.mul_div_assoc", "nat.bit0_val", "nat.mul_div_right", "nat.add_mul_div_left", "nat.sub_mul_mod", "nat.mul_mod_mul_left", "nat.bodd_mul", "nat.mul_pred_left", "nat.div_eq_of_lt_le", "nat.sub_mul_div", "nat.mul_sub_right_distrib", "nat.mod_add_div", "nat.zero_shiftl", "nat.div_mul_le_self", "nat.add_mul_mod_self_left", "nat.zero_pow", "nat.le_div_iff_mul_le", "nat.div_div_eq_div_mul", "nat.mul_sub_div"]}, {"id": "nat.decidable_linear_ordered_semiring", "parentIds": ["nat.semiring", "list.length_take_le", "nat.bit1_lt", "nat.add_comm_monoid", "nat.sub_eq_sub_min", "nat.bit0_inj", "nat.ordered_semiring", "nat.div_le_of_le_mul", "list.length_take", "nat.distrib", "nat.zero_min", "nat.bit0_lt", "tactic.explode.pad_right", "nat.monoid", "nat.bit0_lt_bit1", "nat.sub_add_min_cancel", "nat.min_zero", "list.length_map\u2082", "list.length_map_accumr\u2082", "nat.eq_of_mul_eq_mul_left", "nat.decidable_linear_ordered_cancel_comm_monoid", "nat.bit1_lt_bit0", "nat.min_succ_succ"]}, {"id": "decidable_linear_ordered_semiring.to_linear_ordered_semiring", "parentIds": ["nat.semiring", "nat.bit1_lt", "nat.add_comm_monoid", "nat.bit0_inj", "nat.ordered_semiring", "nat.div_le_of_le_mul", "nat.distrib", "nat.bit0_lt", "nat.monoid", "nat.bit0_lt_bit1", "nat.eq_of_mul_eq_mul_left", "nat.bit1_lt_bit0"]}, {"id": "string.iterator", "parentIds": ["string.iterator.extract", "string.iterator.set_curr", "string.iterator.next_to_string", "string.iterator.length_next_to_string_next", "string.iterator.curr", "string.iterator.prevn", "string.iterator.nextn", "string.iterator.has_next", "string.iterator.next", "string.iterator.zero_lt_length_next_to_string_of_has_next", "string.iterator.prev", "name.deinternalize_field", "string.iterator.insert", "string.iterator.remove", "string.iterator.has_prev", "string.iterator.prev_to_string", "string.iterator.to_string", "string.iterator.inhabited", "string.iterator.to_end", "string.mk_iterator"]}, {"id": "string.iterator_imp", "parentIds": ["string.iterator", "string.iterator.length_next_to_string_next", "string.iterator.zero_lt_length_next_to_string_of_has_next", "string.iterator_imp.inhabited"]}, {"id": "name_set.size", "parentIds": []}, {"id": "norm_num.bit0_add_bit1", "parentIds": []}, {"id": "array.rev_foldl", "parentIds": ["array.to_list"]}, {"id": "abs_mul_abs_self", "parentIds": ["abs_sub_square", "abs_abs_sub_abs_le_abs_sub", "abs_mul_self"]}, {"id": "linear_ordered_comm_ring.to_integral_domain", "parentIds": ["abs_mul_abs_self", "abs_sub_square", "int.eq_one_of_mul_eq_self_left", "abs_mul", "abs_div", "eq_zero_of_mul_self_add_mul_self_eq_zero", "int.eq_one_of_mul_eq_self_right", "abs_abs_sub_abs_le_abs_sub", "abs_mul_self"]}, {"id": "abs_by_cases", "parentIds": ["abs_mul_abs_self", "abs_le_of_le_of_neg_le", "abs_lt_of_lt_of_neg_lt"]}, {"id": "ordered_ring.to_ring", "parentIds": ["abs_mul_abs_self", "mul_lt_mul_of_neg_left", "abs_sub_square", "sub_le_of_abs_sub_le_left", "mul_lt_mul_of_neg_right", "sub_lt_of_abs_sub_lt_right", "abs_mul", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "sub_lt_of_abs_sub_lt_left", "ordered_ring.mul_le_mul_of_nonneg_right", "gt_of_mul_lt_mul_neg_left", "zero_gt_neg_one", "sub_le_of_abs_sub_le_right", "eq_zero_of_mul_self_add_mul_self_eq_zero", "ordered_ring.mul_lt_mul_of_pos_right", "ordered_ring.mul_le_mul_of_nonneg_left", "abs_abs_sub_abs_le_abs_sub", "ordered_ring.mul_lt_mul_of_pos_left", "mul_le_mul_of_nonpos_right"]}, {"id": "decidable_linear_ordered_comm_ring", "parentIds": ["abs_mul_abs_self", "abs_sub_square", "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "sub_le_of_abs_sub_le_left", "sub_lt_of_abs_sub_lt_right", "abs_mul", "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_comm_group", "sub_lt_of_abs_sub_lt_left", "int.decidable_linear_ordered_comm_ring", "discrete_linear_ordered_field.to_discrete_field", "sub_le_of_abs_sub_le_right", "eq_zero_of_mul_self_add_mul_self_eq_zero", "discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring", "decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring", "abs_abs_sub_abs_le_abs_sub", "abs_mul_self"]}, {"id": "neg_mul_neg", "parentIds": ["abs_mul_abs_self", "abs_mul", "one_div_neg_one_eq_neg_one", "mul_self_eq_mul_self_iff"]}, {"id": "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_comm_group", "parentIds": ["abs_mul_abs_self", "abs_one_div", "abs_sub_square", "sub_le_of_abs_sub_le_left", "sub_lt_of_abs_sub_lt_right", "abs_mul", "sub_lt_of_abs_sub_lt_left", "abs_div", "sub_le_of_abs_sub_le_right", "int.decidable_linear_ordered_comm_group", "abs_abs_sub_abs_le_abs_sub", "abs_mul_self"]}, {"id": "pexpr.get_uninst_pis", "parentIds": []}, {"id": "imp_or_distrib'", "parentIds": []}, {"id": "imp_congr_eq", "parentIds": ["imp_or_distrib'", "string.iterator.zero_lt_length_next_to_string_of_has_next", "function.injective_prod", "d_array.of_beq_eq_tt", "d_array.of_beq_eq_ff", "forall_eq'", "nat.eq_zero_of_add_eq_zero_right"]}, {"id": "imp_true_iff", "parentIds": ["imp_or_distrib'"]}, {"id": "or_iff_right_of_imp", "parentIds": ["imp_or_distrib'"]}, {"id": "tactic.revertible_local_context", "parentIds": ["tactic.rename'"]}, {"id": "list.after", "parentIds": ["tactic.revertible_local_context"]}, {"id": "tactic.local_context", "parentIds": ["tactic.revertible_local_context", "well_founded_tactics.clear_internals", "tactic.injections_with", "tactic.find_assumption", "tactic.mk_assumption_set", "tactic.interactive.loc.get_local_pp_names", "tactic.back_chaining_using_hs", "has_dup", "tactic.interactive.apply_assumption", "tactic.non_dep_prop_hyps", "tactic.generalize_proofs", "tactic.match_hypothesis", "tactic.interactive.unfold_projs", "tactic.revert_all", "tactic.extract_def", "tactic.apply_assumption", "tactic.kdependencies", "tactic.clear_aux_decl", "tactic.interactive.guard_hyp_nums", "tactic.case_bash", "tactic.any_hyp", "tactic.contradiction", "interactive.loc.get_locals", "tactic.interactive.clear_", "tactic.collect_ctx_simps", "tactic.prove_goal_async", "tactic.assumption", "tactic.interactive.dunfold", "tactic.interactive.extract_goal", "tactic.interactive.clear_except", "tactic.injections_and_clear", "tactic.interactive.push_neg", "dedup", "tactic.interactive.delta"]}, {"id": "tactic.frozen_local_instances", "parentIds": ["tactic.revertible_local_context", "tactic.revert_all"]}, {"id": "nat.bitwise_zero", "parentIds": []}, {"id": "nat.bitwise", "parentIds": ["nat.bitwise_zero", "nat.test_bit_bitwise", "int.nat_bitwise", "nat.bitwise_zero_left", "nat.bitwise_swap", "nat.bitwise_zero_right", "nat.lor", "nat.bitwise_bit", "nat.land", "nat.lxor", "nat.ldiff"]}, {"id": "nat.bitwise_zero_left", "parentIds": ["nat.bitwise_zero", "nat.bitwise_swap"]}, {"id": "cond", "parentIds": ["nat.bitwise_zero", "int.bit", "nat.bodd_add_div2", "nat.mod_two_of_bodd", "int.nat_bitwise", "nat.bitwise_zero_left", "nat.bitwise", "nat.bit", "tactic.interactive.set", "monad.whenb", "nat.bit_decomp", "nat.bitwise_swap", "nat.bitwise_zero_right", "nat.bitwise_bit", "nat.bitwise_bit_aux", "bool.cond_ff", "bool.has_to_string", "bool.cond_tt", "bool.cond_to_bool", "nat.div2_val", "nat.bodd_bit", "nat.div2_bit", "nat.bit_val", "monad.unlessb", "nat.div2_succ", "cond_a_a", "bool.has_repr", "mcond", "nat.cond_to_bool_mod_two", "expr.of_nat"]}, {"id": "tactic.apply_iff", "parentIds": []}, {"id": "tactic.iff_mp", "parentIds": ["tactic.apply_iff"]}, {"id": "tactic.apply", "parentIds": ["tactic.apply_iff", "tactic.symm_apply", "tactic.left", "tactic.interactive.generalize_hyp", "tactic.constructor_idx", "tactic.right", "tactic.fapply", "tactic.by_cases", "tactic.suggest.apply_and_solve", "tactic.interactive.use", "tactic.apply_congr_core", "tactic.fsplit", "tactic.interactive.mapply", "tactic.interactive.apply_with", "tactic.split", "smt_tactic.by_contradiction", "tactic.applyc", "tactic.interactive.apply", "tactic.eapply"]}, {"id": "tactic.iff_mpr", "parentIds": ["tactic.apply_iff"]}, {"id": "mul_lt_mul_of_neg_left", "parentIds": []}, {"id": "lt_of_neg_lt_neg", "parentIds": ["mul_lt_mul_of_neg_left", "mul_lt_mul_of_neg_right", "neg_of_neg_pos", "pos_of_neg_neg"]}, {"id": "ordered_ring.to_zero_ne_one_class", "parentIds": ["mul_lt_mul_of_neg_left", "mul_nonneg_of_nonpos_of_nonpos", "div_nonneg_of_nonpos_of_neg", "abs_sub_square", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "mul_self_lt_mul_self_iff", "mul_lt_mul_of_neg_right", "mul_self_le_mul_self_iff", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "one_div_neg_of_neg", "mul_pos_of_neg_of_neg", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "ordered_ring.mul_le_mul_of_nonneg_right", "norm_num.nonzero_of_neg_helper", "mul_le_of_div_le_of_neg", "gt_of_mul_lt_mul_neg_left", "zero_gt_neg_one", "ordered_ring.mul_lt_mul_of_pos_right", "ordered_ring.mul_le_mul_of_nonneg_left", "mul_self_nonneg", "nonneg_le_nonneg_of_squares_le", "abs_abs_sub_abs_le_abs_sub", "ordered_ring.mul_lt_mul_of_pos_left", "pos_and_pos_or_neg_and_neg_of_mul_pos", "mul_le_mul_of_nonpos_right"]}, {"id": "mul_lt_mul_of_pos_left", "parentIds": ["mul_lt_mul_of_neg_left", "nat.mul_mod_mul_left", "le_of_mul_le_mul_left", "lt_mul_of_gt_one_right", "mul_neg_of_pos_of_neg", "mul_lt_mul'"]}, {"id": "ordered_ring", "parentIds": ["mul_lt_mul_of_neg_left", "mul_nonneg_of_nonpos_of_nonpos", "ordered_ring.to_ordered_comm_group", "mul_lt_mul_of_neg_right", "linear_ordered_comm_ring", "ordered_ring.to_zero_ne_one_class", "discrete_linear_ordered_field", "linear_ordered_ring", "mul_pos_of_neg_of_neg", "mul_le_mul_of_nonpos_left", "linear_ordered_ring.to_ordered_ring", "ordered_ring.mul_le_mul_of_nonneg_right", "ordered_ring.mul_lt_mul_of_pos_right", "ordered_ring.mul_le_mul_of_nonneg_left", "decidable_linear_ordered_comm_ring", "ordered_ring.to_ordered_semiring", "linear_ordered_field", "ordered_ring.mul_lt_mul_of_pos_left", "ordered_ring.to_ring", "mul_le_mul_of_nonpos_right"]}, {"id": "neg_pos_of_neg", "parentIds": ["mul_lt_mul_of_neg_left", "mul_lt_mul_of_neg_right", "eq_zero_of_neg_eq", "abs_pos_of_neg", "neg_of_one_div_neg"]}, {"id": "prod.decidable_eq", "parentIds": ["unused_arguments"]}, {"id": "comp.run_pure", "parentIds": ["comp.map_pure", "comp.pure_seq_eq_map", "comp.seq_pure"]}, {"id": "functor.comp.run", "parentIds": ["comp.run_pure", "comp.map_pure", "functor.comp.ext", "comp.run_seq", "comp.pure_seq_eq_map", "functor.comp.run_map", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "file_name", "parentIds": ["print_item_crawl"]}, {"id": "nat.one_ne_zero", "parentIds": ["nat.bit0_ne_one"]}, {"id": "string.iterator.extract", "parentIds": []}, {"id": "tactic.mllist.m_of_list", "parentIds": ["tactic.mllist.squash"]}, {"id": "tactic.mllist", "parentIds": ["tactic.mllist.m_of_list", "tactic.mllist.empty", "tactic.mllist.head", "tactic.mllist.force", "tactic.mllist.enum_from", "tactic.mllist.map", "tactic.mllist.enum", "tactic.mllist.filter", "tactic.mllist.fix", "tactic.mllist.squash", "tactic.mllist.range", "tactic.mllist.concat", "tactic.suggest_core", "tactic.mllist.of_list", "tactic.mllist.fixl_with", "tactic.mllist.bind_", "tactic.mllist.uncons", "tactic.mllist.mmap", "tactic.mllist.filter_map", "tactic.mllist.monad_lift", "tactic.mllist.join", "tactic.mllist.mfirst", "tactic.mllist.take", "tactic.mllist.mfilter", "tactic.mllist.append", "tactic.mllist.mfilter_map", "tactic.suggest", "tactic.mllist.fixl"]}, {"id": "auto_param_eq", "parentIds": []}, {"id": "infer_type_cmd", "parentIds": []}, {"id": "tactic.fail", "parentIds": ["infer_type_cmd", "to_additive.target_name", "tactic.interactive.trivial", "tactic.existsi", "tactic.cc_core", "tactic.get_constructors_for", "tactic.apply_instance", "tactic.match_or", "tactic.clear'", "restate_axiom_cmd", "tactic.symmetry_hyp", "to_additive.proceed_fields", "use_cmd", "tactic.left", "tactic.interactive.triv", "tactic.assoc_refl", "ematch_lhs", "tactic.terminal_goal", "smt_tactic.monad_fail", "simps_add_projection", "tactic.interactive.unfold_projs", "tactic.choose1", "old_conv.conversion", "tactic.match_eq", "tactic.get_goal", "tactic.interactive.congr_core'", "tactic.interactive.change'", "tactic.mk_iff_of_inductive_prop", "tactic.apply_assumption", "tactic.constructor_idx", "tactic.unprime", "tactic.interactive.guard_hyp_nums", "tactic.lift", "tactic.abstract", "tactic.interactive.simp_core_aux", "tactic.right", "tactic.match_heq", "tactic.by_cases", "tactic.mk_inhabited_instance", "tactic.explode", "tactic.subobject_names", "old_conv.interactive.find", "tactic.interactive.simp_rw", "tactic.eqn_stub", "tactic.ac_refl", "tactic.match_not", "ematch", "smt_tactic.slift_aux", "tactic.match_ne", "rsimp.rsimplify_at", "tactic.revert_and_transform", "tactic.local_def_value", "tactic.use", "smt_tactic.fail", "tactic.interactive.obtain", "tactic.contradiction", "tactic.mk_has_reflect_instance", "tactic.match_and", "tactic.alias.alias_cmd", "conv.interactive.find", "tactic.interactive.simp_intros", "tactic.iff_mpr", "tactic.unfold_projs", "tactic.by_contradiction", "tactic.match_iff", "tactic.match_refl_app", "tactic.fsplit", "get_linters", "tactic.injection_with", "tactic.fail_if_no_goals", "tactic.interactive.change", "tactic.match_stub", "tactic.mk_simp_set_core", "tactic.simp_hyp", "tactic.solve1", "tactic.interactive.simpa", "tactic.ext1", "tactic.interactive.specialize", "tactic.prove_goal_async", "tactic.split", "tactic.iff_mp", "tactic.assumption", "tactic.mk_assoc_instance", "mk_hinst_lemma_attr_set", "instance_derive_handler", "tactic.inhabited_instance", "tactic.interactive.h_generalize", "tactic.get_lift_prf", "tactic.interactive.case", "tactic.injections_and_clear", "mk_hinst_lemma_attr_core", "conv.convert", "tactic.find_private_decl", "tactic.rename'", "tactic.replacer_attr", "equiv_type_constr", "tactic.interactive.suggest", "old_conv.fail", "tactic.done", "tactic.ids_to_simp_arg_list", "tactic.congr_core"]}, {"id": "exists_prop_decidable", "parentIds": []}, {"id": "fin.has_one", "parentIds": []}, {"id": "smt_tactic.iterate_exactly", "parentIds": []}, {"id": "native.rb_set", "parentIds": ["native.rb_set.erase", "expr.dedup_size", "native.rb_set.size", "expr_set", "native.rb_set.mfilter", "mk_expr_set", "native.rb_set.fold", "native.rb_set.contains", "level.dedup_size_aux", "native.rb_set.mfold", "native.rb_set.has_to_format", "native.rb_set.union", "level.dedup_size", "native.rb_set.inhabited", "native.mk_rb_set", "native.rb_set.insert", "native.rb_set.filter", "native.rb_set.to_list", "expr.dedup_size_aux", "native.rb_set.empty", "expr.lift"]}, {"id": "add_lt_of_lt_neg_add", "parentIds": []}, {"id": "add_lt_add_left", "parentIds": ["add_lt_of_lt_neg_add", "neg_add_lt_of_lt_add", "neg_lt_neg", "two_gt_one", "add_lt_add", "sub_lt_self", "sub_lt_sub_left", "lt_add_of_neg_add_lt", "add_lt_add_of_le_of_lt", "add_lt_add_right", "lt_add_of_pos_right", "lt_neg_add_of_add_lt", "add_lt_of_lt_sub_left"]}, {"id": "add_neg_cancel_left", "parentIds": ["add_lt_of_lt_neg_add", "add_eq_of_eq_sub'", "add_le_of_le_neg_add", "left_inverse_add_right_neg_add", "neg_add_eq_iff_eq_add", "sub_sub_self", "le_add_of_neg_add_le", "lt_add_of_neg_add_lt", "add_left_surjective", "eq_add_of_neg_add_eq", "eq_neg_add_iff_add_eq", "add_eq_of_eq_neg_add"]}, {"id": "ite.decidable", "parentIds": []}, {"id": "and_imp", "parentIds": ["not_and"]}, {"id": "smt_tactic.failed", "parentIds": ["smt_tactic.swap"]}, {"id": "smt_tactic.has_coe", "parentIds": ["smt_tactic.failed", "smt_tactic.definev", "smt_tactic.interactive.destruct", "smt_tactic.trace_state", "smt_tactic.interactive.guard_target", "smt_tactic.trace", "smt_tactic.interactive.have", "smt_tactic.monad_fail", "smt_tactic.when", "smt_tactic.pose", "smt_tactic.add_ematch_lemma_core", "smt_tactic.interactive.trace", "smt_tactic.interactive.dsimp", "smt_tactic.proof_for", "smt_tactic.to_expr", "smt_tactic.interactive.add_simp_lemmas", "smt_tactic.interactive.let", "smt_tactic.define", "smt_tactic.save_info", "smt_tactic.assertv", "smt_tactic.fail", "smt_tactic.note", "rsimp.collect_implied_eqs", "smt_tactic.assert", "smt_tactic.get_goals", "smt_tactic.interactive.apply", "smt_tactic.read", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "smt_tactic.interactive.rsimp", "smt_tactic.interactive.simp", "smt_tactic.interactive.apply_instance", "smt_tactic.interactive.change", "smt_tactic.interactive.add_fact", "smt_tactic.destruct", "smt_tactic.interactive.by_cases", "smt_tactic.refutation_for", "smt_tactic.interactive.exact", "smt_tactic.add_ematch_lemma_from_decl_core", "smt_tactic.interactive.fapply"]}, {"id": "native.float.infinity", "parentIds": []}, {"id": "tactic.apply_cfg.inhabited", "parentIds": []}, {"id": "nat.bit_zero", "parentIds": ["nat.bitwise_bit_aux"]}, {"id": "nat.bit", "parentIds": ["nat.bit_zero", "nat.shiftl'_add", "nat.lxor_bit", "nat.test_bit_bitwise", "nat.ldiff_bit", "nat.binary_rec_eq", "nat.lor_bit", "nat.binary_rec_zero", "nat.bitwise_zero_left", "nat.bitwise", "nat.shiftl'_sub", "nat.bit_decomp", "nat.bit_cases_on", "nat.bitwise_swap", "nat.bitwise_zero_right", "nat.bitwise_bit", "nat.bitwise_bit_aux", "nat.land_bit", "nat.bodd_bit", "nat.test_bit_succ", "nat.div2_bit", "nat.bit_val", "nat.test_bit_zero", "nat.binary_rec"]}, {"id": "functor.map_const_rev", "parentIds": ["succeeds", "expr.mfoldl", "tactic.interactive.ext1", "mtry", "tactic.interactive.ext", "tactic.match_fn"]}, {"id": "unsigned.has_mod", "parentIds": []}, {"id": "fin.mod", "parentIds": ["unsigned.has_mod", "fin.mod_def", "fin.has_mod"]}, {"id": "char.decidable_eq", "parentIds": ["string.get_rest", "string.map_tokens", "tactic.unprime", "string.split_on", "char.decidable_is_punctuation", "name.deinternalize_field", "string.is_suffix_of", "parser.one_of", "string.has_decidable_eq", "tactic.interactive.clear_", "parser.ch", "string.is_prefix_of", "char.decidable_is_whitespace", "char.quote_core", "tactic.alias.make_left_right"]}, {"id": "le_refl", "parentIds": ["nat.pow_le_pow_of_le_left", "le_of_eq", "abs_add_three", "exists_ge_of_linear", "nat.sub_le_sub_left", "list.length_le_of_sublist", "int.zero_nonneg", "nat.le_mul_self", "le_max_left", "lt_of_not_ge", "nat.pow_le_pow_of_le_right", "min_eq_left", "nat.mod_le", "eq_of_forall_ge_iff", "le_of_not_gt", "add_le_add_three", "le_of_lt_or_eq", "min_le_right", "lt_or_ge", "nat.div_lt_self", "abs_zero", "max_eq_left", "nat.mod_self", "le_abs_self", "le_of_forall_le'", "le_of_forall_le", "nat.le_of_sub_eq_zero", "d_array.of_beq_eq_tt", "one_div_le_one_div_of_le", "nat.div_mul_le_self", "d_array.of_beq_eq_ff", "one_div_le_one_div_of_le_of_neg", "eq_of_forall_le_iff", "int.le_nat_abs", "min_le_left", "nat.div_div_eq_div_mul", "le_max_right"]}, {"id": "nat.lt_le_antisymm", "parentIds": []}, {"id": "nat.le_lt_antisymm", "parentIds": ["nat.lt_le_antisymm", "nat.nat.lt_asymm"]}, {"id": "tactic.interactive.rsimp", "parentIds": []}, {"id": "hinst_lemmas", "parentIds": ["tactic.interactive.rsimp", "smt_tactic.ematch_using", "mk_hinst_singleton", "ematch_lhs", "mk_hinst_lemma_attr_from_simp_attr", "smt_tactic.mk_ematch_eqn_lemmas_for_core", "rsimp_attr", "smt_tactic.interactive.add_simp_lemmas", "merge_hinst_lemma_attrs", "ematch", "hinst_lemmas.fold", "smt_tactic.add_lemmas", "rsimp.collect_implied_eqs", "smt_tactic.get_lemmas", "hinst_lemmas.pp", "get_hinst_lemmas_for_attr", "to_hinst_lemmas_core", "smt_tactic.interactive.eblast_using", "hinst_lemmas.has_to_tactic_format", "tactic.rsimp", "mk_hinst_lemma_attr_set", "tactic.rsimp_at", "smt_tactic.interactive.ematch_using", "smt_tactic.set_lemmas", "mk_hinst_lemma_attr_core", "smt_tactic.add_ematch_eqn_lemmas_for_core", "hinst_lemmas.add", "hinst_lemmas.merge"]}, {"id": "rsimp.config", "parentIds": ["tactic.interactive.rsimp", "rsimp.config.inhabited", "rsimp.collect_implied_eqs", "tactic.rsimp", "tactic.rsimp_at"]}, {"id": "tactic.rsimp", "parentIds": ["tactic.interactive.rsimp"]}, {"id": "if_ctx_simp_congr", "parentIds": ["if_simp_congr"]}, {"id": "if_ctx_congr", "parentIds": ["if_ctx_simp_congr", "if_congr"]}, {"id": "linter.incorrect_type_class_argument", "parentIds": []}, {"id": "linter", "parentIds": ["linter.incorrect_type_class_argument", "linter.unused_arguments", "linter.impossible_instance", "lint", "linter.dup_namespace", "linter_attr", "linter.ge_or_gt", "linter.has_inhabited_instance", "linter.doc_blame_thm", "get_linters", "list_linters", "lint_aux", "linter.doc_blame", "get_checks", "linter.def_lemma", "linter.instance_priority", "lint_mathlib", "lint_all", "linter.dangerous_instance"]}, {"id": "incorrect_type_class_argument", "parentIds": ["linter.incorrect_type_class_argument"]}, {"id": "extensional_attribute", "parentIds": ["tactic.ext1"]}, {"id": "name_map", "parentIds": ["extensional_attribute", "to_additive.target_name", "name_map.inhabited", "mk_name_map", "tactic.instance_cache", "copy_decl_updating_type", "tactic.transport_with_prefix_dict", "to_additive.map_namespace", "to_additive.aux_attr", "copy_decl_using", "tactic.ext1", "tactic.local_decls", "tactic.rename'", "transport_with_dict"]}, {"id": "ext_param_type", "parentIds": ["extensional_attribute", "opt_minus", "ext_param", "tactic.ext1"]}, {"id": "tactic.interactive.rw_rule.has_reflect", "parentIds": ["tactic.interactive.rw_rules_t.has_reflect"]}, {"id": "tactic.interactive.rw_rule", "parentIds": ["tactic.interactive.rw_rule.has_reflect", "tactic.interactive.get_rule_eqn_lemmas", "tactic.interactive.rw_rule_p", "tactic.lift", "tactic.interactive.simp_rw", "tactic.interactive.rw_rules_t.has_reflect", "tactic.interactive.rw_rules", "tactic.interactive.rw_rules_t"]}, {"id": "pos.has_reflect", "parentIds": ["tactic.interactive.rw_rule.has_reflect", "tactic.interactive.rw_rules_t.has_reflect"]}, {"id": "option_to_tactic_format", "parentIds": ["option.has_to_tactic_format"]}, {"id": "subsingleton.elim", "parentIds": ["subsingleton.helim", "bool.to_bool_false", "bool.to_bool_true", "pi.subsingleton", "bool.to_bool_coe"]}, {"id": "subsingleton", "parentIds": ["subsingleton.elim", "subsingleton.helim", "quotient.rec_on_subsingleton\u2082", "pi.subsingleton", "quot.rec_on_subsingleton", "decidable.subsingleton", "subsingleton_prop", "subsingleton_pempty", "punit.subsingleton", "empty.subsingleton", "decidable_eq_of_subsingleton", "quotient.rec_on_subsingleton", "rec_subsingleton"]}, {"id": "as_true", "parentIds": ["of_as_true"]}, {"id": "function.surjective.of_comp", "parentIds": []}, {"id": "list.decidable_ball", "parentIds": ["list.decidable_pairwise"]}, {"id": "not.decidable", "parentIds": ["list.decidable_ball", "bool.to_bool_not", "tactic.mk_assumption_set", "not_forall_not", "list.remove_all", "list.has_decidable_le", "tactic.mk_simp_set_core", "tactic.interactive.refine_one", "environment.in_current_file'", "list_items", "nat.mod_two_eq_zero_or_one", "list.partition_eq_filter_filter"]}, {"id": "thunk", "parentIds": ["scope_trace", "tactic.timetac", "try_for", "dlist.lazy_of_list", "trace", "trace_call_stack", "parser.decorate_errors", "parser.decorate_error", "timeit"]}, {"id": "tactic.rewrite_core", "parentIds": ["tactic.rewrite"]}, {"id": "tactic.rewrite_cfg", "parentIds": ["tactic.rewrite_core", "tactic.rewrite", "tactic.interactive.convert_to_core", "tactic.lift", "tactic.rewrite_hyp", "conv.interactive.rw", "tactic.rewrite_cfg.inhabited", "tactic.interactive.erw", "tactic.interactive.erewrite", "tactic.assoc_rewrite", "tactic.rewrite_target", "conv.interactive.erw", "conv.interactive.rewrite", "tactic.interactive.rwa", "tactic.interactive.rw", "tactic.interactive.h_generalize", "tactic.interactive.rewrite"]}, {"id": "mk_simp_attr_decl_name", "parentIds": ["tactic.mk_simp_attr", "tactic.get_user_simp_lemmas"]}, {"id": "int.nat_abs_of_nat", "parentIds": []}, {"id": "int.nat_abs", "parentIds": ["int.nat_abs_of_nat", "int.nat_abs_bit1_nonneg_step", "int.nat_abs_mul_self", "int.nat_abs_eq", "int.ne_of_nat_ne_nonneg_case", "int.nat_abs_add_neg", "int.nat_abs_pos_of_ne_zero", "int.nat_abs_add_nonneg", "int.eq_coe_or_neg", "int.nat_abs_bit0_step", "int.of_nat_nat_abs_of_nonpos", "int.of_nat_nat_abs_eq_of_nonneg", "int.nat_abs_neg", "int.nat_abs_bit0", "int.abs_eq_nat_abs", "int.sign_mul_abs", "int.nat_abs_of_nat_core", "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "int.nat_abs_bit1_nonneg", "int.eq_nat_abs_of_zero_le", "int.sign_mul_nat_abs", "int.nat_abs_of_nonneg", "int.nat_abs_one", "int.nat_abs_of_neg_succ_of_nat", "int.le_nat_abs", "int.gcd", "int.eq_zero_of_nat_abs_eq_zero", "int.nat_abs_abs", "int.nat_abs_zero"]}, {"id": "add_right_eq_self", "parentIds": []}, {"id": "add_left_cancel", "parentIds": ["add_right_eq_self", "ring.mul_zero", "add_left_injective", "int.lt_irrefl", "int.add_lt_add_left", "int.le_antisymm", "add_left_inj", "add_left_cancel_iff", "ring.zero_mul", "eq_of_add_eq_add_left"]}, {"id": "add_group.to_left_cancel_add_semigroup", "parentIds": ["add_right_eq_self", "ring.mul_zero", "add_self_iff_eq_zero", "int.lt_irrefl", "int.add_lt_add_left", "int.le_antisymm", "sub_left_inj", "ring.zero_mul"]}, {"id": "add_left_cancel_semigroup.to_add_semigroup", "parentIds": ["add_right_eq_self", "add_left_injective", "add_self_iff_eq_zero", "add_left_inj", "add_left_cancel_iff", "sub_left_inj", "add_left_cancel", "eq_of_add_eq_add_left"]}, {"id": "superset", "parentIds": []}, {"id": "has_subset", "parentIds": ["superset", "list.subset_cons_of_subset", "list.nil_subset", "list.has_subset", "list.cons_subset_cons", "list.subset.trans", "set.has_subset", "list.subset_cons", "list.subset_append_left", "set.powerset", "list.subset_append_right", "list.subset_of_cons_subset", "list.subset.refl"]}, {"id": "list.subset_cons_of_subset", "parentIds": []}, {"id": "list.has_subset", "parentIds": ["list.subset_cons_of_subset", "list.nil_subset", "list.cons_subset_cons", "list.subset.trans", "list.subset_cons", "list.subset_append_left", "list.subset_append_right", "list.subset_of_cons_subset", "list.subset.refl"]}, {"id": "list.mem", "parentIds": ["list.subset_cons_of_subset", "list.cons_subset_cons", "list.subset_cons", "list.mem_cons_self", "list.has_mem", "list.mem_cons_of_mem", "list.ball_cons"]}, {"id": "decidable.eq_or_lt_of_le", "parentIds": ["decidable.lt_trichotomy"]}, {"id": "or.swap", "parentIds": ["decidable.eq_or_lt_of_le", "or.comm", "decidable.le_or_lt", "nat.lt_of_le_and_ne", "or.symm", "le_or_gt"]}, {"id": "decidable.lt_or_eq_of_le", "parentIds": ["decidable.eq_or_lt_of_le", "decidable.le_iff_lt_or_eq"]}, {"id": "is_strict_weak_order_of_decidable_linear_order", "parentIds": []}, {"id": "has_le.le.is_total_preorder", "parentIds": ["is_strict_weak_order_of_decidable_linear_order"]}, {"id": "lt_iff_not_ge", "parentIds": ["is_strict_weak_order_of_decidable_linear_order", "mul_self_lt_mul_self_iff", "nat.mul_self_lt_mul_self_iff", "nat.div_lt_iff_lt_mul"]}, {"id": "add_lt_of_le_of_neg", "parentIds": []}, {"id": "add_lt_add_of_le_of_lt", "parentIds": ["add_lt_of_le_of_neg", "lt_add_of_le_of_pos", "add_lt_of_nonpos_of_lt", "add_neg_of_nonpos_of_neg", "lt_add_of_nonneg_of_lt", "add_pos_of_nonneg_of_pos", "sub_lt_sub_of_le_of_lt"]}, {"id": "tactic.get_expl_arity", "parentIds": []}, {"id": "tactic.get_expl_pi_arity", "parentIds": ["tactic.get_expl_arity"]}, {"id": "expr.is_arrow", "parentIds": ["old_conv.congr_core"]}, {"id": "expr.has_var", "parentIds": ["expr.is_arrow", "tactic.interactive.return_cast"]}, {"id": "tactic.mk_constructor_arg_names", "parentIds": []}, {"id": "tactic.constructor_num_fields", "parentIds": ["tactic.mk_constructor_arg_names"]}, {"id": "imp_congr_ctx", "parentIds": ["imp_congr_ctx_eq"]}, {"id": "vm_obj.fields", "parentIds": []}, {"id": "vm_obj", "parentIds": ["vm_obj.fields", "vm.stack_obj", "vm_obj.to_level", "vm_obj.fn_idx", "vm_obj.to_nat", "vm_obj.to_declaration", "vm_obj.to_format", "vm_obj.to_name", "vm_obj.kind", "vm_obj.cidx", "vm_obj.to_environment", "vm_obj.to_expr", "vm.obj_to_string", "vm_obj.to_tactic_state"]}, {"id": "coe_sort_coe_base", "parentIds": []}, {"id": "coe_sort_trans", "parentIds": ["coe_sort_coe_base", "coe_sort_coe_trans"]}, {"id": "lean.parser.get_variables", "parentIds": []}, {"id": "where.mk_flag", "parentIds": ["lean.parser.get_variables", "lean.parser.get_includes", "lean.parser.get_namespace", "where.trace_where", "where.is_variable_name"]}, {"id": "where.get_variables_core", "parentIds": ["lean.parser.get_variables", "where.trace_variables"]}, {"id": "tactic.admit", "parentIds": ["tactic.interactive.admit", "tactic.interactive.sorry"]}, {"id": "expr.mk_sorry", "parentIds": ["tactic.admit", "tactic.mk_sorry"]}, {"id": "nat.bodd", "parentIds": ["nat.test_bit", "nat.bodd_add_div2", "nat.bodd_add", "nat.bodd_succ", "nat.binary_rec_eq", "nat.mod_two_of_bodd", "nat.binary_rec_zero", "nat.bodd_one", "nat.bodd_mul", "nat.bodd_zero", "nat.bit_decomp", "nat.bit_cases_on", "nat.div2_val", "nat.bodd_bit", "nat.test_bit_succ", "nat.div2_succ", "nat.bodd_two"]}, {"id": "nat.bodd_div2", "parentIds": ["nat.bodd", "nat.div2", "nat.bodd_succ", "nat.div2_succ"]}, {"id": "rbmap.to_list", "parentIds": ["rbmap.has_repr"]}, {"id": "rbtree.to_list", "parentIds": ["rbmap.to_list", "rbtree.has_repr"]}, {"id": "tt_band", "parentIds": ["band_eq_true_eq_eq_tt_and_eq_tt", "bool.to_bool_and", "band_eq_false_eq_eq_ff_or_eq_ff"]}, {"id": "band_ff", "parentIds": ["tt_band", "ff_band"]}, {"id": "band_tt", "parentIds": ["tt_band", "ff_band"]}, {"id": "nat.test_bit", "parentIds": ["nat.test_bit_ldiff", "nat.test_bit_bitwise", "nat.test_bit_lor", "nat.test_bit_lxor", "nat.test_bit_succ", "nat.test_bit_zero", "nat.test_bit_land"]}, {"id": "nat.shiftr", "parentIds": ["nat.test_bit", "nat.shiftl_sub", "nat.shiftr_eq_div_pow", "nat.zero_shiftr", "nat.shiftl'_sub", "nat.shiftr_add", "nat.test_bit_succ"]}, {"id": "rbnode.balance1_node", "parentIds": []}, {"id": "bool.to_bool_not", "parentIds": []}, {"id": "bool.to_bool_true", "parentIds": ["bool.to_bool_not", "bool.to_bool_and", "bool.cond_to_bool", "bool.to_bool_or"]}, {"id": "not_false_iff", "parentIds": ["bool.to_bool_not", "eq_ff_eq_not_eq_tt", "function.update_eq_self", "max_self", "if_false_left_eq_and", "max_lt", "le_min", "le_max_left", "div_mul_cancel", "list.filter_append", "lt_min", "if_true_right_eq_or", "div_self", "nat.mod_eq_of_lt", "mul_one_div_cancel", "eq_tt_eq_not_eq_ff", "nat.zero_mod", "max_le", "not_eq_of_eq_false", "one_inv_eq", "min_le_right", "one_div_mul_cancel", "nat.mod_zero", "list.filter_sublist", "div_eq_one_iff_eq", "mul_div_cancel", "min_self", "mul_mul_div", "d_array.read_write_of_ne", "min_le_left", "list.partition_eq_filter_filter", "le_max_right", "bool.not_ff", "function.update_comp"]}, {"id": "bool.to_bool_false", "parentIds": ["bool.to_bool_not", "bool.to_bool_and", "bool.cond_to_bool", "bool.to_bool_or"]}, {"id": "not_true", "parentIds": ["bool.to_bool_not", "eq_ff_eq_not_eq_tt", "if_false_left_eq_and", "if_true_right_eq_or", "not_true_iff", "to_bool_true_eq_tt", "eq_tt_eq_not_eq_ff", "int.lt_iff_le_not_le", "list.partition_eq_filter_filter"]}, {"id": "lt_of_mul_lt_mul_left", "parentIds": ["one_div_pos_of_pos", "gt_of_mul_lt_mul_neg_left"]}, {"id": "linear_ordered_ring.to_linear_ordered_semiring", "parentIds": ["one_div_pos_of_pos", "abs_one_div", "mul_zero_lt_mul_inv_of_neg", "int.one_pos", "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "mul_zero_lt_mul_inv_of_pos", "two_gt_one", "int.bit1_pos", "int.one_nonneg", "le_of_mul_le_of_ge_one", "add_self_div_two", "gt_of_mul_lt_mul_neg_left", "int.nat_abs_bit1_nonneg", "zero_gt_neg_one", "two_pos", "abs_abs_sub_abs_le_abs_sub", "div_two_lt_of_pos"]}, {"id": "mul_zero_lt_mul_inv_of_pos", "parentIds": ["one_div_pos_of_pos"]}, {"id": "tactic.explode.core", "parentIds": ["tactic.explode_expr"]}, {"id": "tactic.explode.entries", "parentIds": ["tactic.explode.core", "tactic.explode.entries.inhabited", "tactic.explode.args", "tactic.explode.entries.size", "tactic.explode.append_dep", "tactic.explode", "tactic.explode.entries.head", "tactic.explode.entries.find", "tactic.explode_expr", "tactic.explode.has_to_tactic_format", "tactic.explode.entries.add"]}, {"id": "int.add_comm_monoid", "parentIds": ["int.add_comm_semigroup"]}, {"id": "int.comm_ring", "parentIds": ["int.add_comm_monoid", "int.has_sub", "int.comm_semiring", "int.add_monoid", "int.decidable_linear_ordered_comm_ring", "int.ring", "int.semiring", "int.comm_monoid", "int.monoid", "int.comm_semigroup"]}, {"id": "add_eq_of_eq_sub'", "parentIds": []}, {"id": "user_attribute.get_param_untyped", "parentIds": ["user_attribute.get_param"]}, {"id": "print_decls_sorted", "parentIds": ["lint_all"]}, {"id": "print_decls", "parentIds": ["print_decls_sorted", "lint", "print_decls_sorted_mathlib"]}, {"id": "format.nil", "parentIds": ["print_decls_sorted", "format.when", "print_decls", "print_decls_sorted_mathlib", "hinst_lemmas.pp", "lint_aux"]}, {"id": "nat.pow_le_pow_of_le_left", "parentIds": ["nat.pow_lt_pow_of_lt_left"]}, {"id": "mul_le_mul", "parentIds": ["nat.pow_le_pow_of_le_left", "nat.pow_le_pow_of_le_right", "nat.mul_self_le_mul_self", "mul_self_le_mul_self"]}, {"id": "nat.zero_le", "parentIds": ["nat.pow_le_pow_of_le_left", "array.take", "nat.lt_or_ge", "nat.zero_lt_succ", "nat.pow_le_pow_of_le_right", "nat.one_le_bit0", "nat.one_le_bit1", "nat.div_le_of_le_mul", "nat.eq_zero_of_le_zero", "nat.zero_min", "nat.div_lt_self", "nat.mul_self_le_mul_self", "nat.div_le_self", "nat.le_of_le_of_sub_le_sub_right", "nat.pos_pow_of_pos", "nat.le_of_sub_eq_zero", "nat.mul_self_lt_mul_self", "nat.pow_lt_pow_of_lt_left", "nat.min_zero", "nat.div_mul_le_self", "nat.le_div_iff_mul_le", "list.length_remove_nth", "int.coe_zero_le"]}, {"id": "has_pow", "parentIds": ["nat.pow_le_pow_of_le_left", "nat.shiftl_eq_mul_pow", "nat.has_pow", "nat.pow_lt_pow_of_lt_right", "nat.shiftr_eq_div_pow", "nat.pow_le_pow_of_le_right", "nat.zero_shiftr", "nat.one_shiftl", "nat.pow_succ", "nat.pos_pow_of_pos", "nat.pow_lt_pow_of_lt_left", "native.float.has_float_pow", "nat.zero_shiftl", "nat.pow_zero", "nat.mod_pow_succ", "nat.zero_pow", "nat.shiftl'_tt_eq_mul_pow", "native.float.has_nat_pow", "nat.pow_one"]}, {"id": "nat.pow", "parentIds": ["nat.pow_le_pow_of_le_left", "nat.has_pow"]}, {"id": "nat.has_pow", "parentIds": ["nat.pow_le_pow_of_le_left", "nat.shiftl_eq_mul_pow", "nat.pow_lt_pow_of_lt_right", "nat.shiftr_eq_div_pow", "nat.pow_le_pow_of_le_right", "nat.zero_shiftr", "nat.one_shiftl", "nat.pow_succ", "nat.pos_pow_of_pos", "nat.pow_lt_pow_of_lt_left", "nat.zero_shiftl", "nat.pow_zero", "nat.mod_pow_succ", "nat.zero_pow", "nat.shiftl'_tt_eq_mul_pow", "nat.pow_one"]}, {"id": "pprod", "parentIds": ["nat.pow_le_pow_of_le_left", "nat.shiftl_eq_mul_pow", "nat.shiftl'_add", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "nat.bodd_add_div2", "list.length_le_of_sublist", "nat.zero_le", "nat.shiftr_eq_div_pow", "list.length_drop", "list.filter_append", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "nat.sub_induction", "nat.zero_mul", "nat.bit0_inj", "nat.add_comm", "nat.shiftl'_sub", "nat.zero_sub", "nat.sub_self", "nat.add_left_cancel", "nat.add_sub_add_right", "nat.bit1_ne_bit0", "nat.shiftr_add", "list.length_take", "d_array.of_beq_aux_eq_ff", "nat.succ_add", "nat.le_add_right", "list.length_map_accumr", "nat.le.dest", "nat.left_distrib", "list.filter_sublist", "nat.right_distrib", "nat.sub_sub", "nat.mul_sub_right_distrib", "nat.le_of_sub_eq_zero", "nat.succ_ne_self", "pprod.inhabited", "nat.two_step_induction", "nat.succ_mul", "nat.sub_le_sub_right", "list.length_map_accumr\u2082", "nat.mul_comm", "nonempty_pprod", "list.length_remove_nth", "nat.zero_add", "nat.shiftl'_tt_eq_mul_pow", "list.partition_eq_filter_filter", "nat.add_assoc"]}, {"id": "has_ssubset", "parentIds": ["ssuperset"]}, {"id": "nat.add_right_cancel", "parentIds": ["nat.decidable_linear_ordered_semiring"]}, {"id": "nat.add_comm", "parentIds": ["nat.add_right_cancel", "nat.eq_zero_of_add_eq_zero_left", "nat.le_add_left", "nat.add_right_comm", "nat.comm_semiring", "nat.add_le_add_right", "nat.le_of_add_le_add_right", "nat.add_lt_add_right", "nat.left_distrib", "nat.right_distrib", "nat.succ_mul", "nat.add_left_comm"]}, {"id": "nat.add_left_cancel", "parentIds": ["nat.add_right_cancel", "nat.div2_val", "nat.decidable_linear_ordered_semiring", "nat.le_of_add_le_add_left", "nat.decidable_linear_ordered_cancel_comm_monoid"]}, {"id": "unsigned.has_le", "parentIds": []}, {"id": "fin.le", "parentIds": ["unsigned.has_le", "fin.le_def", "fin.has_le"]}, {"id": "list.union", "parentIds": ["list.has_union"]}, {"id": "list.has_insert", "parentIds": ["list.union", "expr.list_local_consts", "expr.list_meta_vars"]}, {"id": "insert", "parentIds": ["list.union", "expr.list_local_consts", "expr.list_meta_vars"]}, {"id": "right_commutative", "parentIds": ["right_comm"]}, {"id": "and_or_distrib_left", "parentIds": ["or_and_distrib_right"]}, {"id": "or.imp", "parentIds": ["and_or_distrib_left", "or.imp_right", "or_of_or_of_imp_of_imp", "or.imp_left", "or_congr"]}, {"id": "and.imp_right", "parentIds": ["and_or_distrib_left"]}, {"id": "smt_tactic.add_lemmas_from_facts_core", "parentIds": ["smt_tactic.add_lemmas_from_facts"]}, {"id": "tactic.unify", "parentIds": ["tactic.existsi", "old_conv.change", "tactic.mk_eq_simp_ext", "conv.update_lhs", "old_conv.conversion", "linter_attr", "tactic.comp_val", "expr.is_eta_expansion_aux", "tactic.interactive.transitivity", "tactic.interactive.return_cast", "conv.congr", "tactic.get_lift_prf", "equiv_type_constr", "tactic.mk_instance_cache", "tactic.match_fn"]}, {"id": "mul_self_sub_one_eq", "parentIds": []}, {"id": "mul_one", "parentIds": ["mul_self_sub_one_eq", "nat.shiftl_eq_mul_pow", "mul_right_eq_self", "norm_num.mul_bit1_helper", "eq_zero_of_mul_eq_self_right", "nat.succ_mul_succ_eq", "norm_num.mul_one", "abs_sub_square", "nat.pow_lt_pow_of_lt_right", "div_div_eq_div_mul", "nat.le_mul_self", "one_dvd", "eq_of_mul_eq_mul_of_nonzero_right", "div_mul_cancel", "nat.pow_le_pow_of_le_right", "le_mul_of_ge_one_right", "int.mul_one", "mul_self_iff_eq_one", "add_mul_self_eq", "le_of_mul_le_of_ge_one", "lt_mul_of_gt_one_right", "nat.div_lt_self", "add_self_div_two", "functor.const.is_lawful_applicative", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "division_ring.mul_ne_zero", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "div_eq_one_iff_eq", "dvd_refl", "nat.mod_add_div", "mul_inv_eq_of_eq_mul", "div_one", "inv_eq_of_mul_eq_one", "add_halves", "mul_div_cancel", "int.eq_one_of_mul_eq_self_right", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "nat.le_of_dvd", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "norm_num.mul_bit1", "mul_mul_div", "field.div_div_eq_div_mul", "mul_inv_cancel_right", "mul_self_eq_one_iff", "division_ring.one_div_neg_eq_neg_one_div", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "distrib.to_has_mul", "parentIds": ["mul_self_sub_one_eq", "ring.mul_zero", "norm_num.mul_bit0", "two_mul", "norm_num.mul_bit0_helper", "right_distrib", "norm_num.mul_bit1_helper", "nat.succ_mul_succ_eq", "abs_sub_square", "neg_mul_eq_neg_mul", "add_mul_self_eq", "nat.mul_le_mul_left", "add_div_eq_mul_add_div", "left_distrib", "norm_num.div_add_helper", "add_mul", "norm_num.add_div_helper", "add_self_div_two", "mul_self_sub_mul_self_eq", "mul_sub_right_distrib", "nat.mul_self_sub_mul_self_eq", "nat.mod_add_div", "add_halves", "distrib_three_right", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "mul_sub_left_distrib", "one_div_add_one_div", "neg_mul_eq_mul_neg", "norm_num.mul_bit1", "ring.zero_mul", "mul_add"]}, {"id": "mul_neg_eq_neg_mul_symm", "parentIds": ["mul_self_sub_one_eq", "abs_sub_square", "norm_num.pos_mul_neg_helper", "neg_mul_comm", "neg_dvd_of_dvd", "mul_self_sub_mul_self_eq", "norm_num.neg_mul_neg_helper", "dvd_neg_of_dvd", "mul_sub_left_distrib", "neg_mul_neg", "division_ring.one_div_neg_eq_neg_one_div"]}, {"id": "ring.to_monoid", "parentIds": ["mul_self_sub_one_eq", "div_sub_div", "mul_inv_eq", "eq_zero_of_mul_eq_self_right", "abs_sub_square", "one_div_eq_inv", "div_div_eq_div_mul", "eq_of_mul_eq_mul_of_nonzero_right", "div_mul_cancel", "le_mul_of_ge_one_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "add_mul_self_eq", "mul_one_div_cancel", "field.div_mul_eq_mul_div_comm", "le_of_mul_le_of_ge_one", "one_inv_eq", "field.div_mul_div", "one_div_mul_cancel", "neg_eq_neg_one_mul", "lt_mul_of_gt_one_right", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_mul_one_div", "add_self_div_two", "one_div_neg_one_eq_neg_one", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "mul_div_assoc", "field.div_mul_right", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "mul_eq_mul_of_div_eq_div", "div_eq_one_iff_eq", "mul_div_mul_left", "div_one", "add_halves", "mul_div_cancel", "neg_div", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "int.monoid", "mul_mul_div", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "division_ring.one_div_mul_one_div", "mul_self_eq_one_iff", "division_ring.one_div_neg_eq_neg_one_div"]}, {"id": "right_distrib", "parentIds": ["mul_self_sub_one_eq", "two_mul", "nat.succ_mul_succ_eq", "abs_sub_square", "neg_mul_eq_neg_mul", "add_mul_self_eq", "add_div_eq_mul_add_div", "norm_num.div_add_helper", "add_mul", "mul_self_sub_mul_self_eq", "mul_sub_right_distrib", "nat.mul_self_sub_mul_self_eq", "div_add_div_same", "distrib_three_right", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "one_div_add_one_div", "ring.zero_mul"]}, {"id": "add_right_neg", "parentIds": ["mul_self_sub_one_eq", "add_sub_add_left_eq_sub", "eq_zero_of_mul_eq_self_right", "neg_mul_eq_neg_mul", "add_neg_eq_of_eq_add", "eq_add_neg_of_add_eq", "int.sub_nat_nat_eq_coe", "add_sub_add_right_eq_sub", "add_neg_self", "sub_eq_of_eq_add", "sub_eq_of_eq_add'", "add_neg_cancel_right", "add_group.add_right_cancel", "eq_sub_of_add_eq", "neg_sub", "mul_self_sub_mul_self_eq", "add_neg_cancel_left", "neg_add_rev", "eq_sub_of_add_eq'", "sub_pos_of_lt", "sub_nonpos_of_le", "eq_add_of_sub_eq'", "neg_mul_eq_mul_neg", "sub_eq_sub_add_sub", "int.neg_succ_of_nat_lt_zero", "sub_self", "sub_neg_of_lt", "sub_nonneg_of_le"]}, {"id": "left_distrib", "parentIds": ["mul_self_sub_one_eq", "ring.mul_zero", "norm_num.mul_bit0", "norm_num.mul_bit0_helper", "norm_num.mul_bit1_helper", "nat.succ_mul_succ_eq", "abs_sub_square", "add_mul_self_eq", "nat.mul_le_mul_left", "norm_num.add_div_helper", "add_self_div_two", "mul_self_sub_mul_self_eq", "dvd_add", "nat.mod_add_div", "add_halves", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "mul_sub_left_distrib", "neg_mul_eq_mul_neg", "norm_num.mul_bit1", "mul_add"]}, {"id": "ring.to_distrib", "parentIds": ["mul_self_sub_one_eq", "ring.mul_zero", "div_sub_div", "add_midpoint", "two_ne_zero", "eq_zero_of_mul_eq_self_right", "abs_sub_square", "dvd_add_iff_right", "ge_of_forall_ge_sub", "exists_add_lt_and_pos_of_lt", "neg_mul_eq_neg_mul", "sub_le_of_abs_sub_le_left", "div_le_div_of_mul_sub_mul_div_nonpos", "div_two_sub_self", "two_gt_one", "add_mul_self_eq", "add_div_eq_mul_add_div", "norm_num.div_add_helper", "sub_lt_of_abs_sub_lt_left", "norm_num.add_div_helper", "add_self_div_two", "mul_self_sub_mul_self_eq", "mul_sub_right_distrib", "eq_zero_of_mul_self_add_mul_self_eq_zero", "div_add_div_same", "sub_self_div_two", "two_ge_one", "two_pos", "mul_self_eq_mul_self_iff", "add_halves", "int.distrib", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "div_sub_div_same", "mul_sub_left_distrib", "one_div_add_one_div", "neg_mul_eq_mul_neg", "abs_abs_sub_abs_le_abs_sub", "dvd_add_iff_left", "ring.zero_mul", "div_add_div", "four_pos", "div_two_lt_of_pos", "div_lt_div_of_mul_sub_mul_div_neg"]}, {"id": "has_insert", "parentIds": ["insert", "singleton", "set.has_insert", "list.has_insert"]}, {"id": "or_and_distrib_right", "parentIds": []}, {"id": "or_congr", "parentIds": ["or_and_distrib_right", "not_lt_iff_eq_or_lt", "or.left_comm"]}, {"id": "iff.trans", "parentIds": ["or_and_distrib_right", "not_and'", "iff_true_right", "iff_false_right", "true_iff", "list.filter_append", "mul_self_lt_mul_self_iff", "false_iff", "bex_or_distrib", "false_or", "and.left_comm", "nat.mul_self_lt_mul_self_iff", "not_lt_iff_eq_or_lt", "bool.ff_eq_to_bool_iff", "or.left_comm", "exists_eq_right", "and_or_distrib_right", "to_bool_ff_iff", "lt_iff_lt_of_le_iff_le", "list.filter_sublist", "bool.tt_eq_to_bool_iff", "le_iff_eq_or_lt", "or_iff_not_imp_right", "ball_and_distrib", "decidable.le_iff_le_iff_lt_iff_lt", "iff_congr", "iff_def'", "sub_left_inj", "d_array.read_write_of_ne", "lt_iff_lt_of_le_iff_le'", "le_iff_le_iff_lt_iff_lt", "nat.div_zero", "bool.to_bool_eq"]}, {"id": "and.comm", "parentIds": ["or_and_distrib_right", "and.left_comm", "and_comm", "exists_eq_right", "and.rotate", "iff_def'", "and.right_comm"]}, {"id": "not_and_of_not_left", "parentIds": []}, {"id": "sub_right_lt_of_lt_add", "parentIds": ["int.sub_one_le_of_lt", "neg_lt_sub_right_of_lt_add"]}, {"id": "nat.lt.step", "parentIds": ["array.pop_back_idx"]}, {"id": "nat.less_than_or_equal", "parentIds": ["nat.lt.step", "nat.not_succ_le_zero", "nat.pred_le", "nat.sub_le_sub_left", "nat.zero_le", "nat.le_succ", "nat.le_trans", "nat.le_of_eq", "nat.shiftl'_sub", "nat.linear_order", "nat.pred_le_pred", "nat.le", "nat.has_le", "nat.le_succ_of_pred_le", "nat.lt", "nat.le.dest", "nat.eq_or_lt_of_le", "nat.pred_lt", "nat.succ_le_succ", "nat.le_refl", "nat.lt_trans", "nat.le_antisymm"]}, {"id": "ring.mul_zero", "parentIds": ["ring.to_semiring"]}, {"id": "le_trans", "parentIds": ["abs_add_three", "nat.sub_le_sub_left", "ge_trans", "sub_le_of_abs_sub_le_left", "max_assoc", "has_le.le.is_total_preorder", "lt_trans", "nat.div_le_of_le_mul", "nat.mod_le", "le_of_mul_le_of_ge_one", "add_le_add_three", "le_implies_le_of_le_of_le", "nat.sub_mul_div", "le_abs_self", "min_assoc", "abs_of_nonneg", "add_le_add", "lt_of_lt_of_le", "lt_of_le_of_lt", "int.le_nat_abs", "mul_self_le_mul_self", "mul_le_mul", "abs_of_nonpos"]}, {"id": "lean.parser.reflectable.to_parser", "parentIds": []}, {"id": "lean.parser.val", "parentIds": ["lean.parser.reflectable.to_parser", "lean.parser.reflectable.cast", "lean.parser.itactic"]}, {"id": "lean.parser.reflectable", "parentIds": ["lean.parser.reflectable.to_parser", "lean.parser.reflectable.optional", "lean.parser.reflectable.has_reflect", "lean.parser.reflectable.cast", "lean.parser.reflectable.expr", "lean.parser.reflect", "interactive.parse"]}, {"id": "decidable.by_contradiction", "parentIds": ["decidable.of_not_not", "classical.by_contradiction", "nat.mul_self_le_mul_self_iff", "lt_of_incomp_of_lt", "not_iff", "by_contradiction", "decidable.le_of_not_lt", "lt_of_lt_of_incomp"]}, {"id": "old_conv.interactive.trace_state", "parentIds": []}, {"id": "old_conv.trace_lhs", "parentIds": ["old_conv.interactive.trace_state"]}, {"id": "ulift", "parentIds": ["nonempty_ulift", "ulift.functor", "tactic.mllist.empty", "tactic.down", "ulift.up_down", "ulift.inhabited", "ulift.down_up", "tactic.up", "ulift.ext"]}, {"id": "add_monoid", "parentIds": ["discrete_field", "bit0_zero", "functor.add_const.is_lawful_applicative", "add_comm_group", "add_monoid_to_is_right_id", "add_zero", "integral_domain", "add_monoid.to_add_semigroup", "norm_num.add1_zero", "add_comm_monoid.to_add_monoid", "ring", "division_ring", "add_monoid_to_is_left_id", "linear_ordered_comm_ring", "discrete_linear_ordered_field", "nat.add_monoid", "comm_ring", "add_group", "linear_ordered_ring", "add_monoid.to_has_zero", "int.add_monoid", "add_group.to_add_monoid", "bit1_zero", "norm_num.bin_zero_add", "ordered_comm_group", "zero_add", "field", "decidable_linear_ordered_comm_ring", "norm_num.bin_add_zero", "linear_ordered_field", "ordered_ring", "decidable_linear_ordered_comm_group"]}, {"id": "tactic.copy_attribute", "parentIds": ["transport_with_dict"]}, {"id": "tactic.set_basic_attribute", "parentIds": ["tactic.copy_attribute", "attribute.register", "simps_add_projection", "tactic.def_replacer", "instance_derive_handler", "tactic.delta_instance"]}, {"id": "comp.map_pure", "parentIds": ["comp.is_lawful_applicative"]}, {"id": "functor.comp.ext", "parentIds": ["comp.map_pure", "comp.pure_seq_eq_map", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "functor.comp.run_map", "parentIds": ["comp.map_pure", "comp.pure_seq_eq_map", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "functor.comp.functor", "parentIds": ["comp.map_pure", "functor.comp.map_mk", "functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "comp.pure_seq_eq_map", "functor.comp.is_lawful_functor", "functor.comp.run_map", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "string.over_list", "parentIds": ["tactic.unprime"]}, {"id": "list.as_string", "parentIds": ["string.over_list", "string.get_rest", "nat.repr", "string.split_on", "string.intercalate", "parser.many_char1", "buffer.to_string", "parser.many_char"]}, {"id": "function.injective_of_has_left_inverse", "parentIds": ["function.injective_surj_inv", "function.injective_iff_has_left_inverse"]}, {"id": "function.injective_of_left_inverse", "parentIds": ["function.injective_of_has_left_inverse", "function.involutive.injective", "function.bijective_iff_has_inverse"]}, {"id": "function.has_left_inverse", "parentIds": ["function.injective_of_has_left_inverse", "function.injective_iff_has_left_inverse", "function.injective.has_left_inverse"]}, {"id": "exists.elim", "parentIds": ["function.injective_of_has_left_inverse", "nat.sub_eq_zero_of_le", "exists_imp_exists'", "int.lt.elim", "exists_unique_of_exists_of_unique", "exists_of_exists_unique", "nat.add_sub_assoc", "dvd.elim", "exists_unique.elim", "function.left_inverse_of_surjective_of_right_inverse", "nat.succ_sub", "function.surjective_comp", "dvd.elim_left", "int.le.elim", "nat.add_sub_of_le", "exists_imp_exists"]}, {"id": "and_not_self_iff", "parentIds": []}, {"id": "le_of_eq", "parentIds": ["le_of_eq_or_lt", "eq_iff_le_not_lt", "le_antisymm_iff", "nat.eq_of_mul_eq_mul_left"]}, {"id": "nat.shiftl_eq_mul_pow", "parentIds": ["nat.one_shiftl", "nat.zero_shiftl"]}, {"id": "nat.bit0_val", "parentIds": ["nat.shiftl_eq_mul_pow", "nat.bit1_val", "nat.bit_val"]}, {"id": "nat.comm_semigroup", "parentIds": ["nat.shiftl_eq_mul_pow", "nat.add_mul_mod_self_right", "nat.bodd_add_div2", "nat.add_mul_div_right", "int.distrib_left", "nat.div_mul_cancel", "nat.dvd_of_mul_dvd_mul_right", "nat.mul_mod_left", "nat.div_lt_self", "nat.mul_div_left", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "nat.bodd_bit", "nat.mul_self_sub_mul_self_eq", "nat.mul_div_cancel_left", "nat.mod_pow_succ", "nat.mul_mod_mul_right", "nat.shiftl'_tt_eq_mul_pow", "nat.div_div_eq_div_mul", "nat.mul_sub_div"]}, {"id": "mul_left_comm", "parentIds": ["nat.shiftl_eq_mul_pow", "mul_dvd_mul", "dvd_of_mul_left_dvd", "div_mul_eq_mul_div", "dvd_trans", "field.div_mul_div", "mul_mul_mul_comm", "nat.shiftl'_tt_eq_mul_pow"]}, {"id": "nat.shiftl", "parentIds": ["nat.shiftl_eq_mul_pow", "nat.shiftl_sub", "nat.one_shiftl", "nat.shiftl_succ", "nat.shiftl_add", "nat.zero_shiftl", "nat.shiftl_zero"]}, {"id": "nat.add", "parentIds": ["nat.shiftl_eq_mul_pow", "nat.shiftl'_add", "nat.lt_or_ge", "d_array.of_beq_aux_eq_tt", "nat.zero_le", "nat.add_right_comm", "nat.shiftr_eq_div_pow", "nat.bit0_inj", "nat.add_comm", "nat.comm_semiring", "nat.shiftl'_sub", "nat.has_add", "nat.zero_sub", "nat.bit1_ne_bit0", "nat.shiftr_add", "d_array.of_beq_aux_eq_ff", "nat.succ_add", "nat.le_add_right", "nat.le_of_sub_eq_zero", "nat.succ_ne_self", "nat.bit1_ne_one", "nat.add_left_comm", "nat.zero_add", "nat.shiftl'_tt_eq_mul_pow"]}, {"id": "monoid.to_semigroup", "parentIds": ["nat.shiftl_eq_mul_pow", "div_sub_div", "eq_inv_iff_mul_eq_one", "monoid_to_is_left_id", "mul_right_eq_self", "eq_mul_inv_iff_mul_eq", "mul_inv_rev", "eq_zero_of_mul_eq_self_right", "mul_eq_one_iff_inv_eq", "norm_num.mul_one", "comm_group", "nat.pow_lt_pow_of_lt_right", "div_div_eq_div_mul", "mul_one", "mul_inv", "eq_of_mul_eq_mul_of_nonzero_right", "one_mul", "div_mul_cancel", "nat.pow_le_pow_of_le_right", "dvd_of_mul_right_dvd", "le_mul_of_ge_one_right", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "mul_self_iff_eq_one", "mul_right_surjective", "eq_inv_mul_iff_mul_eq", "mul_eq_one_iff_eq_inv", "mul_eq_of_eq_inv_mul", "mul_left_eq_self", "int.eq_one_of_mul_eq_self_left", "mul_inv_eq_iff_eq_mul", "mul_inv_cancel_left", "nat.semigroup", "mul_right_inv", "field.div_mul_eq_mul_div_comm", "mul_inv_self", "le_of_mul_le_of_ge_one", "one_inv_eq", "inv_mul_cancel_left", "group", "field.div_mul_div", "mul_eq_of_eq_mul_inv", "int.semigroup", "lt_mul_of_gt_one_right", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "group.mul_left_cancel", "add_self_div_two", "dvd_mul_of_dvd_left", "one_div_neg_one_eq_neg_one", "functor.const.is_lawful_applicative", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_lt_one_div_of_lt", "mul_div_assoc", "field.div_mul_right", "division_ring.mul_ne_zero", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "mul_inv_eq_one", "inv_comm_of_comm", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "mul_left_surjective", "div_eq_one_iff_eq", "mul_div_mul_left", "eq_mul_of_inv_mul_eq", "inv_mul_self", "mul_inv_eq_of_eq_mul", "inv_eq_of_mul_eq_one", "eq_inv_of_mul_eq_one", "add_halves", "mul_div_cancel", "eq_inv_mul_of_mul_eq", "int.eq_one_of_mul_eq_self_right", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "nat.le_of_dvd", "mul_left_inv", "eq_one_div_of_mul_eq_one_left", "eq_one_div_of_mul_eq_one", "monoid_to_is_right_id", "mul_mul_div", "field.div_div_eq_div_mul", "abs_abs_sub_abs_le_abs_sub", "mul_inv_cancel_right", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "division_ring.one_div_mul_one_div", "eq_mul_of_mul_inv_eq", "mul_self_eq_one_iff", "inv_mul_eq_iff_eq_mul", "division_ring.one_div_neg_eq_neg_one_div", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "nat.monoid", "parentIds": ["nat.shiftl_eq_mul_pow", "nat.succ_mul_succ_eq", "nat.pow_lt_pow_of_lt_right", "nat.le_mul_self", "nat.pow_le_pow_of_le_right", "int.mul_one", "nat.one_shiftl", "nat.semigroup", "nat.div_lt_self", "nat.div_le_self", "nat.mod_add_div", "nat.le_of_dvd", "nat.shiftl'_tt_eq_mul_pow", "nat.div_one", "nat.pow_one"]}, {"id": "nat.has_mul", "parentIds": ["nat.shiftl_eq_mul_pow", "nat.add_mul_mod_self_right", "nat.mul_one", "nat.mul_div_mul", "nat.lcm", "nat.mul_div_assoc", "int.nat_abs_mul_self", "nat.eq_of_mul_eq_mul_right", "nat.bodd_add_div2", "nat.succ_mul_succ_eq", "nat.add_mul_div_right", "nat.bit0_val", "nat.pow_lt_pow_of_lt_right", "nat.le_mul_self", "nat.mul_div_right", "nat.shiftr_eq_div_pow", "nat.mod_two_of_bodd", "nat.add_mul_div_left", "nat.sub_mul_mod", "nat.pow_le_pow_of_le_right", "nat.mul_assoc", "nat.zero_mul", "string.hash", "nat.mul_self_le_mul_self_iff", "int.mul_one", "nat.one_shiftl", "nat.mul_le_mul_left", "int.coe_nat_mul_out", "nat.mul_zero", "nat.div_le_of_le_mul", "nat.mul_mod_mul_left", "nat.bodd_mul", "int.distrib_left", "nat.mul_self_lt_mul_self_iff", "int.of_nat_mul", "nat.div_mul_cancel", "nat.eq_zero_of_mul_eq_zero", "nat.div_eq_of_eq_mul_right", "nat.mul_div_cancel'", "nat.bit_decomp", "nat.pow_succ", "nat.mul_pred_left", "fin.mul_def", "nat.dvd_add_iff_right", "nat.dvd_mod_iff", "nat.mul_lt_mul_of_pos_left", "nat.mul_le_mul_right", "nat.dvd_of_mul_dvd_mul_right", "int.mul_pos", "nat.mul_mod_left", "nat.mul_lt_mul_of_pos_right", "nat.div_lt_self", "nat.mul_mod_right", "nat.mul_succ", "nat.div2_val", "nat.mul_self_le_mul_self", "nat.bit1_val", "nat.mul_div_left", "nat.div_eq_of_lt_le", "int.mul_assoc", "nat.mul_sub_left_distrib", "nat.mul_pred_right", "nat.div_le_self", "nat.bodd_bit", "nat.sub_mul_div", "nat.left_distrib", "nat.right_distrib", "nat.div2_bit", "nat.mul_sub_right_distrib", "nat.mul_self_sub_mul_self_eq", "nat.mul_self_lt_mul_self", "nat.bit_val", "nat.pow_lt_pow_of_lt_left", "nat.dvd_of_mod_eq_zero", "nat.mod_add_div", "nat.mul_div_cancel_left", "nat.dvd_of_mul_dvd_mul_left", "int.mul_nonneg", "nat.zero_shiftl", "nat.succ_mul", "nat.div_mul_le_self", "nat.div_eq_of_eq_mul_left", "nat.le_of_dvd", "nat.mul_comm", "nat.eq_of_mul_eq_mul_left", "nat.add_mul_mod_self_left", "int.mul_comm", "nat.mod_pow_succ", "nat.zero_pow", "nat.one_mul", "nat.le_div_iff_mul_le", "nat.div_lt_iff_lt_mul", "nat.mul_mod_mul_right", "nat.shiftl'_tt_eq_mul_pow", "int.coe_nat_mul", "nat.div_div_eq_div_mul", "nat.mul_sub_div", "nat.div_one", "nat.mod_eq_zero_of_dvd", "nat.mul_div_cancel", "nat.pow_one"]}, {"id": "cmp_using_eq_gt", "parentIds": []}, {"id": "if_false_right_eq_and", "parentIds": ["cmp_using_eq_gt", "cmp_using_eq_lt", "d_array.of_beq_aux_eq_tt"]}, {"id": "cmp_using", "parentIds": ["cmp_using_eq_gt", "cmp_using_eq_lt", "cmp_compares", "cmp_swap", "cmp_using_eq_eq", "cmp"]}, {"id": "and_true", "parentIds": ["cmp_using_eq_gt", "cmp_using_eq_lt", "and_eq_of_eq_true_right", "cmp_using_eq_eq"]}, {"id": "trans", "parentIds": ["cmp_using_eq_gt", "is_asymm_of_is_trans_of_is_irrefl", "trans_of"]}, {"id": "irrefl", "parentIds": ["cmp_using_eq_gt", "irrefl_of", "is_asymm_of_is_trans_of_is_irrefl", "strict_weak_order.erefl"]}, {"id": "if_false_left_eq_and", "parentIds": ["cmp_using_eq_gt", "cmp_using_eq_lt", "cmp_using_eq_eq"]}, {"id": "sum.bind", "parentIds": ["sum.is_lawful_monad", "sum.monad"]}, {"id": "forall_prop_of_true", "parentIds": []}, {"id": "forall_const", "parentIds": ["forall_prop_of_true"]}, {"id": "expr.is_iff", "parentIds": ["tactic.match_iff"]}, {"id": "well_founded_tactics.clear_internals", "parentIds": ["well_founded_tactics.default_dec_tac'", "well_founded_tactics.default_dec_tac"]}, {"id": "tactic.explode.entries.inhabited", "parentIds": ["tactic.explode_expr"]}, {"id": "expr.has_lt", "parentIds": ["tactic.explode.entries.inhabited", "tactic.interactive.clear_dependent", "tactic.interactive.clear'", "mk_expr_set"]}, {"id": "tactic.explode.entry", "parentIds": ["tactic.explode.entries.inhabited", "tactic.explode.entries.size", "tactic.explode.append_dep", "tactic.explode.entries.head", "tactic.explode.entries.find", "tactic.explode.has_to_tactic_format", "tactic.explode.format_aux", "tactic.explode.entries", "tactic.explode.entries.add"]}, {"id": "expr.decidable_rel", "parentIds": ["tactic.explode.entries.inhabited", "tactic.interactive.clear_dependent", "tactic.interactive.clear'", "mk_expr_set"]}, {"id": "list.inhabited", "parentIds": ["tactic.explode.entries.inhabited", "unused_arguments", "unification_hint.inhabited", "fun_info.inhabited", "param_info.inhabited", "string_imp.inhabited", "string.iterator_imp.inhabited"]}, {"id": "expr_map", "parentIds": ["tactic.explode.entries.inhabited", "rsimp.repr_map", "tactic.explode.entries", "tactic.explode.entries.add", "mk_expr_map", "rsimp.mk_repr_map"]}, {"id": "native.rb_map.inhabited", "parentIds": ["tactic.explode.entries.inhabited"]}, {"id": "option.lift_or_get_comm", "parentIds": []}, {"id": "is_commutative", "parentIds": ["option.lift_or_get_comm", "comm_semigroup_to_is_commutative", "add_comm_semigroup_to_is_eq_commutative", "is_symm_op_of_is_commutative"]}, {"id": "option.lift_or_get", "parentIds": ["option.lift_or_get_comm", "option.lift_or_get_idem", "option.lift_or_get_is_left_id", "option.lift_or_get_is_right_id", "option.lift_or_get_assoc"]}, {"id": "name_set.mfold", "parentIds": []}, {"id": "norm_num.mul_bit0", "parentIds": []}, {"id": "distrib", "parentIds": ["norm_num.mul_bit0", "norm_num.mul_bit0_helper", "right_distrib", "semiring.to_distrib", "distrib.to_has_mul", "left_distrib", "add_mul", "nat.distrib", "distrib.to_has_add", "int.distrib", "ring.to_distrib", "mul_add"]}, {"id": "mul_assoc", "parentIds": ["div_sub_div", "nat.mul_div_assoc", "mul_inv_rev", "div_mul_cancel", "mul_left_comm", "dvd_of_mul_right_dvd", "mul_right_comm", "mul_inv_cancel_left", "inv_mul_cancel_left", "field.div_mul_div", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "dvd_mul_of_dvd_left", "functor.const.is_lawful_applicative", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "mul_div_assoc", "field.div_mul_right", "division_ring.mul_ne_zero", "semigroup_to_is_associative", "inv_comm_of_comm", "mul_eq_mul_of_div_eq_div", "eq_mul_inv_of_mul_eq", "div_eq_one_iff_eq", "mul_inv_eq_of_eq_mul", "nat.dvd_of_mul_dvd_mul_left", "inv_eq_of_mul_eq_one", "mul_div_cancel", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "eq_one_div_of_mul_eq_one", "mul_mul_div", "abs_abs_sub_abs_le_abs_sub", "mul_inv_cancel_right", "division_ring.one_div_mul_one_div", "mul_mul_mul_comm", "nat.div_div_eq_div_mul", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "mul_div_assoc", "parentIds": ["div_sub_div", "eq_of_mul_eq_mul_of_nonzero_right", "mul_le_mul_of_mul_div_le", "norm_num.div_mul_helper", "div_div_eq_mul_div", "field.div_div_eq_mul_div", "neg_div", "eq_one_div_of_mul_eq_one_left", "norm_num.mul_div_helper"]}, {"id": "field", "parentIds": ["div_sub_div", "field.one_div_mul_one_div", "field.div_mul_eq_div_mul_one_div", "div_mul_eq_mul_div", "linear_ordered_field.to_field", "eq_of_mul_eq_mul_of_nonzero_right", "mul_div_cancel_left", "field.div_div_div_div_eq", "field.to_comm_ring", "norm_num.div_add_helper", "field.div_mul_left", "field.div_mul_eq_mul_div_comm", "norm_num.add_div_helper", "field.div_mul_div", "field.to_division_ring", "norm_num.div_mul_helper", "field.div_mul_right", "eq_of_mul_eq_mul_of_nonzero_left", "mul_eq_mul_of_div_eq_div", "mul_div_mul_left", "discrete_field.to_field", "mul_div_cancel'", "mul_div_mul_right", "field.div_div_eq_mul_div", "one_div_add_one_div", "norm_num.div_helper", "field.div_div_eq_div_mul", "norm_num.nonzero_of_div_helper", "norm_num.div_eq_div_helper", "norm_num.mul_div_helper", "div_add_div"]}, {"id": "neg_eq_neg_one_mul", "parentIds": ["div_sub_div", "int.sign_mul_nat_abs", "neg_div", "division_ring.one_div_neg_eq_neg_one_div"]}, {"id": "div_add_div", "parentIds": ["div_sub_div"]}, {"id": "proof_irrel_heq", "parentIds": []}, {"id": "param_info.to_format", "parentIds": ["param_info.has_to_format"]}, {"id": "format.cbrace", "parentIds": ["param_info.to_format", "subsingleton_info_to_format", "hinst_lemmas.pp"]}, {"id": "param_info", "parentIds": ["param_info.to_format", "fun_info_to_format", "tactic.fold_explicit_args_aux", "fun_info.inhabited", "fun_info", "param_info.inhabited", "param_info.has_to_format"]}, {"id": "nat.has_to_format", "parentIds": ["param_info.to_format", "unused_arguments", "print_arguments", "occurrences_to_format", "tactic.interactive.guard_hyp_nums", "fun_info_to_format", "lint_aux", "unsigned.has_to_format", "tactic.has_to_tactic_format"]}, {"id": "format.when", "parentIds": ["param_info.to_format", "subsingleton_info_to_format"]}, {"id": "format.group", "parentIds": ["param_info.to_format", "sigma.has_to_format", "name_set.has_to_format", "native.rb_map.has_to_tactic_format", "native.has_to_format", "native.rb_set.has_to_format", "subsingleton_info_to_format", "prod.has_to_format", "tactic.interactive.rintro", "fun_info_to_format", "list.to_format", "hinst_lemmas.pp"]}, {"id": "is_symm_op_of_is_symm", "parentIds": []}, {"id": "is_symm", "parentIds": ["is_symm_op_of_is_symm", "symm_of", "strict_weak_order.is_equiv", "is_per", "symm", "eq_is_equiv", "is_equiv"]}, {"id": "is_symm_op", "parentIds": ["is_symm_op_of_is_symm", "is_symm_op_of_is_commutative"]}, {"id": "int.coe_nat_add_out", "parentIds": []}, {"id": "int.add", "parentIds": ["int.has_add", "int.comm_ring"]}, {"id": "non_contradictory", "parentIds": []}, {"id": "hinst_lemma.id", "parentIds": []}, {"id": "hinst_lemma", "parentIds": ["hinst_lemma.id", "hinst_lemma.has_to_tactic_format", "mk_hinst_singleton", "smt_tactic.add_ematch_lemma_core", "hinst_lemma.pp", "tactic.ematch_all_core", "hinst_lemmas.fold", "hinst_lemma.mk_from_decl", "tactic.ematch_core", "tactic.ematch_all", "tactic.ematch", "hinst_lemmas.pp", "hinst_lemma.mk_from_decl_core", "hinst_lemmas.add", "hinst_lemma.mk_core", "smt_tactic.add_ematch_lemma_from_decl_core"]}, {"id": "smt_tactic.interactive.by_contradiction", "parentIds": []}, {"id": "smt_tactic.by_contradiction", "parentIds": ["smt_tactic.interactive.by_contradiction", "smt_tactic.interactive.by_contra"]}, {"id": "int.neg_of_nat", "parentIds": ["int.mul_one", "int.of_nat_sub", "int.distrib_left", "int.mul_assoc", "int.mul_comm"]}, {"id": "eqv_lt_iff_eq", "parentIds": []}, {"id": "is_trichotomous", "parentIds": ["eqv_lt_iff_eq", "eq_of_incomp", "trichotomous_of", "incomp_iff_eq", "is_strict_total_order", "eq_of_eqv_lt", "trichotomous"]}, {"id": "incomp_iff_eq", "parentIds": ["eqv_lt_iff_eq"]}, {"id": "strict_weak_order.equiv", "parentIds": ["eqv_lt_iff_eq", "strict_weak_order.etrans", "strict_weak_order.is_equiv", "strict_weak_order.esymm", "strict_weak_order.erefl", "eq_of_eqv_lt", "strict_weak_order.not_lt_of_equiv'", "strict_weak_order.not_lt_of_equiv"]}, {"id": "level.lt", "parentIds": ["expr.dedup_size", "level.dedup_size"]}, {"id": "tactic.find_same_type", "parentIds": ["tactic.find_assumption", "tactic.assumption"]}, {"id": "nat.shiftl'_add", "parentIds": ["nat.shiftl_add"]}, {"id": "nat.shiftl'", "parentIds": ["nat.shiftl'_add", "nat.shiftl'_sub", "nat.shiftl", "nat.shiftl'_tt_eq_mul_pow"]}, {"id": "monad_reader_trans", "parentIds": []}, {"id": "monad_reader", "parentIds": ["monad_reader_trans", "reader_t.monad_reader"]}, {"id": "has_monad_lift", "parentIds": ["monad_reader_trans", "has_monad_lift_t_trans", "monad_fail_lift", "reader_t.has_monad_lift", "monad_state_trans", "state_t.has_monad_lift", "smt_tactic.has_monad_lift", "option_t.has_monad_lift", "except_t.has_monad_lift"]}, {"id": "has_monad_lift_t_trans", "parentIds": ["monad_reader_trans", "expr.mfoldl", "state_t.run_monad_lift", "except_t.run_monad_lift", "reader_t.run_monad_lift", "monad_fail_lift", "monad_state_trans", "smt_tactic.has_coe", "tactic.find_private_decl", "option_t.run_monad_lift"]}, {"id": "has_monad_lift_t_refl", "parentIds": ["monad_reader_trans", "monad_lift_refl", "expr.mfoldl", "monad_fail_lift", "monad_state_trans", "smt_tactic.has_coe", "tactic.find_private_decl"]}, {"id": "has_monad_lift_t", "parentIds": ["monad_reader_trans", "has_monad_lift_t_trans", "monad_lift_refl", "expr.mfoldl", "state_t.run_monad_lift", "except_t.run_monad_lift", "reader_t.run_monad_lift", "monad_fail_lift", "has_monad_lift_to_has_coe", "monad_state_trans", "has_monad_lift_t_refl", "smt_tactic.has_coe", "tactic.find_private_decl", "option_t.run_monad_lift"]}, {"id": "nat.add_mul_mod_self_right", "parentIds": []}, {"id": "nat.add_mul_mod_self_left", "parentIds": ["nat.add_mul_mod_self_right", "nat.mul_mod_right"]}, {"id": "int.lt.intro", "parentIds": ["int.lt_iff_le_and_ne", "int.mul_pos", "int.neg_succ_of_nat_lt_zero"]}, {"id": "int.lt_add_succ", "parentIds": ["int.lt.intro"]}, {"id": "expr.mk_exists_lst", "parentIds": ["tactic.constr_to_prop"]}, {"id": "expr.lambdas", "parentIds": ["expr.mk_exists_lst", "simps_add_projection", "tactic.choose1", "tactic.mk_eq_proof"]}, {"id": "expr.has_coe_to_fun", "parentIds": ["expr.mk_exists_lst", "tactic.constr_to_prop", "tactic.lift", "old_conv.congr_core", "tactic.interactive.erase_simp_args"]}, {"id": "expr.occurs", "parentIds": ["expr.mk_exists_lst"]}, {"id": "level.has_decidable_eq", "parentIds": ["expr.mk_exists_lst", "incorrect_def_lemma", "tactic.constr_to_prop"]}, {"id": "list.mfoldr", "parentIds": ["expr.mk_exists_lst", "instance_derive_handler", "has_reflect_derive_handler"]}, {"id": "coe_fn", "parentIds": ["expr.mk_exists_lst", "coe_fn_coe_trans", "applicative_transformation.preserves_map", "tactic.constr_to_prop", "tactic.lift", "applicative_transformation.preserves_seq", "old_conv.congr_core", "is_lawful_traversable", "coe_fn_coe_base", "coe_fn_trans", "applicative_transformation.preserves_pure", "tactic.interactive.erase_simp_args"]}, {"id": "decidable_eq_inl_refl", "parentIds": []}, {"id": "vm", "parentIds": ["vm.stack_obj", "vm.pp_expr", "vm.pc", "vm.pp_stack_obj", "vm.call_stack_fn", "vm.bp", "vm.get_attribute", "vm.eof", "vm.call_stack_var_range", "vm.call_stack_size", "vm.stack_obj_info", "vm.get_line", "vm.curr_fn", "vm.put_str", "vm.trace", "vm.get_options", "vm.get_decl", "vm.stack_size", "vm.get_env", "vm_monitor", "vm.obj_to_string"]}, {"id": "option_t", "parentIds": ["vm", "option_t.ext", "option_t.run_pure", "option_t.monad_run", "option_t.fail", "option_t.bind", "option_t.run_map", "option_t.run_monad_map", "option_t.orelse", "option_t.monad_map", "option_t.alternative", "option_t.pure", "option_t.run_bind", "option_t.catch", "option_t.monad_functor", "option_t.has_monad_lift", "option_t.bind_cont", "option_t.monad_except", "option_t.is_lawful_monad", "tactic.find_private_decl", "option_t.monad", "option_t.run_monad_lift", "option_t.lift"]}, {"id": "interactive.types.opt_pexpr_list", "parentIds": []}, {"id": "interactive.types.pexpr_list", "parentIds": ["interactive.types.opt_pexpr_list", "interactive.types.pexpr_list_or_texpr"]}, {"id": "function.surj_inv_eq", "parentIds": ["function.right_inverse_surj_inv"]}, {"id": "function.surj_inv", "parentIds": ["function.surj_inv_eq", "function.left_inverse_surj_inv", "function.surjective.has_right_inverse", "function.right_inverse_surj_inv", "function.injective_surj_inv", "function.bijective_iff_has_inverse"]}, {"id": "classical.some_spec", "parentIds": ["function.surj_inv_eq", "classical.some_spec2", "function.inv_fun_on_pos", "function.partial_inv_of_injective", "classical.axiom_of_choice"]}, {"id": "native.rb_set.erase", "parentIds": ["native.rb_set.mfilter", "native.rb_set.filter"]}, {"id": "native.rb_map.erase", "parentIds": ["native.rb_set.erase", "native.rb_map.add", "native.rb_lmap.insert", "native.rb_lmap.erase"]}, {"id": "classical.or_not", "parentIds": []}, {"id": "classical.by_cases", "parentIds": ["classical.or_not", "lt_or_eq_of_le"]}, {"id": "tactic.rcases_hint.process_constructors", "parentIds": []}, {"id": "tactic.using_new_ref", "parentIds": ["tactic.split_ifs"]}, {"id": "tactic.ref", "parentIds": ["tactic.using_new_ref", "tactic.read_ref", "tactic.split_ifs", "tactic.write_ref"]}, {"id": "monoid", "parentIds": ["semiring.to_monoid", "monoid_to_is_left_id", "ring.to_monoid", "norm_num.mul_one", "comm_group", "mul_one", "one_mul", "monoid.to_has_one", "group", "group.to_monoid", "functor.const.is_lawful_applicative", "nat.monoid", "comm_monoid.to_monoid", "monoid.to_semigroup", "int.monoid", "monoid_to_is_right_id"]}, {"id": "tactic.mk_congr_fun", "parentIds": []}, {"id": "subsingleton.helim", "parentIds": []}, {"id": "heq_of_eq", "parentIds": ["subsingleton.helim", "heq_of_eq_of_heq", "function.hfunext", "applicative.ext", "heq_iff_eq", "heq_of_heq_of_eq"]}, {"id": "nat.lxor_bit", "parentIds": []}, {"id": "nat.lxor", "parentIds": ["nat.lxor_bit", "nat.test_bit_lxor"]}, {"id": "nat.bitwise_bit", "parentIds": ["nat.lxor_bit", "nat.test_bit_bitwise", "nat.ldiff_bit", "nat.lor_bit", "nat.bitwise_swap", "nat.land_bit"]}, {"id": "eqv_gen.is_equivalence", "parentIds": ["eqv_gen.setoid"]}, {"id": "eqv_gen", "parentIds": ["eqv_gen.is_equivalence", "quot.exact", "eqv_gen.setoid", "quot.eqv_gen_sound"]}, {"id": "mk_equivalence", "parentIds": ["eqv_gen.is_equivalence", "function.equiv.is_equivalence"]}, {"id": "equivalence", "parentIds": ["eqv_gen.is_equivalence", "function.equiv.is_equivalence", "setoid.trans", "mk_equivalence", "eq_equivalence", "setoid.symm", "setoid", "setoid.refl"]}, {"id": "d_array.read", "parentIds": ["d_array.of_beq_aux_eq_tt", "d_array.map\u2082", "array.read", "d_array.read_write", "d_array.of_beq_aux_eq_ff", "d_array.write", "d_array.ext'", "d_array.ext", "d_array.of_beq_eq_ff", "d_array.read_write_of_ne"]}, {"id": "tactic.injections_with", "parentIds": ["tactic.interactive.injections"]}, {"id": "tactic.interactive.any_goals", "parentIds": []}, {"id": "tactic.any_goals", "parentIds": ["tactic.interactive.any_goals", "conv.solve1", "tactic.interactive.assumption'", "tactic.suggest.apply_and_solve", "conv.convert"]}, {"id": "options.get_nat", "parentIds": ["tactic.get_nat_option"]}, {"id": "int.nat_abs_bit1_nonneg_step", "parentIds": []}, {"id": "int.nat_abs_bit1_nonneg", "parentIds": ["int.nat_abs_bit1_nonneg_step"]}, {"id": "tactic.elide.unelide", "parentIds": ["tactic.interactive.unelide"]}, {"id": "expr.replace", "parentIds": ["tactic.elide.unelide", "tactic.change_with_at", "expr.replace_with", "tactic.interactive.change", "tactic.interactive.clean", "tactic.suggest.replace_mvars", "expr.apply_replacement_fun"]}, {"id": "iff.symm", "parentIds": ["eq_inv_iff_mul_eq_one", "classical.forall_or_distrib", "mul_self_lt_mul_self_iff", "decidable_of_iff'", "and.left_comm", "nat.mul_self_lt_mul_self_iff", "or.left_comm", "not_le", "eq_neg_iff_add_eq_zero", "to_bool_ff_iff", "lt_iff_lt_of_le_iff_le", "eq_iff_iff", "of_iff_true", "neg_eq_iff_add_eq_zero", "decidable.le_iff_le_iff_lt_iff_lt", "iff.comm", "iff_congr", "inv_eq_iff_mul_eq_one", "lt_iff_lt_of_le_iff_le'", "le_iff_le_iff_lt_iff_lt", "function.involutive_iff_iter_2_eq_id", "bool.to_bool_eq"]}, {"id": "iff.elim_left", "parentIds": ["iff.symm", "imp_congr_right", "and_congr_right", "not_iff_not_of_iff"]}, {"id": "iff.elim_right", "parentIds": ["iff.symm", "imp_congr_right", "and_congr_right", "not_iff_not_of_iff"]}, {"id": "int.le_of_lt_add_one", "parentIds": ["int.lt_of_sub_one_le"]}, {"id": "le_of_add_le_add_right", "parentIds": ["int.le_of_lt_add_one", "nat.sub_mul_div", "abs_sub_abs_le_abs_sub"]}, {"id": "expr.get_app_args_aux", "parentIds": ["expr.get_app_args"]}, {"id": "smt_tactic.definev", "parentIds": ["smt_tactic.pose", "smt_tactic.interactive.let"]}, {"id": "tactic.definev_core", "parentIds": ["smt_tactic.definev", "tactic.definev"]}, {"id": "smt_tactic.intros", "parentIds": ["smt_tactic.definev", "smt_tactic.interactive.intros", "smt_tactic.define", "smt_tactic.assertv", "smt_tactic.assert", "smt_tactic.by_contradiction", "smt_tactic.destruct"]}, {"id": "nat.one_lt_bit0", "parentIds": []}, {"id": "nat.zero_lt_succ", "parentIds": ["nat.one_lt_bit0", "nat.zero_lt_one", "nat.zero_lt_one_add", "nat.div_le_of_le_mul", "nat.succ_pos", "nat.sub_one_sub_lt", "buffer.lt_aux_3", "nat.zero_lt_bit1", "nat.one_lt_bit1", "nat.zero_lt_bit0"]}, {"id": "nat.succ_lt_succ", "parentIds": ["nat.one_lt_bit0", "nat.bit1_lt", "nat.one_lt_bit1"]}, {"id": "nat.bit0_succ_eq", "parentIds": ["nat.one_lt_bit0", "nat.one_le_bit0", "nat.bit1_ne_bit0", "nat.bit1_succ_eq", "nat.zero_lt_bit0"]}, {"id": "div_pos_of_neg_of_neg", "parentIds": []}, {"id": "one_div_neg_of_neg", "parentIds": ["div_pos_of_neg_of_neg", "div_nonneg_of_nonpos_of_neg", "one_div_le_of_one_div_le_of_neg", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "div_neg_of_pos_of_neg", "div_lt_of_mul_gt_of_neg", "div_lt_div_of_lt_of_neg", "div_nonpos_of_nonneg_of_neg"]}, {"id": "mul_pos_of_neg_of_neg", "parentIds": ["div_pos_of_neg_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero"]}, {"id": "nat.succ_le_succ", "parentIds": ["nat.succ_lt_succ", "list.length_le_of_sublist", "nat.zero_lt_succ", "nat.one_le_bit0", "nat.one_le_bit1", "nat.le_succ_of_pred_le", "nat.eq_or_lt_of_le", "nat.div_le_self", "nat.le_of_le_of_sub_le_sub_right", "nat.lt_succ_of_le", "nat.lt_of_le_of_lt", "nat.bit1_lt_bit0", "nat.min_succ_succ"]}, {"id": "expr.mk_binding", "parentIds": ["expr.bind_lambda", "expr.bind_pi"]}, {"id": "expr.abstract_local", "parentIds": ["expr.mk_binding", "expr.instantiate_local", "expr.abstract"]}, {"id": "smt_tactic.interactive.ematch", "parentIds": []}, {"id": "smt_tactic.ematch", "parentIds": ["smt_tactic.interactive.ematch", "rsimp.collect_implied_eqs", "smt_tactic.eblast"]}, {"id": "tactic.rotate", "parentIds": ["tactic.interactive.rotate"]}, {"id": "tactic.rotate_left", "parentIds": ["tactic.rotate", "tactic.rotate_right"]}, {"id": "dvd.intro", "parentIds": ["dvd_mul_left", "dvd_of_mul_left_dvd", "one_dvd", "dvd.intro_left", "neg_dvd_of_dvd", "dvd_mul_right", "dvd_add", "nat.dvd_of_mod_eq_zero", "dvd_refl", "dvd_neg_of_dvd", "dvd_zero", "dvd_of_mul_right_eq"]}, {"id": "comm_semiring.to_semiring", "parentIds": ["dvd.intro", "eq_zero_of_zero_dvd", "mul_dvd_mul", "dvd_mul_left", "dvd_of_mul_left_dvd", "nat.lt_add_of_pos_left", "one_dvd", "dvd_of_mul_right_dvd", "nat.mul_le_mul_left", "exists_eq_mul_left_of_dvd", "dvd.elim", "nat.pos_of_dvd_of_pos", "exists_eq_mul_right_of_dvd", "dvd.intro_left", "nat.dvd_add_iff_right", "nat.dvd_mod_iff", "neg_dvd_of_dvd", "dvd_trans", "dvd_mul_of_dvd_right", "dvd_mul_of_dvd_left", "mul_dvd_mul_left", "dvd_mul_right", "mul_dvd_mul_right", "dvd_add", "comm_semiring_has_dvd", "dvd.elim_left", "dvd_refl", "dvd_neg_of_dvd", "dvd_of_mul_left_eq", "nat.dvd_of_mul_dvd_mul_left", "nat.le_of_dvd", "dvd_zero", "dvd_of_mul_right_eq", "nat.mod_eq_zero_of_dvd", "nat.dvd_antisymm"]}, {"id": "list.mem_append_eq", "parentIds": []}, {"id": "tactic.mk_mapp", "parentIds": ["tactic.assoc_refl", "simps_add_projection", "tactic.lift", "tactic.by_cases", "tactic.by_contradiction", "tactic.interactive.return_cast", "tactic.injection_with", "tactic.mk_assoc_instance", "smt_tactic.by_contradiction", "tactic.interactive.source_fields", "derive_struct_ext_lemma", "expr.of_nat"]}, {"id": "tactic.interactive.contradiction", "parentIds": []}, {"id": "tactic.interactive.refl", "parentIds": ["tactic.mk_inj_eq"]}, {"id": "tactic.reflexivity", "parentIds": ["tactic.interactive.refl", "tactic.interactive.trivial", "conv.interactive.conv", "tactic.interactive.triv", "conv.solve1", "conv.skip", "tactic.interactive.substs", "tactic.interactive.reflexivity", "tactic.interactive.simp_intros", "tactic.interactive.subst", "tactic.subst_vars", "tactic.interactive.simp_core", "conv.convert", "derive_struct_ext_lemma"]}, {"id": "nat.lt", "parentIds": ["nat.mod", "nat.lt_wf", "nat.div_def_aux", "nat.linear_order", "nat.gcd.induction", "nat.has_lt", "nat.div", "list.qsort_cons", "list.qsort", "nat.decidable_linear_ordered_semiring", "nat.mod_def_aux", "list.qsort_nil"]}, {"id": "well_founded.fix", "parentIds": ["nat.mod", "nat.div", "list.qsort_cons", "list.qsort", "well_founded.fix_eq", "list.qsort_nil", "nat.find_x"]}, {"id": "nat.lt_wf", "parentIds": ["nat.mod", "nat.div_def_aux", "nat.gcd.induction", "nat.div", "nat.mod_def_aux", "measure_wf"]}, {"id": "mul_nonpos_of_nonpos_of_nonneg", "parentIds": ["pos_of_mul_pos_right", "abs_mul", "div_nonpos_of_nonpos_of_pos"]}, {"id": "zero_mul", "parentIds": ["mul_nonpos_of_nonpos_of_nonneg", "eq_zero_of_zero_dvd", "mul_nonneg_of_nonpos_of_nonpos", "one_div_mul_one_div'", "neg_mul_eq_neg_mul", "ne_zero_of_mul_ne_zero_right", "norm_num.zero_mul", "mul_pos", "nat.mul_mod_mul_left", "zero_div", "nat.mul_pred_left", "mul_neg_of_neg_of_pos", "mul_pos_of_neg_of_neg", "mul_eq_zero_iff_eq_zero_or_eq_zero", "mul_inv'", "division_ring.mul_ne_zero", "nat.mul_sub_right_distrib", "nat.zero_shiftl", "div_mul_eq_mul_div_comm", "eq_one_div_of_mul_eq_one", "mul_nonneg", "nat.le_div_iff_mul_le", "div_mul_div", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.div_div_eq_div_mul", "nat.mul_sub_div"]}, {"id": "nat.test_bit_ldiff", "parentIds": []}, {"id": "nat.test_bit_bitwise", "parentIds": ["nat.test_bit_ldiff", "nat.test_bit_lor", "nat.test_bit_lxor", "nat.test_bit_land"]}, {"id": "nat.ldiff", "parentIds": ["nat.test_bit_ldiff", "nat.ldiff_bit"]}, {"id": "tactic.open_namespaces", "parentIds": ["tactic.in_open_namespaces", "where.get_opens"]}, {"id": "abs_add_three", "parentIds": []}, {"id": "add_le_add_right", "parentIds": ["abs_add_three", "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "le_add_of_sub_left_le", "sub_left_le_of_le_add", "div_le_div_of_mul_sub_mul_div_nonpos", "neg_le_neg", "add_le_of_le_sub_right", "sub_right_le_of_le_add", "le_sub_left_of_add_le", "sub_le_sub_right", "le_add_of_sub_right_le", "le_sub_right_of_add_le", "add_lt_add_of_le_of_lt", "nat.le_of_sub_eq_zero", "add_le_add", "sub_nonpos_of_le", "int.lt_add_one_of_le", "le_of_sub_nonneg", "le_of_sub_nonpos", "le_add_of_nonneg_left", "sub_nonneg_of_le"]}, {"id": "tactic.build_list_expr_for_apply", "parentIds": ["tactic.apply_rules"]}, {"id": "scope_trace", "parentIds": ["old_conv.istep", "tactic.istep", "smt_tactic.istep"]}, {"id": "nonempty_sum", "parentIds": []}, {"id": "add_assoc", "parentIds": ["abs_sub_le", "functor.add_const.is_lawful_applicative", "add_midpoint", "add_add_sub_cancel", "add_neg_eq_of_eq_add", "eq_add_neg_of_add_eq", "nat.add_mul_div_left", "add_add_add_comm", "nat.add_sub_assoc", "neg_add_cancel_right", "add_semigroup_to_is_eq_associative", "add_sub_add_right_eq_sub", "int.le_antisymm", "int.le_trans", "sub_sub_assoc_swap", "sub_eq_of_eq_add", "neg_comm_of_comm", "add_neg_cancel_right", "add_group.add_right_cancel", "eq_sub_of_add_eq", "neg_sub", "int.add_le_add_left", "add_right_comm", "add_sub", "add_neg_cancel_left", "neg_add_rev", "neg_add_cancel_left", "int.to_nat_sub", "eq_add_of_sub_eq", "int.lt.dest", "nat.add_mul_mod_self_left", "add_left_comm", "neg_eq_of_add_eq_zero", "add_eq_of_eq_sub", "sub_add_eq_sub_sub_swap", "add_sub_assoc"]}, {"id": "imp_congr_ctx_eq", "parentIds": ["nat.add_left_cancel"]}, {"id": "eq.to_iff", "parentIds": ["imp_congr_ctx_eq", "forall_congr_eq", "imp_congr_eq", "iff_eq_eq", "decidable_of_decidable_of_eq"]}, {"id": "two_mul", "parentIds": ["nat.bit0_val"]}, {"id": "one_mul", "parentIds": ["two_mul", "mul_inv_rev", "mul_inv_eq", "nat.succ_mul_succ_eq", "one_inv", "one_div_eq_inv", "one_div_lt_one_div_of_lt_of_neg", "div_helper", "nat.one_shiftl", "mul_one_div_cancel", "mul_left_eq_self", "int.eq_one_of_mul_eq_self_left", "mul_inv_cancel_left", "field.div_mul_eq_mul_div_comm", "one_inv_eq", "inv_mul_cancel_left", "one_div_mul_cancel", "neg_eq_neg_one_mul", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_mul_one_div", "one_div_neg_one_eq_neg_one", "functor.const.is_lawful_applicative", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "nat.div_le_self", "one_div_lt_one_div_of_lt", "field.div_mul_right", "eq_of_mul_eq_mul_of_nonzero_left", "int.sign_mul_nat_abs", "div_eq_one_iff_eq", "mul_div_mul_left", "inv_eq_of_mul_eq_one", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "eq_one_div_of_mul_eq_one", "mul_mul_div", "division_ring.one_div_mul_one_div", "nat.shiftl'_tt_eq_mul_pow", "nat.div_one", "nat.pow_one"]}, {"id": "tactic.interactive.recover", "parentIds": []}, {"id": "tactic.metavariables", "parentIds": ["tactic.interactive.recover", "tactic.terminal_goal"]}, {"id": "nonempty_sigma", "parentIds": []}, {"id": "sigma", "parentIds": ["nonempty_sigma", "sigma.has_to_string", "sigma.has_to_format", "buffer.take", "buffer.to_array", "list.sigma", "buffer.read_eq_read'", "sigma.has_sizeof", "buffer.drop", "buffer.reverse", "buffer.take_right", "buffer.write_eq_write'", "mk_buffer", "buffer", "buffer.size", "sigma.eq", "array.to_buffer", "sigma.has_repr"]}, {"id": "nat.add_one_ne_zero", "parentIds": []}, {"id": "nat.succ_ne_zero", "parentIds": ["nat.add_one_ne_zero", "nat.add_self_ne_one", "int.lt_irrefl", "nat.bit1_ne_bit0", "nat.bit0_ne_one", "nat.succ_ne_self", "nat.bit1_ne_one", "int.eq_zero_of_nat_abs_eq_zero", "int.zero_ne_one", "nat.gcd_def", "nat.eq_zero_of_add_eq_zero_right"]}, {"id": "tactic.explode.args", "parentIds": []}, {"id": "norm_num.mul_bit0_helper", "parentIds": []}, {"id": "option_t.ext", "parentIds": ["option_t.is_lawful_monad"]}, {"id": "refl", "parentIds": ["refl_of"]}, {"id": "is_refl", "parentIds": ["refl", "is_preorder", "strict_weak_order.is_equiv", "eq_is_equiv", "refl_of", "is_total_preorder_is_preorder"]}, {"id": "environment.mfold", "parentIds": ["find_cmd", "environment.mfilter"]}, {"id": "add_nonpos", "parentIds": []}, {"id": "add_le_add", "parentIds": ["add_nonpos", "le_add_of_le_of_nonneg", "le_add_of_nonneg_of_le", "add_le_of_nonpos_of_le", "add_le_add_three", "add_nonneg", "nat.bit0_lt_bit1", "sub_le_sub", "nat.bit1_lt_bit0", "add_le_of_le_of_nonpos"]}, {"id": "tactic.explode.status", "parentIds": ["tactic.explode.entry", "tactic.explode.status.inhabited"]}, {"id": "exists_prop", "parentIds": []}, {"id": "or_and_distrib_left", "parentIds": ["and_or_distrib_right"]}, {"id": "imp_intro", "parentIds": ["or_and_distrib_left", "imp_iff_right", "not_of_not_imp"]}, {"id": "and.imp", "parentIds": ["or_and_distrib_left", "and_congr", "and.imp_left", "and_implies", "and.imp_right"]}, {"id": "tactic.is_trace_enabled_for", "parentIds": ["smt_tactic.when_tracing", "tactic.interactive.library_search", "tactic.when_tracing", "tactic.interactive.suggest"]}, {"id": "state_t.run_bind", "parentIds": ["state_t.run_map", "state_t.is_lawful_monad"]}, {"id": "state_t.monad", "parentIds": ["state_t.run_bind", "state_t.run_map", "expr.mfoldl", "state_t.alternative", "smt_tactic.monad", "state_t.is_lawful_monad", "state_t.run_pure"]}, {"id": "state_t.bind", "parentIds": ["state_t.run_bind", "state_t.alternative", "state_t.monad", "state_t.is_lawful_monad"]}, {"id": "bind_ext_congr", "parentIds": ["state_t.run_bind", "option_t.run_map", "except_t.run_map", "except_t.is_lawful_monad", "option_t.is_lawful_monad"]}, {"id": "sum.lex_acc_inr", "parentIds": ["sum.lex_wf"]}, {"id": "sum.lex", "parentIds": ["sum.lex_acc_inr", "sum.lex_wf", "sum.lex_inl_inl", "sum.lex_acc_inl", "sum.lex_inr_inr", "sum.lex_inr_inl"]}, {"id": "acc", "parentIds": ["sum.lex_acc_inr", "tc.accessible", "nat.lt_wf", "subrelation.accessible", "well_founded.apply", "inv_image.accessible", "psigma.rev_lex_accessible", "sum.lex_wf", "well_founded", "well_founded.fix_F", "prod.lex_wf", "well_founded.recursion", "sum.lex_acc_inl", "prod.lex_accessible", "well_founded.fix_F_eq", "empty_wf", "psigma.lex_accessible", "acc.inv"]}, {"id": "vm.stack_obj", "parentIds": []}, {"id": "tactic.save_const_type_info", "parentIds": []}, {"id": "tactic.save_type_info", "parentIds": ["tactic.save_const_type_info", "tactic.i_to_expr_for_apply", "tactic.interactive.to_expr'"]}, {"id": "smt_tactic.interactive.destruct", "parentIds": []}, {"id": "tactic.to_expr_strict", "parentIds": ["smt_tactic.interactive.destruct", "tactic.interactive.by_cases", "smt_tactic.interactive.add_fact", "smt_tactic.interactive.by_cases"]}, {"id": "smt_tactic.destruct", "parentIds": ["smt_tactic.interactive.destruct", "smt_tactic.by_cases"]}, {"id": "tactic.unsafe.type_context.bind", "parentIds": ["tactic.unsafe.type_context.monad", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "eq_inv_iff_mul_eq_one", "parentIds": []}, {"id": "group.to_monoid", "parentIds": ["eq_inv_iff_mul_eq_one", "mul_right_eq_self", "eq_mul_inv_iff_mul_eq", "mul_inv_rev", "mul_eq_one_iff_inv_eq", "one_inv", "mul_inv", "mul_self_iff_eq_one", "mul_right_surjective", "eq_inv_mul_iff_mul_eq", "mul_eq_one_iff_eq_inv", "mul_eq_of_eq_inv_mul", "inv_ne_one", "mul_left_eq_self", "mul_inv_eq_iff_eq_mul", "mul_inv_cancel_left", "mul_right_inv", "mul_inv_self", "inv_mul_cancel_left", "mul_eq_of_eq_mul_inv", "inv_eq_one", "group.mul_left_cancel", "mul_inv_eq_one", "inv_comm_of_comm", "eq_mul_inv_of_mul_eq", "mul_left_surjective", "eq_mul_of_inv_mul_eq", "inv_mul_self", "mul_inv_eq_of_eq_mul", "inv_eq_of_mul_eq_one", "eq_inv_of_mul_eq_one", "eq_inv_mul_of_mul_eq", "mul_left_inv", "mul_inv_cancel_right", "inv_eq_iff_mul_eq_one", "inv_mul_eq_of_eq_mul", "eq_mul_of_mul_inv_eq", "inv_mul_eq_iff_eq_mul", "group.mul_right_cancel", "inv_mul_cancel_right"]}, {"id": "mul_eq_one_iff_eq_inv", "parentIds": ["eq_inv_iff_mul_eq_one", "mul_eq_one_iff_inv_eq", "mul_inv_eq_one"]}, {"id": "to_additive.target_name", "parentIds": []}, {"id": "to_additive.guess_name", "parentIds": ["to_additive.target_name"]}, {"id": "string.has_decidable_eq", "parentIds": ["to_additive.target_name", "simps_tac", "name.is_private", "declaration.is_auto_generated", "tactic.alias.make_left_right", "tactic.find_private_decl", "tactic.success_if_fail_with_msg"]}, {"id": "name.map_prefix", "parentIds": ["to_additive.target_name"]}, {"id": "name.get_prefix", "parentIds": ["to_additive.target_name", "tactic.injection_with", "list_linters", "declaration.is_auto_generated", "expr.list_names_with_prefix"]}, {"id": "tactic.timetac", "parentIds": []}, {"id": "timeit", "parentIds": ["tactic.timetac"]}, {"id": "interaction_monad.result", "parentIds": ["tactic.timetac", "interaction_monad", "interaction_monad.orelse'", "old_conv.istep", "interaction_monad.fail", "smt_tactic.write", "tactic.down", "tactic.interactive.continue", "interaction_monad.result_to_string", "tactic.try_for", "tactic.success_if_fail", "interaction_monad.get_result", "tactic.returnopt", "interaction_monad_return", "lean.parser_result", "lean.parser.of_tactic'", "tactic.interactive.try_for", "tactic.fail_if_success", "tactic.trace_error", "tactic.istep", "tactic.skip", "tactic.decorate_ex", "interaction_monad.mk_exception", "tactic.lock_tactic_state", "tactic.read", "tactic.try_core", "tactic.write", "smt_tactic.try", "smt_tactic.istep", "tactic.retrieve", "interaction_monad_fmap", "interaction_monad_orelse", "tactic.returnex", "interaction_monad.result.clamp_pos", "tactic.up", "lean.parser.parser_orelse", "lean.parser.cur_pos", "tactic.trace_call_stack", "interaction_monad.result_has_string", "tactic.rcases_patt_parse_core", "interaction_monad_bind", "tactic.run_async", "tactic.success_if_fail_with_msg", "tactic_result", "interaction_monad.silent_fail"]}, {"id": "bit0_zero", "parentIds": []}, {"id": "list.length_cons", "parentIds": []}, {"id": "tactic.focus", "parentIds": ["tactic.seq_focus", "tactic.mk_iff_of_inductive_prop"]}, {"id": "string.iterator.set_curr", "parentIds": []}, {"id": "div_lt_of_mul_lt_of_pos", "parentIds": ["one_div_lt_one_div_of_lt"]}, {"id": "mul_mul_div", "parentIds": ["div_lt_of_mul_lt_of_pos", "lt_div_of_mul_lt", "div_le_of_mul_le_of_neg", "div_lt_of_mul_gt_of_neg", "le_div_of_mul_le"]}, {"id": "mul_lt_mul_of_pos_right", "parentIds": ["div_lt_of_mul_lt_of_pos", "lt_div_of_mul_lt", "one_lt_div_of_lt", "mul_lt_mul_of_neg_right", "mul_lt_mul", "mul_pos", "mul_neg_of_neg_of_pos", "le_of_mul_le_mul_right", "div_lt_div_of_lt_of_pos", "mul_lt_of_lt_div"]}, {"id": "ne_of_gt", "parentIds": ["div_lt_of_mul_lt_of_pos", "ordering.compares.eq_gt", "div_mul_le_div_mul_of_div_le_div_pos", "ne_iff_lt_or_gt", "one_div_le_of_one_div_le_of_pos", "add_self_div_two", "norm_num.nonzero_of_pos_helper", "decidable.ne_iff_lt_or_gt", "ordering.compares.eq_eq"]}, {"id": "mul_ne_zero_comm", "parentIds": ["field.div_mul_left"]}, {"id": "division_ring.mul_ne_zero", "parentIds": ["mul_ne_zero_comm", "one_div_add_one_div"]}, {"id": "ne_zero_of_mul_ne_zero_right", "parentIds": ["mul_ne_zero_comm", "field.div_mul_right"]}, {"id": "add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "parentIds": []}, {"id": "le_antisymm", "parentIds": ["add_eq_zero_iff_eq_zero_and_eq_zero_of_nonneg_of_nonneg", "eq_min", "decidable.lt_or_eq_of_le", "nat.eq_zero_of_le_zero", "eq_of_forall_ge_iff", "nat.eq_one_of_dvd_one", "eq_zero_of_abs_eq_zero", "nat.div_eq_of_lt_le", "eq_iff_le_not_lt", "eq_zero_of_mul_self_add_mul_self_eq_zero", "le_antisymm_iff", "lt_of_le_of_ne'", "lt_or_eq_of_le", "nat.eq_of_mul_eq_mul_left", "eq_of_forall_le_iff", "eq_max", "nat.div_div_eq_div_mul", "nat.dvd_antisymm"]}, {"id": "option.is_lawful_monad", "parentIds": []}, {"id": "function.comp_app", "parentIds": ["option.is_lawful_monad", "state_t.run_map", "sum.is_lawful_monad", "option_t.run_map", "parser.is_lawful_monad", "reader_t.is_lawful_monad", "except_t.run_map", "id.is_lawful_monad", "list.is_lawful_monad", "seq_bind_eq", "except_t.is_lawful_monad", "list.map_map", "option_t.is_lawful_monad", "state_t.is_lawful_monad", "list.partition_eq_filter_filter", "function.update_comp"]}, {"id": "is_lawful_monad", "parentIds": ["option.is_lawful_monad", "mjoin_map_map", "bind_pure", "state_t.run_map", "sum.is_lawful_monad", "reader_t.run_map", "option_t.run_map", "mjoin_pure", "parser.is_lawful_monad", "reader_t.is_lawful_monad", "fish_pipe", "except_t.run_map", "functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "mjoin_map_pure", "comp.applicative_id_comp", "id.is_lawful_monad", "list.is_lawful_monad", "seq_bind_eq", "mjoin_map_mjoin", "comp.applicative_comp_id", "except_t.is_lawful_monad", "fish_assoc", "fish_pure", "map_bind", "option_t.is_lawful_monad", "state_t.is_lawful_monad", "seq_eq_bind_map"]}, {"id": "option.monad", "parentIds": ["option.is_lawful_monad", "option.traversable", "string.get_rest", "expr.to_int", "tactic.suggest.process_declaration", "option.alternative", "tactic.find_private_decl"]}, {"id": "option.map", "parentIds": ["option.is_lawful_monad", "option_t.run_map", "option.map_id", "environment.structure_fields_full", "expr.is_eta_expansion_aux", "fold_over_with_cond", "option.alternative", "option.monad", "option_t.is_lawful_monad"]}, {"id": "option.bind", "parentIds": ["option.is_lawful_monad", "option.filter", "option_t.run_map", "option.map", "option.alternative", "option.monad"]}, {"id": "parser.one_of'", "parentIds": []}, {"id": "parser.one_of", "parentIds": ["parser.one_of'"]}, {"id": "parser.eps", "parentIds": ["parser.one_of'", "parser.many'", "parser.ch"]}, {"id": "tactic.suggest.head_symbol_match.decidable_eq", "parentIds": []}, {"id": "tactic.suggest.head_symbol_match", "parentIds": ["tactic.suggest.head_symbol_match.decidable_eq", "tactic.suggest.head_symbol_match.inhabited", "tactic.suggest.head_symbol_match.to_string", "tactic.suggest.match_head_symbol", "tactic.suggest.process_declaration", "tactic.suggest.decl_data", "tactic.suggest.apply_declaration"]}, {"id": "sigma.has_to_string", "parentIds": []}, {"id": "interaction_monad", "parentIds": ["interaction_monad.orelse'", "lean.parser", "interaction_monad.fail", "interaction_monad.get_result", "interaction_monad_return", "interaction_monad_seq", "interaction_monad.monad", "tactic.try", "tactic.step", "interaction_monad.failed", "interaction_monad_fmap", "interaction_monad_orelse", "lean.parser.alternative", "tactic.alternative", "interaction_monad_bind", "tactic.failed", "tactic", "interaction_monad.monad_fail", "interaction_monad.silent_fail", "tactic.fail"]}, {"id": "smt_state", "parentIds": ["smt_tactic.set_goals", "smt_tactic.trace_state", "using_smt", "smt_tactic.write", "smt_tactic", "smt_state.to_format", "smt_tactic.classical", "smt_state.has_append", "smt_tactic.alternative", "smt_tactic.slift_aux", "smt_tactic.save_info", "smt_tactic.try", "smt_tactic.monad_state", "smt_tactic.istep", "smt_tactic.get_goals", "smt_tactic.monad", "smt_tactic.read", "smt_state.classical"]}, {"id": "environment.is_projection", "parentIds": ["print_item_crawl", "declaration.is_auto_generated", "environment.get_modifiers", "tactic.ids_to_simp_arg_list"]}, {"id": "environment.projection_info", "parentIds": ["environment.is_projection", "environment.projection_info.inhabited", "print_item_crawl", "declaration.is_auto_generated", "environment.get_modifiers", "tactic.ids_to_simp_arg_list"]}, {"id": "has_andthen", "parentIds": ["tactic.interactive.min_tac", "tactic.repeat1", "smt_tactic.has_andthen", "tactic.interactive.use", "tactic.andthen_seq_focus", "tactic.andthen_seq", "tactic.mk_inj_eq", "tactic.interactive.ac_change", "tactic.split_if1"]}, {"id": "add_sub_comm", "parentIds": []}, {"id": "neg_add_rev", "parentIds": ["add_sub_comm", "add_sub_add_left_eq_sub", "abs_sub_square", "neg_add", "int.sub_nat_nat_eq_coe", "neg_neg_sub_neg", "sub_sub", "sub_sub_assoc_swap", "sub_sub_self", "int.le_total", "sub_add_eq_sub_sub", "int.neg_succ_of_nat_lt_zero", "sub_add", "sub_add_eq_sub_sub_swap"]}, {"id": "native.float.pow", "parentIds": ["native.float.has_float_pow", "native.float.has_nat_pow"]}, {"id": "le_add_of_sub_left_le", "parentIds": ["le_add_of_neg_add_le_left"]}, {"id": "nat.mul_one", "parentIds": ["nat.comm_semiring", "nat.one_mul"]}, {"id": "nat.zero_add", "parentIds": ["nat.mul_one", "nat.add_comm", "nat.comm_semiring", "nat.add_left_cancel", "nat.eq_zero_of_add_eq_zero_right"]}, {"id": "abs_of_pos", "parentIds": ["abs_pos_of_pos"]}, {"id": "abs_of_nonneg", "parentIds": ["abs_of_pos", "abs_one_div", "abs_nonneg", "abs_mul", "int.abs_eq_nat_abs", "abs_zero", "le_abs_self", "abs_by_cases", "abs_abs", "dist_bdd_within_interval"]}, {"id": "nat.mul_div_mul", "parentIds": []}, {"id": "nat.mul_div_cancel_left", "parentIds": ["nat.mul_div_mul", "nat.div_eq_of_eq_mul_right"]}, {"id": "nat.div_div_eq_div_mul", "parentIds": ["nat.mul_div_mul", "nat.shiftr_eq_div_pow"]}, {"id": "lt_or_gt_of_ne", "parentIds": ["abs_pos_of_ne_zero", "ne_iff_lt_or_gt"]}, {"id": "linear_order", "parentIds": ["lt_or_gt_of_ne", "exists_ge_of_linear", "lt_of_not_ge'", "le_of_not_ge", "linear_ordered_semiring.to_linear_order", "decidable_linear_ordered_semiring", "max_self", "not_lt_of_gt", "lt_imp_lt_of_le_imp_le", "forall_lt_iff_le", "push_neg.not_le_eq", "le_of_forall_lt'", "lt_iff_not_ge", "le_or_lt", "max_lt", "le_min", "le_max_left", "lt_of_not_ge", "decidable_linear_ordered_cancel_comm_monoid", "push_neg.not_lt_eq", "linear_ordered_ring.to_linear_order", "decidable.lt_by_cases", "lt_min", "ne_iff_lt_or_gt", "nat.linear_order", "has_le.le.decidable", "decidable_linear_order", "not_lt_iff_eq_or_lt", "lt_trichotomy", "has_lt.lt.decidable", "discrete_linear_ordered_field", "not_lt", "max_le", "not_le", "linear_order.to_partial_order", "le_of_not_gt", "decidable.le_imp_le_iff_lt_imp_lt", "le_of_forall_lt", "min_le_right", "lt_or_ge", "decidable_linear_order.to_linear_order", "le_imp_le_iff_lt_imp_lt", "lt_iff_lt_of_le_iff_le", "cmp_compares", "lt_or_le", "le_total", "le_of_not_lt", "decidable_linear_ordered_comm_ring", "min_self", "le_imp_le_of_lt_imp_lt", "le_of_not_le", "le_iff_le_iff_lt_iff_lt", "min_le_left", "le_or_gt", "decidable_linear_ordered_comm_group", "le_max_right", "forall_lt_iff_le'", "lt_iff_not_ge'"]}, {"id": "lt_trichotomy", "parentIds": ["lt_or_gt_of_ne", "lt_of_not_ge", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "eq_zero_of_neg_eq", "le_of_not_gt", "lt_or_ge", "pos_and_pos_or_neg_and_neg_of_mul_pos"]}, {"id": "prod.id_prod", "parentIds": []}, {"id": "is_cond_right_inv", "parentIds": []}, {"id": "tactic.rcases.process_constructor", "parentIds": []}, {"id": "ball_true_iff", "parentIds": []}, {"id": "mjoin_map_map", "parentIds": []}, {"id": "map_bind", "parentIds": ["mjoin_map_map"]}, {"id": "mjoin", "parentIds": ["mjoin_map_map", "mjoin_pure", "mjoin_map_pure", "monad.join", "mjoin_map_mjoin"]}, {"id": "decidable_of_bool", "parentIds": []}, {"id": "tactic.interactive.trivial", "parentIds": ["tactic.interactive.simpa"]}, {"id": "tactic.triv", "parentIds": ["tactic.interactive.trivial", "tactic.interactive.simp_intros", "tactic.interactive.simp_core"]}, {"id": "nat.lcm", "parentIds": []}, {"id": "nat.gcd", "parentIds": ["nat.lcm", "nat.gcd_succ", "nat.gcd_zero_left", "nat.coprime", "nat.gcd_one_left", "nat.gcd_zero_right", "nat.gcd_rec", "int.gcd", "nat.gcd_self", "nat.gcd_def"]}, {"id": "nat.not_succ_le_zero", "parentIds": ["nat.not_lt_zero", "nat.le_of_le_of_sub_le_sub_right", "nat.not_succ_le_self", "nat.le_div_iff_mul_le"]}, {"id": "coe_fn_coe_trans", "parentIds": []}, {"id": "coe_fn_trans", "parentIds": ["coe_fn_coe_trans", "coe_fn_coe_base"]}, {"id": "has_coe_to_fun", "parentIds": ["coe_fn_coe_trans", "coe_fn", "coe_fn_coe_base", "applicative_transformation.has_coe_to_fun", "coe_fn_trans", "coe_fn_b", "expr.has_coe_to_fun"]}, {"id": "option.has_to_tactic_format", "parentIds": []}, {"id": "module_info.of_module_name", "parentIds": []}, {"id": "module_info.module_id", "parentIds": ["module_info.of_module_name", "module_info.of_module_id", "environment.for_decl_of_imported_module", "module_info.id", "module_info.has_to_tactic_format", "module_info.resolve_module_name", "environment.from_imported_module", "module_info.has_to_format"]}, {"id": "module_info.resolve_module_name", "parentIds": ["module_info.of_module_name", "environment.from_imported_module_name", "environment.for_decl_of_imported_module_name"]}, {"id": "module_info.module_name", "parentIds": ["module_info.of_module_name", "environment.from_imported_module_name", "module_info.resolve_module_name", "environment.for_decl_of_imported_module_name"]}, {"id": "module_info.of_module_id", "parentIds": ["module_info.of_module_name", "environment.for_decl_of_imported_module", "environment.from_imported_module"]}, {"id": "bnot_eq_ff_eq_eq_tt", "parentIds": []}, {"id": "tactic.find_assumption", "parentIds": []}, {"id": "where.trace_namespace", "parentIds": ["where.trace_where"]}, {"id": "lean.parser.has_coe'", "parentIds": ["where.trace_namespace", "where.trace_variables", "where.mk_flag", "tactic.mk_simp_attribute_cmd", "apply_nolint_cmd", "to_additive.parser", "localized_cmd", "lean.parser.get_includes", "tactic.def_replacer_cmd", "find_cmd", "where.get_variables_core", "open_locale_cmd", "list_linters", "where.trace_where", "where.is_variable_name", "tactic.explode_cmd", "tactic.import_private_cmd"]}, {"id": "tactic.mk_assoc_pattern'", "parentIds": ["tactic.mk_assoc_pattern"]}, {"id": "cc_state.mk_using_hs", "parentIds": []}, {"id": "id.is_lawful_traversable", "parentIds": []}, {"id": "is_lawful_traversable", "parentIds": ["id.is_lawful_traversable"]}, {"id": "id.traversable", "parentIds": ["id.is_lawful_traversable"]}, {"id": "smt_tactic.execute_with", "parentIds": []}, {"id": "using_smt", "parentIds": ["smt_tactic.execute_with", "smt_tactic.execute", "using_smt_with", "smt_tactic.interactive.executor"]}, {"id": "smt_config", "parentIds": ["smt_tactic.execute_with", "smt_tactic.get_config", "using_smt", "smt_tactic.slift", "smt_tactic.slift_aux", "smt_tactic.execute", "rsimp.collect_implied_eqs", "smt_config.inhabited", "using_smt_with", "smt_config.set_classical", "smt_tactic.interactive.executor"]}, {"id": "format.sbracket", "parentIds": []}, {"id": "not_imp", "parentIds": ["push_neg.not_implies_eq"]}, {"id": "of_not_imp", "parentIds": ["not_imp"]}, {"id": "not_of_not_imp", "parentIds": ["not_imp"]}, {"id": "int.repr", "parentIds": ["int.has_repr", "int.has_to_string"]}, {"id": "exists_ge_of_linear", "parentIds": []}, {"id": "smt_tactic.ematch_using", "parentIds": ["smt_tactic.interactive.eblast_using", "smt_tactic.interactive.ematch_using"]}, {"id": "option_t.run_pure", "parentIds": ["option_t.run_map", "option_t.is_lawful_monad"]}, {"id": "option_t.alternative", "parentIds": ["option_t.run_pure", "option_t.run_map"]}, {"id": "tactic.interactive.field_simp", "parentIds": []}, {"id": "tactic.interactive.propagate_tags", "parentIds": ["tactic.interactive.field_simp", "tactic.interactive.revert", "tactic.interactive.have_field", "tactic.interactive.apply_field", "tactic.interactive.simp", "tactic.interactive.rename", "tactic.interactive.erw", "tactic.interactive.generalize", "tactic.interactive.erewrite", "tactic.interactive.intro", "tactic.interactive.assoc_rewrite", "tactic.interactive.rw", "tactic.interactive.intros", "tactic.interactive.introv", "tactic.interactive.rewrite"]}, {"id": "tactic.interactive.simp_core", "parentIds": ["tactic.interactive.field_simp", "tactic.interactive.unfold", "tactic.interactive.simp"]}, {"id": "nat.succ_eq_add_one", "parentIds": []}, {"id": "classical.forall_or_distrib", "parentIds": []}, {"id": "forall_or_distrib_right", "parentIds": ["classical.forall_or_distrib", "classical.forall_or_distrib_right"]}, {"id": "forall_or_distrib_left", "parentIds": ["classical.forall_or_distrib", "classical.forall_or_distrib_left", "forall_or_distrib_right"]}, {"id": "forall_congr_eq", "parentIds": ["classical.forall_or_distrib", "bex_imp_distrib", "not_exists_not", "forall_eq'", "state_t.is_lawful_monad", "forall_or_distrib_right"]}, {"id": "tactic.doc_string", "parentIds": ["doc_blame_report_defn", "doc_blame_report_thm", "tactic.module_doc_strings"]}, {"id": "attribute.register", "parentIds": ["tactic.mk_simp_attr", "register_attribute", "mk_hinst_lemma_attr_from_simp_attr", "mk_hinst_lemma_attr_set", "mk_hinst_lemma_attr_core"]}, {"id": "name.has_append", "parentIds": ["tactic.mk_user_fresh_name", "environment.structure_fields_full", "instance_derive_handler", "tactic.delta_instance", "derive_struct_ext_lemma"]}, {"id": "name.append", "parentIds": ["name.has_append", "tactic.mk_simp_attribute_cmd", "tactic.mk_iff_of_inductive_prop", "where.is_in_namespace_nonsynthetic"]}, {"id": "try_for", "parentIds": ["tactic.try_for", "tactic.interactive.try_for"]}, {"id": "function.left_inverse_surj_inv", "parentIds": ["function.bijective_iff_has_inverse"]}, {"id": "function.right_inverse_of_injective_of_left_inverse", "parentIds": ["function.left_inverse_surj_inv"]}, {"id": "function.right_inverse_surj_inv", "parentIds": ["function.left_inverse_surj_inv", "function.surjective.has_right_inverse", "function.injective_surj_inv", "function.bijective_iff_has_inverse"]}, {"id": "reflected_value", "parentIds": ["lean.parser.reflectable.optional", "lean.parser.val", "lean.parser.reflectable", "reflected_value.subst", "reflected_value.expr", "lean.parser.reflectable.has_reflect", "lean.parser.reflectable.cast", "lean.parser.reflectable.expr", "lean.parser.itactic_reflected"]}, {"id": "reflected_value.subst", "parentIds": ["lean.parser.reflectable.optional"]}, {"id": "tactic.cases", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.interactive.cases_core", "tactic.case_bash", "tactic.mk_dec_eq_instance_core", "tactic.mk_has_reflect_instance", "derive_struct_ext_lemma"]}, {"id": "tactic.cases_core", "parentIds": ["tactic.cases"]}, {"id": "tactic.intro1", "parentIds": ["tactic.cases", "tactic.rcases_hint", "tactic.interactive.induction", "tactic.mk_dec_eq_instance", "tactic.choose1", "tactic.mk_iff_of_inductive_prop", "old_conv.funext", "tactic.mk_dec_eq_instance_core", "tactic.contradiction", "tactic.interactive.generalize", "tactic.by_contradiction", "tactic.rcases", "tactic.interactive.intro", "tactic.intro1_aux", "tactic.intros1", "derive_struct_ext_lemma"]}, {"id": "tactic.revert", "parentIds": ["tactic.cases", "tactic.rcases_hint", "tactic.interactive.induction", "tactic.change_core", "tactic.revert_and_transform", "tactic.local_def_value", "tactic.rcases", "tactic.rename"]}, {"id": "tactic.assertv", "parentIds": ["tactic.cases", "tactic.rcases_hint", "tactic.note", "tactic.rcases", "tactic.interactive.simpa", "tactic.mk_assoc_instance", "tactic.interactive.have", "tactic.subst"]}, {"id": "tactic.intron", "parentIds": ["tactic.cases", "tactic.clear'", "tactic.interactive.induction", "tactic.interactive.dsimp", "tactic.interactive.generalize_hyp", "tactic.change_core", "tactic.revert_and_transform", "tactic.rename", "tactic.interactive.dunfold", "tactic.interactive.case", "derive_struct_ext_lemma", "dedup", "tactic.interactive.delta"]}, {"id": "tactic.generalize", "parentIds": ["tactic.cases", "tactic.rcases_hint", "tactic.interactive.induction", "tactic.interactive.generalize", "tactic.rcases"]}, {"id": "expr.is_local_constant", "parentIds": ["tactic.cases", "tactic.rcases_hint", "tactic.interactive.induction", "expr.list_local_consts", "tactic.lift", "rsimp.rsimplify_at", "tactic.rcases", "tactic.simp_hyp", "tactic.interactive.specialize", "incorrect_type_class_argument", "tactic.subst"]}, {"id": "tactic.revert_kdependencies", "parentIds": ["tactic.cases", "tactic.rcases_hint", "tactic.revert_kdeps", "tactic.rcases"]}, {"id": "int.lt", "parentIds": ["int.has_lt", "int.decidable_linear_ordered_comm_ring"]}, {"id": "quotient", "parentIds": ["quot.exact", "quotient.rec_on_subsingleton\u2082", "quotient.ind\u2082", "quotient.hrec_on", "quotient.induction_on\u2083", "quotient.decidable_eq", "quotient.lift_on\u2082", "quotient.exact", "quotient.sound", "funext", "quotient.induction_on", "quotient.ind", "quotient.lift_on", "quotient.lift", "quotient.exists_rep", "quotient.induction_on\u2082", "quotient.rec_on_subsingleton", "quotient.lift\u2082"]}, {"id": "setoid", "parentIds": ["quotient", "quot.exact", "quotient.rec_on_subsingleton\u2082", "quotient.ind\u2082", "quotient.hrec_on", "quotient.induction_on\u2083", "quotient.decidable_eq", "quotient.lift_on\u2082", "quotient.exact", "setoid.trans", "quotient.sound", "quotient.induction_on", "quotient.ind", "quotient.lift_on", "quotient.lift", "eqv_gen.setoid", "quotient.exists_rep", "setoid.symm", "quotient.induction_on\u2082", "quotient.rec_on_subsingleton", "setoid_has_equiv", "quotient.lift\u2082", "setoid.refl"]}, {"id": "quot", "parentIds": ["quotient", "quot.exact", "quot.ind", "quot.hrec_on", "quot.lift_beta", "quot.lift_on", "quot.ind_beta", "quot.exists_rep", "quot.rec_on_subsingleton", "quot.indep", "quot.lift", "quot.eqv_gen_sound", "quot.sound", "quot.lift_indep_pr1", "quot.indep_coherent", "quot.induction_on"]}, {"id": "failure", "parentIds": ["guard", "tactic.mllist.head", "assert", "guard_true", "guard_false", "reader_t.failure", "state_t.failure"]}, {"id": "state_t.monad_map", "parentIds": ["state_t.monad_functor"]}, {"id": "parser.pure", "parentIds": ["parser.alternative", "parser.is_lawful_monad", "parser.monad"]}, {"id": "tactic.existsi", "parentIds": []}, {"id": "expr.binding_domain", "parentIds": ["tactic.existsi", "tactic.injection_with"]}, {"id": "expr.is_pi", "parentIds": ["tactic.existsi", "tactic.intro"]}, {"id": "tactic.get_constructors_for", "parentIds": ["tactic.existsi", "tactic.left", "tactic.constructor_idx", "tactic.right", "tactic.constructor", "tactic.fsplit", "tactic.split"]}, {"id": "tactic.get_arity", "parentIds": ["tactic.existsi", "tactic.injection_with", "saturate_fun"]}, {"id": "when", "parentIds": ["tactic.existsi", "tactic.get_constructors_for", "tactic.interactive.propagate_tags", "tactic.clear'", "tactic.mk_dec_eq_instance", "simps_add_projection", "tactic.interactive.unfold_projs", "tactic.try_apply_opt_auto_param_for_apply", "tactic.interactive.set", "tactic.interactive.change'", "tactic.lift", "tactic.abstract", "tactic.case_bash", "tactic.when_tracing", "tactic.mk_inhabited_instance", "tactic.try_apply_opt_auto_param", "rsimp.rsimplify_at", "conv.interactive.find", "tactic.interactive.simp_intros", "tactic.fail_if_no_goals", "tactic.mk_simp_set_core", "tactic.simp_hyp", "tactic.prove_goal_async", "tactic.interactive.extract_goal", "tactic.interactive.clear_except", "tactic.interactive.h_generalize", "tactic.interactive.case", "tactic.injections_and_clear", "conv.convert", "tactic.rename'", "tactic.done", "tactic.reduce_ifs_at", "tactic.ids_to_simp_arg_list"]}, {"id": "tactic.whnf", "parentIds": ["tactic.existsi", "tactic.whnf_target", "tactic.mk_dec_eq_instance", "tactic.choose1", "push_neg.whnf_reducible", "tactic.instance_stub", "tactic.whnf_no_delta", "conv.whnf", "well_founded_tactics.cancel_nat_add_lt", "tactic.eqn_stub", "tactic.mk_local_pis_whnf", "tactic.list_constructors_hole", "tactic.comp_val", "old_conv.congr_core", "tactic.get_pi_arity", "tactic.injection_with", "tactic.match_stub", "tactic.whnf_ginductive", "old_conv.whnf", "has_inhabited_instance", "tactic.get_expl_pi_arity"]}, {"id": "tactic.eapply", "parentIds": ["tactic.existsi", "tactic.interactive.eapply", "tactic.by_contradiction", "tactic.injection_with", "tactic.eapplyc"]}, {"id": "nat.succ_sub_sub_succ", "parentIds": []}, {"id": "nat.sub_sub", "parentIds": ["nat.succ_sub_sub_succ", "nat.sub_mul_mod", "nat.sub_one_sub_lt", "nat.sub_mul_div", "nat.sub.right_comm", "nat.mul_sub_right_distrib"]}, {"id": "nat.add_succ", "parentIds": ["nat.succ_sub_sub_succ", "int.add_assoc", "int.nat_abs_add_neg", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "nat.add_sub_add_right", "nat.le.dest", "nat.succ_sub", "nat.sub_sub", "nat.succ_mul", "nat.add_lt_add_left", "nat.add_assoc"]}, {"id": "nat.succ_sub_succ", "parentIds": ["nat.succ_sub_sub_succ", "nat.sub_self", "nat.add_sub_add_right", "nat.le_of_le_of_sub_le_sub_right"]}, {"id": "expr.dedup_size", "parentIds": ["print_item_crawl"]}, {"id": "expr.dedup_size_aux", "parentIds": ["expr.dedup_size"]}, {"id": "native.mk_rb_set", "parentIds": ["expr.dedup_size", "mk_expr_set", "level.dedup_size", "native.rb_set.inhabited"]}, {"id": "expr.lt", "parentIds": ["expr.dedup_size", "expr.decidable_rel", "expr.expr.lt_prop"]}, {"id": "unused_arguments", "parentIds": ["linter.unused_arguments"]}, {"id": "declaration.type", "parentIds": ["unused_arguments", "incorrect_def_lemma", "tactic.instance_cache.mk_app", "where.get_def_variables", "simps_tac", "tactic.mk_iff_of_inductive_prop", "tactic.constructor_num_fields", "copy_decl_updating_type", "tactic.explode", "tactic.decl_mk_const", "check_unused_arguments", "print_item_crawl", "copy_decl_using", "tactic.suggest.process_declaration", "declaration.update_with_fun", "tactic.mk_constructor_fresh_names", "list_linters", "tactic.alias.alias_iff", "impossible_instance", "incorrect_type_class_argument", "instance_priority", "instance_derive_handler", "tactic.is_prop_decl", "tactic.delta_instance", "tactic.replaceable_attr", "dangerous_instance", "tactic.replacer_attr", "ge_or_gt_in_statement", "has_inhabited_instance", "tactic.import_private_cmd"]}, {"id": "list.to_string_aux", "parentIds": ["unused_arguments", "print_arguments"]}, {"id": "format.has_to_string", "parentIds": ["unused_arguments", "print_arguments", "interaction_monad.result_to_string", "tactic.suggest.tactic_statement", "exceptional.to_string", "print_item_crawl", "where.format_variable"]}, {"id": "binder.inhabited", "parentIds": ["unused_arguments", "expr.to_binder"]}, {"id": "list.countp", "parentIds": ["unused_arguments", "list.count"]}, {"id": "option.iget", "parentIds": ["unused_arguments", "list.inth", "fold_over_with_cond_sorted", "option.iget_some", "tactic.success_if_fail_with_msg", "dup_namespace", "native.rb_map.ifind"]}, {"id": "list.nth", "parentIds": ["unused_arguments", "tactic.constructor_idx", "tactic.lift", "tactic.relation_lhs_rhs", "list.inth", "tactic.interactive.swap", "tactic.interactive.field"]}, {"id": "list.decidable_eq", "parentIds": ["unused_arguments", "tactic.interactive.propagate_tags", "tactic.interactive.guard_tags", "tactic.lift", "well_founded_tactics.cancel_nat_add_lt", "check_unused_arguments", "string.has_decidable_eq"]}, {"id": "tactic.get_pi_binders", "parentIds": ["unused_arguments", "incorrect_type_class_argument"]}, {"id": "binder.has_to_tactic_format", "parentIds": ["unused_arguments", "impossible_instance", "incorrect_type_class_argument", "dangerous_instance"]}, {"id": "check_unused_arguments", "parentIds": ["unused_arguments"]}, {"id": "array.push_back_idx", "parentIds": []}, {"id": "nat.lt_of_le_and_ne", "parentIds": ["array.push_back_idx", "nat.lt_iff_le_not_le", "nat.lt_of_add_lt_add_left"]}, {"id": "group.to_left_cancel_semigroup", "parentIds": ["mul_right_eq_self", "mul_self_iff_eq_one"]}, {"id": "left_cancel_semigroup", "parentIds": ["group.to_left_cancel_semigroup", "mul_left_cancel", "mul_left_injective", "left_cancel_semigroup.to_semigroup", "mul_left_cancel_iff", "mul_left_inj"]}, {"id": "group.mul_left_cancel", "parentIds": ["group.to_left_cancel_semigroup"]}, {"id": "push_neg.not_eq", "parentIds": []}, {"id": "iff.rfl", "parentIds": ["push_neg.not_eq", "imp_false", "gt_iff_lt", "list.mem_nil_iff", "list.mem_cons_iff", "iff_self", "not_lt_iff_eq_or_lt", "ge_iff_le", "iff_of_eq", "option.mem_def", "eq.to_iff", "exists_unique_congr"]}, {"id": "list.map_accumr\u2082", "parentIds": ["list.length_map_accumr\u2082"]}, {"id": "quot.exact", "parentIds": []}, {"id": "eqv_gen.setoid", "parentIds": ["quot.exact"]}, {"id": "quot.lift", "parentIds": ["quot.exact", "quot.lift_beta", "quot.lift_on", "quotient.lift", "quot.lift_indep_pr1"]}, {"id": "quot.sound", "parentIds": ["quot.exact", "quotient.sound", "quot.eqv_gen_sound", "quot.lift_indep_pr1", "quot.indep_coherent"]}, {"id": "quotient.exact", "parentIds": ["quot.exact"]}, {"id": "applicative_transformation.preserves_map", "parentIds": []}, {"id": "applicative_transformation.has_coe_to_fun", "parentIds": ["applicative_transformation.preserves_map", "applicative_transformation.preserves_seq", "is_lawful_traversable", "applicative_transformation.preserves_pure"]}, {"id": "applicative_transformation.preserves_seq", "parentIds": ["applicative_transformation.preserves_map"]}, {"id": "applicative_transformation", "parentIds": ["applicative_transformation.preserves_map", "applicative_transformation.preserves_seq", "is_lawful_traversable", "applicative_transformation.has_coe_to_fun", "applicative_transformation.preserves_pure"]}, {"id": "applicative_transformation.preserves_pure", "parentIds": ["applicative_transformation.preserves_map"]}, {"id": "gt.trans", "parentIds": []}, {"id": "gt_trans", "parentIds": ["gt.trans"]}, {"id": "interactive.loc.inhabited", "parentIds": []}, {"id": "function.uncurry_curry", "parentIds": []}, {"id": "function.uncurry", "parentIds": ["function.uncurry_curry", "function.curry_uncurry", "function.uncurry_bicompr", "native.rb_map.mfilter", "function.uncurry_def"]}, {"id": "function.curry", "parentIds": ["function.uncurry_curry", "function.curry_uncurry'", "function.curry_uncurry", "function.uncurry'_curry"]}, {"id": "unsigned.has_zero", "parentIds": ["ext_param", "unsigned.inhabited", "saturate_fun"]}, {"id": "array.take", "parentIds": ["buffer.take"]}, {"id": "cast", "parentIds": ["array.take", "array.take_right", "unchecked_cast", "cast_proof_irrel", "cast_heq", "cast_eq"]}, {"id": "array.slice", "parentIds": ["array.take", "array.drop"]}, {"id": "lean.githash", "parentIds": []}, {"id": "congr_arg_kind.has_to_format", "parentIds": []}, {"id": "congr_arg_kind.to_string", "parentIds": ["congr_arg_kind.has_to_format", "congr_arg_kind.has_repr"]}, {"id": "congr_arg_kind", "parentIds": ["congr_arg_kind.has_to_format", "congr_arg_kind.to_string", "congr_arg_kind.inhabited", "congr_arg_kind.has_repr", "congr_lemma"]}, {"id": "sigma.has_to_format", "parentIds": []}, {"id": "format.line", "parentIds": ["sigma.has_to_format", "tactic.cc_core", "old_conv.conversion", "format.indent", "tactic.lift", "tactic.mk_patterns", "tactic.decorate_ex", "tactic.eqn_stub", "tactic.list_constructors_hole", "prod.has_to_format", "list.to_format", "hinst_lemmas.pp", "tactic.match_stub", "lint_aux", "tactic.interactive.extract_goal", "tactic.get_lift_prf", "tactic.rename'", "tactic.success_if_fail_with_msg"]}, {"id": "format.nest", "parentIds": ["sigma.has_to_format", "sum_has_to_format", "name_set.has_to_format", "native.rb_map.has_to_tactic_format", "native.has_to_format", "format.indent", "tactic.decorate_ex", "native.rb_set.has_to_format", "prod.has_to_format", "option.has_to_format", "list.to_format", "format.bracket", "format.dcbrace"]}, {"id": "applicative.map_seq_map", "parentIds": []}, {"id": "seq_map_assoc", "parentIds": ["applicative.map_seq_map", "comp.is_comm_applicative", "comp.seq_assoc"]}, {"id": "congr_fun", "parentIds": ["applicative.map_seq_map", "nat.div_def_aux", "d_array.read_write", "nat.bitwise_zero_left", "function.uncurry'_curry", "nat.bitwise_zero_right", "nat.bitwise_bit", "comp.pure_seq_eq_map", "function.cantor_surjective", "nat.mod_def_aux", "functor.comp.id_map", "d_array.read_write_of_ne"]}, {"id": "flip", "parentIds": ["applicative.map_seq_map", "expr.mfoldl", "is_comm_applicative.commutative_map", "comp.is_comm_applicative", "tactic.mllist.monad_lift"]}, {"id": "map_map", "parentIds": ["applicative.map_seq_map", "functor.comp.comp_map", "is_comm_applicative.commutative_map", "comp.is_comm_applicative", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "eq_zero_of_zero_dvd", "parentIds": ["nat.pos_of_dvd_of_pos", "nat.dvd_antisymm"]}, {"id": "dvd.elim", "parentIds": ["eq_zero_of_zero_dvd", "dvd_of_mul_left_dvd", "dvd_of_mul_right_dvd", "exists_eq_mul_left_of_dvd", "nat.dvd_add_iff_right", "neg_dvd_of_dvd", "dvd_mul_of_dvd_left", "dvd_add", "dvd_neg_of_dvd", "nat.dvd_of_mul_dvd_mul_left", "nat.mod_eq_zero_of_dvd"]}, {"id": "classical.by_contradiction", "parentIds": ["not_imp_eq_of_eq_false_right", "eq_true_of_not_eq_false", "eq_iff_le_not_lt"]}, {"id": "not_exists_of_forall_not", "parentIds": []}, {"id": "monoid_to_is_left_id", "parentIds": []}, {"id": "is_left_id", "parentIds": ["monoid_to_is_left_id", "option.lift_or_get_is_left_id", "add_monoid_to_is_left_id"]}, {"id": "norm_num.add1_bit1", "parentIds": []}, {"id": "norm_num.add1", "parentIds": ["norm_num.add1_bit1", "norm_num.bit1_add_one_helper", "norm_num.bit1_add_one", "norm_num.add1_zero", "norm_num.one_add_bit1", "norm_num.add1_bit1_helper", "norm_num.bit1_add_bit1", "norm_num.bit1_add_bit1_helper", "norm_num.one_add_bit1_helper", "norm_num.add1_one", "norm_num.add1_bit0"]}, {"id": "abs_pos_of_ne_zero", "parentIds": []}, {"id": "abs_pos_of_neg", "parentIds": ["abs_pos_of_ne_zero"]}, {"id": "abs_pos_of_pos", "parentIds": ["abs_pos_of_ne_zero", "abs_pos_of_neg"]}, {"id": "lt_of_not_ge'", "parentIds": ["lt_imp_lt_of_le_imp_le", "lt_iff_not_ge'"]}, {"id": "lt_of_le_not_le", "parentIds": ["lt_of_not_ge'", "lt_of_add_lt_add_left", "lt_trans", "decidable.lt_or_eq_of_le", "eq_iff_le_not_lt", "decidable.le_of_not_lt", "lt_of_le_of_ne'", "lt_or_eq_of_le", "add_lt_add_left", "lt_of_lt_of_le", "lt_of_le_of_lt"]}, {"id": "or.resolve_right", "parentIds": ["lt_of_not_ge'", "eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "lt_of_le_of_ne", "nat.lt_of_le_and_ne", "decidable.le_of_not_lt"]}, {"id": "vm_obj.to_level", "parentIds": []}, {"id": "cc_state.is_eqv", "parentIds": ["tactic.cc_core", "tactic.ac_refl"]}, {"id": "cc_state.has_to_tactic_format", "parentIds": ["tactic.cc_core"]}, {"id": "cc_state.proof_for_false", "parentIds": ["tactic.cc_core"]}, {"id": "cc_state.inconsistent", "parentIds": ["tactic.cc_core"]}, {"id": "tactic.get_bool_option", "parentIds": ["tactic.cc_core"]}, {"id": "cc_state.eqv_proof", "parentIds": ["tactic.cc_core", "tactic.ac_refl", "rsimp.rsimplify"]}, {"id": "cc_state.internalize", "parentIds": ["tactic.cc_core", "tactic.ac_refl"]}, {"id": "pos.inhabited", "parentIds": []}, {"id": "nat.inhabited", "parentIds": ["pos.inhabited", "environment.projection_info.inhabited"]}, {"id": "nonempty_empty", "parentIds": []}, {"id": "empty", "parentIds": ["nonempty_empty", "empty.decidable_eq", "empty.elim", "empty.subsingleton"]}, {"id": "empty.elim", "parentIds": ["nonempty_empty", "empty.decidable_eq", "empty.subsingleton"]}, {"id": "mul_nonneg_of_nonpos_of_nonpos", "parentIds": ["div_nonneg_of_nonpos_of_neg", "abs_mul", "mul_self_nonneg"]}, {"id": "mul_le_mul_of_nonpos_right", "parentIds": ["mul_nonneg_of_nonpos_of_nonpos", "div_le_div_of_le_of_neg", "div_le_of_mul_le_of_neg", "mul_le_of_div_le_of_neg"]}, {"id": "nat.sub", "parentIds": ["nat.sub_le_sub_left", "nat.sub_le_sub_right", "nat.has_sub"]}, {"id": "abs_sub_le", "parentIds": []}, {"id": "le_of_not_ge", "parentIds": ["nat.sub_eq_sub_min"]}, {"id": "neg_add_lt_of_lt_add", "parentIds": []}, {"id": "le_add_of_neg_le_sub_right", "parentIds": []}, {"id": "le_add_of_sub_right_le", "parentIds": ["le_add_of_neg_le_sub_right", "ge_of_forall_ge_sub", "sub_le_of_abs_sub_le_left", "sub_le_of_sub_le", "le_add_of_neg_add_le_right"]}, {"id": "add_le_of_le_sub_left", "parentIds": ["le_add_of_neg_le_sub_right"]}, {"id": "bex.elim", "parentIds": []}, {"id": "ematch_state.internalize", "parentIds": []}, {"id": "ematch_state", "parentIds": ["ematch_state.internalize", "tactic.ematch_all_core", "smt_tactic.to_em_state", "tactic.ematch_core", "tactic.ematch_all", "tactic.ematch"]}, {"id": "function.comp.assoc", "parentIds": []}, {"id": "add_sub_add_left_eq_sub", "parentIds": []}, {"id": "smt_tactic.get_config", "parentIds": ["smt_tactic.slift"]}, {"id": "cmp_using_eq_lt", "parentIds": []}, {"id": "ordering.ite_eq_lt_distrib", "parentIds": ["cmp_using_eq_lt"]}, {"id": "and_false", "parentIds": ["cmp_using_eq_lt", "band_eq_true_eq_eq_tt_and_eq_tt", "nat.mod_eq_of_lt", "bor_eq_false_eq_eq_ff_and_eq_ff", "and_eq_of_eq_false_right", "bool.to_bool_and"]}, {"id": "option.lift_or_get_idem", "parentIds": []}, {"id": "is_idempotent", "parentIds": ["option.lift_or_get_idem"]}, {"id": "tactic.mk_comp", "parentIds": []}, {"id": "tactic.back_lemmas_find", "parentIds": []}, {"id": "tactic.back_lemmas", "parentIds": ["tactic.back_lemmas_find", "tactic.back_lemmas_add_extra", "tactic.back_lemmas_insert_core", "tactic.mk_back_lemmas_core", "tactic.back_lemmas_insert", "tactic.back_chaining_core", "tactic.mk_back_lemmas", "tactic.backward_chaining_core"]}, {"id": "char.of_nat_eq_of_not_is_valid", "parentIds": []}, {"id": "char.eq_of_veq", "parentIds": ["char.of_nat_eq_of_not_is_valid", "char.vne_of_ne"]}, {"id": "char.val_of_nat_eq_of_not_is_valid", "parentIds": ["char.of_nat_eq_of_not_is_valid"]}, {"id": "linear_ordered_semiring.to_linear_order", "parentIds": ["nonneg_of_mul_nonneg_left", "lt_of_mul_lt_mul_right", "pos_of_mul_pos_right", "le_of_mul_le_mul_right", "nonneg_of_mul_nonneg_right", "le_of_mul_le_mul_left", "neg_of_mul_neg_right", "nonpos_of_mul_nonpos_left", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "neg_of_mul_neg_left", "nonpos_of_mul_nonpos_right"]}, {"id": "vm_obj.fn_idx", "parentIds": []}, {"id": "id_delta", "parentIds": []}, {"id": "functor.add_const.is_lawful_applicative", "parentIds": []}, {"id": "functor.add_const", "parentIds": ["functor.add_const.is_lawful_applicative", "functor.add_const.functor", "functor.add_const.is_lawful_functor", "functor.add_const.run", "functor.add_const.applicative"]}, {"id": "functor.add_const.applicative", "parentIds": ["functor.add_const.is_lawful_applicative"]}, {"id": "tactic.apply_inj_lemma", "parentIds": ["tactic.mk_inj_eq"]}, {"id": "tactic.applyc", "parentIds": ["tactic.apply_inj_lemma", "tactic.interactive.apply_iff_congr_core", "tactic.extract_def", "tactic.interactive.apply_field", "conv.funext", "tactic.apply_heq_congr_core", "tactic.apply_congr_core", "tactic.ext1", "tactic.inhabited_instance", "tactic.reduce_ifs_at"]}, {"id": "tactic.assumption", "parentIds": ["tactic.apply_inj_lemma", "tactic.interactive.assumption'", "tactic.back_chaining", "tactic.find_local", "tactic.back_chaining_using", "tactic.apply_rules", "tactic.mk_assoc_instance", "tactic.reduce_ifs_at", "tactic.interactive.assumption"]}, {"id": "tactic.intro", "parentIds": ["tactic.apply_inj_lemma", "tactic.mk_has_sizeof_instance_core", "tactic.interactive.generalize_hyp", "tactic.rintro", "conv.funext", "tactic.intro1", "tactic.assert", "tactic.by_cases", "tactic.mk_dec_eq_instance_core", "tactic.mk_has_reflect_instance", "tactic.define", "tactic.by_contradiction", "tactic.assertv", "tactic.interactive.intro", "tactic.rename", "tactic.prove_goal_async", "tactic.intro1_aux", "tactic.definev"]}, {"id": "expr.is_eq", "parentIds": ["tactic.apply_inj_lemma", "tactic.match_eq", "tactic.comp_val"]}, {"id": "tactic.interactive.from", "parentIds": []}, {"id": "tactic.interactive.exact", "parentIds": ["tactic.interactive.from", "tactic.mk_dec_eq_instance", "tactic.interactive.exactI", "tactic.interactive.generalize", "tactic.exact_dec_trivial", "smt_tactic.interactive.exact"]}, {"id": "tactic.mk_has_sizeof_instance_core", "parentIds": ["tactic.mk_has_sizeof_instance"]}, {"id": "list.zip", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.constr_to_prop", "list.revzip", "tactic.mk_dec_eq_instance_core", "expr.is_eta_expansion", "instance_priority", "instance_derive_handler", "tactic.interactive.field", "tactic.interactive.h_generalize"]}, {"id": "mk_str_name", "parentIds": ["tactic.mk_has_sizeof_instance_core", "mk_simple_name", "tactic.mk_dec_eq_instance_core", "tactic.mk_has_reflect_instance", "tactic.injection_with", "tactic.def_replacer", "tactic.alias.make_left_right", "derive_struct_ext_lemma"]}, {"id": "list.iota", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.mk_dec_eq_instance_core", "saturate_fun"]}, {"id": "environment.is_recursive", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.mk_dec_eq_instance_core", "tactic.mk_has_reflect_instance"]}, {"id": "mk_num_name", "parentIds": ["tactic.mk_has_sizeof_instance_core", "localized_cmd", "tactic.mk_dec_eq_instance_core"]}, {"id": "list.repeat", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.mk_dec_eq_instance_core", "list.length_repeat"]}, {"id": "environment.inductive_num_indices", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.mk_iff_of_inductive_prop", "tactic.mk_dec_eq_instance_core", "tactic.mk_has_reflect_instance", "tactic.interactive.case"]}, {"id": "tactic.mk_constructors_arg_names", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.mk_has_reflect_instance"]}, {"id": "tactic.induction", "parentIds": ["tactic.mk_has_sizeof_instance_core", "tactic.interactive.induction", "tactic.mk_dec_eq_instance_core", "tactic.mk_has_reflect_instance", "smt_tactic.induction", "tactic.induction'"]}, {"id": "native.rb_map.add", "parentIds": []}, {"id": "native.rb_map.zfind", "parentIds": ["native.rb_map.add"]}, {"id": "native.rb_map.fold", "parentIds": ["native.rb_map.add", "native.rb_map.has_to_tactic_format", "native.has_to_string", "native.has_to_format", "native.rb_map.map", "native.rb_set.fold", "native.rb_map.values", "native.rb_map.keys", "native.rb_map.mfold", "native.rb_map.filter", "native.rb_map.to_list"]}, {"id": "mul_right_eq_self", "parentIds": []}, {"id": "mul_left_cancel", "parentIds": ["mul_right_eq_self", "mul_left_injective", "mul_left_cancel_iff", "mul_left_inj"]}, {"id": "left_cancel_semigroup.to_semigroup", "parentIds": ["mul_right_eq_self", "mul_self_iff_eq_one", "mul_left_cancel", "mul_left_injective", "mul_left_cancel_iff", "mul_left_inj"]}, {"id": "mul_dvd_mul", "parentIds": ["mul_dvd_mul_left", "mul_dvd_mul_right"]}, {"id": "comm_semiring.to_comm_monoid", "parentIds": ["mul_dvd_mul", "dvd_mul_left", "nat.eq_of_mul_eq_mul_right", "dvd_of_mul_left_dvd", "one_dvd", "exists_eq_mul_left_of_dvd", "dvd.intro_left", "nat.mul_le_mul_right", "dvd_trans", "dvd_mul_of_dvd_right", "nat.mul_lt_mul_of_pos_right", "int.comm_monoid", "nat.comm_monoid"]}, {"id": "comm_monoid.to_comm_semigroup", "parentIds": ["mul_dvd_mul", "dvd_mul_left", "nat.eq_of_mul_eq_mul_right", "dvd_of_mul_left_dvd", "mul_inv", "one_dvd", "nat.comm_semigroup", "exists_eq_mul_left_of_dvd", "dvd.intro_left", "nat.mul_le_mul_right", "dvd_trans", "dvd_mul_of_dvd_right", "nat.mul_lt_mul_of_pos_right"]}, {"id": "smt_tactic.trace_state", "parentIds": ["smt_tactic.interactive.trace_state"]}, {"id": "smt_state.to_format", "parentIds": ["smt_tactic.trace_state", "smt_tactic.save_info"]}, {"id": "smt_tactic.read", "parentIds": ["smt_tactic.trace_state", "smt_tactic.save_info", "smt_tactic.get_goals"]}, {"id": "decidable.rec_on_true", "parentIds": []}, {"id": "expr.macro_def_name", "parentIds": []}, {"id": "print_arguments", "parentIds": ["impossible_instance", "incorrect_type_class_argument", "dangerous_instance"]}, {"id": "environment.is_inductive", "parentIds": ["tactic.get_constructors_for", "tactic.interactive.induction", "tactic.mk_dec_eq_instance", "tactic.mk_iff_of_inductive_prop", "environment.is_ginductive'", "declaration.is_auto_generated", "instance_derive_handler", "tactic.delta_instance"]}, {"id": "environment.constructors_of", "parentIds": ["tactic.get_constructors_for", "to_additive.proceed_fields", "tactic.mk_iff_of_inductive_prop", "tactic.mk_patterns", "tactic.mk_inhabited_instance", "tactic.subobject_names", "tactic.mk_constructors_arg_names", "tactic.list_constructors_hole", "tactic.mk_constructors_fresh_names", "tactic.interactive.case"]}, {"id": "expr.extract_opt_auto_param", "parentIds": ["tactic.get_constructors_for"]}, {"id": "expr.const_name", "parentIds": ["tactic.get_constructors_for", "tactic.mk_assumption_set", "tactic.symmetry_hyp", "tactic.instance_stub", "environment.is_refl_app", "tactic.mk_patterns", "tactic.list_constructors_hole", "tactic.injection_with", "tactic.interactive.refine_one", "incorrect_type_class_argument", "expr.is_eta_expansion", "interactive.single_inductive_decl.name", "tactic.alias.get_alias_target", "list_items", "instance_priority", "environment.is_constructor_app", "expr.list_constant", "tactic.interactive.get_current_field", "interactive.param_desc", "tactic.interactive.source_fields", "tactic.ids_to_simp_arg_list", "has_inhabited_instance", "expr.contains_constant"]}, {"id": "eq_mul_inv_iff_mul_eq", "parentIds": []}, {"id": "mul_inv_cancel_right", "parentIds": ["eq_mul_inv_iff_mul_eq", "mul_inv_eq_iff_eq_mul", "inv_comm_of_comm"]}, {"id": "inv_mul_cancel_right", "parentIds": ["eq_mul_inv_iff_mul_eq", "mul_right_surjective", "mul_inv_eq_iff_eq_mul", "mul_eq_of_eq_mul_inv", "eq_mul_of_mul_inv_eq"]}, {"id": "int.mod", "parentIds": ["int.has_mod"]}, {"id": "sub_right_comm", "parentIds": []}, {"id": "add_right_comm", "parentIds": ["sub_right_comm"]}, {"id": "int.add_assoc", "parentIds": ["int.comm_ring"]}, {"id": "function.inv_fun_on_eq", "parentIds": ["function.inv_fun_eq", "function.inv_fun_on_eq'"]}, {"id": "set.has_mem", "parentIds": ["function.inv_fun_on_eq", "function.inv_fun_on_neg", "function.inv_fun_eq", "set.image", "set.subset", "set.sUnion", "set.compl", "function.inv_fun_on_eq'", "function.inv_fun_on", "function.inv_fun_on_pos", "set.inter", "function.inv_fun_neg", "function.inv_fun_on_mem", "set.sep", "set.piecewise", "set.diff", "set.union", "set.is_lawful_functor", "set.insert"]}, {"id": "function.inv_fun_on", "parentIds": ["function.inv_fun_on_eq", "function.inv_fun_on_neg", "function.inv_fun", "function.inv_fun_on_eq'", "function.inv_fun_on_pos", "function.inv_fun_on_mem"]}, {"id": "function.inv_fun_on_pos", "parentIds": ["function.inv_fun_on_eq", "function.inv_fun_on_mem"]}, {"id": "char.has_to_string", "parentIds": []}, {"id": "char.to_string", "parentIds": ["char.has_to_string", "char.has_to_format", "parser.one_of", "parser.ch"]}, {"id": "not_imp_eq_of_eq_false_right", "parentIds": []}, {"id": "tactic.apply_instance", "parentIds": ["wf_tacs", "well_founded_tactics.default", "tactic.interactive.apply_instance", "tactic.delta_instance", "smt_tactic.interactive.apply_instance"]}, {"id": "tactic.is_class", "parentIds": ["tactic.apply_instance", "tactic.interactive.clear_"]}, {"id": "tactic.rcases_patt_inverted.inhabited", "parentIds": ["tactic.rcases_parse", "tactic.interactive.obtain"]}, {"id": "tactic.rcases_patt_inverted", "parentIds": ["tactic.rcases_patt_inverted.inhabited", "tactic.rcases_patt_inverted.format_list", "tactic.ext_parse", "tactic.rintro_parse", "tactic.rcases_patt.invert_many", "tactic.interactive.obtain_parse", "tactic.rcases_parse", "tactic.rcases_patt_inverted.format", "tactic.interactive.obtain", "tactic.rcases_patt.invert", "tactic.rcases_patt_parse", "tactic.rcases_patt_inverted.has_to_format", "tactic.rcases_patt_inverted.invert", "tactic.rcases_patt_inverted.has_reflect", "tactic.rcases_patt.invert_list", "tactic.rcases_patt_parse_core", "tactic.rcases_patt.invert'", "tactic.rcases_patt_inverted.invert_list", "tactic.rcases_patt_parse_list"]}, {"id": "int.neg_ne_of_pos", "parentIds": ["int.ne_neg_of_pos"]}, {"id": "neg_of_neg_pos", "parentIds": ["int.neg_ne_of_pos", "neg_of_one_div_neg"]}, {"id": "int.le_of_lt", "parentIds": ["int.neg_ne_of_pos", "int.add_lt_add_left", "int.lt_iff_le_and_ne", "int.bit1_nonneg", "int.one_nonneg", "int.abs_eq_nat_abs", "int.nonneg_of_pos", "int.nat_abs_bit1_nonneg"]}, {"id": "vm.pp_expr", "parentIds": []}, {"id": "smt_tactic.ematch_core", "parentIds": ["smt_tactic.ematch"]}, {"id": "nat.mul_div_assoc", "parentIds": []}, {"id": "nat.comm_semiring", "parentIds": ["nat.mul_div_assoc", "nat.eq_of_mul_eq_mul_right", "nat.lt_add_of_pos_left", "nat.mul_le_mul_left", "nat.div_mul_cancel", "nat.pos_of_dvd_of_pos", "nat.mul_div_cancel'", "nat.dvd_add_iff_right", "nat.dvd_mod_iff", "nat.dvd_sub", "nat.eq_one_of_dvd_one", "nat.mul_le_mul_right", "nat.dvd_of_mul_dvd_mul_right", "nat.mul_lt_mul_of_pos_right", "nat.dvd_iff_mod_eq_zero", "nat.decidable_linear_ordered_semiring", "nat.dvd_of_mod_eq_zero", "nat.dvd_of_mul_dvd_mul_left", "nat.le_of_dvd", "nat.decidable_dvd", "nat.dvd_add_iff_left", "nat.mod_eq_zero_of_dvd", "nat.dvd_antisymm", "nat.comm_monoid"]}, {"id": "nat.div_mul_cancel", "parentIds": ["nat.mul_div_assoc"]}, {"id": "nat.semigroup", "parentIds": ["nat.mul_div_assoc", "nat.dvd_of_mul_dvd_mul_left", "nat.div_div_eq_div_mul"]}, {"id": "nat.div_zero", "parentIds": ["nat.mul_div_assoc", "nat.div_le_of_le_mul", "nat.div_le_self", "nat.sub_mul_div", "nat.div_mul_le_self", "nat.div_div_eq_div_mul"]}, {"id": "nat.mul_div_cancel", "parentIds": ["nat.mul_div_assoc", "nat.mul_div_cancel_left", "nat.div_eq_of_eq_mul_left"]}, {"id": "add_midpoint", "parentIds": []}, {"id": "two_pos", "parentIds": ["add_midpoint", "two_ne_zero", "exists_add_lt_and_pos_of_lt", "four_pos"]}, {"id": "sub_self_div_two", "parentIds": ["add_midpoint"]}, {"id": "div_lt_div_of_lt_of_pos", "parentIds": ["add_midpoint", "exists_add_lt_and_pos_of_lt"]}, {"id": "add_lt_of_lt_sub_right", "parentIds": ["add_midpoint", "lt_add_of_neg_lt_sub_left"]}, {"id": "div_sub_div_same", "parentIds": ["add_midpoint"]}, {"id": "unification_constraint", "parentIds": ["add_succ_defeq_succ_add_hint", "unification_constraint.inhabited", "unification_hint.inhabited", "unification_hint"]}, {"id": "fin.vne_of_ne", "parentIds": []}, {"id": "fin.eq_of_veq", "parentIds": ["fin.vne_of_ne"]}, {"id": "mul_zero_class", "parentIds": ["semiring.to_mul_zero_class", "mul_zero_class.to_has_mul", "norm_num.zero_mul", "mul_zero_class.to_has_zero", "zero_mul", "norm_num.mul_zero", "mul_zero"]}, {"id": "tactic.tag", "parentIds": ["tactic.interactive.propagate_tags", "tactic.interactive.guard_tags", "tactic.interactive.induction", "tactic.interactive.cases_core", "tactic.set_main_tag", "tactic.get_main_tag", "tactic.interactive.concat_tags", "tactic.set_tag", "tactic.get_tag", "tactic.interactive.field", "tactic.interactive.get_current_field", "tactic.interactive.case"]}, {"id": "tactic.set_main_tag", "parentIds": ["tactic.interactive.propagate_tags", "tactic.interactive.refine_one"]}, {"id": "tactic.get_main_tag", "parentIds": ["tactic.interactive.propagate_tags", "tactic.interactive.guard_tags", "tactic.interactive.induction", "tactic.interactive.cases_core", "tactic.interactive.concat_tags", "tactic.interactive.get_current_field"]}, {"id": "tactic.whnf_target", "parentIds": ["tactic.intro", "control_laws_tac", "order_laws_tac"]}, {"id": "unsigned.decidable_eq", "parentIds": []}, {"id": "fin.decidable_eq", "parentIds": ["unsigned.decidable_eq", "d_array.read_write", "d_array.write", "d_array.read_write_of_ne"]}, {"id": "tactic.mk_assumption_set", "parentIds": ["tactic.interactive.solve_by_elim", "tactic.suggest.apply_and_solve", "tactic.solve_by_elim"]}, {"id": "list.decidable_mem", "parentIds": ["tactic.mk_assumption_set", "list.insert", "list.remove_all", "tactic.subobject_names", "char.decidable_is_punctuation", "parser.one_of", "check_unused_arguments", "declaration.is_auto_generated", "tactic.mk_simp_set_core", "list.inter", "conv.interactive.for", "tactic.interactive.refine_one", "char.decidable_is_whitespace", "tactic.interactive.clean", "environment.in_current_file'", "list_items", "tactic.interactive.source_fields", "ge_or_gt_in_statement", "has_inhabited_instance"]}, {"id": "list.append", "parentIds": ["tactic.mk_assumption_set", "list.alternative", "list.has_append", "get_checks"]}, {"id": "attribute.get_instances", "parentIds": ["tactic.mk_assumption_set", "simp_attr.pre_smt", "tactic.replacer", "tactic.get_library_notes", "tactic.mk_simp_attr", "can_lift_attr", "mk_hinst_lemma_attr_from_simp_attr", "rsimp_attr", "simp_attr.functor_norm", "simp_attr.norm", "simp_attr.split_if_reduction", "tactic.ext1", "get_checks", "tactic.get_classes", "has_inhabited_instance"]}, {"id": "tactic.i_to_expr_for_apply", "parentIds": ["tactic.mk_assumption_set", "tactic.interactive.eapply", "tactic.interactive.mapply", "tactic.interactive.apply_with", "tactic.interactive.fapply", "tactic.interactive.apply"]}, {"id": "tactic.decode_simp_arg_list", "parentIds": ["tactic.mk_assumption_set", "tactic.mk_simp_set_core", "tactic.interactive.erase_simp_args"]}, {"id": "expr.local_uniq_name", "parentIds": ["tactic.mk_assumption_set", "tactic.non_dep_prop_hyps", "tactic.revert_all", "tactic.dependent_pose_core", "tactic.interactive.loc.get_local_uniq_names", "expr.has_local_constant", "tactic.mk_simp_set_core"]}, {"id": "array.decidable_eq", "parentIds": []}, {"id": "d_array.decidable_eq", "parentIds": ["array.decidable_eq"]}, {"id": "smt_tactic.interactive.induction", "parentIds": []}, {"id": "smt_tactic.slift", "parentIds": ["smt_tactic.interactive.induction", "smt_tactic.induction"]}, {"id": "tactic.interactive.induction", "parentIds": ["smt_tactic.interactive.induction"]}, {"id": "interactive.types.using_ident", "parentIds": ["smt_tactic.interactive.induction", "tactic.interactive.induction"]}, {"id": "int.has_div", "parentIds": []}, {"id": "int.div", "parentIds": ["int.has_div"]}, {"id": "int.le_of_coe_nat_le_coe_nat", "parentIds": ["int.coe_nat_le_coe_nat_iff"]}, {"id": "int.coe_nat_inj", "parentIds": ["int.le_of_coe_nat_le_coe_nat", "int.lt_irrefl", "int.le_antisymm"]}, {"id": "int.coe_nat_add", "parentIds": ["int.le_of_coe_nat_le_coe_nat", "int.sub_nat_nat_eq_coe", "int.le_antisymm", "int.neg_succ_of_nat_lt_zero"]}, {"id": "nat.le.intro", "parentIds": ["int.le_of_coe_nat_le_coe_nat", "nat.mul_le_mul_left", "nat.add_le_add_left", "nat.le_of_add_le_add_left"]}, {"id": "int.le.elim", "parentIds": ["int.le_of_coe_nat_le_coe_nat", "int.le_antisymm", "int.lt_iff_le_and_ne", "int.le_trans", "int.add_le_add_left", "int.mul_nonneg", "int.lt.dest"]}, {"id": "expr.to_nat", "parentIds": ["expr.to_int"]}, {"id": "expr.to_pos_nat", "parentIds": ["expr.to_nat"]}, {"id": "int.zero_ne_neg_of_ne", "parentIds": []}, {"id": "int.neg_ne_zero_of_ne", "parentIds": ["int.zero_ne_neg_of_ne"]}, {"id": "norm_num.bit1_add_one_helper", "parentIds": []}, {"id": "cc_state.roots", "parentIds": ["rsimp.to_repr_map"]}, {"id": "cc_state.roots_core", "parentIds": ["cc_state.roots"]}, {"id": "tactic.mk_psigma", "parentIds": []}, {"id": "tactic.instance_cache.append_typeclasses", "parentIds": ["tactic.instance_cache.mk_app"]}, {"id": "function.involutive.surjective", "parentIds": ["function.involutive.bijective"]}, {"id": "function.involutive", "parentIds": ["function.involutive.surjective", "function.involutive.left_inverse", "function.involutive.injective", "inv_involutive", "neg_involutive", "function.involutive.right_inverse", "function.involutive.bijective", "function.involutive_iff_iter_2_eq_id"]}, {"id": "tactic.mk_iff_mp_app", "parentIds": ["tactic.iff_mp_core", "tactic.iff_mpr_core"]}, {"id": "tactic.dsimplify", "parentIds": []}, {"id": "prod.mk.eta", "parentIds": ["function.uncurry'_curry", "prod.ext_iff", "state_t.is_lawful_monad"]}, {"id": "list.length_take_le", "parentIds": []}, {"id": "list.length_take", "parentIds": ["list.length_take_le"]}, {"id": "decidable_linear_ordered_semiring.to_decidable_linear_order", "parentIds": ["list.length_take_le", "sub_le_of_abs_sub_le_left", "nat.sub_eq_sub_min", "list.length_take", "sub_lt_of_abs_sub_lt_left", "nat.zero_min", "tactic.explode.pad_right", "nat.sub_add_min_cancel", "nat.min_zero", "list.length_map\u2082", "list.length_map_accumr\u2082", "nat.min_succ_succ"]}, {"id": "min_le_left", "parentIds": ["list.length_take_le", "eq_min", "min_comm", "min_add_add_left", "min_assoc", "nat.sub_add_min_cancel", "max_neg_neg"]}, {"id": "list.take", "parentIds": ["list.length_take_le", "tactic.elim_gen_sum", "tactic.mk_iff_of_inductive_prop", "list.length_take"]}, {"id": "int.bit", "parentIds": []}, {"id": "is_valid_char_range_2", "parentIds": []}, {"id": "d_array.beq", "parentIds": ["d_array.decidable_eq", "d_array.of_beq_eq_tt", "d_array.of_beq_eq_ff"]}, {"id": "d_array.beq_aux", "parentIds": ["d_array.beq", "d_array.of_beq_aux_eq_tt", "d_array.of_beq_aux_eq_ff", "d_array.of_beq_eq_tt", "d_array.of_beq_eq_ff"]}, {"id": "string.back", "parentIds": []}, {"id": "string.iterator.curr", "parentIds": ["string.back", "name.deinternalize_field", "string.front"]}, {"id": "rbmap.min", "parentIds": []}, {"id": "rbtree.min", "parentIds": ["rbmap.min"]}, {"id": "expr.mk_or_lst", "parentIds": ["tactic.mk_iff_of_inductive_prop"]}, {"id": "expr.mk_op_lst", "parentIds": ["expr.mk_or_lst", "expr.mk_and_lst"]}, {"id": "option.orelse", "parentIds": ["option.alternative"]}, {"id": "conv.monad", "parentIds": ["conv.interactive.conv", "conv.lhs", "conv.update_lhs", "conv.dsimp", "conv.interactive.trace_lhs", "conv.whnf", "conv.interactive.change", "conv.interactive.find", "conv.replace_lhs", "tactic.interactive.conv_rhs", "conv.change", "conv.interactive.for", "conv.interactive.simp", "conv.step", "conv.save_info", "conv.congr", "conv.rhs", "conv.interactive.to_lhs", "conv.interactive.to_rhs", "conv.interactive.dsimp", "tactic.interactive.conv_lhs", "conv.discharge_eq_lhs"]}, {"id": "d_array.nil", "parentIds": ["array.nil"]}, {"id": "list.split_on_p_aux", "parentIds": ["list.split_on_p"]}, {"id": "except_t.ext", "parentIds": ["except_t.is_lawful_monad"]}, {"id": "add_add_sub_cancel", "parentIds": []}, {"id": "add_sub_cancel'_right", "parentIds": ["add_add_sub_cancel", "add_add_neg_cancel'_right"]}, {"id": "tactic.interactive.loc.get_local_pp_names", "parentIds": ["tactic.interactive.change'"]}, {"id": "list.reduce_option", "parentIds": ["tactic.interactive.loc.get_local_pp_names"]}, {"id": "monad_reader_adapter", "parentIds": ["monad_reader_adapter_trans", "reader_t.monad_reader_adapter"]}, {"id": "list.eq_or_mem_of_mem_cons", "parentIds": ["list.cons_subset_cons"]}, {"id": "wf_tacs", "parentIds": []}, {"id": "well_founded_tactics", "parentIds": ["wf_tacs", "well_founded_tactics.default"]}, {"id": "well_founded_tactics.default_dec_tac'", "parentIds": ["wf_tacs"]}, {"id": "congr_arg2", "parentIds": []}, {"id": "decidable.false", "parentIds": ["ne.decidable", "tactic.interactive.solve_by_elim", "tactic.interactive.clear'", "bool.to_bool_false", "tactic.suggest.apply_and_solve", "tactic.solve_by_elim", "instance_derive_handler"]}, {"id": "implies.decidable", "parentIds": ["ne.decidable"]}, {"id": "interaction_monad.orelse'", "parentIds": []}, {"id": "smt_tactic.add_lemmas_from_facts", "parentIds": ["rsimp.collect_implied_eqs"]}, {"id": "smt_tactic.get_facts", "parentIds": ["smt_tactic.add_lemmas_from_facts"]}, {"id": "old_conv.skip", "parentIds": []}, {"id": "old_conv.monad", "parentIds": ["old_conv.skip", "old_conv.istep", "old_conv.apply_propext_simp_set", "old_conv.trace_lhs", "old_conv.alternative", "old_conv.apply_simp_set", "old_conv.step"]}, {"id": "expr.to_string", "parentIds": ["expr.has_to_string", "expr.has_to_format", "binder.to_string"]}, {"id": "tactic.try_intros", "parentIds": ["tactic.ext1"]}, {"id": "tactic.ext_patt", "parentIds": ["tactic.try_intros", "tactic.ext_parse", "tactic.ext", "tactic.interactive.ext1", "tactic.interactive.ext", "tactic.ext1"]}, {"id": "mul_inv_rev", "parentIds": ["mul_inv"]}, {"id": "mul_right_inv", "parentIds": ["mul_inv_rev", "mul_inv_cancel_left", "mul_inv_self", "eq_mul_inv_of_mul_eq", "mul_inv_eq_of_eq_mul", "mul_inv_cancel_right", "group.mul_right_cancel"]}, {"id": "inv_eq_of_mul_eq_one", "parentIds": ["mul_inv_rev", "one_inv", "inv_inv", "eq_inv_of_mul_eq_one"]}, {"id": "where.trace_variables", "parentIds": ["where.trace_where"]}, {"id": "where.compile_variable_list", "parentIds": ["where.trace_variables"]}, {"id": "list.reverse", "parentIds": ["tactic.get_pi_binders", "tactic.elim_gen_sum", "expr.instantiate_locals", "nat.repr", "name.components", "local_context.to_list", "list.revzip", "tactic.case_bash", "check_unused_arguments", "tactic.iterate'", "tactic.interactive.clear_", "list.is_suffix_of", "tactic.interactive.list_cast_of", "tactic.decode_simp_arg_list", "tactic.interactive.clear_except", "tactic.alias.make_left_right", "expr.pi_binders", "tactic.interactive.collect_struct"]}, {"id": "list.reverse_core", "parentIds": ["list.reverse"]}, {"id": "nat.le_of_succ_le_succ", "parentIds": ["nat.lt_wf", "nat.shiftl'_sub", "nat.le_of_le_of_sub_le_sub_right", "nat.le_of_lt_succ", "nat.not_succ_le_self", "nat.lt_of_succ_lt_succ"]}, {"id": "nat.pred_le_pred", "parentIds": ["nat.le_of_succ_le_succ", "nat.sub_le_sub_right", "nat.min_succ_succ"]}, {"id": "cc_state.mt", "parentIds": []}, {"id": "tactic.mk_brec_on_rec_value", "parentIds": []}, {"id": "function.involutive.left_inverse", "parentIds": ["function.involutive.injective"]}, {"id": "array.read_mem", "parentIds": []}, {"id": "array.read", "parentIds": ["array.read_mem", "array.read_write_of_ne", "buffer.read_eq_read'", "array.read_write", "array.mem", "array.ext'", "array.read'", "array.map\u2082", "array.read_eq_read'", "array.ext"]}, {"id": "array.has_mem", "parentIds": ["array.read_mem"]}, {"id": "nat.le_add_right", "parentIds": ["nat.le_add_left", "nat.sub_mul_mod", "nat.le.intro", "nat.sub_add_comm", "buffer.lt_aux_1", "int.to_nat_sub", "nat.lt_add_right", "nat.le_div_iff_mul_le"]}, {"id": "norm_num.bit1_add_one", "parentIds": []}, {"id": "psigma.lex_wf", "parentIds": []}, {"id": "psigma.lex", "parentIds": ["psigma.lex_wf", "psigma.has_well_founded", "psigma.lex_accessible", "psigma.lex_ndep"]}, {"id": "psigma", "parentIds": ["psigma.lex_wf", "psigma.rev_lex_wf", "psigma.has_well_founded", "nonempty_psigma", "psigma.rev_lex_accessible", "psigma.mk_skip_left", "quot.indep", "ex_of_psig", "psigma.rev_lex", "psigma.lex", "psigma.skip_left_wf", "psigma.skip_left", "psigma.lex_accessible", "quot.lift_indep_pr1", "psigma.eq", "psigma.lex_ndep_wf", "quot.indep_coherent", "psigma.lex_ndep", "psigma.has_sizeof"]}, {"id": "well_founded", "parentIds": ["psigma.lex_wf", "well_founded.fix", "prod.rprod_wf", "nat.lt_wf", "psigma.rev_lex_wf", "well_founded.apply", "sum.lex_wf", "tc.wf", "subrelation.wf", "prod.lex_wf", "inv_image.wf", "well_founded.recursion", "well_founded.induction", "sizeof_measure_wf", "psigma.skip_left_wf", "empty_wf", "psigma.lex_accessible", "measure_wf", "well_founded.fix_eq", "has_well_founded", "psigma.lex_ndep_wf"]}, {"id": "where.strip_namespace", "parentIds": ["where.get_opens"]}, {"id": "name.replace_prefix", "parentIds": ["where.strip_namespace"]}, {"id": "or_of_or_of_imp_right", "parentIds": []}, {"id": "zero_le_one", "parentIds": ["abs_one_div"]}, {"id": "zero_lt_one", "parentIds": ["zero_le_one", "norm_num.pos_bit1_helper", "mul_zero_lt_mul_inv_of_neg", "int.one_pos", "mul_zero_lt_mul_inv_of_pos", "two_gt_one", "int.bit1_pos", "int.one_nonneg", "le_of_mul_le_of_ge_one", "add_self_div_two", "int.nat_abs_bit1_nonneg", "zero_gt_neg_one", "two_pos", "abs_abs_sub_abs_le_abs_sub", "div_two_lt_of_pos"]}, {"id": "band_eq_true_eq_eq_tt_and_eq_tt", "parentIds": []}, {"id": "ff_band", "parentIds": ["band_eq_true_eq_eq_tt_and_eq_tt", "bool.to_bool_and", "band_eq_false_eq_eq_ff_or_eq_ff"]}, {"id": "false_and", "parentIds": ["band_eq_true_eq_eq_tt_and_eq_tt", "if_false_left_eq_and", "bor_eq_false_eq_eq_ff_and_eq_ff", "bool.to_bool_and", "and_eq_of_eq_false_left", "nat.mod_zero", "if_false_right_eq_and", "nat.div_zero"]}, {"id": "and_self", "parentIds": ["band_eq_true_eq_eq_tt_and_eq_tt", "dlist.to_list_cons", "list.map_append", "list.filter_append", "bor_eq_false_eq_eq_ff_and_eq_ff", "list.map_id", "list.append_nil", "bool.forall_bool", "bool.to_bool_and", "list.is_lawful_monad", "and_eq_of_eq", "list.append_assoc", "prod.lex_def", "list.map_map", "dlist.to_list_of_list", "dlist.to_list_singleton"]}, {"id": "function.inv_fun_on_neg", "parentIds": ["function.inv_fun_neg"]}, {"id": "classical.some", "parentIds": ["function.inv_fun_on_neg", "classical.some_spec2", "function.surj_inv", "function.inv_fun_on", "function.inv_fun_on_pos", "classical.exists_cases", "function.partial_inv", "classical.some_spec", "exists.classical_rec_on", "classical.subtype_of_exists", "function.partial_inv_of_injective", "classical.axiom_of_choice"]}, {"id": "dif_neg", "parentIds": ["function.inv_fun_on_neg", "char.val_of_nat_eq_of_not_is_valid", "nat.binary_rec_eq", "function.update_noteq", "d_array.read_write_of_ne", "function.partial_inv_of_injective"]}, {"id": "bex_def", "parentIds": ["function.inv_fun_on_neg", "function.inv_fun_on_pos"]}, {"id": "and_iff_left_of_imp", "parentIds": []}, {"id": "tactic.simplify_top_down", "parentIds": ["push_neg.normalize_negations", "tactic.simp_top_down", "rsimp.rsimplify"]}, {"id": "tactic.ext_simplify_core", "parentIds": ["tactic.simplify_top_down", "old_conv.find_pattern", "old_conv.interactive.find", "tactic.simplify_bottom_up", "conv.interactive.find", "conv.interactive.for", "old_conv.find", "old_conv.top_down", "old_conv.bottom_up"]}, {"id": "expr.alpha_eqv", "parentIds": ["tactic.simplify_top_down", "tactic.non_dep_prop_hyps", "tactic.simplify_bottom_up", "tactic.interactive.guard_expr_eq", "rsimp.rsimplify", "tactic.replacer_attr", "smt_tactic.interactive.guard_expr_eq"]}, {"id": "mul_inv_eq", "parentIds": ["field.div_mul_div", "division_ring.one_div_div", "mul_inv'"]}, {"id": "division_ring.one_div_mul_one_div", "parentIds": ["mul_inv_eq", "field.one_div_mul_one_div", "one_div_mul_one_div'", "field.div_mul_right", "division_ring.one_div_neg_eq_neg_one_div"]}, {"id": "tactic.suggest.unfold_head_symbol", "parentIds": []}, {"id": "or.by_cases", "parentIds": ["nat.strong_rec_on"]}, {"id": "decidable_linear_ordered_semiring", "parentIds": ["decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "decidable_linear_ordered_semiring.to_linear_ordered_semiring", "nat.decidable_linear_ordered_semiring", "decidable_linear_ordered_semiring.to_decidable_linear_order", "nat.decidable_linear_ordered_cancel_comm_monoid"]}, {"id": "tactic_state.env", "parentIds": ["tactic.get_env", "tactic.get_decl"]}, {"id": "tactic.read", "parentIds": ["tactic.get_env", "tactic_format_expr", "tactic.suggest.message", "tactic.save_info", "tactic.get_string_option", "old_conv.save_info", "tactic.trace_state", "tactic.set_nat_option", "tactic.set_string_option", "tactic.get_decl", "tactic.get_options", "smt_tactic.read", "tactic.get_nat_option", "tactic.set_bool_option", "tactic.inhabited_instance", "conv.save_info", "tactic.set_options", "tactic.get_bool_option", "tactic.run_async"]}, {"id": "function.on_fun", "parentIds": []}, {"id": "nat.le_succ_of_le", "parentIds": ["nat.lt_or_ge", "list.length_le_of_sublist", "nat.lt_succ_of_lt", "nat.le_add_right"]}, {"id": "nat.lt_succ_self", "parentIds": ["nat.lt_or_ge", "d_array.of_beq_aux_eq_ff", "nat.strong_rec_on", "nat.mul_sub_div"]}, {"id": "nat.eq_or_lt_of_le", "parentIds": ["nat.lt_or_ge", "nat.lt_wf", "nat.lt_of_le_and_ne"]}, {"id": "tactic.mk_user_fresh_name", "parentIds": ["where.mk_flag"]}, {"id": "lean.parser.emit_code_here", "parentIds": ["where.mk_flag", "localized_cmd", "open_locale_cmd", "tactic.setup_tactic_parser_cmd"]}, {"id": "tactic.resolve_constant", "parentIds": ["where.mk_flag", "restate_axiom_cmd", "tactic.interactive.cases_type", "tactic.alias.alias_cmd", "tactic.interactive.case", "saturate_fun", "derive_struct_ext_lemma", "tactic.import_private_cmd"]}, {"id": "name.components", "parentIds": ["where.mk_flag", "interactive.param_desc", "dup_namespace"]}, {"id": "neg_add_eq_sub", "parentIds": []}, {"id": "function.update_eq_self", "parentIds": []}, {"id": "function.update", "parentIds": ["function.update_eq_self", "function.update_same", "function.update_noteq", "function.update_comp"]}, {"id": "ne.def", "parentIds": ["function.update_eq_self", "div_mul_cancel", "div_self", "mul_one_div_cancel", "one_inv_eq", "one_div_mul_cancel", "int.lt_iff_le_not_le", "div_eq_one_iff_eq", "mul_div_cancel", "mul_mul_div", "function.update_comp"]}, {"id": "function.update_noteq", "parentIds": ["function.update_eq_self", "function.update_comp"]}, {"id": "function.update_same", "parentIds": ["function.update_eq_self", "function.update_comp"]}, {"id": "linter.unused_arguments", "parentIds": []}, {"id": "d_array.of_beq_aux_eq_tt", "parentIds": ["d_array.of_beq_eq_tt"]}, {"id": "ite_eq_tt_distrib", "parentIds": ["d_array.of_beq_aux_eq_tt"]}, {"id": "nat.not_lt_zero", "parentIds": ["d_array.of_beq_aux_eq_tt", "nat.pred_lt_pred", "nat.lt_wf", "nat.strong_rec_on", "nat.pow_lt_pow_of_lt_left", "nat.bit1_lt_bit0", "nat.mul_sub_div"]}, {"id": "lt_of_le_of_ne", "parentIds": ["d_array.of_beq_aux_eq_tt", "eq_or_lt_of_not_lt", "lt_iff_le_and_ne"]}, {"id": "int.nat_abs_mul_self", "parentIds": []}, {"id": "int.has_mul", "parentIds": ["int.nat_abs_mul_self", "int.zero_mul", "int.distrib_right", "int.mul_one", "int.coe_nat_mul_out", "int.distrib_left", "int.of_nat_mul", "int.eq_one_of_mul_eq_self_left", "int.one_mul", "int.mul_zero", "int.sign_mul_abs", "int.mul_pos", "int.mul_assoc", "int.sign_mul_nat_abs", "int.mul_nonneg", "int.eq_one_of_mul_eq_self_right", "int.mul_comm", "int.coe_nat_mul"]}, {"id": "tactic.interactive.guard_tags", "parentIds": []}, {"id": "smt_tactic.add_ematch_lhs_lemma_from_decl", "parentIds": []}, {"id": "smt_tactic.add_ematch_lemma_from_decl_core", "parentIds": ["smt_tactic.add_ematch_lhs_lemma_from_decl", "smt_tactic.add_ematch_lemma_from_decl"]}, {"id": "old_conv.failed", "parentIds": ["old_conv.alternative"]}, {"id": "lt_add_of_le_of_pos", "parentIds": ["int.bit1_pos"]}, {"id": "function.inv_fun_eq", "parentIds": ["function.left_inverse_inv_fun", "function.inv_fun_eq_of_injective_of_right_inverse", "function.right_inverse_inv_fun"]}, {"id": "function.inv_fun", "parentIds": ["function.inv_fun_eq", "function.left_inverse_inv_fun", "function.inv_fun_eq_of_injective_of_right_inverse", "function.inv_fun_surjective", "function.inv_fun_neg", "function.inv_fun_comp", "function.right_inverse_inv_fun", "function.injective.has_left_inverse"]}, {"id": "tactic.rcases_hint", "parentIds": ["tactic.interactive.rcases"]}, {"id": "tactic.rcases_hint_core", "parentIds": ["tactic.rcases_hint"]}, {"id": "tactic.mk_fresh_name", "parentIds": ["tactic.rcases_hint", "tactic.mk_local'", "tactic.mk_user_fresh_name", "tactic.interactive.obtain", "tactic.rcases"]}, {"id": "nonempty_ulift", "parentIds": []}, {"id": "tactic.back_chaining_using_hs", "parentIds": []}, {"id": "tactic.back_chaining_core", "parentIds": ["tactic.back_chaining_using_hs", "tactic.back_chaining", "tactic.back_chaining_using"]}, {"id": "add_monoid_to_is_right_id", "parentIds": []}, {"id": "is_right_id", "parentIds": ["add_monoid_to_is_right_id", "option.lift_or_get_is_right_id", "monoid_to_is_right_id"]}, {"id": "smt_tactic.add_ematch_lemma_from_decl", "parentIds": []}, {"id": "min_eq_left_of_lt", "parentIds": []}, {"id": "min_eq_left", "parentIds": ["min_eq_left_of_lt", "nat.sub_eq_sub_min", "min_add_add_left", "nat.zero_min", "min_eq_right"]}, {"id": "simp_attr.pre_smt", "parentIds": []}, {"id": "list.mfoldl", "parentIds": ["simp_attr.pre_smt", "tactic.non_dep_prop_hyps", "tactic.mk_simp_attr", "monad.foldl", "tactic.has_opt_auto_param", "tactic.has_opt_auto_param_for_apply", "simp_attr.functor_norm", "simp_attr.norm", "interactive.loc.get_locals", "rsimp.to_repr_map", "simp_attr.split_if_reduction", "lint_aux", "simp_lemmas.append", "tactic.module_doc_strings"]}, {"id": "user_attribute_cache_cfg", "parentIds": ["simp_attr.pre_smt", "localized_attr", "tactic.mk_simp_attr", "ematch_lhs", "nolint_attr", "tactic.alias.alias_attr", "can_lift_attr", "no_rsimp", "mk_hinst_lemma_attr_from_simp_attr", "user_attribute.dflt_cache_cfg", "rsimp_attr", "linter_attr", "ematch", "library_note_attr", "simp_attr.functor_norm", "simp_attr.norm", "tactic.ancestor_attr", "simp_attr.split_if_reduction", "user_attribute", "debugger.attr", "derive_handler_attr", "mk_hinst_lemma_attr_set", "tactic.replaceable_attr", "mk_name_set_attr", "mk_hinst_lemma_attr_core", "tactic.replacer_attr"]}, {"id": "norm_num.pos_bit1_helper", "parentIds": ["norm_num.nonneg_bit1_helper"]}, {"id": "add_pos_of_nonneg_of_pos", "parentIds": ["norm_num.pos_bit1_helper"]}, {"id": "norm_num.nonneg_bit0_helper", "parentIds": ["norm_num.pos_bit1_helper"]}, {"id": "native.float.is_nan", "parentIds": []}, {"id": "simp_lemmas.rewrite", "parentIds": ["old_conv.apply_lemmas_core", "old_conv.apply_propext_lemmas_core"]}, {"id": "div_nonneg_of_nonpos_of_neg", "parentIds": []}, {"id": "dif_eq_if", "parentIds": ["nat.div_def", "nat.mod_def"]}, {"id": "nat.div_def_aux", "parentIds": ["nat.div_def"]}, {"id": "norm_num.mul_bit1_helper", "parentIds": []}, {"id": "expr.binding_names", "parentIds": []}, {"id": "nat.sub_eq_zero_of_le", "parentIds": ["nat.sub_eq_sub_min", "nat.lt_of_sub_eq_succ", "int.of_nat_sub", "norm_num.sub_nat_zero_helper", "int.to_nat_sub", "nat.sub_eq_zero_iff_le"]}, {"id": "nat.sub_self_add", "parentIds": ["nat.sub_eq_zero_of_le"]}, {"id": "nat.le.dest", "parentIds": ["nat.sub_eq_zero_of_le", "int.sub_nat_nat_elim", "nat.mul_le_mul_left", "nat.add_sub_assoc", "nat.succ_sub", "int.coe_nat_le_coe_nat_of_le", "nat.add_le_add_left", "nat.le_of_add_le_add_left", "nat.add_sub_of_le"]}, {"id": "two_ne_zero", "parentIds": ["add_halves"]}, {"id": "tactic.cleanup", "parentIds": ["tactic.step"]}, {"id": "set.has_neg", "parentIds": []}, {"id": "set.compl", "parentIds": ["set.has_neg"]}, {"id": "native.rb_set.size", "parentIds": ["tactic.clear'"]}, {"id": "native.rb_map.size", "parentIds": ["native.rb_set.size", "tactic.explode.entries.size"]}, {"id": "dvd_mul_left", "parentIds": []}, {"id": "vm.pc", "parentIds": []}, {"id": "conv.interactive.itactic", "parentIds": ["conv.interactive.conv", "conv.interactive.find", "tactic.interactive.conv", "tactic.interactive.conv_rhs", "conv.interactive.for", "tactic.interactive.conv_lhs"]}, {"id": "tactic.is_prop", "parentIds": ["restate_axiom", "tactic.non_dep_prop_hyps", "tactic.abstract", "tactic.is_proof", "tactic.interactive.extract_goal", "tactic.is_prop_decl"]}, {"id": "tactic.kdepends_on", "parentIds": ["tactic.clear'", "tactic.terminal_goal"]}, {"id": "max_self", "parentIds": []}, {"id": "if_pos", "parentIds": ["max_self", "implies_of_if_pos", "max_lt", "le_min", "le_max_left", "lt_min", "if_true", "max_le", "min_le_right", "nat.div_eq_sub_div", "list.filter_cons_of_pos", "nat.mod_add_div", "nat.mod_eq_sub_mod", "min_self", "if_eq_of_eq_true", "min_le_left", "nat.min_succ_succ", "le_max_right"]}, {"id": "smt_tactic.seq", "parentIds": ["smt_tactic.has_andthen", "smt_tactic.destruct"]}, {"id": "smt_tactic.monad_fail", "parentIds": ["smt_tactic.seq", "smt_tactic.focus1"]}, {"id": "smt_tactic.all_goals", "parentIds": ["smt_tactic.seq", "smt_tactic.interactive.all_goals"]}, {"id": "string.iterator.next_to_string", "parentIds": ["string.iterator.length_next_to_string_next", "string.popn", "string.iterator.next_to_string_mk_iterator", "string.iterator.zero_lt_length_next_to_string_of_has_next", "string.backn", "name.deinternalize_field"]}, {"id": "let_body_eq", "parentIds": []}, {"id": "pi.can_lift", "parentIds": []}, {"id": "can_lift", "parentIds": ["pi.can_lift", "nat.can_lift"]}, {"id": "empty.decidable_eq", "parentIds": []}, {"id": "except_t.run_pure", "parentIds": ["except_t.run_map", "except_t.is_lawful_monad"]}, {"id": "except_t.monad", "parentIds": ["except_t.run_pure", "except_t.run_map", "except_t.is_lawful_monad", "except_t.run_bind"]}, {"id": "eq_zero_of_mul_eq_self_right", "parentIds": ["eq_zero_of_mul_eq_self_left"]}, {"id": "mul_sub_left_distrib", "parentIds": ["eq_zero_of_mul_eq_self_right", "mul_sub", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "div_lt_div_of_pos_of_lt_of_pos", "eq_of_mul_eq_mul_left", "ordered_ring.mul_le_mul_of_nonneg_left", "ordered_ring.mul_lt_mul_of_pos_left"]}, {"id": "integral_domain.to_zero_ne_one_class", "parentIds": ["eq_zero_of_mul_eq_self_right", "eq_zero_of_mul_eq_self_left", "mul_self_eq_one_iff"]}, {"id": "integral_domain.to_comm_ring", "parentIds": ["eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "abs_sub_square", "mul_eq_zero_iff_eq_zero_or_eq_zero", "eq_of_mul_eq_mul_left", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "mul_self_eq_one_iff"]}, {"id": "integral_domain", "parentIds": ["eq_zero_of_mul_eq_self_right", "eq_of_mul_eq_mul_right", "mul_ne_zero", "discrete_field.to_integral_domain", "integral_domain.to_no_zero_divisors", "mul_eq_zero_iff_eq_zero_or_eq_zero", "eq_of_mul_eq_mul_left", "integral_domain.to_comm_ring", "eq_zero_of_mul_eq_self_left", "mul_self_eq_mul_self_iff", "integral_domain.to_zero_ne_one_class", "linear_ordered_comm_ring.to_integral_domain", "mul_self_eq_one_iff"]}, {"id": "well_founded.fix_F", "parentIds": ["well_founded.fix", "well_founded.fix_F_eq"]}, {"id": "transport_multiplicative_to_additive", "parentIds": []}, {"id": "name.lt.decidable_rel", "parentIds": ["transport_multiplicative_to_additive", "tactic.interactive.rename'", "localized_attr", "tactic.local_decls", "tactic.rename'"]}, {"id": "exceptional.to_bool", "parentIds": ["transport_multiplicative_to_additive"]}, {"id": "transport_with_dict", "parentIds": ["transport_multiplicative_to_additive"]}, {"id": "name.has_lt", "parentIds": ["transport_multiplicative_to_additive", "tactic.interactive.rename'", "localized_attr", "tactic.local_decls", "tactic.rename'"]}, {"id": "add_left_cancel_semigroup", "parentIds": ["ordered_cancel_comm_monoid.to_add_left_cancel_semigroup", "add_group.to_left_cancel_add_semigroup", "add_left_injective", "add_left_inj", "add_left_cancel_semigroup.to_add_semigroup", "add_left_cancel_iff", "add_left_cancel", "eq_of_add_eq_add_left"]}, {"id": "nat_add_zero", "parentIds": []}, {"id": "sum.elim", "parentIds": ["sum.elim_injective", "sum.elim_inl", "sum.elim_inr"]}, {"id": "native.float.sub", "parentIds": ["native.float.has_sub"]}, {"id": "sum_has_to_format", "parentIds": []}, {"id": "subtype.has_to_string", "parentIds": []}, {"id": "irrefl_of", "parentIds": ["incomp_iff_eq", "not_lt_of_lt"]}, {"id": "bex_congr", "parentIds": []}, {"id": "exists_congr", "parentIds": ["bex_congr", "bex_or_distrib", "exists_eq_right", "exists_unique_congr"]}, {"id": "nat.test_bit_zero", "parentIds": ["nat.test_bit_bitwise"]}, {"id": "nat.bit_cases_on", "parentIds": ["nat.test_bit_bitwise", "nat.bitwise_swap", "nat.bitwise_zero_right", "nat.bitwise_bit", "nat.bitwise_bit_aux"]}, {"id": "nat.test_bit_succ", "parentIds": ["nat.test_bit_bitwise"]}, {"id": "nat.eq_of_mul_eq_mul_right", "parentIds": []}, {"id": "nat.eq_of_mul_eq_mul_left", "parentIds": ["nat.eq_of_mul_eq_mul_right", "nat.div2_val", "nat.dvd_of_mul_dvd_mul_left"]}, {"id": "option.traversable", "parentIds": ["tactic.interactive.squeeze_simpa"]}, {"id": "traversable", "parentIds": ["option.traversable", "tactic.interactive.squeeze_simpa", "list.traversable", "is_lawful_traversable", "sequence", "sum.traversable", "id.traversable"]}, {"id": "option.traverse", "parentIds": ["option.traversable", "tactic.interactive.extract_goal"]}, {"id": "eq_of_sub_eq_zero", "parentIds": ["eq_of_mul_eq_mul_right", "sub_ne_zero_of_ne", "sub_eq_zero", "eq_of_mul_eq_mul_left", "eq_of_abs_sub_eq_zero", "mul_self_eq_mul_self_iff", "sub_eq_zero_iff_eq"]}, {"id": "tactic.seq_focus", "parentIds": ["tactic.andthen_seq_focus"]}, {"id": "option_t.monad_run", "parentIds": []}, {"id": "monad_run", "parentIds": ["option_t.monad_run", "except_t.monad_run", "state_t.monad_run", "id.monad_run", "reader_t.monad_run"]}, {"id": "tactic.interactive.guard_target_strict", "parentIds": []}, {"id": "tactic.interactive.guard_expr_strict", "parentIds": ["tactic.interactive.guard_target_strict", "tactic.interactive.guard_hyp_strict"]}, {"id": "restate_axiom", "parentIds": ["restate_axiom_cmd"]}, {"id": "tactic.updateex_env", "parentIds": ["restate_axiom", "tactic.add_inductive", "tactic.alias.alias_direct", "tactic.alias.alias_iff", "tactic.add_defn_equations"]}, {"id": "declaration.to_definition", "parentIds": ["restate_axiom", "tactic.alias.alias_direct"]}, {"id": "simp_lemmas.dsimplify", "parentIds": ["restate_axiom", "old_conv.dsimp", "tactic.dsimp_hyp", "tactic.interactive.unfold_aux", "conv.dsimp", "expr.dsimp", "tactic.dsimp_target", "tactic.get_lift_prf"]}, {"id": "tactic.mk_simp_set", "parentIds": ["restate_axiom", "tactic.interactive.dsimp", "tactic.lift", "tactic.interactive.simp_intros", "expr.simp", "expr.dsimp", "tactic.interactive.simp_core", "conv.interactive.simp", "tactic.interactive.trace_simp_set", "conv.interactive.dsimp"]}, {"id": "undefined", "parentIds": ["restate_axiom", "unchecked_cast", "tactic.alias.alias_direct"]}, {"id": "task.pure", "parentIds": ["restate_axiom", "task.monad", "declaration.value_task", "declaration.to_definition", "tactic.mk_theorem", "declaration.update_value", "tactic.alias.alias_direct", "tactic.alias.alias_iff", "task.delay"]}, {"id": "environment.add", "parentIds": ["restate_axiom", "tactic.alias.alias_direct", "tactic.alias.alias_iff"]}, {"id": "buffer.take", "parentIds": ["parser.mk_error_msg"]}, {"id": "buffer.to_array", "parentIds": ["buffer.take", "buffer.drop", "buffer.reverse", "buffer.take_right", "buffer.to_list", "buffer.to_string"]}, {"id": "tactic.interactive.convert", "parentIds": []}, {"id": "tactic.mk_mvar", "parentIds": ["tactic.interactive.convert", "saturate_fun", "tactic.resolve_name'"]}, {"id": "interactive.with_desc", "parentIds": ["tactic.interactive.convert", "tactic.rintro_parse", "tactic.interactive.rw_rule_p", "tactic.interactive.obtain_parse", "tactic.interactive.cases_arg_p", "tactic.rcases_parse", "tactic.rcases_patt_parse", "interactive.parse_binders", "tactic.interactive.convert_to", "tactic.interactive.congr'", "tactic.interactive.suggest", "interactive.types.location"]}, {"id": "tactic.interactive.refine", "parentIds": ["tactic.interactive.convert", "tactic.interactive.generalize_hyp", "tactic.interactive.refine_struct", "tactic.inhabited_instance"]}, {"id": "tactic.interactive.try", "parentIds": ["tactic.interactive.convert", "tactic.interactive.change'", "tactic.interactive.simp_core_aux", "tactic.interactive.injection", "tactic.interactive.substs", "tactic.interactive.use", "tactic.interactive.simp_intros", "tactic.interactive.subst", "tactic.interactive.simp_core", "tactic.interactive.simpa", "tactic.interactive.specialize", "tactic.interactive.refine_one", "tactic.interactive.injections", "tactic.interactive.clear_except", "tactic.mk_inj_eq", "tactic.interactive.h_generalize", "tactic.interactive.ac_change", "tactic.interactive.choose"]}, {"id": "nat.reflect", "parentIds": ["tactic.interactive.convert", "tactic.interactive.rcases", "tactic.interactive.elide", "tactic.interactive.iterate", "tactic.interactive.rintros", "tactic.interactive.ext", "tactic.interactive.rintro", "tactic.interactive.convert_to", "tactic.interactive.congr'", "conv.interactive.for", "unsigned.reflect", "tactic.interactive.ac_change", "tactic.interactive.suggest", "pos.has_reflect"]}, {"id": "pexpr.has_to_pexpr", "parentIds": ["tactic.interactive.convert", "tactic.mk_simp_attribute_cmd", "tactic.interactive.min_tac", "old_conv.change", "use_cmd", "smt_tactic.interactive.have", "tactic.trace_macro", "tactic.interactive.let", "tactic.interactive.convert_to_core", "tactic.interactive.set", "tactic.interactive.exact", "smt_tactic.interactive.let", "tactic.interactive.obtain", "tactic.pformat_macro", "get_attribute_cache_dyn", "tactic.interactive.change", "tactic.interactive.simpa", "tactic.refine", "tactic.interactive.clean", "tactic.interactive.have", "tactic.interactive.parse_config", "tactic.fail_macro"]}, {"id": "tactic.interactive.congr'", "parentIds": ["tactic.interactive.convert", "tactic.interactive.convert_to"]}, {"id": "lean.parser.small_nat", "parentIds": ["tactic.interactive.convert", "tactic.interactive.elide", "tactic.interactive.iterate", "tactic.rcases_parse_depth", "tactic.interactive.ext", "tactic.interactive.convert_to", "tactic.interactive.congr'", "conv.interactive.for", "tactic.interactive.ac_change", "tactic.interactive.suggest"]}, {"id": "nat.pred_le", "parentIds": ["nat.sub_le_sub_left", "nat.sub_le"]}, {"id": "smt_tactic.close", "parentIds": ["using_smt", "smt_tactic.define", "rsimp.collect_implied_eqs", "smt_tactic.assert", "smt_tactic.interactive.close", "smt_tactic.eblast", "smt_tactic.interactive.eblast_using", "smt_tactic.solve_goals"]}, {"id": "smt_pre_config", "parentIds": ["using_smt", "smt_pre_config.inhabited", "smt_tactic.execute", "rsimp.collect_implied_eqs", "smt_config", "smt_config.inhabited", "smt_tactic.interactive.executor"]}, {"id": "smt_tactic.iterate", "parentIds": ["using_smt", "smt_tactic.interactive.iterate", "smt_tactic.eblast", "smt_tactic.interactive.eblast_using", "smt_tactic.solve_goals"]}, {"id": "ematch_config", "parentIds": ["using_smt", "smt_tactic.execute", "rsimp.collect_implied_eqs", "smt_config", "smt_config.inhabited", "ematch_config.inhabited", "smt_tactic.interactive.executor"]}, {"id": "repr", "parentIds": ["char.repr", "array.has_repr", "rbtree.has_repr", "rbmap.has_repr", "nat.has_to_string", "unsigned.has_repr", "buffer.has_repr", "fin.has_repr", "subtype.has_repr", "name.last"]}, {"id": "unsigned.of_nat", "parentIds": []}, {"id": "tactic.decl_name", "parentIds": ["tactic.interactive.unfold_aux", "tactic.new_aux_decl_name"]}, {"id": "environment.for_decl_of_imported_module", "parentIds": ["environment.for_decl_of_imported_module_name"]}, {"id": "environment.import_until_decl", "parentIds": ["environment.for_decl_of_imported_module"]}, {"id": "environment.mk_std", "parentIds": ["environment.for_decl_of_imported_module", "environment.inhabited", "environment.from_imported_module"]}, {"id": "smt_tactic.interactive.guard_target", "parentIds": []}, {"id": "smt_tactic.interactive.guard_expr_eq", "parentIds": ["smt_tactic.interactive.guard_target"]}, {"id": "antisymm", "parentIds": []}, {"id": "is_antisymm", "parentIds": ["antisymm", "is_partial_order"]}, {"id": "tactic.explode.entries.size", "parentIds": []}, {"id": "tactic.enable_tags", "parentIds": ["tactic.with_enable_tags"]}, {"id": "sub_add_add_cancel", "parentIds": []}, {"id": "conv.interactive.conv", "parentIds": []}, {"id": "tactic.transitivity", "parentIds": ["conv.interactive.conv", "conv.update_lhs", "tactic.interactive.transitivity"]}, {"id": "conv.monad_fail", "parentIds": ["conv.interactive.conv", "conv.congr"]}, {"id": "conv.lhs", "parentIds": ["conv.interactive.guard_lhs", "conv.dsimp", "conv.interactive.trace_lhs", "conv.whnf", "conv.replace_lhs", "conv.discharge_eq_lhs"]}, {"id": "tactic.target_lhs_rhs", "parentIds": ["conv.lhs", "old_conv.conversion", "conv.funext", "tactic.interactive.transitivity", "conv.interactive.find", "conv.change", "conv.interactive.for", "conv.interactive.simp", "conv.congr", "conv.rhs"]}, {"id": "nat.sub_sub_self", "parentIds": []}, {"id": "nat.sub_le", "parentIds": ["nat.sub_sub_self", "array.take_right", "buffer.lt_aux_3", "nat.sub_lt", "nat.sub_lt_succ"]}, {"id": "nat.add_sub_of_le", "parentIds": ["nat.sub_sub_self", "nat.sub_add_cancel"]}, {"id": "nat.sub_eq_iff_eq_add", "parentIds": ["nat.sub_sub_self", "int.sub_nat_nat_elim", "nat.sub_add_comm"]}, {"id": "smt_pre_config.inhabited", "parentIds": []}, {"id": "tactic.interactive.focus", "parentIds": []}, {"id": "tactic.match_or", "parentIds": []}, {"id": "expr.is_or", "parentIds": ["tactic.match_or"]}, {"id": "rbmap_of", "parentIds": []}, {"id": "rbmap.from_list", "parentIds": ["rbmap_of"]}, {"id": "level.lex_lt", "parentIds": []}, {"id": "mk_name_set", "parentIds": ["name_set.of_list", "has_dup", "tactic.non_dep_prop_hyps", "mk_hinst_lemma_attr_from_simp_attr", "rsimp_attr", "name_set.inhabited", "expr.has_local_constant", "lint_aux", "name_set.mmap", "tactic.mk_constructors_fresh_names", "expr.list_constant", "expr.list_names_with_prefix"]}, {"id": "int.nat_abs_eq", "parentIds": ["int.eq_coe_or_neg"]}, {"id": "dlist.to_list_concat", "parentIds": []}, {"id": "dlist.concat", "parentIds": ["dlist.to_list_concat"]}, {"id": "classical.cases", "parentIds": []}, {"id": "hinst_lemma.has_to_tactic_format", "parentIds": []}, {"id": "hinst_lemma.pp", "parentIds": ["hinst_lemma.has_to_tactic_format", "hinst_lemmas.pp"]}, {"id": "to_additive.tokens_dict", "parentIds": ["to_additive.guess_name"]}, {"id": "string.has_lt", "parentIds": ["to_additive.tokens_dict", "string.has_decidable_lt", "fold_over_with_cond_sorted"]}, {"id": "string.has_decidable_lt", "parentIds": ["to_additive.tokens_dict", "fold_over_with_cond_sorted"]}, {"id": "parser.run_string", "parentIds": []}, {"id": "string.to_char_buffer", "parentIds": ["parser.run_string", "parser.mk_error_msg", "tactic.alias.make_left_right"]}, {"id": "parser.run", "parentIds": ["parser.run_string", "tactic.alias.make_left_right"]}, {"id": "nat.add_div_left", "parentIds": ["nat.mul_div_right"]}, {"id": "nat.add_div_right", "parentIds": ["nat.add_div_left", "nat.add_mul_div_left", "nat.div_self"]}, {"id": "list.concat", "parentIds": []}, {"id": "tactic.mk_higher_order_type", "parentIds": []}, {"id": "list.nil_subset", "parentIds": []}, {"id": "eq_of_mul_eq_mul_right", "parentIds": ["int.eq_one_of_mul_eq_self_left"]}, {"id": "mul_sub_right_distrib", "parentIds": ["eq_of_mul_eq_mul_right", "sub_mul", "ordered_ring.mul_le_mul_of_nonneg_right", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "ordered_ring.mul_lt_mul_of_pos_right"]}, {"id": "sub_eq_zero_of_eq", "parentIds": ["eq_of_mul_eq_mul_right", "eq_of_mul_eq_mul_left", "sub_eq_zero_iff_eq"]}, {"id": "name.lt", "parentIds": ["name.has_lt", "name.lt.decidable_rel"]}, {"id": "nat.gcd_succ", "parentIds": []}, {"id": "nat.bodd_add_div2", "parentIds": ["nat.bit_decomp", "nat.div2_val"]}, {"id": "nat.succ_mul", "parentIds": ["nat.bodd_add_div2", "nat.eq_zero_of_mul_eq_zero", "nat.mul_pred_left", "nat.left_distrib", "nat.mul_sub_right_distrib", "nat.mul_comm", "nat.le_div_iff_mul_le"]}, {"id": "nat.div2", "parentIds": ["nat.bodd_add_div2", "nat.shiftr_eq_div_pow", "nat.binary_rec_eq", "nat.binary_rec_zero", "nat.shiftl'_sub", "nat.div2_zero", "nat.bit_decomp", "nat.bit_cases_on", "nat.shiftr_add", "nat.div2_val", "nat.test_bit_succ", "nat.div2_bit", "nat.div2_succ", "nat.div2_two", "nat.div2_one"]}, {"id": "nat.add_monoid", "parentIds": ["nat.bodd_add_div2", "nat.bodd_add", "list.length_append", "nat.add_mul_div_left", "nat.add_sub_cancel", "nat.sub_pos_of_lt", "nat.mul_div_cancel'", "nat.lt_add_of_zero_lt_left", "nat.add_sub_add_right", "nat.mul_mod_right", "nat.sub_sub", "nat.div2_bit", "nat.dvd_of_mod_eq_zero", "nat.mod_add_div", "nat.div_self", "nat.add_semigroup", "nat.add_mul_mod_self_left", "nat.div_one", "nat.mul_div_cancel"]}, {"id": "nat.bodd_succ", "parentIds": ["nat.bodd_add_div2", "nat.bodd_add", "nat.mod_two_of_bodd", "nat.bodd_mul", "nat.bodd_bit"]}, {"id": "nat.div2_succ", "parentIds": ["nat.bodd_add_div2"]}, {"id": "string_imp", "parentIds": ["string.iterator.length_next_to_string_next", "string.empty", "string.iterator.next_to_string_mk_iterator", "string.iterator.zero_lt_length_next_to_string_of_has_next", "string.str_ne_str_right", "string.empty_ne_str", "string.has_decidable_eq", "list.as_string", "string", "string.str_ne_str_left", "string.has_decidable_lt", "string.has_lt", "string_imp.inhabited"]}, {"id": "not_of_iff_false", "parentIds": []}, {"id": "neg_le_abs_self", "parentIds": []}, {"id": "le_abs_self", "parentIds": ["neg_le_abs_self", "eq_zero_of_abs_eq_zero", "abs_abs_sub_abs_le_abs_sub"]}, {"id": "buffer.append_string", "parentIds": ["string.to_char_buffer"]}, {"id": "le_add_of_le_of_nonneg", "parentIds": []}, {"id": "quotient.rec_on_subsingleton\u2082", "parentIds": ["quotient.decidable_eq"]}, {"id": "quotient.rec_on_subsingleton", "parentIds": ["quotient.rec_on_subsingleton\u2082"]}, {"id": "tactic.interactive.symmetry", "parentIds": []}, {"id": "tactic.symmetry", "parentIds": ["tactic.interactive.symmetry", "tactic.symm_apply"]}, {"id": "tactic.simp_all_entry", "parentIds": ["tactic.simp_all"]}, {"id": "reducibility_hints.inhabited", "parentIds": []}, {"id": "nat.sub_le_sub_left", "parentIds": ["nat.mul_sub_div"]}, {"id": "bool.band_comm", "parentIds": []}, {"id": "not_lt_of_gt", "parentIds": []}, {"id": "lt_asymm", "parentIds": ["not_lt_of_gt", "ordering.compares.eq_lt", "ordering.compares.eq_gt", "eq_zero_of_neg_eq", "cmp_swap", "pos_and_pos_or_neg_and_neg_of_mul_pos"]}, {"id": "unsigned.has_lt", "parentIds": []}, {"id": "fin.lt", "parentIds": ["unsigned.has_lt", "fin.has_lt", "fin.lt_def"]}, {"id": "field.one_div_mul_one_div", "parentIds": []}, {"id": "one_div_le_of_one_div_le_of_neg", "parentIds": []}, {"id": "division_ring.one_div_one_div", "parentIds": ["one_div_le_of_one_div_le_of_neg", "one_div_le_of_one_div_le_of_pos", "one_div_one_div", "pos_of_one_div_pos", "division_ring.eq_of_one_div_eq_one_div", "division_ring.inv_inv"]}, {"id": "not_lt_of_ge", "parentIds": ["one_div_le_of_one_div_le_of_neg", "lt_imp_lt_of_le_imp_le", "decidable.not_lt", "int.nat_abs_add_nonneg", "nat.mul_self_le_mul_self_iff", "lt_of_mul_lt_mul_right", "int.of_nat_nat_abs_eq_of_nonneg", "pos_of_mul_pos_right", "le_of_one_div_le_one_div_of_neg", "not_lt", "int.eq_neg_succ_of_lt_zero", "le_of_one_div_le_one_div", "neg_of_mul_neg_right", "pos_of_mul_pos_left", "lt_of_mul_lt_mul_left", "neg_of_mul_neg_left"]}, {"id": "lt_of_one_div_lt_one_div_of_neg", "parentIds": ["one_div_le_of_one_div_le_of_neg"]}, {"id": "lt_trans", "parentIds": ["one_div_le_of_one_div_le_of_neg", "lt.trans", "one_div_lt_one_div_of_lt_of_neg", "lt_asymm", "add_lt_add", "nat.div_lt_self", "one_div_lt_one_div_of_lt", "gt_trans"]}, {"id": "add_sub_cancel'", "parentIds": ["add_sub_sub_cancel", "add_sub_cancel'_right"]}, {"id": "sub_eq_neg_add", "parentIds": ["add_sub_cancel'"]}, {"id": "classical.type_decidable", "parentIds": []}, {"id": "psum", "parentIds": ["classical.type_decidable", "psum.inhabited_right", "psum.has_sizeof", "nonempty_psum", "psum.inhabited_left"]}, {"id": "task.bind", "parentIds": ["task.monad"]}, {"id": "task.flatten", "parentIds": ["task.bind"]}, {"id": "task.map", "parentIds": ["task.bind", "task.monad", "declaration.map_value", "task.delay"]}, {"id": "list.length_le_of_sublist", "parentIds": []}, {"id": "list.sublist", "parentIds": ["list.length_le_of_sublist", "list.filter_sublist"]}, {"id": "int.ne_of_nat_ne_nonneg_case", "parentIds": []}, {"id": "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "parentIds": ["int.ne_of_nat_ne_nonneg_case"]}, {"id": "string.get_rest", "parentIds": []}, {"id": "list.get_rest", "parentIds": ["string.get_rest"]}, {"id": "nat.succ_mul_succ_eq", "parentIds": []}, {"id": "nat.distrib", "parentIds": ["nat.succ_mul_succ_eq", "nat.mul_self_sub_mul_self_eq", "nat.mod_add_div"]}, {"id": "nat.add_one", "parentIds": ["nat.succ_mul_succ_eq", "list.length_take", "nat.sub_mul_div", "list.length_map\u2082", "nat.le_div_iff_mul_le", "nat.eq_zero_of_add_eq_zero_right"]}, {"id": "tactic.get_unused_decl_name", "parentIds": ["simps_add_projection", "tactic.delta_instance"]}, {"id": "tactic.get_unused_decl_name_aux", "parentIds": ["tactic.get_unused_decl_name"]}, {"id": "environment.contains", "parentIds": ["tactic.get_unused_decl_name", "environment.in_current_file", "tactic.in_open_namespaces", "tactic.injection_with"]}, {"id": "is_dec_eq", "parentIds": ["decidable_eq_of_bool_pred"]}, {"id": "exists_imp_exists'", "parentIds": []}, {"id": "list.mem_append_left", "parentIds": ["list.subset_append_left"]}, {"id": "tactic.apply_list_expr", "parentIds": ["tactic.apply_rules"]}, {"id": "conv.alternative", "parentIds": ["conv.congr"]}, {"id": "abs_one_div", "parentIds": []}, {"id": "abs_div", "parentIds": ["abs_one_div"]}, {"id": "discrete_linear_ordered_field.to_linear_ordered_field", "parentIds": ["abs_one_div", "div_mul_le_div_mul_of_div_le_div_pos'", "abs_div", "pos_of_one_div_pos", "neg_of_one_div_neg"]}, {"id": "discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring", "parentIds": ["abs_one_div", "abs_div", "discrete_linear_ordered_field.to_discrete_field"]}, {"id": "discrete_linear_ordered_field", "parentIds": ["abs_one_div", "discrete_linear_ordered_field.to_linear_ordered_field", "div_mul_le_div_mul_of_div_le_div_pos'", "abs_div", "discrete_linear_ordered_field.to_discrete_field", "discrete_linear_ordered_field.to_decidable_linear_ordered_comm_ring", "pos_of_one_div_pos", "neg_of_one_div_neg"]}, {"id": "monad_reader_adapter_trans", "parentIds": []}, {"id": "monad_functor", "parentIds": ["monad_reader_adapter_trans", "monad_state_adapter_trans", "monad_functor_t_trans", "option_t.monad_functor", "reader_t.monad_functor", "except_t.monad_functor", "monad_except_adapter_trans", "state_t.monad_functor"]}, {"id": "monad_functor_t", "parentIds": ["monad_reader_adapter_trans", "state_t.run_monad_map", "monad_state_adapter_trans", "option_t.run_monad_map", "monad_map_refl", "monad_functor_t_trans", "except_t.run_monad_map", "monad_functor_t_refl", "reader_t.run_monad_map", "monad_except_adapter_trans"]}, {"id": "monad_functor_t_refl", "parentIds": ["monad_reader_adapter_trans", "monad_state_adapter_trans", "monad_map_refl", "monad_except_adapter_trans"]}, {"id": "monad_functor_t_trans", "parentIds": ["monad_reader_adapter_trans", "state_t.run_monad_map", "monad_state_adapter_trans", "option_t.run_monad_map", "except_t.run_monad_map", "reader_t.run_monad_map", "monad_except_adapter_trans"]}, {"id": "has_lift_t", "parentIds": ["coe_to_lift", "lift_t", "lift_fn", "lift_pair\u2081", "int.sub_nat_nat_eq_coe", "coe", "lift_pair", "lift_trans", "int.mul_pos", "lift_base", "lift_pair\u2082", "lift_fn_range", "lift_list"]}, {"id": "coe_t", "parentIds": ["coe_to_lift", "coe_trans"]}, {"id": "has_coe_t", "parentIds": ["coe_to_lift", "coe_t", "coe_trans", "coe_base", "coe_option", "coe_coe"]}, {"id": "nat.add_mul_div_right", "parentIds": ["nat.mul_div_cancel"]}, {"id": "nat.add_mul_div_left", "parentIds": ["nat.add_mul_div_right", "nat.div2_bit"]}, {"id": "prod.rprod_wf", "parentIds": []}, {"id": "prod.rprod", "parentIds": ["prod.rprod_wf", "prod.rprod_sub_lex"]}, {"id": "subrelation.wf", "parentIds": ["prod.rprod_wf"]}, {"id": "prod.lex_wf", "parentIds": ["prod.rprod_wf"]}, {"id": "prod.lex", "parentIds": ["prod.rprod_wf", "prod.lex.decidable", "prod.lex_wf", "prod.lex_accessible", "prod.has_well_founded", "prod.lex_def", "prod.rprod_sub_lex"]}, {"id": "prod.rprod_sub_lex", "parentIds": ["prod.rprod_wf"]}, {"id": "eq.congr_left", "parentIds": []}, {"id": "tactic.is_in_mathlib", "parentIds": []}, {"id": "tactic.get_mathlib_dir", "parentIds": ["tactic.is_in_mathlib", "lint_mathlib"]}, {"id": "nat.bodd_add", "parentIds": ["nat.mod_two_of_bodd", "nat.bodd_mul", "nat.bodd_bit"]}, {"id": "nat.bodd_zero", "parentIds": ["nat.bodd_add", "nat.binary_rec_eq", "nat.mod_two_of_bodd", "nat.bodd_mul", "nat.bodd_bit"]}, {"id": "tactic.get_pi_binders_aux", "parentIds": ["tactic.get_pi_binders"]}, {"id": "mul_eq_one_iff_inv_eq", "parentIds": ["inv_eq_iff_mul_eq_one"]}, {"id": "eq_inv_iff_eq_inv", "parentIds": ["mul_eq_one_iff_inv_eq", "inv_eq_iff_inv_eq"]}, {"id": "expr.local_binding_info", "parentIds": ["dangerous_instance"]}, {"id": "one_inv", "parentIds": ["inv_eq_one"]}, {"id": "mul_eq_of_eq_div", "parentIds": []}, {"id": "eq_div_iff_mul_eq", "parentIds": ["mul_eq_of_eq_div", "add_div_eq_mul_add_div", "eq_div_of_mul_eq", "add_self_div_two"]}, {"id": "list.head", "parentIds": ["tactic.lift"]}, {"id": "norm_num.mul_one", "parentIds": []}, {"id": "and_eq_of_eq_true_left", "parentIds": []}, {"id": "tactic.interactive.by_contra", "parentIds": []}, {"id": "tactic.interactive.by_contradiction", "parentIds": ["tactic.interactive.by_contra"]}, {"id": "tactic.interactive.get_rule_eqn_lemmas", "parentIds": []}, {"id": "expr.erase_annotations", "parentIds": ["tactic.interactive.get_rule_eqn_lemmas", "incorrect_type_class_argument"]}, {"id": "tactic.get_eqn_lemmas_for", "parentIds": ["tactic.interactive.get_rule_eqn_lemmas", "tactic.transport_with_prefix_fun", "tactic.mk_simp_set_core", "tactic.ids_to_simp_arg_list"]}, {"id": "tactic.resolve_name", "parentIds": ["tactic.interactive.get_rule_eqn_lemmas", "tactic.i_to_expr_for_apply", "tactic.resolve_constant", "tactic.lift", "tactic.explode", "tactic.delta_instance", "tactic.interactive.get_current_field", "tactic.resolve_name'", "tactic.ids_to_simp_arg_list"]}, {"id": "tactic.rcases_patt.format", "parentIds": ["tactic.rcases_patt.has_to_format", "tactic.interactive.rintro"]}, {"id": "tactic.rcases_patt_inverted.format_list", "parentIds": ["tactic.rcases_patt.format"]}, {"id": "tactic.rcases_patt.invert", "parentIds": ["tactic.rcases_patt.format"]}, {"id": "monad_fail", "parentIds": ["conv.monad_fail", "smt_tactic.monad_fail", "tactic.unsafe.type_context.monad_fail", "match_failed", "monad_fail_lift", "parser.monad_fail", "interaction_monad.monad_fail"]}, {"id": "parser.foldl", "parentIds": []}, {"id": "parser.foldl_core", "parentIds": ["parser.foldl"]}, {"id": "list.subset", "parentIds": ["list.has_subset"]}, {"id": "list.has_sizeof", "parentIds": []}, {"id": "tactic.mk_simp_attribute_cmd", "parentIds": []}, {"id": "tactic.mk_simp_attr", "parentIds": ["tactic.mk_simp_attribute_cmd"]}, {"id": "lean.parser.pexpr", "parentIds": ["tactic.mk_simp_attribute_cmd", "tactic.interactive.min_tac", "interactive.types.pexpr_list", "localized_cmd", "tactic.interactive.try_for", "old_conv.interactive.find", "interactive.types.texpr", "find_cmd", "conv.interactive.find", "tactic.interactive.find", "tactic.interactive.conv", "tactic.interactive.conv_rhs", "conv.interactive.for", "tactic.interactive.apply_with", "tactic.interactive.rw_rules", "library_note", "tactic.interactive.conv_lhs"]}, {"id": "std.prec.max", "parentIds": ["tactic.mk_simp_attribute_cmd", "tactic.interactive.min_tac", "interactive.types.pexpr_list", "localized_cmd", "tactic.interactive.try_for", "old_conv.interactive.find", "find_cmd", "std.prec.max_plus", "conv.interactive.find", "interactive.parse_binders", "tactic.interactive.find", "tactic.interactive.conv", "tactic.interactive.conv_rhs", "conv.interactive.for", "tactic.interactive.apply_with", "lean.parser.pexpr", "tactic.interactive.rw_rules", "library_note", "tactic.interactive.conv_lhs"]}, {"id": "tactic.add_doc_string", "parentIds": ["tactic.mk_simp_attribute_cmd", "tactic.alias.alias_direct", "tactic.def_replacer", "tactic.alias.alias_iff"]}, {"id": "conv.interactive.skip", "parentIds": ["conv.interactive.to_lhs", "conv.interactive.to_rhs"]}, {"id": "conv.skip", "parentIds": ["conv.interactive.skip", "conv.discharge_eq_lhs"]}, {"id": "bind_pure", "parentIds": ["mjoin_map_pure", "fish_pure"]}, {"id": "tactic.interactive.by_cases", "parentIds": ["tactic.interactive.min_tac"]}, {"id": "tactic.by_cases", "parentIds": ["tactic.interactive.by_cases", "tactic.split_if1"]}, {"id": "where.sort_variable_list", "parentIds": ["where.compile_variable_list"]}, {"id": "where.collect_by", "parentIds": ["where.sort_variable_list"]}, {"id": "where.inflate", "parentIds": ["where.sort_variable_list"]}, {"id": "list.qsort", "parentIds": ["where.sort_variable_list", "list.qsort_cons", "list.qsort_nil", "tactic.suggest"]}, {"id": "where.binder_less_important", "parentIds": ["where.sort_variable_list"]}, {"id": "string.has_to_string", "parentIds": ["where.format_variable"]}, {"id": "old_conv.repeat", "parentIds": []}, {"id": "nat.shiftl_sub", "parentIds": []}, {"id": "nat.shiftl'_sub", "parentIds": ["nat.shiftl_sub"]}, {"id": "reader_t.run_read", "parentIds": []}, {"id": "reader_t.read", "parentIds": ["reader_t.run_read", "reader_t.monad_reader"]}, {"id": "reader_t", "parentIds": ["reader_t.run_read", "reader_t.monad_except", "reader_t.run_map", "reader_t.run_pure", "reader_t.adapt", "reader", "reader_t.is_lawful_monad", "reader_t.monad_reader_adapter", "reader_t.read", "reader_t.monad_reader", "reader_t.bind", "reader_t.run_monad_lift", "reader_t.has_monad_lift", "reader_t.lift", "reader_t.monad_functor", "reader_t.monad_map", "reader_t.orelse", "reader_t.pure", "reader_t.alternative", "reader_t.run_bind", "reader_t.run_monad_map", "reader_t.ext", "reader_t.failure", "reader_t.monad", "reader_t.monad_run"]}, {"id": "mk_rbtree", "parentIds": ["mk_rbmap", "rbtree.from_list", "rbtree.inhabited"]}, {"id": "rbtree", "parentIds": ["mk_rbtree", "rbtree.mem", "rbtree.max", "rbtree.empty", "rbmap", "rbtree.has_repr", "rbtree.depth", "rbtree.fold", "rbtree.rev_fold", "rbtree.insert", "rbtree.to_list", "rbtree.mem_exact", "rbtree.from_list", "rbtree_of", "rbtree.has_mem", "rbtree.find", "rbtree.inhabited", "rbtree.min", "rbtree.contains"]}, {"id": "list.inits", "parentIds": []}, {"id": "add_right_surjective", "parentIds": []}, {"id": "tactic.interactive.cc", "parentIds": []}, {"id": "tactic.cc", "parentIds": ["tactic.interactive.cc"]}, {"id": "tt_eq_ff_eq_false", "parentIds": []}, {"id": "comm_group.to_group", "parentIds": ["mul_inv"]}, {"id": "comm_group", "parentIds": ["comm_group.to_group", "mul_inv", "comm_group.to_comm_monoid"]}, {"id": "list.ilast", "parentIds": ["tactic.constr_to_prop", "expr.is_eta_expansion_test", "interactive.param_desc"]}, {"id": "abs_sub_square", "parentIds": ["abs_abs_sub_abs_le_abs_sub"]}, {"id": "tactic.interactive.min_tac", "parentIds": []}, {"id": "tactic.andthen_seq", "parentIds": ["tactic.interactive.min_tac", "tactic.repeat1", "tactic.interactive.use", "tactic.mk_inj_eq", "tactic.interactive.ac_change", "tactic.split_if1"]}, {"id": "int.zero", "parentIds": ["int.has_zero", "int.comm_ring"]}, {"id": "ulift.functor", "parentIds": []}, {"id": "lean.parser.of_tactic", "parentIds": ["lean.parser.of_tactic'", "lean.parser.has_coe", "library_note"]}, {"id": "tactic.clear'", "parentIds": ["tactic.interactive.clear_dependent", "tactic.interactive.clear'"]}, {"id": "format.intercalate", "parentIds": ["tactic.clear'", "tactic.instance_stub", "tactic.list_constructors_hole", "tactic.rename'"]}, {"id": "expr_set", "parentIds": ["tactic.clear'", "mk_expr_set"]}, {"id": "tactic.revert_lst", "parentIds": ["tactic.clear'", "tactic.interactive.revert", "tactic.interactive.induction", "tactic.revert_kdependencies", "tactic.revert_all", "tactic.interactive.generalize_hyp", "tactic.revert", "tactic.prove_goal_async", "tactic.interactive.dunfold", "tactic.rename'", "dedup", "tactic.interactive.delta"]}, {"id": "expr.has_to_format", "parentIds": ["tactic.clear'", "tactic.interactive.rcases", "tactic.assoc_refl", "reflected.has_to_format", "tactic.interactive.rec.to_tactic_format", "tactic.local_def_value", "tactic.use", "tactic.mk_assoc_instance", "local_context.to_format", "tactic.interactive.parse_config"]}, {"id": "tactic.mk_meta_var", "parentIds": ["tactic.clear'", "smt_tactic.interactive.have", "tactic.interactive.let", "tactic.solve_aux", "tactic.dependent_pose_core", "tactic.abstract", "smt_tactic.interactive.let", "tactic.mk_mvar", "tactic.interactive.change", "tactic.prove_goal_async", "tactic.interactive.have", "conv.convert", "conv.discharge_eq_lhs", "tactic.mk_sorry"]}, {"id": "native.rb_set.to_list", "parentIds": ["tactic.clear'"]}, {"id": "tactic.replacer", "parentIds": []}, {"id": "tactic.replacer_core", "parentIds": ["tactic.replacer"]}, {"id": "int.zero_mul", "parentIds": []}, {"id": "int.mul_zero", "parentIds": ["int.zero_mul"]}, {"id": "int.mul_comm", "parentIds": ["int.zero_mul", "int.distrib_right", "int.comm_ring", "int.one_mul"]}, {"id": "native.float.is_normal", "parentIds": []}, {"id": "native.float.sign", "parentIds": []}, {"id": "tactic.interactive.revert", "parentIds": ["tactic.interactive.h_generalize"]}, {"id": "ordered_comm_group.lt_of_add_lt_add_left", "parentIds": []}, {"id": "mul_zero_lt_mul_inv_of_neg", "parentIds": ["one_div_neg_of_neg"]}, {"id": "mul_inv_cancel", "parentIds": ["mul_zero_lt_mul_inv_of_neg", "div_self", "mul_zero_lt_mul_inv_of_pos", "mul_one_div_cancel", "one_inv_eq", "div_eq_one_iff_eq", "mul_div_cancel", "mul_mul_div"]}, {"id": "inv_eq_one_div", "parentIds": ["mul_zero_lt_mul_inv_of_neg", "inv_ne_zero", "mul_zero_lt_mul_inv_of_pos", "field.div_mul_right", "division_ring.inv_inv", "div_neg_eq_neg_div"]}, {"id": "tactic.by_elim_opt", "parentIds": ["tactic.interactive.solve_by_elim", "tactic.suggest.apply_and_solve", "tactic.solve_by_elim"]}, {"id": "one_le_div_of_le", "parentIds": []}, {"id": "mul_one_div_cancel", "parentIds": ["one_le_div_of_le", "one_lt_div_of_lt", "division_ring.one_div_one_div", "one_div_ne_zero", "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "field.div_mul_right", "division_ring.mul_ne_zero", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "division_ring.one_div_mul_one_div"]}, {"id": "old_conv.execute", "parentIds": []}, {"id": "old_conv.conversion", "parentIds": ["old_conv.execute"]}, {"id": "lt_imp_lt_of_le_imp_le", "parentIds": ["decidable.le_imp_le_iff_lt_imp_lt", "le_imp_le_iff_lt_imp_lt"]}, {"id": "nat.gcd_zero_left", "parentIds": []}, {"id": "expr.is_napp_of", "parentIds": ["tactic.has_opt_auto_param", "tactic.has_opt_auto_param_for_apply", "tactic.comp_val", "expr.is_bin_arith_app"]}, {"id": "expr.get_app_num_args", "parentIds": ["expr.is_napp_of", "environment.is_refl_app", "tactic.apply_heq_congr_core", "tactic.fold_explicit_args", "expr.ith_arg"]}, {"id": "expr.is_app_of", "parentIds": ["expr.is_napp_of", "tactic.match_app_of", "can_lift_attr"]}, {"id": "sub_le_sub_left", "parentIds": ["abs_abs_sub_abs_le_abs_sub"]}, {"id": "old_conv.trace", "parentIds": ["old_conv.trace_lhs"]}, {"id": "exceptional.to_option", "parentIds": []}, {"id": "tactic.get_library_notes", "parentIds": []}, {"id": "lift_t", "parentIds": ["coe", "lift_trans"]}, {"id": "fin.succ", "parentIds": []}, {"id": "nat.add_le_add_iff_le_right", "parentIds": ["nat.le_div_iff_mul_le"]}, {"id": "nat.add_le_add_right", "parentIds": ["nat.add_le_add_iff_le_right"]}, {"id": "nat.le_of_add_le_add_right", "parentIds": ["nat.add_le_add_iff_le_right", "nat.sub_mul_mod"]}, {"id": "function.injective.decidable_eq", "parentIds": []}, {"id": "tactic.interactive.unfold", "parentIds": ["tactic.interactive.unfold_coes", "tactic.interactive.unfold1", "tactic.interactive.refine_one"]}, {"id": "string_to_name", "parentIds": ["tactic.interactive.unfold", "localized_attr", "nolint_attr", "can_lift_attr", "tactic.interactive.letI", "tactic.subobject_names", "linter_attr", "name.deinternalize_field", "tactic.interactive.haveI", "tactic.delta_instance", "tactic.interactive.h_generalize", "tactic.note_anon"]}, {"id": "tactic.unfold_config", "parentIds": ["tactic.interactive.unfold", "tactic.interactive.unfold_coes", "tactic.interactive.unfold1", "tactic.interactive.refine_one", "tactic.unfold_config.inhabited"]}, {"id": "tactic.ids_to_simp_arg_list", "parentIds": ["tactic.interactive.unfold"]}, {"id": "tactic.explode.append_dep", "parentIds": []}, {"id": "tactic.explode.entries.find", "parentIds": ["tactic.explode.append_dep"]}, {"id": "true_iff_false", "parentIds": []}, {"id": "norm_num.subst_into_sum", "parentIds": []}, {"id": "list.all", "parentIds": ["list.band", "expr.is_eta_expansion_of", "instance_priority"]}, {"id": "nat.zero_lt_one", "parentIds": ["nat.div_lt_self", "nat.one_pos"]}, {"id": "ordered_cancel_comm_monoid.to_add_left_cancel_semigroup", "parentIds": []}, {"id": "forall_lt_iff_le", "parentIds": []}, {"id": "le_of_forall_lt", "parentIds": ["forall_lt_iff_le"]}, {"id": "is_asymm_of_is_trans_of_is_irrefl", "parentIds": []}, {"id": "is_asymm", "parentIds": ["is_asymm_of_is_trans_of_is_irrefl", "asymm", "asymm_of"]}, {"id": "sizeof", "parentIds": ["sizeof_measure", "print_item_crawl", "sizeof_measure_wf"]}, {"id": "expr.fold", "parentIds": ["tactic.interactive.induction", "expr.list_local_consts", "expr.list_meta_vars", "expr.mfold", "list_items", "expr.list_constant", "expr.list_names_with_prefix", "expr.contains_constant"]}, {"id": "tactic.whnf_ginductive", "parentIds": ["tactic.interactive.induction", "tactic.injection_with"]}, {"id": "list.drop", "parentIds": ["tactic.interactive.induction", "tactic.elim_gen_sum", "list.length_drop", "tactic.constr_to_prop", "tactic.mk_iff_of_inductive_prop", "expr.is_eta_expansion"]}, {"id": "list.partition", "parentIds": ["tactic.interactive.induction", "tactic.subobject_names", "list.qsort_cons", "tactic.interactive.field", "list.partition_eq_filter_filter"]}, {"id": "tactic.revert_kdeps", "parentIds": ["tactic.interactive.induction"]}, {"id": "environment.inductive_num_params", "parentIds": ["tactic.interactive.induction", "tactic.mk_iff_of_inductive_prop", "tactic.constructor_num_fields", "tactic.mk_constructors_fresh_names", "instance_derive_handler", "tactic.interactive.case"]}, {"id": "int.neg_of_nat_zero", "parentIds": []}, {"id": "push_neg.not_le_eq", "parentIds": []}, {"id": "not_le", "parentIds": ["push_neg.not_le_eq", "decidable.lt_or_le", "lt_iff_lt_of_le_iff_le"]}, {"id": "tactic.interactive.rcases", "parentIds": []}, {"id": "tactic.rcases_patt.has_to_format", "parentIds": ["tactic.interactive.rcases"]}, {"id": "tactic.rcases_patt.has_reflect", "parentIds": ["tactic.interactive.rcases", "tactic.interactive.ext1", "tactic.interactive.rintros", "tactic.interactive.ext", "tactic.interactive.rintro"]}, {"id": "tactic.rcases_parse", "parentIds": ["tactic.interactive.rcases"]}, {"id": "tactic.rcases", "parentIds": ["tactic.interactive.rcases", "tactic.lift", "tactic.interactive.obtain"]}, {"id": "environment.inductive_dep_elim", "parentIds": []}, {"id": "sub_left_le_of_le_add", "parentIds": ["sub_le_of_abs_sub_le_left", "sub_le_of_sub_le", "neg_le_sub_left_of_le_add", "neg_add_le_left_of_le_add"]}, {"id": "incorrect_def_lemma", "parentIds": ["linter.def_lemma"]}, {"id": "declaration.is_constant", "parentIds": ["incorrect_def_lemma"]}, {"id": "declaration.is_definition", "parentIds": ["incorrect_def_lemma"]}, {"id": "declaration.is_axiom", "parentIds": ["incorrect_def_lemma"]}, {"id": "tactic.is_instance", "parentIds": ["incorrect_def_lemma", "impossible_instance", "instance_priority", "dangerous_instance", "dup_namespace"]}, {"id": "rbnode.mem", "parentIds": ["rbtree.mem"]}, {"id": "native.float.atan", "parentIds": []}, {"id": "rbtree.mem", "parentIds": ["rbtree.has_mem"]}, {"id": "nonneg_of_mul_nonneg_left", "parentIds": []}, {"id": "mul_neg_of_pos_of_neg", "parentIds": ["nonneg_of_mul_nonneg_left", "div_neg_of_pos_of_neg", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "div_lt_div_of_pos_of_lt_of_pos", "pos_and_pos_or_neg_and_neg_of_mul_pos"]}, {"id": "rbtree.default_lt", "parentIds": []}, {"id": "tactic.step", "parentIds": ["rbtree.default_lt", "tactic.mk_dec_eq_instance", "tactic.istep", "well_founded_tactics.cancel_nat_add_lt", "tactic.simp_intros", "tactic.interactive.convert_to", "tactic.inhabited_instance", "tactic.mk_inj_eq", "tactic.interactive.push_neg", "tactic.exact_dec_trivial"]}, {"id": "has_bind.seq", "parentIds": ["rbtree.default_lt", "tactic.mk_dec_eq_instance", "well_founded_tactics.cancel_nat_add_lt", "tactic.interactive.convert_to", "tactic.inhabited_instance", "tactic.mk_inj_eq", "tactic.interactive.push_neg", "tactic.exact_dec_trivial"]}, {"id": "tactic.save_info", "parentIds": ["rbtree.default_lt", "tactic.mk_dec_eq_instance", "well_founded_tactics.cancel_nat_add_lt", "tactic.interactive.simp_rw", "tactic.interactive.convert_to", "tactic.inhabited_instance", "tactic.mk_inj_eq", "tactic.interactive.push_neg", "tactic.exact_dec_trivial"]}, {"id": "tactic.interactive.apply", "parentIds": ["rbtree.default_lt", "well_founded_tactics.cancel_nat_add_lt", "smt_tactic.interactive.apply", "tactic.mk_inj_eq"]}, {"id": "lean.parser.with_input", "parentIds": ["lean.parser.emit_command_here"]}, {"id": "old_conv.findp", "parentIds": []}, {"id": "tactic.pattern", "parentIds": ["old_conv.findp", "tactic.interactive.cases_matching", "tactic.mk_pattern", "tactic.match_subexpr", "tactic.match_hypothesis", "tactic.match_expr", "old_conv.match_pattern", "old_conv.find_pattern", "old_conv.interactive.find", "conv.interactive.find", "tactic.interactive.constructor_matching", "conv.interactive.for", "tactic.match_pattern", "tactic.has_to_tactic_format", "old_conv.mk_match_expr", "tactic.pexpr_to_pattern", "old_conv.match_expr"]}, {"id": "old_conv.find_pattern", "parentIds": ["old_conv.findp"]}, {"id": "tactic.pexpr_to_pattern", "parentIds": ["old_conv.findp", "tactic.interactive.cases_matching", "tactic.match_subexpr", "tactic.match_hypothesis", "tactic.match_expr", "old_conv.interactive.find", "conv.interactive.find", "tactic.interactive.constructor_matching", "conv.interactive.for", "old_conv.mk_match_expr", "old_conv.match_expr"]}, {"id": "int.zero_nonneg", "parentIds": []}, {"id": "sum.elim_injective", "parentIds": []}, {"id": "tactic.symm_apply", "parentIds": ["tactic.apply_assumption"]}, {"id": "mul_right_cancel", "parentIds": ["mul_right_inj", "mul_left_eq_self", "mul_right_cancel_iff", "mul_right_injective"]}, {"id": "right_cancel_semigroup.to_semigroup", "parentIds": ["mul_right_cancel", "mul_right_inj", "mul_eq_one_iff_eq_inv", "mul_left_eq_self", "mul_right_cancel_iff", "mul_right_injective"]}, {"id": "right_cancel_semigroup", "parentIds": ["mul_right_cancel", "mul_right_inj", "group.to_right_cancel_semigroup", "mul_right_cancel_iff", "mul_right_injective", "right_cancel_semigroup.to_semigroup"]}, {"id": "fin.sub", "parentIds": ["fin.has_sub", "fin.sub_def", "unsigned.has_sub"]}, {"id": "dvd_add_iff_right", "parentIds": []}, {"id": "dvd_add_iff_left", "parentIds": ["dvd_add_iff_right"]}, {"id": "parser.many'", "parentIds": []}, {"id": "parser.many", "parentIds": ["parser.many'", "parser.sep_by1", "parser.many1", "parser.many_char"]}, {"id": "sum.swap_right_inverse", "parentIds": []}, {"id": "sum.swap", "parentIds": ["sum.swap_right_inverse", "sum.swap_swap_eq", "sum.swap_swap", "sum.swap_left_inverse"]}, {"id": "sum.swap_swap", "parentIds": ["sum.swap_right_inverse", "sum.swap_swap_eq", "sum.swap_left_inverse"]}, {"id": "tactic.kdependencies", "parentIds": ["tactic.revert_kdependencies"]}, {"id": "old_conv.first", "parentIds": []}, {"id": "add_sub_sub_cancel", "parentIds": []}, {"id": "sub_add", "parentIds": ["add_sub_sub_cancel"]}, {"id": "tactic.interactive.unfold_coes", "parentIds": []}, {"id": "name_set.of_list", "parentIds": ["lint", "no_rsimp", "tactic.interactive.clear_except", "mk_name_set_attr"]}, {"id": "name_set.insert", "parentIds": ["name_set.of_list", "has_dup", "tactic.non_dep_prop_hyps", "name_set.union", "name_set.insert_list", "expr.has_local_constant", "name_set.mmap", "expr.list_constant", "expr.list_names_with_prefix"]}, {"id": "name.inhabited", "parentIds": ["environment.projection_info.inhabited", "tactic.lift", "to_additive.value_type.inhabited", "binder.inhabited", "interactive.param_desc", "dup_namespace"]}, {"id": "restate_axiom_cmd", "parentIds": []}, {"id": "tactic.get_decl", "parentIds": ["restate_axiom_cmd", "tactic.instance_cache.mk_app", "where.get_def_variables", "tactic.constr_to_prop", "tactic.mk_iff_of_inductive_prop", "tactic.explode", "tactic.alias.alias_cmd", "tactic.mk_constructor_fresh_names", "tactic.alias.alias_iff", "tactic.alias.get_alias_target", "instance_priority", "instance_derive_handler", "tactic.delta_instance", "tactic.replaceable_attr", "tactic.find_private_decl", "tactic.replacer_attr", "derive_struct_ext_lemma", "has_inhabited_instance", "tactic.import_private_cmd"]}, {"id": "lean.parser.has_coe", "parentIds": ["restate_axiom_cmd", "tactic.alias.alias_cmd"]}, {"id": "tactic.interactive.dsimp", "parentIds": ["smt_tactic.interactive.dsimp"]}, {"id": "tactic.dsimp_hyp", "parentIds": ["tactic.interactive.dsimp", "tactic.lift"]}, {"id": "interactive.loc.apply", "parentIds": ["tactic.interactive.dsimp", "tactic.interactive.elide", "tactic.interactive.unelide", "tactic.interactive.dunfold", "tactic.interactive.delta"]}, {"id": "tactic.revert_all", "parentIds": ["tactic.interactive.dsimp"]}, {"id": "tactic.dsimp_target", "parentIds": ["tactic.interactive.dsimp", "tactic.get_lift_prf"]}, {"id": "mk_nat_val_le_proof", "parentIds": ["tactic.comp_val"]}, {"id": "list.cons_subset_cons", "parentIds": []}, {"id": "pexpr.of_expr", "parentIds": ["tactic.lift", "reflected.has_to_pexpr", "expr.has_to_pexpr"]}, {"id": "dlist.to_list_cons", "parentIds": []}, {"id": "dlist.cons", "parentIds": ["dlist.to_list_cons"]}, {"id": "and_eq_of_eq_true_right", "parentIds": ["prod.mk.inj_iff"]}, {"id": "or.assoc", "parentIds": ["or.left_comm", "or_assoc"]}, {"id": "prod.forall", "parentIds": []}, {"id": "tactic.interactive.cases_matching", "parentIds": ["tactic.interactive.casesm", "tactic.mk_inj_eq"]}, {"id": "interactive.types.pexpr_list_or_texpr", "parentIds": ["tactic.interactive.cases_matching", "tactic.interactive.existsi", "smt_tactic.interactive.add_lemma", "tactic.interactive.use", "tactic.interactive.constructor_matching", "tactic.interactive.exacts", "smt_tactic.interactive.eblast_using", "tactic.interactive.casesm", "smt_tactic.interactive.ematch_using", "tactic.interactive.apply_rules", "smt_tactic.interactive.add_lhs_lemma"]}, {"id": "tactic.repeat", "parentIds": ["tactic.interactive.cases_matching", "tactic.repeat1", "tactic.interactive.repeat", "tactic.interactive.cases_type", "tactic.interactive.clear_", "tactic.interactive.constructor_matching", "derive_struct_ext_lemma"]}, {"id": "arbitrary", "parentIds": ["forall_const", "exists_const"]}, {"id": "list.is_prefix_of", "parentIds": ["list.is_suffix_of", "string.is_prefix_of", "tactic.alias.make_left_right"]}, {"id": "expr.is_ne", "parentIds": ["tactic.match_ne", "tactic.comp_val"]}, {"id": "nat.test_bit_lor", "parentIds": []}, {"id": "nat.lor", "parentIds": ["nat.test_bit_lor", "nat.lor_bit"]}, {"id": "tactic.suggest.head_symbol_match.inhabited", "parentIds": []}, {"id": "max_comm", "parentIds": ["max_eq_right", "abs_neg", "max_left_comm"]}, {"id": "max_le", "parentIds": ["max_comm", "max_assoc", "eq_max"]}, {"id": "smt_tactic.interactive.intros", "parentIds": []}, {"id": "smt_tactic.intro_lst", "parentIds": ["smt_tactic.interactive.intros"]}, {"id": "mk_simple_name", "parentIds": ["string_to_name"]}, {"id": "environment.projection_info.inhabited", "parentIds": []}, {"id": "bool.inhabited", "parentIds": ["environment.projection_info.inhabited", "subsingleton_info.inhabited", "bool.default_bool", "param_info.inhabited"]}, {"id": "tactic.interactive.rename'", "parentIds": []}, {"id": "tactic.rename'", "parentIds": ["tactic.interactive.rename'"]}, {"id": "tactic.interactive.rename'_args_parser", "parentIds": ["tactic.interactive.rename'"]}, {"id": "ne_false_of_self", "parentIds": ["true_ne_false"]}, {"id": "expr.hash", "parentIds": []}, {"id": "imp_eq_of_eq_false_right", "parentIds": []}, {"id": "fin.has_sub", "parentIds": ["fin.sub_def"]}, {"id": "format.to_buffer", "parentIds": []}, {"id": "option_t.fail", "parentIds": ["option_t.alternative", "option_t.monad_except"]}, {"id": "not_iff_not", "parentIds": []}, {"id": "iff_def'", "parentIds": ["not_iff_not"]}, {"id": "not_imp_not", "parentIds": ["not_iff_not", "classical.not_imp_not"]}, {"id": "expr.pi_arity_aux", "parentIds": ["expr.pi_arity"]}, {"id": "classical.epsilon_spec", "parentIds": ["classical.epsilon_singleton"]}, {"id": "nonempty_of_exists", "parentIds": ["classical.epsilon_spec"]}, {"id": "classical.epsilon_spec_aux", "parentIds": ["classical.epsilon_spec"]}, {"id": "classical.epsilon", "parentIds": ["classical.epsilon_spec", "classical.epsilon_spec_aux", "classical.epsilon_singleton"]}, {"id": "environment.unfold_all_macros", "parentIds": []}, {"id": "tactic.interactive.solve_by_elim", "parentIds": []}, {"id": "tactic.solve_by_elim", "parentIds": ["tactic.interactive.solve_by_elim", "tactic.suggest.apply_and_solve"]}, {"id": "nat.le_refl", "parentIds": ["nat.zero_le", "nat.le_succ", "nat.linear_order", "nat.pred_le_pred", "nat.le_add_right", "nat.lt_iff_le_not_le", "nat.decidable_linear_ordered_semiring", "nat.succ_le_succ", "nat.sub_le", "nat.lt.base"]}, {"id": "list.length_append", "parentIds": []}, {"id": "lt_div_of_mul_lt", "parentIds": ["one_div_lt_one_div_of_lt"]}, {"id": "neg_inj'", "parentIds": ["eq_of_neg_eq_neg", "neg_eq_zero", "sub_left_inj"]}, {"id": "set.image", "parentIds": ["set.functor", "set.is_lawful_functor"]}, {"id": "set_of", "parentIds": ["set.image", "set.sUnion", "set.compl", "set.inter", "set.powerset", "set.sep", "set.union", "set.insert"]}, {"id": "ge_of_forall_ge_sub", "parentIds": []}, {"id": "exists_add_lt_and_pos_of_lt", "parentIds": ["ge_of_forall_ge_sub"]}, {"id": "dvd_of_mul_left_dvd", "parentIds": []}, {"id": "tactic.read_ref", "parentIds": []}, {"id": "has_dup", "parentIds": ["dedup"]}, {"id": "name_set.contains", "parentIds": ["has_dup", "tactic.non_dep_prop_hyps", "tactic.interactive.clear_except"]}, {"id": "associative", "parentIds": ["right_comm", "left_comm"]}, {"id": "string.iterator.length_next_to_string_next", "parentIds": []}, {"id": "string.length", "parentIds": ["string.iterator.length_next_to_string_next", "tactic.unprime", "string.iterator.zero_lt_length_next_to_string_of_has_next", "string.has_sizeof", "string.is_empty", "tactic.explode.pad_right", "format.bracket", "where.format_variable", "lint_mathlib", "string.to_nat"]}, {"id": "nat.zero_sub", "parentIds": ["string.iterator.length_next_to_string_next", "list.length_drop", "nat.zero_mod", "nat.mul_pred_left", "nat.sub_self_add", "nat.sub_mul_div"]}, {"id": "nat.add_sub_cancel_left", "parentIds": ["string.iterator.length_next_to_string_next", "int.sub_nat_nat_elim", "nat.add_sub_assoc", "nat.dvd_add_iff_right", "nat.succ_sub", "nat.mod_add_div", "int.to_nat_sub", "nat.add_sub_of_le"]}, {"id": "string.iterator.next", "parentIds": ["string.iterator.length_next_to_string_next", "name.deinternalize_field"]}, {"id": "rbmap.inhabited", "parentIds": []}, {"id": "mk_rbmap", "parentIds": ["rbmap.inhabited", "rbmap.from_list"]}, {"id": "tactic.replace", "parentIds": []}, {"id": "tactic.note", "parentIds": ["tactic.replace", "tactic.interactive.have_field", "tactic.classical", "tactic.lift", "tactic.interactive.specialize", "tactic.interactive.have", "tactic.interactive.h_generalize", "tactic.apply_at", "tactic.note_anon"]}, {"id": "list.transpose_aux", "parentIds": []}, {"id": "nat.pow_lt_pow_of_lt_right", "parentIds": []}, {"id": "nat.pos_pow_of_pos", "parentIds": ["nat.pow_lt_pow_of_lt_right", "nat.pow_lt_pow_of_lt_left", "nat.mod_pow_succ"]}, {"id": "nat.pow_le_pow_of_le_right", "parentIds": ["nat.pow_lt_pow_of_lt_right", "nat.pos_pow_of_pos"]}, {"id": "nat.lt_of_succ_lt", "parentIds": ["nat.pow_lt_pow_of_lt_right"]}, {"id": "nat.pow_succ", "parentIds": ["nat.pow_lt_pow_of_lt_right", "nat.pow_le_pow_of_le_right", "nat.pow_lt_pow_of_lt_left", "nat.mod_pow_succ", "nat.zero_pow", "nat.pow_one"]}, {"id": "nat.mul_lt_mul_of_pos_left", "parentIds": ["nat.pow_lt_pow_of_lt_right", "nat.mul_lt_mul_of_pos_right", "nat.decidable_linear_ordered_semiring"]}, {"id": "left_commutative", "parentIds": ["left_comm"]}, {"id": "int.zero_ne_one_class", "parentIds": []}, {"id": "int.zero_ne_one", "parentIds": ["int.zero_ne_one_class", "int.decidable_linear_ordered_comm_ring"]}, {"id": "not.elim", "parentIds": ["forall_prop_of_false", "peirce", "not_not_of_not_imp", "iff_of_false"]}, {"id": "one_div_mul_one_div'", "parentIds": ["one_div_mul_one_div"]}, {"id": "rsimp.rsimplify_goal", "parentIds": ["tactic.rsimp", "smt_tactic.interactive.rsimp"]}, {"id": "rsimp.rsimplify", "parentIds": ["rsimp.rsimplify_goal", "rsimp.rsimplify_at"]}, {"id": "rsimp.repr_map", "parentIds": ["rsimp.rsimplify_goal", "rsimp.rsimplify_at", "rsimp.to_repr_map", "rsimp.rsimplify", "tactic.rsimp", "tactic.rsimp_at", "smt_tactic.interactive.rsimp"]}, {"id": "lean.parser_state.options", "parentIds": []}, {"id": "bor_ff", "parentIds": ["ff_bor", "tt_bor"]}, {"id": "bor_self", "parentIds": ["bor_ff", "bor_tt"]}, {"id": "int.comm_semiring", "parentIds": []}, {"id": "lean.parser.emit_command_here", "parentIds": ["tactic.import_private_cmd"]}, {"id": "lean.parser.command_like", "parentIds": ["lean.parser.emit_command_here"]}, {"id": "buffer.write", "parentIds": ["buffer.write_eq_write'"]}, {"id": "tactic.symmetry_hyp", "parentIds": []}, {"id": "tactic.apply_at", "parentIds": ["tactic.symmetry_hyp"]}, {"id": "environment.symm_for", "parentIds": ["tactic.symmetry_hyp", "tactic.symmetry"]}, {"id": "dite.decidable", "parentIds": []}, {"id": "expr.get_depth", "parentIds": []}, {"id": "neg_zero", "parentIds": ["int.neg_ne_zero_of_ne", "norm_num.neg_zero_helper", "neg_of_neg_pos", "neg_nonpos_of_nonneg", "sub_zero", "norm_num.nonzero_of_neg_helper", "one_div_neg_eq_neg_one_div", "int.eq_coe_of_zero_le", "neg_pos_of_neg", "zero_gt_neg_one", "neg_eq_zero", "nonpos_of_neg_nonneg", "pos_of_neg_neg", "neg_div_neg_eq", "nonneg_of_neg_nonpos", "neg_nonneg_of_nonpos", "division_ring.one_div_neg_eq_neg_one_div", "neg_neg_of_pos"]}, {"id": "neg_inj", "parentIds": ["int.neg_ne_zero_of_ne", "int.ne_neg_of_ne", "norm_num.nonzero_of_neg_helper", "norm_num.neg_add_neg_helper"]}, {"id": "tactic.unfold_proj_config.inhabited", "parentIds": []}, {"id": "tactic.unfold_proj_config", "parentIds": ["tactic.unfold_proj_config.inhabited", "tactic.interactive.unfold_projs", "tactic.unfold_projs", "tactic.unfold_projs_target", "tactic.unfold_projs_hyp"]}, {"id": "name_set.has_to_format", "parentIds": []}, {"id": "if_congr", "parentIds": []}, {"id": "opt_minus", "parentIds": ["ext_param"]}, {"id": "old_conv.dsimp", "parentIds": ["old_conv.interactive.dsimp"]}, {"id": "simp_lemmas.mk_default", "parentIds": ["old_conv.dsimp", "conv.dsimp", "tactic.get_simp_lemmas_or_default", "old_conv.find_pattern", "old_conv.interactive.find", "conv.interactive.find", "tactic.join_user_simp_lemmas", "conv.interactive.for", "old_conv.find", "old_conv.top_down", "old_conv.bottom_up", "tactic.get_user_simp_lemmas"]}, {"id": "tactic.interactive.apply_opt_param", "parentIds": ["tactic.interactive.refine_one"]}, {"id": "tactic.apply_opt_param", "parentIds": ["tactic.interactive.apply_opt_param", "tactic.try_apply_opt_auto_param_for_apply", "tactic.try_apply_opt_auto_param"]}, {"id": "div_le_div_of_le_of_neg", "parentIds": []}, {"id": "vm_decl_kind", "parentIds": ["vm_decl_kind.inhabited", "vm_decl.kind"]}, {"id": "div_le_of_mul_le_of_neg", "parentIds": []}, {"id": "field.div_mul_eq_div_mul_one_div", "parentIds": ["div_mul_le_div_mul_of_div_le_div_pos"]}, {"id": "field.div_div_eq_div_mul", "parentIds": ["field.div_mul_eq_div_mul_one_div", "field.div_div_div_div_eq"]}, {"id": "string.empty", "parentIds": ["string.singleton", "string.str_ne_empty", "string.inhabited", "string.empty_ne_str"]}, {"id": "mul_right_inj", "parentIds": ["mul_eq_one_iff_eq_inv"]}, {"id": "list.repr_aux", "parentIds": []}, {"id": "tactic.transport_with_prefix_fun", "parentIds": ["tactic.transport_with_prefix_dict"]}, {"id": "char.decidable_lt", "parentIds": ["string.has_decidable_lt"]}, {"id": "char.has_lt", "parentIds": ["char.decidable_lt", "string.has_decidable_lt", "string.has_lt"]}, {"id": "mk_hinst_singleton", "parentIds": ["smt_tactic.add_ematch_lemma_core", "smt_tactic.add_ematch_lemma_from_decl_core"]}, {"id": "hinst_lemmas.add", "parentIds": ["mk_hinst_singleton"]}, {"id": "list.is_prefix", "parentIds": []}, {"id": "rbtree.max", "parentIds": ["rbmap.max"]}, {"id": "singleton", "parentIds": []}, {"id": "has_emptyc", "parentIds": ["singleton", "set.has_emptyc", "list.has_emptyc"]}, {"id": "state_t.run_map", "parentIds": ["state_t.is_lawful_monad"]}, {"id": "state_t.run_pure", "parentIds": ["state_t.run_map", "state_t.is_lawful_monad"]}, {"id": "tactic.interactive.apply_assumption", "parentIds": []}, {"id": "tactic.apply_assumption", "parentIds": ["tactic.interactive.apply_assumption"]}, {"id": "option.eq_of_eq_some", "parentIds": []}, {"id": "one_div_eq_inv", "parentIds": ["division_ring.one_div_div", "inv_eq_one_div"]}, {"id": "implies_of_if_pos", "parentIds": []}, {"id": "prod.lex.decidable", "parentIds": []}, {"id": "format.highlight", "parentIds": []}, {"id": "format.color", "parentIds": ["format.highlight", "format.color.inhabited"]}, {"id": "tactic.is_assigned", "parentIds": ["tactic.try_apply_opt_auto_param_for_apply", "tactic.try_apply_opt_auto_param", "tactic.interactive.concat_tags", "tactic.apply_at"]}, {"id": "imp_eq_of_eq_false_left", "parentIds": []}, {"id": "expr.reduce_lets", "parentIds": []}, {"id": "peirce'", "parentIds": []}, {"id": "smt_tactic.intron", "parentIds": []}, {"id": "le_of_forall_lt'", "parentIds": ["forall_lt_iff_le'"]}, {"id": "lt_irrefl", "parentIds": ["le_of_forall_lt'", "ne_of_gt", "lt_asymm", "gt_irrefl", "nat.pos_of_dvd_of_pos", "nat.zero_mod", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "le_of_forall_lt", "nat.mod_zero", "ne_of_lt", "eq_iff_le_not_lt", "nat.le_of_dvd", "nat.pred_inj", "pos_and_pos_or_neg_and_neg_of_mul_pos", "nat.div_zero", "nat.succ_pred_eq_of_pos"]}, {"id": "le_of_not_lt", "parentIds": ["le_of_forall_lt'", "le_of_forall_lt"]}, {"id": "monad.filter", "parentIds": []}, {"id": "tactic.unsafe.type_context.get_fun_info", "parentIds": []}, {"id": "fun_info", "parentIds": ["tactic.unsafe.type_context.get_fun_info", "fun_info.has_to_format", "tactic.fold_explicit_args", "fun_info_to_format", "fun_info.inhabited", "tactic.get_fun_info"]}, {"id": "bxor_self", "parentIds": ["bxor_tt", "bxor_ff"]}, {"id": "int.coe_nat_le_coe_nat_iff", "parentIds": ["int.coe_nat_lt_coe_nat_iff"]}, {"id": "int.coe_nat_le_coe_nat_of_le", "parentIds": ["int.coe_nat_le_coe_nat_iff", "int.coe_zero_le"]}, {"id": "and_iff_left", "parentIds": ["and_true"]}, {"id": "add_self_div_two", "parentIds": ["exists_add_lt_and_pos_of_lt"]}, {"id": "add_sub_cancel", "parentIds": ["exists_add_lt_and_pos_of_lt", "add_le_of_le_sub_left", "left_inverse_sub_add_left", "sub_self_div_two", "dvd_add_iff_left", "add_lt_of_lt_sub_left"]}, {"id": "add_sub", "parentIds": ["exists_add_lt_and_pos_of_lt"]}, {"id": "div_pos_of_pos_of_pos", "parentIds": ["exists_add_lt_and_pos_of_lt", "div_two_lt_of_pos"]}, {"id": "div_add_div_same", "parentIds": ["exists_add_lt_and_pos_of_lt", "add_halves", "div_sub_div_same", "div_add_div"]}, {"id": "sub_pos_of_lt", "parentIds": ["exists_add_lt_and_pos_of_lt", "ordered_ring.mul_lt_mul_of_pos_right", "ordered_ring.mul_lt_mul_of_pos_left"]}, {"id": "reflexive", "parentIds": ["setoid.trans", "equivalence", "mk_equivalence", "eq_equivalence", "setoid.symm", "setoid.refl"]}, {"id": "and_assoc", "parentIds": []}, {"id": "and.assoc", "parentIds": ["and_assoc", "and.left_comm"]}, {"id": "string.str", "parentIds": ["string.str_ne_empty", "string.str_ne_str_right", "string.empty_ne_str", "string.str_ne_str_left"]}, {"id": "string.push", "parentIds": ["string.str", "string.singleton", "tactic.explode.pad_right"]}, {"id": "int.lt.elim", "parentIds": ["int.lt_irrefl", "int.mul_pos", "int.le_of_lt"]}, {"id": "int.lt.dest", "parentIds": ["int.lt.elim"]}, {"id": "one_le_one_div", "parentIds": []}, {"id": "one_div_one", "parentIds": ["one_le_one_div", "one_lt_one_div"]}, {"id": "ne_true_of_not", "parentIds": []}, {"id": "cc_state.proof_for", "parentIds": ["smt_tactic.proof_for"]}, {"id": "div_div_eq_div_mul", "parentIds": ["div_mul_eq_div_mul_one_div", "div_div_div_div_eq"]}, {"id": "div_mul_div", "parentIds": ["div_div_eq_div_mul"]}, {"id": "rbtree.empty", "parentIds": ["rbmap.empty"]}, {"id": "int.add_zero", "parentIds": ["int.comm_ring", "int.zero_add"]}, {"id": "interactive.executor", "parentIds": ["interactive.executor.execute_with_explicit", "interactive.interactive.executor", "interactive.executor.execute_explicit", "smt_tactic.interactive.executor"]}, {"id": "tactic.elim_gen_sum", "parentIds": []}, {"id": "nat.zero_lt_one_add", "parentIds": ["string.iterator.zero_lt_length_next_to_string_of_has_next"]}, {"id": "neg_eq_of_add_eq_zero", "parentIds": ["neg_mul_eq_neg_mul", "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "neg_sub", "neg_add_rev", "neg_neg", "eq_neg_of_add_eq_zero", "neg_mul_eq_mul_neg", "neg_zero"]}, {"id": "list.drop_while", "parentIds": []}, {"id": "div_mul_eq_mul_div", "parentIds": ["div_helper", "field.div_div_div_div_eq", "field.div_mul_eq_mul_div_comm", "eq_of_mul_eq_mul_of_nonzero_left", "mul_eq_mul_of_div_eq_div", "div_div_div_div_eq", "norm_num.div_eq_div_helper"]}, {"id": "native.rb_lmap.of_list", "parentIds": ["localized_attr", "fold_over_with_cond_sorted"]}, {"id": "set.subset", "parentIds": ["set.has_subset"]}, {"id": "environment.is_definition", "parentIds": []}, {"id": "add_neg_eq_of_eq_add", "parentIds": ["norm_num.neg_add_neg_eq_of_add_add_eq_zero"]}, {"id": "native.rb_map.has_to_tactic_format", "parentIds": []}, {"id": "expr.local_type", "parentIds": ["tactic.constr_to_prop", "tactic.interactive.assume", "dangerous_instance"]}, {"id": "fin.le_def", "parentIds": []}, {"id": "fin.has_le", "parentIds": ["fin.le_def", "fin.decidable_le"]}, {"id": "le_add_of_nonneg_of_le", "parentIds": []}, {"id": "le_or_lt", "parentIds": []}, {"id": "le_or_gt", "parentIds": ["le_or_lt", "max_lt", "lt_min", "nat.mul_mod_mul_left"]}, {"id": "tactic.repeat1", "parentIds": ["tactic.interactive.ext"]}, {"id": "nat.add_right_comm", "parentIds": ["nat.sub_add_comm"]}, {"id": "right_comm", "parentIds": ["nat.add_right_comm", "mul_right_comm", "add_right_comm"]}, {"id": "nat.add_assoc", "parentIds": ["nat.add_right_comm", "nat.comm_semiring", "nat.add_le_add_left", "nat.le_of_add_le_add_left", "nat.add_left_comm"]}, {"id": "list.func.neg", "parentIds": []}, {"id": "tactic.interactive.split_ifs", "parentIds": []}, {"id": "tactic.split_ifs", "parentIds": ["tactic.interactive.split_ifs"]}, {"id": "nat.lt_trichotomy", "parentIds": ["nat.eq_or_lt_of_not_lt"]}, {"id": "nat.lt_by_cases", "parentIds": ["nat.lt_trichotomy"]}, {"id": "old_conv.istep", "parentIds": []}, {"id": "interaction_monad.result.clamp_pos", "parentIds": ["old_conv.istep", "tactic.istep", "smt_tactic.istep"]}, {"id": "tactic.pis", "parentIds": ["tactic.extract_def", "derive_struct_ext_lemma"]}, {"id": "not_lt_of_le", "parentIds": []}, {"id": "add_le_of_le_neg_add", "parentIds": []}, {"id": "nat.ldiff_bit", "parentIds": []}, {"id": "quotient.ind\u2082", "parentIds": []}, {"id": "quotient.ind", "parentIds": ["quotient.ind\u2082", "quotient.induction_on\u2083", "quotient.induction_on\u2082"]}, {"id": "tactic.congr", "parentIds": ["tactic.interactive.congr"]}, {"id": "bin_tree.inhabited", "parentIds": []}, {"id": "smt_tactic.trace", "parentIds": []}, {"id": "char.repr", "parentIds": []}, {"id": "char.has_repr", "parentIds": ["char.repr"]}, {"id": "to_additive.proceed_fields", "parentIds": []}, {"id": "tactic.ancestor_attr", "parentIds": ["to_additive.proceed_fields", "tactic.get_ancestors"]}, {"id": "environment.structure_fields", "parentIds": ["to_additive.proceed_fields", "tactic.subobject_names", "environment.structure_fields_full", "environment.is_structure", "derive_struct_ext_lemma"]}, {"id": "user_attribute.get_param", "parentIds": ["to_additive.proceed_fields", "tactic.get_ancestors"]}, {"id": "nat.bit1_lt", "parentIds": []}, {"id": "add_lt_add", "parentIds": ["nat.bit1_lt", "add_lt_of_neg_of_lt", "add_neg", "nat.bit0_lt", "add_pos", "lt_add_of_pos_of_lt", "lt_add_of_lt_of_pos", "sub_lt_sub", "add_lt_of_lt_of_neg"]}, {"id": "native.float.has_one", "parentIds": []}, {"id": "native.float.of_nat", "parentIds": ["native.float.has_one", "native.float.has_zero", "native.float.of_nat_coe", "native.float.has_nat_pow"]}, {"id": "imp_self", "parentIds": []}, {"id": "tactic.dunfold_head", "parentIds": []}, {"id": "list.lt", "parentIds": ["list.has_lt"]}, {"id": "inv_ne_zero", "parentIds": ["division_ring.one_div_div"]}, {"id": "one_div_ne_zero", "parentIds": ["inv_ne_zero", "eq_of_one_div_eq_one_div", "eq_zero_of_one_div_eq_zero"]}, {"id": "tactic.match_app_of", "parentIds": []}, {"id": "nat.mul", "parentIds": ["nat.has_mul", "nat.comm_semiring", "nat.dvd_add_iff_right"]}, {"id": "expr.to_int", "parentIds": []}, {"id": "expr.list_local_consts", "parentIds": []}, {"id": "environment.add_inductive", "parentIds": ["tactic.add_inductive"]}, {"id": "mul_div_mul_left'", "parentIds": ["mul_div_mul_right'"]}, {"id": "mul_div_mul_left", "parentIds": ["mul_div_mul_left'", "mul_div_mul_right", "div_add_div"]}, {"id": "list.update_nth", "parentIds": []}, {"id": "max_lt", "parentIds": []}, {"id": "tactic.interactive.clear_dependent", "parentIds": []}, {"id": "decidable.true", "parentIds": ["tactic.interactive.clear_dependent", "bool.to_bool_true", "list.decidable_chain", "list.decidable_chain'", "instance_derive_handler"]}, {"id": "native.rb_map.set_of_list", "parentIds": ["tactic.interactive.clear_dependent", "tactic.interactive.clear'", "tactic.rename'"]}, {"id": "reader_t.monad_except", "parentIds": []}, {"id": "monad_except", "parentIds": ["reader_t.monad_except", "state_t.monad_except", "monad_except.orelse", "except_t.monad_except", "monad_except.orelse'", "option_t.monad_except"]}, {"id": "reader_t.lift", "parentIds": ["reader_t.monad_except", "reader_t.has_monad_lift"]}, {"id": "norm_num.neg_add_neg_eq_of_add_add_eq_zero", "parentIds": []}, {"id": "functor.const.ext", "parentIds": []}, {"id": "functor.const.run", "parentIds": ["functor.const.ext"]}, {"id": "string.fold", "parentIds": ["string.hash"]}, {"id": "cc_state.add", "parentIds": []}, {"id": "push_neg.normalize_negations", "parentIds": ["push_neg.push_neg_at_goal", "push_neg.push_neg_at_hyp"]}, {"id": "tactic.elide.replace", "parentIds": ["tactic.interactive.elide"]}, {"id": "tactic.interactive.rotate", "parentIds": []}, {"id": "old_conv.change", "parentIds": ["old_conv.interactive.change"]}, {"id": "of_heq_true", "parentIds": []}, {"id": "of_eq_true", "parentIds": ["of_heq_true", "eq_true_of_and_eq_true_right", "prod.mk.inj_iff", "eq_true_of_and_eq_true_left", "if_eq_of_eq_true"]}, {"id": "tactic.rcases_patt.merge", "parentIds": []}, {"id": "function.left_inverse_inv_fun", "parentIds": ["function.inv_fun_surjective", "function.inv_fun_comp", "function.injective.has_left_inverse"]}, {"id": "string.map_tokens", "parentIds": ["to_additive.guess_name"]}, {"id": "is_distinct", "parentIds": []}, {"id": "int.one_pos", "parentIds": []}, {"id": "nat.find_min'", "parentIds": []}, {"id": "nat.find_min", "parentIds": ["nat.find_min'"]}, {"id": "nat.find", "parentIds": ["nat.find_min'", "nat.find_min", "nat.find_spec"]}, {"id": "nonempty.map2", "parentIds": []}, {"id": "classical.or_iff_not_imp_left", "parentIds": []}, {"id": "or_iff_not_imp_left", "parentIds": ["classical.or_iff_not_imp_left", "or_iff_not_imp_right"]}, {"id": "nat.le_mul_self", "parentIds": []}, {"id": "nat.mul_le_mul_left", "parentIds": ["nat.le_mul_self", "nat.mul_mod_mul_left", "nat.mul_lt_mul_of_pos_left", "nat.mul_le_mul_right", "nat.sub_mul_div", "nat.le_of_dvd"]}, {"id": "nat.lt_irrefl", "parentIds": ["nat.le_lt_antisymm", "nat.lt_iff_le_not_le", "nat.lt_of_add_lt_add_left", "nat.sub_lt", "nat.le_antisymm"]}, {"id": "nat.not_succ_le_self", "parentIds": ["nat.lt_irrefl"]}, {"id": "tactic.interactive.apply_iff_congr_core", "parentIds": ["tactic.interactive.congr_core'"]}, {"id": "pexpr.mk_placeholder", "parentIds": ["tactic.interactive.set", "tactic.interactive.obtain", "tactic.suggest.replace_mvars"]}, {"id": "array.read_write_of_ne", "parentIds": []}, {"id": "d_array.read_write_of_ne", "parentIds": ["array.read_write_of_ne"]}, {"id": "array.write", "parentIds": ["array.read_write_of_ne", "array.write'", "array.read_write", "buffer.write_eq_write'", "array.foreach", "array.write_eq_write'"]}, {"id": "list.sigma", "parentIds": []}, {"id": "nat.le_succ", "parentIds": ["nat.le_of_succ_le", "nat.sub_mul_div", "nat.le_succ_of_le"]}, {"id": "tactic.non_dep_prop_hyps", "parentIds": ["tactic.interactive.simp_core", "tactic.simp_all"]}, {"id": "mcond", "parentIds": ["tactic.non_dep_prop_hyps", "native.rb_set.mfilter", "name_set.mfilter", "monad.cond", "tactic.alias.alias_cmd", "tactic.interactive.concat_tags", "linter.doc_blame", "mwhen"]}, {"id": "tactic.head_zeta", "parentIds": ["tactic.non_dep_prop_hyps"]}, {"id": "vm.pp_stack_obj", "parentIds": []}, {"id": "int.rem", "parentIds": []}, {"id": "nat.lt_add_of_pos_left", "parentIds": []}, {"id": "nat.lt_add_of_pos_right", "parentIds": ["nat.lt_add_of_pos_left", "nat.mul_lt_mul_of_pos_left"]}, {"id": "int.distrib_right", "parentIds": ["int.comm_ring"]}, {"id": "int.distrib_left", "parentIds": ["int.distrib_right", "int.comm_ring"]}, {"id": "tactic.mk_iff", "parentIds": ["tactic.mk_iff_of_inductive_prop"]}, {"id": "decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring", "parentIds": ["sub_le_of_abs_sub_le_left", "sub_lt_of_abs_sub_lt_left"]}, {"id": "sum.is_lawful_monad", "parentIds": []}, {"id": "sum.is_lawful_functor", "parentIds": ["sum.is_lawful_monad"]}, {"id": "sum.monad", "parentIds": ["sum.is_lawful_monad", "sum.is_lawful_functor", "sum.traversable"]}, {"id": "use_cmd", "parentIds": []}, {"id": "tactic_format_expr", "parentIds": ["use_cmd", "expr.has_to_tactic_format"]}, {"id": "tactic.is_def_eq", "parentIds": ["use_cmd", "tactic.constr_to_prop", "tactic.comp_val", "tactic.interactive.return_cast", "tactic.interactive.guard_expr_eq'", "tactic.subst"]}, {"id": "tactic.get_options", "parentIds": ["use_cmd", "tactic.save_options", "tactic.returnex", "tactic.add_defn_equations"]}, {"id": "punit.has_sizeof", "parentIds": []}, {"id": "std.priority.default", "parentIds": ["nat.prio"]}, {"id": "tactic.iterate_range", "parentIds": ["tactic.interactive.ext"]}, {"id": "is_left_cancel", "parentIds": []}, {"id": "tactic.interactive.rename'_arg_parser", "parentIds": ["tactic.interactive.rename'_args_parser"]}, {"id": "lint_cmd", "parentIds": []}, {"id": "lint", "parentIds": ["lint_cmd", "lint_hole_cmd"]}, {"id": "list.func.sub", "parentIds": []}, {"id": "list.func.pointwise", "parentIds": ["list.func.sub", "list.func.add"]}, {"id": "nat.mul_div_right", "parentIds": ["nat.mul_div_left"]}, {"id": "nat.mul_succ", "parentIds": ["nat.mul_div_right", "nat.add_mul_div_left", "nat.sub_mul_mod", "nat.mul_assoc", "nat.zero_mul", "nat.bodd_mul", "nat.mul_lt_mul_of_pos_left", "int.mul_pos", "nat.sub_mul_div", "nat.right_distrib", "nat.succ_mul", "nat.mul_comm", "nat.add_mul_mod_self_left"]}, {"id": "nat.zero_div", "parentIds": ["nat.mul_div_right", "nat.zero_shiftr", "nat.div_self", "nat.div_div_eq_div_mul", "nat.mul_div_cancel"]}, {"id": "reader_t.run_map", "parentIds": ["reader_t.is_lawful_monad"]}, {"id": "reader_t.monad", "parentIds": ["reader_t.run_map", "reader_t.run_pure", "reader_t.is_lawful_monad", "reader_t.alternative", "reader_t.run_bind"]}, {"id": "list.of_fn", "parentIds": []}, {"id": "list.of_fn_aux", "parentIds": ["list.of_fn"]}, {"id": "string.singleton", "parentIds": ["char.to_string", "string.map_tokens", "hex_digit_repr", "char.quote_core"]}, {"id": "list.insert", "parentIds": ["list.has_insert"]}, {"id": "list.map_append", "parentIds": []}, {"id": "to_additive.value_type", "parentIds": ["to_additive.parser", "to_additive.value_type.has_reflect", "to_additive.value_type.inhabited", "to_additive.attr"]}, {"id": "expr.is_ge", "parentIds": ["tactic.comp_val"]}, {"id": "expr.is_bin_arith_app", "parentIds": ["expr.is_ge", "expr.is_gt", "expr.is_le", "expr.is_lt"]}, {"id": "where.trace_nl", "parentIds": ["where.trace_where"]}, {"id": "buffer.iterate", "parentIds": []}, {"id": "interaction_monad.fail", "parentIds": ["interaction_monad.failed", "interaction_monad.monad_fail", "tactic.fail"]}, {"id": "interaction_monad.mk_exception", "parentIds": ["interaction_monad.fail", "tactic.try_for", "tactic.success_if_fail", "tactic.returnopt", "tactic.fail_if_success", "tactic.success_if_fail_with_msg"]}, {"id": "subtype.has_to_format", "parentIds": []}, {"id": "norm_num.add_comm_middle", "parentIds": []}, {"id": "tactic.left", "parentIds": ["tactic.interactive.left"]}, {"id": "quotient.hrec_on", "parentIds": []}, {"id": "quot.hrec_on", "parentIds": ["quotient.hrec_on"]}, {"id": "setoid_has_equiv", "parentIds": ["quotient.hrec_on", "quotient.decidable_eq", "quotient.lift_on\u2082", "quotient.exact", "setoid.trans", "quotient.sound", "quotient.lift_on", "quotient.lift", "setoid.symm", "quotient.lift\u2082", "setoid.refl"]}, {"id": "has_equiv", "parentIds": ["quotient.hrec_on", "quotient.decidable_eq", "quotient.lift_on\u2082", "quotient.exact", "setoid.trans", "quotient.sound", "quotient.lift_on", "quotient.lift", "setoid.symm", "setoid_has_equiv", "quotient.lift\u2082", "setoid.refl"]}, {"id": "nat.add_comm_monoid", "parentIds": ["nat.add_monoid", "nat.add_comm_semigroup"]}, {"id": "congr_arg_heq", "parentIds": []}, {"id": "heq.rfl", "parentIds": ["congr_arg_heq"]}, {"id": "le_neg_of_le_neg", "parentIds": []}, {"id": "option.some_inj", "parentIds": []}, {"id": "smt_tactic.write", "parentIds": []}, {"id": "ge_trans", "parentIds": ["sub_le_of_abs_sub_le_left"]}, {"id": "tactic.interactive.triv", "parentIds": ["tactic.interactive.use"]}, {"id": "tactic.triv'", "parentIds": ["tactic.interactive.triv"]}, {"id": "d_array.map\u2082", "parentIds": []}, {"id": "d_array.foreach", "parentIds": ["d_array.map\u2082", "d_array.map"]}, {"id": "le_of_neg_le_neg", "parentIds": ["mul_le_mul_of_nonpos_left", "nonpos_of_neg_nonneg", "nonneg_of_neg_nonpos", "mul_le_mul_of_nonpos_right"]}, {"id": "fin.has_lt", "parentIds": ["fin.decidable_lt", "fin.lt_def"]}, {"id": "buffer.foreach", "parentIds": []}, {"id": "non_contradictory_intro", "parentIds": ["not_non_contradictory_iff_absurd"]}, {"id": "nat.shiftr_eq_div_pow", "parentIds": ["nat.zero_shiftr"]}, {"id": "nat.div_one", "parentIds": ["nat.shiftr_eq_div_pow"]}, {"id": "nat.div2_val", "parentIds": ["nat.shiftr_eq_div_pow", "nat.div2_bit"]}, {"id": "sub_le_of_abs_sub_le_left", "parentIds": ["sub_le_of_abs_sub_le_right"]}, {"id": "le_of_sub_nonneg", "parentIds": ["sub_le_of_abs_sub_le_left", "sub_lt_of_abs_sub_lt_left", "ordered_ring.mul_le_mul_of_nonneg_right", "ordered_ring.mul_le_mul_of_nonneg_left"]}, {"id": "neg_sub", "parentIds": ["sub_le_of_abs_sub_le_left", "sub_sub_sub_cancel_left", "sub_lt_of_abs_sub_lt_left", "dist_bdd_within_interval", "sub_sub_sub_cancel_right", "abs_sub"]}, {"id": "sub_le_self", "parentIds": ["sub_le_of_abs_sub_le_left"]}, {"id": "abs_nonneg", "parentIds": ["sub_le_of_abs_sub_le_left", "sub_lt_of_abs_sub_lt_left", "le_abs_self", "abs_abs", "abs_abs_sub_abs_le_abs_sub"]}, {"id": "abs_of_neg", "parentIds": ["sub_le_of_abs_sub_le_left", "sub_lt_of_abs_sub_lt_left", "dist_bdd_within_interval"]}, {"id": "is_dec_refl", "parentIds": ["decidable_eq_of_bool_pred"]}, {"id": "name_map.inhabited", "parentIds": []}, {"id": "mk_name_map", "parentIds": ["name_map.inhabited", "tactic.mk_instance_cache"]}, {"id": "expr.is_default_local", "parentIds": ["tactic.mk_patterns"]}, {"id": "div_le_div_of_mul_sub_mul_div_nonpos", "parentIds": []}, {"id": "one_div_mul_one_div", "parentIds": []}, {"id": "nat.mod_one", "parentIds": ["nat.gcd_one_left", "nat.div_one"]}, {"id": "nat.eq_zero_of_le_zero", "parentIds": ["nat.mod_one", "nat.pow_le_pow_of_le_right"]}, {"id": "native.float.specification.emin", "parentIds": []}, {"id": "tactic.assoc_refl", "parentIds": []}, {"id": "tactic.match_eq", "parentIds": ["tactic.assoc_refl", "tactic.assoc_rewrite_intl", "tactic.mk_eq_simp_ext", "tactic.ac_refl", "tactic.apply_eq_congr_core", "tactic.assoc_rewrite", "tactic.injection_with", "tactic.mk_eq_proof"]}, {"id": "tactic.assoc_refl'", "parentIds": ["tactic.assoc_refl", "tactic.assoc_rewrite_intl", "tactic.flatten"]}, {"id": "prod.map_snd'", "parentIds": []}, {"id": "prod.map_snd", "parentIds": ["prod.map_snd'", "prod.map_def"]}, {"id": "prod.map", "parentIds": ["prod.map_snd'", "prod.map_fst'", "prod.map_fst", "prod.map_snd", "prod.map_def", "tactic.interactive.collect_struct"]}, {"id": "array.has_to_tactic_format", "parentIds": []}, {"id": "list.has_to_tactic_format", "parentIds": ["array.has_to_tactic_format", "buffer.has_to_tactic_format", "tactic.has_to_tactic_format"]}, {"id": "vm.call_stack_fn", "parentIds": []}, {"id": "nat.strong_induction_on", "parentIds": ["nat.mul_mod_mul_left", "nat.case_strong_induction_on", "nat.mod_add_div", "nat.mod_pow_succ", "nat.le_div_iff_mul_le"]}, {"id": "nat.strong_rec_on", "parentIds": ["nat.strong_induction_on"]}, {"id": "tactic.interactive.have_field", "parentIds": []}, {"id": "tactic.interactive.get_current_field", "parentIds": ["tactic.interactive.have_field", "tactic.interactive.apply_field"]}, {"id": "and.swap", "parentIds": ["and.comm", "and.symm"]}, {"id": "nat.to_digits", "parentIds": ["nat.repr"]}, {"id": "options.set_bool", "parentIds": ["tactic.set_bool_option"]}, {"id": "list.zip_with", "parentIds": ["list.zip"]}, {"id": "max_assoc", "parentIds": ["max_left_comm"]}, {"id": "vm_decl_kind.inhabited", "parentIds": []}, {"id": "environment.is_namespace", "parentIds": []}, {"id": "tactic.mllist.empty", "parentIds": []}, {"id": "tactic.mllist.uncons", "parentIds": ["tactic.mllist.empty", "tactic.mllist.head"]}, {"id": "vm_obj_kind.decidable_eq", "parentIds": []}, {"id": "vm_obj_kind", "parentIds": ["vm_obj_kind.decidable_eq", "vm_obj.kind", "vm_obj_kind.inhabited"]}, {"id": "imp_congr_right", "parentIds": []}, {"id": "and.symm", "parentIds": []}, {"id": "native.float.specification.emax", "parentIds": []}, {"id": "tactic.independent_goal", "parentIds": ["tactic.suggest.apply_and_solve"]}, {"id": "tactic.no_mvars_in_target", "parentIds": ["tactic.independent_goal"]}, {"id": "tactic.terminal_goal", "parentIds": ["tactic.independent_goal"]}, {"id": "tactic.mllist.head", "parentIds": ["tactic.mllist.mfirst"]}, {"id": "tactic.revert_and_transform", "parentIds": ["tactic.dsimp_hyp", "tactic.dunfold_hyp", "tactic.delta_hyp", "tactic.unfold_projs_hyp"]}, {"id": "tactic.get_simp_lemmas_or_default", "parentIds": ["tactic.dsimp_hyp", "tactic.dsimp_target"]}, {"id": "or_of_or_of_imp_of_imp", "parentIds": []}, {"id": "add_lt_of_nonpos_of_lt", "parentIds": []}, {"id": "user_attribute.parse_reflect", "parentIds": []}, {"id": "list.range_core", "parentIds": ["list.range"]}, {"id": "native.float.log2", "parentIds": []}, {"id": "native.float.atan2", "parentIds": []}, {"id": "classical.some_spec2", "parentIds": []}, {"id": "functor.comp.comp_map", "parentIds": ["functor.comp.is_lawful_functor"]}, {"id": "set.sUnion", "parentIds": []}, {"id": "option.filter", "parentIds": []}, {"id": "classical.cases_true_false", "parentIds": []}, {"id": "classical.prop_complete", "parentIds": ["classical.cases_true_false", "classical.eq_false_or_eq_true", "classical.eq_true_or_eq_false"]}, {"id": "tc.accessible", "parentIds": ["tc.wf"]}, {"id": "tc", "parentIds": ["tc.accessible", "tc.wf"]}, {"id": "acc.inv", "parentIds": ["tc.accessible", "nat.lt_wf", "well_founded.fix_F_eq"]}, {"id": "ematch_lhs", "parentIds": []}, {"id": "to_hinst_lemmas_core", "parentIds": ["ematch_lhs", "ematch", "mk_hinst_lemma_attr_set", "mk_hinst_lemma_attr_core"]}, {"id": "smt_tactic.swap", "parentIds": ["smt_tactic.define", "smt_tactic.assert"]}, {"id": "true_ne_false", "parentIds": []}, {"id": "smt_tactic.interactive.have", "parentIds": []}, {"id": "tactic.mk_meta_univ", "parentIds": ["smt_tactic.interactive.have", "tactic.interactive.let", "smt_tactic.interactive.let", "tactic.decl_mk_const", "tactic.mk_mvar", "tactic.interactive.return_cast", "tactic.interactive.change", "tactic.interactive.have", "saturate_fun", "tactic.mk_instance_cache", "tactic.mk_sorry"]}, {"id": "smt_tactic.note", "parentIds": ["smt_tactic.interactive.have", "smt_tactic.interactive.add_fact"]}, {"id": "smt_tactic.assert", "parentIds": ["smt_tactic.interactive.have"]}, {"id": "smt_tactic.assertv", "parentIds": ["smt_tactic.interactive.have", "smt_tactic.note"]}, {"id": "tactic.interactive.subst_vars", "parentIds": ["tactic.mk_inj_eq"]}, {"id": "tactic.subst_vars", "parentIds": ["tactic.interactive.subst_vars", "derive_struct_ext_lemma"]}, {"id": "interactive.types.list_of", "parentIds": ["interactive.types.pexpr_list", "conv.interactive.for", "tactic.simp_arg_list"]}, {"id": "subsingleton_info.has_to_format", "parentIds": []}, {"id": "subsingleton_info_to_format", "parentIds": ["subsingleton_info.has_to_format"]}, {"id": "tactic.mk_pattern", "parentIds": ["tactic.pexpr_to_pattern"]}, {"id": "set.has_sep", "parentIds": ["set.diff"]}, {"id": "has_sep", "parentIds": ["set.has_sep", "set.diff"]}, {"id": "set.sep", "parentIds": ["set.has_sep"]}, {"id": "nat.binary_rec_eq", "parentIds": ["nat.bitwise_zero_right", "nat.bitwise_bit", "nat.bitwise_bit_aux"]}, {"id": "nat.bodd_bit", "parentIds": ["nat.binary_rec_eq", "nat.test_bit_zero"]}, {"id": "nat.div2_zero", "parentIds": ["nat.binary_rec_eq"]}, {"id": "nat.binary_rec", "parentIds": ["nat.binary_rec_eq", "nat.binary_rec_zero", "nat.bitwise_zero_left", "nat.bitwise", "nat.mk_numeral", "nat.bitwise_swap", "nat.bitwise_zero_right", "nat.size", "nat.bitwise_bit", "nat.bitwise_bit_aux", "nat.bits", "expr.of_nat"]}, {"id": "nat.binary_rec_zero", "parentIds": ["nat.binary_rec_eq", "nat.bitwise_zero_left", "nat.bitwise_zero_right", "nat.bitwise_bit"]}, {"id": "nat.div2_bit", "parentIds": ["nat.binary_rec_eq", "nat.shiftl'_sub", "nat.test_bit_succ"]}, {"id": "tactic.match_subexpr", "parentIds": ["tactic.match_target_subexpr"]}, {"id": "function.equiv.refl", "parentIds": ["function.equiv.is_equivalence"]}, {"id": "function.equiv", "parentIds": ["function.equiv.refl", "function.equiv.trans", "function.equiv.is_equivalence", "function.equiv.symm"]}, {"id": "one_div_lt_neg_one", "parentIds": []}, {"id": "one_div_neg_one_eq_neg_one", "parentIds": ["one_div_lt_neg_one", "division_ring.one_div_neg_eq_neg_one_div", "one_div_le_neg_one"]}, {"id": "one_div_lt_one_div_of_lt_of_neg", "parentIds": ["one_div_lt_neg_one", "le_of_one_div_le_one_div_of_neg", "one_div_le_one_div_of_le_of_neg"]}, {"id": "string.iterator.nextn", "parentIds": ["string.popn"]}, {"id": "id.bind_eq", "parentIds": []}, {"id": "native.has_to_string", "parentIds": []}, {"id": "native.float.has_add", "parentIds": []}, {"id": "native.float.add", "parentIds": ["native.float.has_add"]}, {"id": "quotient.induction_on\u2083", "parentIds": []}, {"id": "coe_ff", "parentIds": []}, {"id": "coe_bool_to_Prop", "parentIds": ["coe_ff", "coe_decidable_eq", "coe_tt"]}, {"id": "tactic.mk_dec_eq_instance", "parentIds": ["tactic.decidable_eq_derive_handler"]}, {"id": "tactic.mk_dec_eq_instance_core", "parentIds": ["tactic.mk_dec_eq_instance"]}, {"id": "environment.is_ginductive", "parentIds": ["tactic.mk_dec_eq_instance", "environment.is_ginductive'", "environment.get_modifiers"]}, {"id": "nat.pred_lt_pred", "parentIds": []}, {"id": "nat.lt_of_succ_lt_succ", "parentIds": ["nat.pred_lt_pred", "list.length_remove_nth"]}, {"id": "int.of_nat_inj", "parentIds": ["int.coe_nat_inj", "int.of_nat_eq_of_nat_iff", "int.zero_ne_one"]}, {"id": "not_and'", "parentIds": []}, {"id": "not_and", "parentIds": ["not_and'"]}, {"id": "vm.bp", "parentIds": []}, {"id": "nat.lt_ge_by_cases", "parentIds": ["nat.lt_by_cases"]}, {"id": "tactic.rcases_patt.name", "parentIds": ["tactic.rintro"]}, {"id": "fin.mod_def", "parentIds": []}, {"id": "fin.has_mod", "parentIds": ["fin.mod_def"]}, {"id": "parser.failure", "parentIds": ["parser.alternative", "parser.inhabited"]}, {"id": "parser.bind", "parentIds": ["parser.alternative", "parser.is_lawful_monad", "parser.monad"]}, {"id": "parser.orelse", "parentIds": ["parser.alternative"]}, {"id": "vm.get_attribute", "parentIds": []}, {"id": "array.has_repr", "parentIds": []}, {"id": "list.has_repr", "parentIds": ["array.has_repr", "rbtree.has_repr", "rbmap.has_repr", "buffer.has_repr"]}, {"id": "print_localized_commands", "parentIds": []}, {"id": "list.band", "parentIds": []}, {"id": "div_two_sub_self", "parentIds": []}, {"id": "zero_sub", "parentIds": ["div_two_sub_self"]}, {"id": "add_halves", "parentIds": ["div_two_sub_self", "sub_self_div_two", "div_two_lt_of_pos"]}, {"id": "sub_add_eq_sub_sub", "parentIds": ["div_two_sub_self"]}, {"id": "tactic.suggest_scripts", "parentIds": ["tactic.interactive.suggest"]}, {"id": "tactic.suggest.application", "parentIds": ["tactic.suggest_scripts", "tactic.library_search", "tactic.suggest_core", "tactic.suggest"]}, {"id": "tactic.suggest", "parentIds": ["tactic.suggest_scripts"]}, {"id": "is_associative", "parentIds": ["add_semigroup_to_is_eq_associative", "semigroup_to_is_associative", "option.lift_or_get_assoc"]}, {"id": "tactic.generalize_proofs", "parentIds": ["tactic.interactive.generalize_proofs"]}, {"id": "tactic.is_proof", "parentIds": ["tactic.generalize_proofs", "tactic.propositional_goal", "expr.is_eta_expansion_aux", "print_item_crawl"]}, {"id": "tactic.intros_dep", "parentIds": ["tactic.generalize_proofs"]}, {"id": "tactic.refine", "parentIds": ["tactic.interactive.refine", "derive_struct_ext_lemma"]}, {"id": "one_lt_div_of_lt", "parentIds": []}, {"id": "lt_add_of_pos_of_le", "parentIds": []}, {"id": "tactic_state.format_expr", "parentIds": ["tactic_format_expr", "old_conv.save_info"]}, {"id": "exists_unique_of_exists_of_unique", "parentIds": []}, {"id": "exists_unique.intro", "parentIds": ["exists_unique_of_exists_of_unique"]}, {"id": "exists_unique", "parentIds": ["exists_unique_of_exists_of_unique", "exists_unique.intro", "exists_of_exists_unique", "exists_unique.elim", "unique_of_exists_unique", "exists_unique_congr"]}, {"id": "reader_t.run_pure", "parentIds": ["reader_t.is_lawful_monad"]}, {"id": "dlist.of_list_to_list", "parentIds": []}, {"id": "dlist.of_list", "parentIds": ["dlist.of_list_to_list", "dlist.to_list_of_list"]}, {"id": "smt_tactic.when_tracing", "parentIds": []}, {"id": "smt_tactic.when", "parentIds": ["smt_tactic.when_tracing"]}, {"id": "rbtree.has_repr", "parentIds": []}, {"id": "nolint_attr", "parentIds": ["apply_nolint_tac"]}, {"id": "le_not_le_of_lt", "parentIds": ["not_le_of_gt", "lt_trans", "not_le_of_lt", "le_of_lt", "lt_irrefl", "lt_of_lt_of_le", "lt_of_le_of_lt"]}, {"id": "function.injective.eq_iff", "parentIds": []}, {"id": "le_min", "parentIds": ["eq_min", "min_comm", "min_assoc", "max_neg_neg"]}, {"id": "register_attribute", "parentIds": ["mk_name_set_attr"]}, {"id": "heq_of_eq_mp", "parentIds": []}, {"id": "function.injective_of_partial_inv_right", "parentIds": []}, {"id": "function.is_partial_inv", "parentIds": ["function.injective_of_partial_inv_right", "function.injective_of_partial_inv", "function.is_partial_inv_left", "function.partial_inv_of_injective"]}, {"id": "option.has_mem", "parentIds": ["function.injective_of_partial_inv_right", "option.decidable_exists_mem", "option.mem_to_list", "option.mem_def", "option.decidable_forall_mem"]}, {"id": "nat.lor_bit", "parentIds": []}, {"id": "option.lift_or_get_is_left_id", "parentIds": []}, {"id": "add_neg_eq_iff_eq_add", "parentIds": ["sub_eq_iff_eq_add"]}, {"id": "apply_nolint_cmd", "parentIds": []}, {"id": "lift_base", "parentIds": ["apply_nolint_cmd", "lift_fn", "lift_fn_dom"]}, {"id": "lift_fn_range", "parentIds": ["apply_nolint_cmd"]}, {"id": "apply_nolint_tac", "parentIds": ["apply_nolint_cmd"]}, {"id": "nonempty.elim", "parentIds": []}, {"id": "interactive.loc.try_apply", "parentIds": ["tactic.interactive.unfold_projs", "tactic.interactive.change"]}, {"id": "tactic.try_lst", "parentIds": ["interactive.loc.try_apply"]}, {"id": "user_attribute.dflt_parser", "parentIds": []}, {"id": "tactic.interactive.right", "parentIds": []}, {"id": "tactic.right", "parentIds": ["tactic.interactive.right"]}, {"id": "sub_ne_zero_of_ne", "parentIds": []}, {"id": "to_additive.parser", "parentIds": []}, {"id": "not_and_self", "parentIds": []}, {"id": "and.elim", "parentIds": ["not_and_self"]}, {"id": "ball.imp_right", "parentIds": []}, {"id": "char.is_whitespace", "parentIds": ["char.decidable_is_whitespace"]}, {"id": "int.lt_succ", "parentIds": []}, {"id": "int.le_refl", "parentIds": ["int.lt_succ", "int.decidable_linear_ordered_comm_ring"]}, {"id": "list.alternative", "parentIds": []}, {"id": "list.monad", "parentIds": ["list.alternative", "list.traversable", "tactic.decl_mk_const", "parser.one_of", "tactic.alias.alias_direct", "list.is_lawful_monad", "tactic.alias.alias_iff", "tactic.interactive.h_generalize", "tactic.interactive.choose"]}, {"id": "int.of_nat_zero", "parentIds": []}, {"id": "parser.sep_by1", "parentIds": ["parser.sep_by", "tactic.alias.make_left_right"]}, {"id": "classical.decidable_inhabited", "parentIds": []}, {"id": "old_conv.apply_propext_lemmas", "parentIds": ["old_conv.apply_propext_simp_set"]}, {"id": "old_conv.apply_propext_lemmas_core", "parentIds": ["old_conv.apply_propext_lemmas"]}, {"id": "not_or_of_imp", "parentIds": ["imp_iff_not_or"]}, {"id": "tactic.alias.alias_attr", "parentIds": ["tactic.alias.alias_direct", "tactic.alias.alias_iff"]}, {"id": "ball_congr", "parentIds": []}, {"id": "forall_congr", "parentIds": ["ball_congr", "forall_congr_eq", "ball_and_distrib", "exists_unique_congr"]}, {"id": "function.surjective.has_right_inverse", "parentIds": ["function.surjective_iff_has_right_inverse"]}, {"id": "function.has_right_inverse", "parentIds": ["function.surjective.has_right_inverse", "function.surjective_of_has_right_inverse", "function.surjective_iff_has_right_inverse"]}, {"id": "tactic.instance_cache.mk_app", "parentIds": []}, {"id": "expr.binding_body", "parentIds": ["tactic.instance_cache.mk_app", "tactic.interactive.generalize"]}, {"id": "tactic.assoc_rewrite_intl", "parentIds": ["tactic.assoc_rewrite"]}, {"id": "expr.app_fn", "parentIds": ["tactic.assoc_rewrite_intl", "environment.is_refl_app", "expr.is_bin_arith_app", "tactic.assoc_rewrite", "interactive.single_inductive_decl.name", "has_inhabited_instance"]}, {"id": "tactic.match_assoc_pattern", "parentIds": ["tactic.assoc_rewrite_intl"]}, {"id": "tactic.chain_eq_trans", "parentIds": ["tactic.assoc_rewrite_intl"]}, {"id": "tactic.flatten", "parentIds": ["tactic.assoc_rewrite_intl"]}, {"id": "tactic.mk_eq_proof", "parentIds": ["tactic.assoc_rewrite_intl"]}, {"id": "binder_info.inhabited", "parentIds": ["binder.inhabited"]}, {"id": "name_set.union", "parentIds": []}, {"id": "local_context.mk_local", "parentIds": []}, {"id": "int.nat_abs_add_neg", "parentIds": ["int.nat_abs_bit0"]}, {"id": "int.nat_abs_of_neg_succ_of_nat", "parentIds": ["int.nat_abs_add_neg"]}, {"id": "nat.succ_add", "parentIds": ["int.nat_abs_add_neg", "nat.add_self_ne_one", "nat.succ_add_eq_succ_add", "nat.bit0_inj", "nat.add_comm", "int.distrib_left", "nat.add_left_cancel", "int.mul_pos", "nat.bit0_succ_eq", "nat.bit0_ne_one", "nat.bit1_lt_bit0", "nat.eq_zero_of_add_eq_zero_right"]}, {"id": "tactic.result", "parentIds": ["tactic.interactive.case", "tactic.metavariables"]}, {"id": "prod.map_fst'", "parentIds": []}, {"id": "prod.map_fst", "parentIds": ["prod.map_fst'", "prod.map_def"]}, {"id": "tactic.write", "parentIds": ["tactic.library_search", "tactic.suggest.message", "tactic.set_nat_option", "tactic.set_string_option", "tactic.set_bool_option", "tactic.set_options"]}, {"id": "tactic.mllist.mfirst", "parentIds": ["tactic.library_search"]}, {"id": "tactic.suggest_core", "parentIds": ["tactic.library_search", "tactic.suggest"]}, {"id": "function.inv_fun_eq_of_injective_of_right_inverse", "parentIds": []}, {"id": "rbtree.depth", "parentIds": []}, {"id": "rbnode.depth", "parentIds": ["rbtree.depth"]}, {"id": "quot.ind", "parentIds": ["quot.ind_beta", "quotient.ind", "quot.lift_indep_pr1", "quot.induction_on"]}, {"id": "functor.const.is_lawful_functor", "parentIds": ["functor.add_const.is_lawful_functor"]}, {"id": "functor.const.functor", "parentIds": ["functor.const.is_lawful_functor", "functor.add_const.functor"]}, {"id": "add_group.add_left_cancel", "parentIds": ["add_group.to_left_cancel_add_semigroup"]}, {"id": "tactic.econstructor", "parentIds": ["tactic.interactive.econstructor"]}, {"id": "tactic.unsafe.type_context.whnf", "parentIds": []}, {"id": "not_and_self_iff", "parentIds": []}, {"id": "tactic.interactive.clear_aux_decl", "parentIds": []}, {"id": "tactic.clear_aux_decl", "parentIds": ["tactic.interactive.clear_aux_decl"]}, {"id": "string.iterator.has_next", "parentIds": ["string.iterator.zero_lt_length_next_to_string_of_has_next"]}, {"id": "tactic.unsafe.type_context.list_mvars", "parentIds": ["tactic.unsafe.type_context.print_mvars"]}, {"id": "tactic.unsafe.type_context.monad", "parentIds": ["tactic.unsafe.type_context.list_mvars", "tactic.unsafe.type_context.print_mvars", "tactic.unsafe.type_context.orelse", "tactic.unsafe.type_context.trace", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "tactic.unsafe.type_context.fold_mvars", "parentIds": ["tactic.unsafe.type_context.list_mvars"]}, {"id": "monad_lift_refl", "parentIds": []}, {"id": "can_lift_attr", "parentIds": ["tactic.lift"]}, {"id": "tactic.mk_local_pis", "parentIds": ["can_lift_attr", "tactic.constr_to_prop", "tactic.mk_iff_of_inductive_prop", "tactic.mk_patterns", "tactic.eqn_stub", "tactic.mk_local_pis_whnf", "tactic.list_constructors_hole", "instance_derive_handler", "dangerous_instance", "derive_struct_ext_lemma", "has_inhabited_instance"]}, {"id": "tactic.add_inductive", "parentIds": []}, {"id": "tactic.match_hypothesis", "parentIds": []}, {"id": "list.range'", "parentIds": []}, {"id": "tactic.explode.head'", "parentIds": ["tactic.explode.entries.head"]}, {"id": "int.sub_nat_nat_elim", "parentIds": ["int.sub_nat_nat_eq_coe", "int.to_nat_sub"]}, {"id": "nat.lt_of_sub_eq_succ", "parentIds": ["int.sub_nat_nat_elim"]}, {"id": "int.sub_nat_nat", "parentIds": ["int.sub_nat_nat_elim", "int.add_left_neg", "int.sub_nat_nat_eq_coe", "int.of_nat_sub", "int.distrib_left", "int.to_nat_sub"]}, {"id": "nat.le_of_sub_eq_zero", "parentIds": ["int.sub_nat_nat_elim", "nat.sub_eq_zero_iff_le"]}, {"id": "monad.whenb", "parentIds": ["tactic.terminal_goal"]}, {"id": "tactic.propositional_goal", "parentIds": ["tactic.terminal_goal", "tactic.lift"]}, {"id": "list.erase", "parentIds": ["tactic.terminal_goal", "where.get_opens"]}, {"id": "tactic.subsingleton_goal", "parentIds": ["tactic.terminal_goal"]}, {"id": "list.sublists_aux\u2081", "parentIds": []}, {"id": "option_t.bind", "parentIds": ["option_t.is_lawful_monad", "option_t.monad"]}, {"id": "option_t.bind_cont", "parentIds": ["option_t.bind", "option_t.run_map", "option_t.run_bind", "option_t.is_lawful_monad"]}, {"id": "lt_of_add_lt_add_right", "parentIds": ["nat.sub_pos_of_lt"]}, {"id": "lt_of_add_lt_add_left", "parentIds": ["lt_of_add_lt_add_right"]}, {"id": "tactic.to_texpr", "parentIds": ["tactic.interactive.lift"]}, {"id": "iff_true_right", "parentIds": []}, {"id": "iff_true_left", "parentIds": ["iff_true_right"]}, {"id": "iff.comm", "parentIds": ["iff_true_right", "iff_false_right", "true_iff", "false_iff"]}, {"id": "mul_inv", "parentIds": []}, {"id": "comm_group.to_comm_monoid", "parentIds": ["mul_inv"]}, {"id": "tactic.mk_local'", "parentIds": ["tactic.mk_local_pis_whnf", "tactic.mk_local_def"]}, {"id": "tactic.interactive.clear'", "parentIds": []}, {"id": "not_non_contradictory_iff_absurd", "parentIds": ["not_not_not_iff"]}, {"id": "options.get_string", "parentIds": ["tactic.get_string_option"]}, {"id": "rbnode.max", "parentIds": []}, {"id": "iff_false_right", "parentIds": []}, {"id": "iff_false_left", "parentIds": ["iff_false_right"]}, {"id": "state_t.run_monad_map", "parentIds": []}, {"id": "state_t.monad_functor", "parentIds": ["state_t.run_monad_map"]}, {"id": "int.mk_numeral", "parentIds": []}, {"id": "nat.mk_numeral", "parentIds": ["int.mk_numeral"]}, {"id": "sum.inhabited_left", "parentIds": []}, {"id": "old_conv.apply_lemmas_core", "parentIds": ["old_conv.apply_lemmas"]}, {"id": "native.rb_set.mfilter", "parentIds": []}, {"id": "native.rb_set.fold", "parentIds": ["native.rb_set.mfilter", "native.rb_set.mfold", "native.rb_set.has_to_format", "native.rb_set.union", "native.rb_set.filter", "native.rb_set.to_list"]}, {"id": "function.curry_uncurry'", "parentIds": []}, {"id": "function.uncurry'", "parentIds": ["function.curry_uncurry'", "function.uncurry'_curry", "function.uncurry'_bicompr"]}, {"id": "option_t.run_map", "parentIds": ["option_t.is_lawful_monad"]}, {"id": "nat.mod_two_of_bodd", "parentIds": ["nat.div2_val"]}, {"id": "nat.mod_add_div", "parentIds": ["nat.mod_two_of_bodd", "nat.div_le_of_le_mul", "nat.mul_div_cancel'", "nat.dvd_mod_iff", "nat.div2_val", "nat.dvd_of_mod_eq_zero", "nat.mod_pow_succ", "nat.div_one"]}, {"id": "nat.mod_two_eq_zero_or_one", "parentIds": ["nat.mod_two_of_bodd", "nat.cond_to_bool_mod_two"]}, {"id": "nat.bodd_mul", "parentIds": ["nat.mod_two_of_bodd", "nat.bodd_bit"]}, {"id": "list.func.set", "parentIds": []}, {"id": "eq_of_incomp", "parentIds": ["incomp_iff_eq", "eq_of_eqv_lt"]}, {"id": "trichotomous_of", "parentIds": ["eq_of_incomp"]}, {"id": "name.sanitize_name", "parentIds": ["tactic.mk_user_fresh_name"]}, {"id": "name.pop_prefix", "parentIds": ["tactic.mk_user_fresh_name", "list_linters"]}, {"id": "parser.inhabited", "parentIds": []}, {"id": "native.float.sqrt", "parentIds": []}, {"id": "tactic.back_lemmas_add_extra", "parentIds": ["tactic.back_chaining_core"]}, {"id": "list.scanr_aux", "parentIds": ["list.scanr"]}, {"id": "environment.from_imported_module_name", "parentIds": []}, {"id": "environment.from_imported_module", "parentIds": ["environment.from_imported_module_name"]}, {"id": "simps_add_projection", "parentIds": []}, {"id": "task.monad", "parentIds": ["simps_add_projection", "to_additive.map_namespace"]}, {"id": "expr.pis", "parentIds": ["simps_add_projection", "tactic.choose1", "tactic.mk_iff_of_inductive_prop", "tactic.dependent_pose_core"]}, {"id": "list.find", "parentIds": ["where.is_variable_name", "dup_namespace"]}, {"id": "expr.binding_name", "parentIds": []}, {"id": "add_lt_of_neg_of_lt", "parentIds": []}, {"id": "where.collect_implicit_names", "parentIds": ["where.format_variable"]}, {"id": "expr.expr.lt_prop", "parentIds": ["expr.decidable_rel", "expr.has_lt"]}, {"id": "list.chain'", "parentIds": ["list.decidable_chain'", "dup_namespace"]}, {"id": "tactic.interactive.lift", "parentIds": []}, {"id": "tactic.using_texpr", "parentIds": ["tactic.interactive.lift"]}, {"id": "tactic.lift", "parentIds": ["tactic.interactive.lift"]}, {"id": "decidable.not_lt", "parentIds": ["decidable.le_iff_le_iff_lt_iff_lt"]}, {"id": "decidable.le_of_not_lt", "parentIds": ["decidable.not_lt", "decidable.le_imp_le_of_lt_imp_lt"]}, {"id": "eq.substr", "parentIds": ["nat.lt_wf"]}, {"id": "tactic.trace_macro", "parentIds": []}, {"id": "tactic.pformat_macro", "parentIds": ["tactic.trace_macro", "tactic.fail_macro"]}, {"id": "eq_add_neg_of_add_eq", "parentIds": ["norm_num.neg_add_pos_helper1"]}, {"id": "one_dvd", "parentIds": []}, {"id": "true_iff", "parentIds": ["iff_eq_of_eq_true_left"]}, {"id": "iff_true", "parentIds": ["true_iff", "eq_true", "iff_eq_of_eq_true_right"]}, {"id": "nat.le_trans", "parentIds": ["nat.sub_mul_mod", "nat.linear_order", "nat.le_of_succ_le", "nat.sub_add_comm", "nat.le_succ_of_le", "nat.decidable_linear_ordered_semiring", "nat.lt_of_le_of_lt", "nat.sub_le", "nat.lt_of_lt_of_le", "nat.lt_trans"]}, {"id": "quotient.decidable_eq", "parentIds": []}, {"id": "div_neg_of_pos_of_neg", "parentIds": []}, {"id": "native.float.is_infinite", "parentIds": []}, {"id": "name.get_nth_prefix", "parentIds": ["where.get_namespace_core"]}, {"id": "tactic.mk_mvar_list", "parentIds": ["tactic.interactive.refine_one"]}, {"id": "rbmap.rev_fold", "parentIds": []}, {"id": "rbtree.rev_fold", "parentIds": ["rbmap.rev_fold"]}, {"id": "int.nat_abs_pos_of_ne_zero", "parentIds": []}, {"id": "int.eq_zero_of_nat_abs_eq_zero", "parentIds": ["int.nat_abs_pos_of_ne_zero"]}, {"id": "expr.instantiate_locals", "parentIds": ["tactic.dependent_pose_core"]}, {"id": "expr.instantiate_vars", "parentIds": ["expr.instantiate_locals"]}, {"id": "expr.abstract_locals", "parentIds": ["expr.instantiate_locals"]}, {"id": "lift_fn", "parentIds": []}, {"id": "has_lift", "parentIds": ["lift_fn", "lift_pair\u2081", "lift_pair", "lift_trans", "lift_fn_dom", "lift_base", "lift_pair\u2082", "lift_fn_range", "lift", "lift_list"]}, {"id": "vm.eof", "parentIds": []}, {"id": "eq_of_mul_eq_mul_of_nonzero_right", "parentIds": ["norm_num.div_add_helper", "norm_num.div_helper"]}, {"id": "mul_div_cancel", "parentIds": ["eq_of_mul_eq_mul_of_nonzero_right", "mul_div_cancel_left", "add_halves", "eq_div_iff_mul_eq"]}, {"id": "div_self", "parentIds": ["eq_of_mul_eq_mul_of_nonzero_right", "one_div_one", "eq_of_mul_eq_mul_of_nonzero_left", "mul_eq_mul_of_div_eq_div", "mul_div_mul_left", "eq_one_div_of_mul_eq_one_left"]}, {"id": "false_ne_true", "parentIds": []}, {"id": "tactic.mllist.force", "parentIds": ["tactic.suggest"]}, {"id": "tactic.mllist.enum_from", "parentIds": ["tactic.mllist.enum"]}, {"id": "list.intercalate", "parentIds": ["string.intercalate"]}, {"id": "sub_eq_iff_eq_add", "parentIds": ["sub_eq_iff_eq_add'"]}, {"id": "tactic.interactive.unfold1", "parentIds": []}, {"id": "list.split_at", "parentIds": ["list.rotate"]}, {"id": "unsigned.has_to_string", "parentIds": []}, {"id": "nat.has_to_string", "parentIds": ["unsigned.has_to_string", "pos_line", "print_item_crawl", "tactic.explode.has_to_tactic_format", "fin.has_to_string"]}, {"id": "tactic.interactive.unfold_projs", "parentIds": []}, {"id": "tactic.unfold_projs_target", "parentIds": ["tactic.interactive.unfold_projs"]}, {"id": "tactic.unfold_projs_hyp", "parentIds": ["tactic.interactive.unfold_projs"]}, {"id": "nat.find_x", "parentIds": ["nat.find_min", "nat.find", "nat.find_spec"]}, {"id": "tactic.down", "parentIds": []}, {"id": "occurrences_to_format", "parentIds": ["occurrences.has_to_format"]}, {"id": "div_lt_of_mul_gt_of_neg", "parentIds": ["one_div_lt_one_div_of_lt_of_neg"]}, {"id": "mul_lt_mul_of_neg_right", "parentIds": ["div_lt_of_mul_gt_of_neg", "mul_pos_of_neg_of_neg", "mul_lt_of_gt_div_of_neg", "div_lt_div_of_lt_of_neg"]}, {"id": "eq_or_lt_of_not_lt", "parentIds": []}, {"id": "eq.decidable", "parentIds": ["eq_or_lt_of_not_lt"]}, {"id": "add_interactive", "parentIds": []}, {"id": "tactic.ext_parse", "parentIds": ["tactic.interactive.ext1", "tactic.interactive.ext"]}, {"id": "tactic.rcases_patt_inverted.invert", "parentIds": ["tactic.ext_parse", "tactic.rintro_parse"]}, {"id": "tactic.rcases_patt_parse", "parentIds": ["tactic.ext_parse", "tactic.rintro_parse"]}, {"id": "tactic.rcases_patt_parse_list", "parentIds": ["tactic.ext_parse", "tactic.rintro_parse", "tactic.interactive.obtain_parse", "tactic.rcases_parse", "tactic.rcases_patt_parse"]}, {"id": "interactive.types.brackets", "parentIds": ["tactic.ext_parse", "ext_param", "tactic.rintro_parse", "tactic.rcases_patt_parse_core", "interactive.types.list_of"]}, {"id": "list.func.equiv", "parentIds": []}, {"id": "list.func.get", "parentIds": ["list.func.equiv"]}, {"id": "ordering.compares.eq_lt", "parentIds": []}, {"id": "ordering.compares", "parentIds": ["ordering.compares.eq_lt", "ordering.compares.eq_gt", "cmp_compares", "ordering.compares.eq_eq"]}, {"id": "list.mpartition", "parentIds": []}, {"id": "expr.is_heq", "parentIds": ["tactic.match_heq", "tactic.subst"]}, {"id": "local_decl", "parentIds": ["local_context.get_local_decl"]}, {"id": "functor.comp.map_mk", "parentIds": []}, {"id": "old_conv.orelse", "parentIds": ["old_conv.alternative"]}, {"id": "where.get_def_variables", "parentIds": ["where.get_includes_core", "where.is_variable_name", "where.fetch_potential_variable_names"]}, {"id": "where.strip_pi_binders", "parentIds": ["where.get_def_variables"]}, {"id": "norm_num.add1_zero", "parentIds": []}, {"id": "int.sign_one", "parentIds": []}, {"id": "int.sign", "parentIds": ["int.sign_one", "int.sign_eq_neg_one_iff_neg", "int.sign_eq_one_iff_pos", "int.sign_mul_abs", "int.sign_neg_one", "int.sign_zero", "int.sign_eq_zero_iff_zero", "int.sign_mul_nat_abs", "int.pos_of_sign_eq_one", "int.neg_of_sign_eq_neg_one", "int.sign_of_succ", "int.sign_eq_neg_one_of_neg", "int.eq_zero_of_sign_eq_zero", "int.sign_eq_one_of_pos"]}, {"id": "tactic.interactive.generalize_hyp", "parentIds": []}, {"id": "has_union", "parentIds": ["set.has_union", "list.has_union"]}, {"id": "options.join", "parentIds": ["options.has_add"]}, {"id": "smt_tactic.slift_aux", "parentIds": ["smt_tactic.slift"]}, {"id": "localized_cmd", "parentIds": []}, {"id": "string.hash", "parentIds": ["localized_cmd"]}, {"id": "environment.fingerprint", "parentIds": ["localized_cmd"]}, {"id": "string.reflect", "parentIds": ["localized_cmd", "to_additive.value_type.has_reflect"]}, {"id": "expr.get_app_fn_args_aux", "parentIds": ["expr.get_app_fn_args"]}, {"id": "tactic.unsafe.type_context.run", "parentIds": []}, {"id": "max_eq_neg_min_neg_neg", "parentIds": []}, {"id": "except_t.return", "parentIds": ["except_t.is_lawful_monad", "except_t.monad"]}, {"id": "tactic.join_user_simp_lemmas_core", "parentIds": ["tactic.join_user_simp_lemmas"]}, {"id": "tactic.mk_eq_simp_ext", "parentIds": []}, {"id": "tactic.mk_local_pisn", "parentIds": []}, {"id": "string.str_ne_empty", "parentIds": []}, {"id": "string.empty_ne_str", "parentIds": ["string.str_ne_empty"]}, {"id": "list.filter_cons_of_neg", "parentIds": ["list.filter_append", "list.filter_sublist"]}, {"id": "char.has_le", "parentIds": ["char.decidable_le"]}, {"id": "char.le", "parentIds": ["char.has_le"]}, {"id": "list.length_drop", "parentIds": []}, {"id": "nat.succ_sub_succ_eq_sub", "parentIds": ["list.length_drop", "nat.shiftl'_sub", "nat.succ_sub_succ", "nat.sub_lt", "list.length_remove_nth"]}, {"id": "nat.add_semigroup", "parentIds": ["nat.add_mul_div_left", "nat.add_sub_assoc", "int.to_nat_sub", "nat.add_mul_mod_self_left"]}, {"id": "tactic.choose1", "parentIds": []}, {"id": "tactic.mk_local_def", "parentIds": ["tactic.choose1", "tactic.mk_eq_proof", "derive_struct_ext_lemma"]}, {"id": "tactic.mk_local_pis_whnf", "parentIds": ["tactic.choose1"]}, {"id": "tactic.dependent_pose_core", "parentIds": ["tactic.choose1"]}, {"id": "comp.seq_mk", "parentIds": []}, {"id": "comp.has_seq", "parentIds": ["comp.seq_mk", "comp.run_seq", "comp.pure_seq_eq_map", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "expr.has_local_in", "parentIds": ["expr.has_local_constant"]}, {"id": "norm_num.subst_into_subtr", "parentIds": []}, {"id": "nonempty.map", "parentIds": ["nonempty.congr"]}, {"id": "tactic.assertv_core", "parentIds": ["smt_tactic.assertv", "tactic.assertv"]}, {"id": "int.nat_abs_add_nonneg", "parentIds": ["int.nat_abs_bit0", "int.nat_abs_bit1_nonneg"]}, {"id": "int.nat_abs_of_nat_core", "parentIds": ["int.nat_abs_add_nonneg"]}, {"id": "int.neg_succ_of_nat_lt_zero", "parentIds": ["int.nat_abs_add_nonneg", "int.of_nat_nat_abs_eq_of_nonneg", "int.nat_abs_bit0"]}, {"id": "native.float.to_repr", "parentIds": ["native.float.has_to_string", "native.float.has_repr"]}, {"id": "neg_sub_neg", "parentIds": []}, {"id": "old_conv.to_tactic", "parentIds": ["old_conv.conversion", "tactic.interactive.old_conv"]}, {"id": "not_forall_not", "parentIds": []}, {"id": "not_iff_comm", "parentIds": ["not_forall_not"]}, {"id": "decidable_of_iff", "parentIds": ["not_forall_not"]}, {"id": "reader_t.adapt", "parentIds": ["reader_t.monad_reader_adapter"]}, {"id": "conv.update_lhs", "parentIds": ["conv.interactive.find", "conv.replace_lhs", "conv.interactive.for", "conv.interactive.simp", "conv.discharge_eq_lhs"]}, {"id": "conv.rhs", "parentIds": ["conv.update_lhs", "conv.discharge_eq_lhs"]}, {"id": "norm_num.neg_add_pos_helper1", "parentIds": []}, {"id": "neg_add_eq_of_eq_add", "parentIds": ["norm_num.neg_add_pos_helper1", "norm_num.neg_add_pos_eq_of_eq_add", "norm_num.neg_add_pos_helper2"]}, {"id": "dvd.trans", "parentIds": []}, {"id": "dvd_trans", "parentIds": ["dvd.trans", "nat.dvd_mod_iff"]}, {"id": "parser.foldr", "parentIds": ["parser.many"]}, {"id": "function.surjective_of_has_right_inverse", "parentIds": ["function.inv_fun_surjective", "function.surjective_iff_has_right_inverse", "function.cantor_injective", "function.bijective_iff_has_inverse"]}, {"id": "eq_min", "parentIds": ["min_eq_left", "min_comm", "min_add_add_left", "min_assoc"]}, {"id": "min_le_right", "parentIds": ["eq_min", "min_comm", "min_add_add_left", "min_assoc", "max_neg_neg"]}, {"id": "nat.repr", "parentIds": ["nat.has_repr"]}, {"id": "nat.digit_char", "parentIds": ["nat.repr", "hex_digit_repr"]}, {"id": "list.ne_nil_of_length_eq_succ", "parentIds": []}, {"id": "eq_true_of_and_eq_true_right", "parentIds": ["prod.mk.inj_iff"]}, {"id": "eq_true_intro", "parentIds": ["eq_true_of_and_eq_true_right", "eq_true_of_not_eq_false", "bool.coe_sort_tt", "prod.mk.inj_iff", "classical.prop_complete", "eq_true_of_and_eq_true_left"]}, {"id": "format.indent", "parentIds": ["old_conv.conversion"]}, {"id": "tactic.extract_def", "parentIds": []}, {"id": "expr.to_implicit_local_const", "parentIds": ["tactic.extract_def", "derive_struct_ext_lemma"]}, {"id": "tactic.solve_aux", "parentIds": ["tactic.extract_def", "old_conv.funext", "tactic.add_theorem_by", "tactic.local_def_value", "tactic.interactive.generalize", "tactic.find_local", "tactic.mk_assoc_instance", "instance_derive_handler", "tactic.interactive.extract_goal", "tactic.delta_instance", "derive_struct_ext_lemma"]}, {"id": "expr.collect_univ_params", "parentIds": ["tactic.extract_def", "tactic.prove_goal_async", "tactic.delta_instance"]}, {"id": "tactic.lambdas", "parentIds": ["tactic.extract_def"]}, {"id": "nat.add_self_ne_one", "parentIds": ["nat.bit1_ne_bit0"]}, {"id": "nat.add_sub_cancel", "parentIds": ["nat.sub_eq_iff_eq_add", "nat.add_sub_assoc", "nat.add_mod_right", "nat.mul_pred_left", "nat.add_div_right", "norm_num.sub_nat_pos_helper", "nat.add_le_to_le_sub"]}, {"id": "nat.sub_add_cancel", "parentIds": ["nat.sub_eq_iff_eq_add", "nat.sub_mul_mod", "nat.sub_pos_of_lt", "nat.dvd_sub", "nat.sub_add_comm", "nat.sub_mul_div", "nat.sub_add_min_cancel", "list.length_remove_nth"]}, {"id": "linter.impossible_instance", "parentIds": []}, {"id": "impossible_instance", "parentIds": ["linter.impossible_instance"]}, {"id": "tactic.interactive.continue", "parentIds": []}, {"id": "tactic.delta_target", "parentIds": ["tactic.delta_instance", "tactic.interactive.delta"]}, {"id": "binder_info.brackets", "parentIds": ["binder.to_string", "binder.has_to_tactic_format", "where.format_variable"]}, {"id": "list.subset.trans", "parentIds": []}, {"id": "int.has_repr", "parentIds": []}, {"id": "smt_tactic.interactive.add_eqn_lemmas", "parentIds": []}, {"id": "smt_tactic.interactive.add_eqn_lemmas_for", "parentIds": ["smt_tactic.interactive.add_eqn_lemmas"]}, {"id": "native.float.cos", "parentIds": []}, {"id": "iff_iff_eq", "parentIds": ["eq_iff_iff"]}, {"id": "iff_of_eq", "parentIds": ["iff_iff_eq", "function.cantor_surjective"]}, {"id": "inv_zero", "parentIds": ["one_div_zero", "mul_inv'"]}, {"id": "list.erasep", "parentIds": []}, {"id": "lean.parser.set_goal_info_pos", "parentIds": ["tactic.interactive.rw_rules"]}, {"id": "function.curry_uncurry", "parentIds": []}, {"id": "tactic.interactive.unfreezeI", "parentIds": []}, {"id": "tactic.unfreeze_local_instances", "parentIds": ["tactic.interactive.unfreezeI", "tactic.reset_instance_cache"]}, {"id": "psigma.rev_lex_wf", "parentIds": ["psigma.skip_left_wf"]}, {"id": "psigma.rev_lex", "parentIds": ["psigma.rev_lex_wf", "psigma.rev_lex_accessible", "psigma.mk_skip_left", "psigma.skip_left"]}, {"id": "old_conv.apply_propext_simp_set", "parentIds": []}, {"id": "tactic.get_user_simp_lemmas", "parentIds": ["old_conv.apply_propext_simp_set", "old_conv.apply_simp_set", "tactic.reduce_ifs_at"]}, {"id": "old_conv.lift_tactic", "parentIds": ["old_conv.apply_propext_simp_set", "old_conv.apply_simp_set"]}, {"id": "inv_mul_cancel", "parentIds": ["div_mul_cancel", "one_div_mul_cancel", "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "div_eq_one_iff_eq"]}, {"id": "gt_of_ge_of_gt", "parentIds": ["sub_lt_of_abs_sub_lt_left"]}, {"id": "nat.le_of_eq", "parentIds": []}, {"id": "vm_obj.to_nat", "parentIds": []}, {"id": "list.length_map", "parentIds": []}, {"id": "list.is_infix", "parentIds": []}, {"id": "expr.mfoldl", "parentIds": []}, {"id": "get", "parentIds": ["expr.mfoldl", "smt_tactic.classical", "smt_tactic.read", "smt_tactic.num_goals"]}, {"id": "state_t.monad_state", "parentIds": ["expr.mfoldl", "smt_tactic.monad_state"]}, {"id": "expr.traverse", "parentIds": ["expr.mfoldl"]}, {"id": "state_t.has_monad_lift", "parentIds": ["expr.mfoldl", "state_t.run_monad_lift"]}, {"id": "list.to_string", "parentIds": ["list.has_to_string"]}, {"id": "push_neg.not_lt_eq", "parentIds": []}, {"id": "not_lt", "parentIds": ["push_neg.not_lt_eq", "not_lt_iff_eq_or_lt", "le_of_not_lt", "le_iff_le_iff_lt_iff_lt"]}, {"id": "linear_ordered_ring", "parentIds": ["linear_ordered_ring.to_linear_order", "mul_self_lt_mul_self_iff", "mul_self_le_mul_self_iff", "linear_ordered_ring.to_linear_ordered_semiring", "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "le_of_mul_le_of_ge_one", "linear_ordered_ring.to_ordered_ring", "norm_num.nonzero_of_neg_helper", "gt_of_mul_lt_mul_neg_left", "linear_ordered_field.to_linear_ordered_ring", "zero_gt_neg_one", "linear_ordered_comm_ring.to_linear_ordered_ring", "mul_self_nonneg", "nonneg_le_nonneg_of_squares_le", "pos_and_pos_or_neg_and_neg_of_mul_pos"]}, {"id": "char.to_lower", "parentIds": []}, {"id": "char.to_nat", "parentIds": ["char.to_lower", "char_to_hex", "char.quote_core"]}, {"id": "conv.interactive.guard_lhs", "parentIds": []}, {"id": "tactic.interactive.guard_expr_eq", "parentIds": ["conv.interactive.guard_lhs", "tactic.interactive.guard_hyp", "tactic.interactive.guard_target", "tactic.interactive.guard_hyp'"]}, {"id": "nat.succ_inj", "parentIds": []}, {"id": "parser.mk_error_msg", "parentIds": []}, {"id": "buffer.take_right", "parentIds": ["parser.mk_error_msg"]}, {"id": "string.intercalate", "parentIds": ["parser.mk_error_msg", "string.map_tokens", "where.trace_includes", "where.trace_opens", "tactic.explode.has_to_tactic_format", "where.format_variable", "tactic.alias.make_left_right", "where.compile_variable_list"]}, {"id": "buffer.has_append", "parentIds": ["parser.mk_error_msg"]}, {"id": "buffer.drop", "parentIds": ["parser.mk_error_msg"]}, {"id": "buffer.map", "parentIds": ["parser.mk_error_msg"]}, {"id": "le_div_of_mul_le", "parentIds": []}, {"id": "forall_iff_forall_surj", "parentIds": []}, {"id": "unsigned.has_mul", "parentIds": []}, {"id": "fin.mul", "parentIds": ["unsigned.has_mul", "fin.mul_def", "fin.has_mul"]}, {"id": "tactic.norm_num", "parentIds": []}, {"id": "function.equiv.trans", "parentIds": ["function.equiv.is_equivalence"]}, {"id": "tactic.interactive.abstract", "parentIds": []}, {"id": "tactic.abstract", "parentIds": ["tactic.interactive.abstract", "well_founded_tactics.default_dec_tac'", "well_founded_tactics.default_dec_tac"]}, {"id": "native.float.cbrt", "parentIds": []}, {"id": "decidable.lt_by_cases", "parentIds": []}, {"id": "has_lt.lt.decidable", "parentIds": ["decidable.lt_by_cases", "cmp_compares"]}, {"id": "mul_ne_zero", "parentIds": ["div_mul_right"]}, {"id": "tactic.mllist.map", "parentIds": []}, {"id": "simps_tac", "parentIds": []}, {"id": "list.erase_dup", "parentIds": ["simps_tac", "where.get_opens", "where.fetch_potential_variable_names", "where.collect_by"]}, {"id": "simps_add_projections", "parentIds": ["simps_tac"]}, {"id": "declaration.value", "parentIds": ["simps_tac", "check_unused_arguments", "print_item_crawl", "declaration.update_with_fun", "tactic.alias.get_alias_target"]}, {"id": "and.imp_left", "parentIds": []}, {"id": "list.filter_append", "parentIds": []}, {"id": "not_congr", "parentIds": ["list.filter_append", "inv_ne_one", "sub_ne_zero", "to_bool_ff_iff", "lt_iff_lt_of_le_iff_le", "list.filter_sublist", "neg_ne_zero", "decidable.le_iff_le_iff_lt_iff_lt", "d_array.read_write_of_ne", "lt_iff_lt_of_le_iff_le'", "le_iff_le_iff_lt_iff_lt"]}, {"id": "list.filter_cons_of_pos", "parentIds": ["list.filter_append", "list.filter_sublist"]}, {"id": "tactic.mllist.enum", "parentIds": []}, {"id": "nat.sub_eq_sub_min", "parentIds": ["nat.sub_add_min_cancel"]}, {"id": "min_eq_right", "parentIds": ["nat.sub_eq_sub_min", "min_add_add_left", "nat.min_zero", "min_eq_right_of_lt"]}, {"id": "nat.sub_self", "parentIds": ["nat.sub_eq_sub_min", "nat.mod_self"]}, {"id": "sub_sub_cancel", "parentIds": []}, {"id": "sub_sub_self", "parentIds": ["sub_sub_cancel"]}, {"id": "d_array.rev_iterate", "parentIds": ["array.rev_iterate"]}, {"id": "d_array.rev_iterate_aux", "parentIds": ["d_array.rev_iterate"]}, {"id": "tactic.interactive.apply_field", "parentIds": []}, {"id": "xor.decidable", "parentIds": ["bxor_coe_iff"]}, {"id": "xor", "parentIds": ["xor.decidable", "bxor_coe_iff"]}, {"id": "native.has_to_format", "parentIds": []}, {"id": "interaction_monad.result_to_string", "parentIds": ["interaction_monad.result_has_string"]}, {"id": "nat.sub_mul_mod", "parentIds": ["nat.mod_pow_succ"]}, {"id": "nat.sub_zero", "parentIds": ["nat.sub_mul_mod", "nat.add_sub_cancel", "nat.sub_self", "nat.add_sub_cancel_left", "nat.mod_zero", "nat.sub_mul_div", "nat.sub_sub", "nat.mul_sub_right_distrib", "nat.le_of_sub_eq_zero", "nat.mod_eq_sub_mod", "list.length_remove_nth", "nat.div_zero"]}, {"id": "opt_param_eq", "parentIds": []}, {"id": "tactic.rewrite", "parentIds": ["tactic.rewrite_hyp", "tactic.assoc_rewrite", "tactic.rewrite_target"]}, {"id": "tactic.try_apply_opt_auto_param", "parentIds": ["tactic.rewrite"]}, {"id": "expr.instantiate_var", "parentIds": ["old_conv.funext", "expr.reduce_let", "tactic.mk_local_pis_whnf", "expr.instantiate_local"]}, {"id": "well_founded.fix_eq", "parentIds": ["nat.div_def_aux", "list.qsort_cons", "nat.mod_def_aux", "list.qsort_nil"]}, {"id": "tactic.interactive.let", "parentIds": ["tactic.interactive.letI"]}, {"id": "tactic.definev", "parentIds": ["tactic.interactive.let", "tactic.interactive.set", "tactic.pose"]}, {"id": "tactic.pose", "parentIds": ["tactic.interactive.let", "tactic.mk_patterns"]}, {"id": "tactic.define", "parentIds": ["tactic.interactive.let"]}, {"id": "has_sdiff", "parentIds": ["list.has_sdiff", "set.has_sdiff"]}, {"id": "monad_from_pure_bind", "parentIds": []}, {"id": "nat.mul_assoc", "parentIds": ["nat.comm_semiring", "int.mul_assoc"]}, {"id": "nat.left_distrib", "parentIds": ["nat.mul_assoc", "nat.comm_semiring", "int.distrib_left"]}, {"id": "module_info.has_to_tactic_format", "parentIds": []}, {"id": "ext_param", "parentIds": []}, {"id": "nat.sub_induction", "parentIds": []}, {"id": "tactic.tactic.has_to_tactic_format", "parentIds": ["tactic.interactive.extract_goal"]}, {"id": "tactic.to_pfmt", "parentIds": ["tactic.tactic.has_to_tactic_format", "tactic.lift", "tactic.interactive.extract_goal", "tactic.get_lift_prf"]}, {"id": "mul_div_cancel_left", "parentIds": ["eq_of_mul_eq_mul_of_nonzero_left", "div_le_of_le_mul"]}, {"id": "lt_min", "parentIds": []}, {"id": "gt_of_gt_of_ge", "parentIds": []}, {"id": "lt_of_le_of_lt", "parentIds": ["gt_of_gt_of_ge", "sub_lt_of_abs_sub_lt_left", "buffer.lt_aux_3", "mul_self_lt_mul_self", "add_lt_add_of_le_of_lt", "buffer.lt_aux_1", "nat.pow_lt_pow_of_lt_left", "list.length_remove_nth", "mul_lt_mul'", "forall_lt_iff_le'"]}, {"id": "nat.comm_monoid", "parentIds": ["nat.comm_semigroup"]}, {"id": "comm_semigroup", "parentIds": ["nat.comm_semigroup", "mul_left_comm", "comm_semigroup_to_is_commutative", "comm_monoid.to_comm_semigroup", "mul_right_comm", "comm_semigroup.to_semigroup", "mul_comm", "mul_mul_mul_comm", "comm_ring.to_comm_semigroup", "int.comm_semigroup"]}, {"id": "add_sub_assoc", "parentIds": ["add_sub_cancel'_right", "add_le_of_le_sub_left", "sub_add_sub_cancel", "add_lt_of_lt_sub_left"]}, {"id": "lt_add_of_neg_add_lt_left", "parentIds": ["lt_add_of_neg_lt_sub_left"]}, {"id": "lt_add_of_sub_left_lt", "parentIds": ["lt_add_of_neg_add_lt_left"]}, {"id": "tactic.try_apply_opt_auto_param_for_apply", "parentIds": ["tactic.apply"]}, {"id": "tactic.has_opt_auto_param_for_apply", "parentIds": ["tactic.try_apply_opt_auto_param_for_apply"]}, {"id": "mwhen", "parentIds": ["tactic.try_apply_opt_auto_param_for_apply", "tactic.try_apply_opt_auto_param", "dedup"]}, {"id": "tactic.apply_auto_param", "parentIds": ["tactic.try_apply_opt_auto_param_for_apply", "tactic.try_apply_opt_auto_param", "tactic.interactive.apply_auto_param"]}, {"id": "set.has_subset", "parentIds": ["set.powerset"]}, {"id": "subrelation.accessible", "parentIds": ["subrelation.wf"]}, {"id": "subrelation", "parentIds": ["subrelation.accessible", "subrelation.wf"]}, {"id": "tactic.back_lemmas_insert_core", "parentIds": ["tactic.back_lemmas_insert"]}, {"id": "smt_tactic.classical", "parentIds": ["smt_tactic.by_contradiction", "smt_tactic.by_cases"]}, {"id": "smt_state.classical", "parentIds": ["smt_tactic.classical"]}, {"id": "smt_tactic.monad_state", "parentIds": ["smt_tactic.classical", "smt_tactic.read", "smt_tactic.num_goals"]}, {"id": "nat.zero_mul", "parentIds": ["nat.comm_semiring", "nat.left_distrib", "nat.mul_comm"]}, {"id": "state_t.run_adapt", "parentIds": []}, {"id": "state_t.adapt", "parentIds": ["state_t.run_adapt", "state_t.monad_state_adapter"]}, {"id": "ff_eq_tt_eq_false", "parentIds": []}, {"id": "int.sign_eq_neg_one_iff_neg", "parentIds": []}, {"id": "int.sign_eq_neg_one_of_neg", "parentIds": ["int.sign_eq_neg_one_iff_neg"]}, {"id": "int.neg_of_sign_eq_neg_one", "parentIds": ["int.sign_eq_neg_one_iff_neg"]}, {"id": "asymm", "parentIds": ["asymm_of"]}, {"id": "nat.succ_add_eq_succ_add", "parentIds": []}, {"id": "to_bool_false_eq_ff", "parentIds": ["nat.cond_to_bool_mod_two"]}, {"id": "bool.bxor_iff_ne", "parentIds": []}, {"id": "rbmap.has_repr", "parentIds": []}, {"id": "prod.has_repr", "parentIds": ["rbmap.has_repr"]}, {"id": "nat.bit0_inj", "parentIds": ["nat.bit1_inj", "nat.bit0_ne"]}, {"id": "list.filter_nil", "parentIds": []}, {"id": "parser.foldr_core", "parentIds": ["parser.foldr"]}, {"id": "nat.bodd_one", "parentIds": []}, {"id": "sub_le_of_sub_le", "parentIds": []}, {"id": "discrete_field.eq_zero_or_eq_zero_of_mul_eq_zero", "parentIds": ["discrete_field.to_integral_domain"]}, {"id": "false_of_ne", "parentIds": ["ne_self_iff_false"]}, {"id": "ne.irrefl", "parentIds": ["false_of_ne"]}, {"id": "neg_lt_neg", "parentIds": ["sub_lt_sub_left", "gt_of_mul_lt_mul_neg_left", "neg_pos_of_neg", "zero_gt_neg_one", "lt_neg_of_lt_neg", "neg_lt_of_neg_lt", "lt_of_neg_lt_neg", "sub_lt_sub_of_le_of_lt", "sub_lt_sub", "neg_neg_of_pos"]}, {"id": "native.float.min", "parentIds": []}, {"id": "tactic.constr_to_prop", "parentIds": ["tactic.mk_iff_of_inductive_prop"]}, {"id": "declaration.instantiate_type_univ_params", "parentIds": ["tactic.constr_to_prop"]}, {"id": "expr.mk_true", "parentIds": ["tactic.constr_to_prop", "smt_tactic.get_facts"]}, {"id": "expr.mk_and_lst", "parentIds": ["tactic.constr_to_prop", "derive_struct_ext_lemma"]}, {"id": "list.filter_map", "parentIds": ["tactic.constr_to_prop", "tactic.successes", "where.get_variables_core", "list.reduce_option", "instance_priority", "derive_struct_ext_lemma", "tactic.module_doc_strings"]}, {"id": "list.init", "parentIds": ["tactic.constr_to_prop", "tactic.interactive.extract_goal"]}, {"id": "expr.drop_pis", "parentIds": ["tactic.constr_to_prop"]}, {"id": "tactic.ext", "parentIds": ["tactic.interactive.ext"]}, {"id": "if_true_right_eq_or", "parentIds": ["d_array.of_beq_aux_eq_ff"]}, {"id": "tactic.interactive.econstructor", "parentIds": []}, {"id": "int.nat_bitwise", "parentIds": []}, {"id": "imp_false", "parentIds": []}, {"id": "well_founded.apply", "parentIds": ["sum.lex_wf", "tc.wf", "subrelation.wf", "prod.lex_wf", "inv_image.wf", "well_founded.recursion", "psigma.lex_accessible", "well_founded.fix_eq"]}, {"id": "tactic.rintro_parse", "parentIds": ["tactic.interactive.rintros", "tactic.interactive.rintro"]}, {"id": "tactic.rcases_parse_depth", "parentIds": ["tactic.rintro_parse", "tactic.rcases_parse"]}, {"id": "left_comm", "parentIds": ["mul_left_comm", "min_left_comm", "nat.add_left_comm", "max_left_comm", "add_left_comm"]}, {"id": "d_array.read_write", "parentIds": ["array.read_write"]}, {"id": "d_array.write", "parentIds": ["d_array.read_write", "array.write", "d_array.foreach", "d_array.read_write_of_ne"]}, {"id": "tactic.local_proof", "parentIds": []}, {"id": "not_and_not_right", "parentIds": []}, {"id": "not.imp_symm", "parentIds": ["not_and_not_right", "not_ball", "not_forall", "not_imp_comm"]}, {"id": "declaration.value_task", "parentIds": []}, {"id": "nat.mod_def", "parentIds": ["nat.mod_eq_of_lt", "nat.zero_mod", "nat.mod_zero", "nat.mod_add_div", "nat.mod_eq_sub_mod"]}, {"id": "bex.imp_right", "parentIds": []}, {"id": "local_context.get_local_decl", "parentIds": []}, {"id": "nat.zero_shiftr", "parentIds": []}, {"id": "native.float.cosh", "parentIds": []}, {"id": "function.injective.of_comp", "parentIds": []}, {"id": "left_inverse_neg_add_add_right", "parentIds": []}, {"id": "smt_tactic.pose", "parentIds": ["smt_tactic.interactive.let"]}, {"id": "Exists.fst", "parentIds": ["Exists.snd", "exists_prop_of_false"]}, {"id": "comm_semigroup_to_is_commutative", "parentIds": []}, {"id": "tactic.interactive.split", "parentIds": []}, {"id": "tactic.split", "parentIds": ["tactic.interactive.split", "tactic.mk_iff_of_inductive_prop", "derive_struct_ext_lemma"]}, {"id": "monad_state_adapter_trans", "parentIds": []}, {"id": "monad_state_adapter", "parentIds": ["monad_state_adapter_trans", "state_t.monad_state_adapter"]}, {"id": "interactive.types.without_ident_list", "parentIds": []}, {"id": "gt_iff_lt", "parentIds": []}, {"id": "tactic.mk_assoc_pattern", "parentIds": ["tactic.match_assoc_pattern", "tactic.flatten"]}, {"id": "tactic.match_assoc_pattern'", "parentIds": ["tactic.match_assoc_pattern"]}, {"id": "smt_tactic.interactive.itactic", "parentIds": ["smt_tactic.interactive.try", "smt_tactic.interactive.iterate", "smt_tactic.interactive.all_goals"]}, {"id": "tactic.interactive.convert_to_core", "parentIds": ["tactic.interactive.convert_to"]}, {"id": "tactic.rewrite_target", "parentIds": ["tactic.interactive.convert_to_core", "tactic.interactive.h_generalize"]}, {"id": "tactic.interactive.swap", "parentIds": ["tactic.interactive.convert_to_core", "tactic.interactive.replace"]}, {"id": "simp_lemmas.add", "parentIds": ["simp_lemmas.append"]}, {"id": "norm_num.bit1_add_bit0_helper", "parentIds": []}, {"id": "dvd_of_mul_right_dvd", "parentIds": []}, {"id": "dvd_mul_right", "parentIds": ["dvd_of_mul_right_dvd", "nat.dvd_mod_iff", "dvd_mul_of_dvd_left"]}, {"id": "environment.add_namespace", "parentIds": []}, {"id": "expr.imp", "parentIds": ["saturate_fun"]}, {"id": "push_neg.whnf_reducible", "parentIds": []}, {"id": "mul_self_lt_mul_self_iff", "parentIds": []}, {"id": "mul_self_le_mul_self_iff", "parentIds": ["mul_self_lt_mul_self_iff"]}, {"id": "false_iff", "parentIds": ["nat.le_div_iff_mul_le"]}, {"id": "iff_false", "parentIds": ["false_iff", "eq_false"]}, {"id": "list.chain_cons", "parentIds": []}, {"id": "list.chain", "parentIds": ["list.chain_cons", "list.decidable_chain"]}, {"id": "monad.foldl", "parentIds": []}, {"id": "ring.zero_mul", "parentIds": ["ring.to_semiring"]}, {"id": "list.has_sdiff", "parentIds": []}, {"id": "list.diff", "parentIds": ["list.has_sdiff", "well_founded_tactics.cancel_nat_add_lt"]}, {"id": "smt_tactic.add_ematch_lemma_core", "parentIds": ["smt_tactic.add_ematch_lhs_lemma", "smt_tactic.add_ematch_lemma"]}, {"id": "hinst_lemma.mk_core", "parentIds": ["smt_tactic.add_ematch_lemma_core"]}, {"id": "smt_tactic.add_lemmas", "parentIds": ["smt_tactic.add_ematch_lemma_core", "smt_tactic.interactive.add_simp_lemmas", "rsimp.collect_implied_eqs", "smt_tactic.add_ematch_eqn_lemmas_for_core", "smt_tactic.add_ematch_lemma_from_decl_core"]}, {"id": "le_mul_of_ge_one_right", "parentIds": ["le_mul_of_ge_one_left", "le_of_one_le_div"]}, {"id": "mul_le_mul_of_nonneg_left", "parentIds": ["le_mul_of_ge_one_right", "mul_lt_mul", "mul_le_mul_of_nonpos_left", "le_of_mul_le_of_ge_one", "lt_of_mul_lt_mul_left", "mul_nonpos_of_nonneg_of_nonpos", "abs_abs_sub_abs_le_abs_sub", "mul_le_mul"]}, {"id": "eq_zero_of_mul_self_eq_zero", "parentIds": ["eq_zero_of_mul_self_add_mul_self_eq_zero"]}, {"id": "mul_le_mul_of_mul_div_le", "parentIds": []}, {"id": "int.neg_succ_of_nat_inj_iff", "parentIds": []}, {"id": "int.neg_succ_of_nat_inj", "parentIds": ["int.neg_succ_of_nat_inj_iff"]}, {"id": "mk_int_val_ne_proof", "parentIds": ["tactic.comp_val"]}, {"id": "name.add_prime", "parentIds": []}, {"id": "int.lt_of_coe_nat_lt_coe_nat", "parentIds": []}, {"id": "int.coe_nat_lt_coe_nat_iff", "parentIds": ["int.lt_of_coe_nat_lt_coe_nat", "int.coe_nat_lt_coe_nat_of_lt"]}, {"id": "list.traverse", "parentIds": ["expr.traverse", "list.traversable"]}, {"id": "list.repr", "parentIds": ["list.has_repr"]}, {"id": "mjoin_pure", "parentIds": []}, {"id": "rsimp.config.inhabited", "parentIds": []}, {"id": "environment.import_only", "parentIds": ["environment.import'"]}, {"id": "list.modify_nth", "parentIds": []}, {"id": "list.modify_nth_tail", "parentIds": ["list.modify_nth", "list.insert_nth"]}, {"id": "list.modify_head", "parentIds": ["list.modify_nth"]}, {"id": "prod_has_decidable_lt", "parentIds": []}, {"id": "prod.has_lt", "parentIds": ["prod_has_decidable_lt", "prod.lt_def"]}, {"id": "left_inverse_add_left_sub", "parentIds": []}, {"id": "tactic.try_for", "parentIds": []}, {"id": "nat.mul_self_le_mul_self_iff", "parentIds": ["nat.mul_self_lt_mul_self_iff"]}, {"id": "nat.mul_self_lt_mul_self", "parentIds": ["nat.mul_self_le_mul_self_iff"]}, {"id": "nat.mul_self_le_mul_self", "parentIds": ["nat.mul_self_le_mul_self_iff"]}, {"id": "quotient.lift_on\u2082", "parentIds": []}, {"id": "quotient.lift\u2082", "parentIds": ["quotient.lift_on\u2082"]}, {"id": "environment.unfold_untrusted_macros", "parentIds": ["tactic.prove_goal_async"]}, {"id": "norm_num.pos_mul_neg_helper", "parentIds": []}, {"id": "native.float.exponent", "parentIds": []}, {"id": "list.any_of", "parentIds": ["tactic.apply_assumption", "tactic.ext1"]}, {"id": "buffer.read_eq_read'", "parentIds": []}, {"id": "buffer.read'", "parentIds": ["buffer.read_eq_read'"]}, {"id": "array.read_eq_read'", "parentIds": ["buffer.read_eq_read'"]}, {"id": "array.read'", "parentIds": ["buffer.read_eq_read'", "array.read_eq_read'"]}, {"id": "neg_mul_eq_mul_neg", "parentIds": ["mul_lt_mul_of_neg_right", "abs_mul", "mul_neg_eq_neg_mul_symm", "div_neg_eq_neg_div", "mul_le_mul_of_nonpos_right"]}, {"id": "has_to_pexpr", "parentIds": ["reflected.has_to_pexpr", "expr.has_to_pexpr", "pexpr.has_to_pexpr", "to_pexpr"]}, {"id": "list.choose_x", "parentIds": ["list.choose"]}, {"id": "tactic.rcases_patt.invert_many", "parentIds": []}, {"id": "bex_imp_distrib", "parentIds": ["not_bex"]}, {"id": "function.inv_fun_on_eq'", "parentIds": []}, {"id": "function.inv_fun_on_mem", "parentIds": ["function.inv_fun_on_eq'"]}, {"id": "is_left_null", "parentIds": []}, {"id": "int.mul_one", "parentIds": ["int.comm_ring", "int.one_mul"]}, {"id": "lift_pair\u2081", "parentIds": []}, {"id": "expr.has_meta_var", "parentIds": ["tactic.suggest.tactic_statement", "tactic.no_mvars_in_target", "tactic.prove_goal_async"]}, {"id": "tactic.suggest.message", "parentIds": []}, {"id": "tactic.suggest.tactic_statement", "parentIds": ["tactic.suggest.message"]}, {"id": "ordering.compares.eq_gt", "parentIds": []}, {"id": "le_of_add_le_add_left", "parentIds": ["lt_of_add_lt_add_left", "add_lt_add_left", "le_of_add_le_add_right"]}, {"id": "let_value_heq", "parentIds": []}, {"id": "to_additive.value_type.has_reflect", "parentIds": []}, {"id": "ulift.up_down", "parentIds": []}, {"id": "decidable.subsingleton", "parentIds": ["bool.to_bool_false", "bool.to_bool_true", "bool.to_bool_coe"]}, {"id": "function.decidable_eq_pfun", "parentIds": []}, {"id": "psigma.has_well_founded", "parentIds": []}, {"id": "has_well_founded", "parentIds": ["psigma.has_well_founded", "has_well_founded_of_has_sizeof", "prod.has_well_founded"]}, {"id": "guardb", "parentIds": ["tactic.propositional_goal", "tactic.no_mvars_in_target", "tactic.explode_expr", "tactic.alias.get_alias_target", "tactic.replacer_attr"]}, {"id": "tactic.choose", "parentIds": ["tactic.interactive.choose"]}, {"id": "expr.is_constant_of", "parentIds": ["tactic.is_type_app_of", "tactic.alias.get_alias_target", "instance_priority", "instance_derive_handler", "expr.is_app_of"]}, {"id": "buffer.pop_back", "parentIds": []}, {"id": "Exists.imp", "parentIds": []}, {"id": "exists_imp_exists", "parentIds": ["Exists.imp", "exists_congr"]}, {"id": "tactic.success_if_fail", "parentIds": ["tactic.interactive.success_if_fail", "tactic.suggest.apply_and_solve"]}, {"id": "int.eq_coe_or_neg", "parentIds": []}, {"id": "eq_true_of_not_eq_false", "parentIds": []}, {"id": "tactic.match_expr", "parentIds": ["tactic.match_target"]}, {"id": "tactic.match_pattern", "parentIds": ["tactic.match_expr", "old_conv.match_pattern", "old_conv.find_pattern", "old_conv.interactive.find", "conv.interactive.find", "conv.interactive.for", "old_conv.mk_match_expr", "old_conv.match_expr"]}, {"id": "environment.has_repr", "parentIds": []}, {"id": "decidable.lt_or_le", "parentIds": ["decidable.le_or_lt", "decidable.lt_trichotomy"]}, {"id": "dlist.lazy_of_list", "parentIds": []}, {"id": "eq_inv_of_eq_inv", "parentIds": ["eq_inv_iff_eq_inv"]}, {"id": "not_true_iff", "parentIds": ["not_eq_of_eq_true"]}, {"id": "lt.trans", "parentIds": ["buffer.lt_aux_3"]}, {"id": "nat.one_le_bit0", "parentIds": []}, {"id": "add_left_injective", "parentIds": []}, {"id": "mk_expr_set", "parentIds": []}, {"id": "smt_state.has_append", "parentIds": ["smt_tactic.slift_aux"]}, {"id": "tactic.save_info_thunk", "parentIds": ["tactic.save_info", "smt_tactic.save_info", "old_conv.save_info", "conv.save_info"]}, {"id": "tactic_state.to_format", "parentIds": ["tactic.save_info", "conv.save_info", "tactic_state.has_to_format"]}, {"id": "expr.is_eta_expansion_of", "parentIds": ["expr.is_eta_expansion_test"]}, {"id": "sigma.has_sizeof", "parentIds": []}, {"id": "div_helper", "parentIds": []}, {"id": "div_mul_right", "parentIds": ["div_helper", "div_mul_left"]}, {"id": "native.float.sin", "parentIds": []}, {"id": "lt_iff_le_not_le", "parentIds": ["le_not_le_of_lt", "lt_of_le_not_le", "lt_iff_lt_of_le_iff_le'"]}, {"id": "eq.congr", "parentIds": []}, {"id": "int.add_left_neg", "parentIds": ["int.comm_ring"]}, {"id": "int.neg_neg_of_nat_succ", "parentIds": ["int.add_left_neg"]}, {"id": "int.neg_of_nat_of_succ", "parentIds": ["int.add_left_neg"]}, {"id": "comm_monoid", "parentIds": ["comm_monoid.to_comm_semigroup", "comm_monoid.to_monoid", "comm_semiring.to_comm_monoid", "comm_group.to_comm_monoid", "int.comm_monoid", "linear_ordered_comm_ring.to_comm_monoid", "nat.comm_monoid"]}, {"id": "mul_self_iff_eq_one", "parentIds": []}, {"id": "mul_left_inj", "parentIds": ["mul_self_iff_eq_one"]}, {"id": "cc_state.refutation_for", "parentIds": ["smt_tactic.refutation_for"]}, {"id": "bor_eq_false_eq_eq_ff_and_eq_ff", "parentIds": []}, {"id": "tt_bor", "parentIds": ["bor_eq_false_eq_eq_ff_and_eq_ff", "bool.to_bool_or", "bor_eq_true_eq_eq_tt_or_eq_tt"]}, {"id": "ff_bor", "parentIds": ["bor_eq_false_eq_eq_ff_and_eq_ff", "bool.to_bool_or", "bor_eq_true_eq_eq_tt_or_eq_tt"]}, {"id": "old_conv.apply_lemmas", "parentIds": ["old_conv.apply_simp_set"]}, {"id": "nat.has_repr", "parentIds": ["nat.has_to_string", "unsigned.has_repr", "fin.has_repr"]}, {"id": "inv_eq_iff_inv_eq", "parentIds": []}, {"id": "smt_tactic.interactive.trace", "parentIds": []}, {"id": "unsigned.has_repr", "parentIds": ["name.last"]}, {"id": "int.nat_abs_bit0_step", "parentIds": []}, {"id": "int.nat_abs_bit0", "parentIds": ["int.nat_abs_bit0_step", "int.nat_abs_bit1_nonneg"]}, {"id": "list.subset_cons", "parentIds": []}, {"id": "tactic.get_goal", "parentIds": []}, {"id": "parser.is_lawful_monad", "parentIds": []}, {"id": "div_mul_le_div_mul_of_div_le_div_pos", "parentIds": []}, {"id": "lean.parser.set_env", "parentIds": []}, {"id": "list.rotate", "parentIds": []}, {"id": "native.float.neg", "parentIds": ["native.float.has_neg"]}, {"id": "tactic.interactive.set", "parentIds": []}, {"id": "tactic.interactive.change'", "parentIds": ["tactic.interactive.set"]}, {"id": "tactic.interactive.reflexivity", "parentIds": ["tactic.interactive.set"]}, {"id": "left_inverse_add_right_neg_add", "parentIds": []}, {"id": "tactic.unsafe.type_context.level.tmp_get_assignment", "parentIds": []}, {"id": "unsigned.to_nat", "parentIds": ["unsigned.has_to_format"]}, {"id": "function.bicompr", "parentIds": ["function.uncurry_bicompr", "function.uncurry'_bicompr"]}, {"id": "ordering.decidable_eq", "parentIds": ["name.lt.decidable_rel", "ordering.or_else_eq_lt"]}, {"id": "sub_lt_of_abs_sub_lt_right", "parentIds": []}, {"id": "abs_sub", "parentIds": ["sub_lt_of_abs_sub_lt_right", "sub_le_of_abs_sub_le_right"]}, {"id": "sub_lt_of_abs_sub_lt_left", "parentIds": ["sub_lt_of_abs_sub_lt_right"]}, {"id": "well_founded_tactics.unfold_wf_rel", "parentIds": ["well_founded_tactics.default_dec_tac'", "well_founded_tactics.default_dec_tac"]}, {"id": "well_founded_tactics.trivial_nat_lt", "parentIds": ["well_founded_tactics.default_dec_tac'", "well_founded_tactics.default_dec_tac"]}, {"id": "well_founded_tactics.unfold_sizeof", "parentIds": ["well_founded_tactics.default_dec_tac'", "well_founded_tactics.default_dec_tac"]}, {"id": "well_founded_tactics.cancel_nat_add_lt", "parentIds": ["well_founded_tactics.default_dec_tac'", "well_founded_tactics.default_dec_tac"]}, {"id": "well_founded_tactics.process_lex", "parentIds": ["well_founded_tactics.default_dec_tac'", "well_founded_tactics.default_dec_tac"]}, {"id": "reader", "parentIds": []}, {"id": "simp_lemmas.add_congr", "parentIds": []}, {"id": "tactic.subst_core", "parentIds": ["tactic.subst"]}, {"id": "int.of_nat_nat_abs_of_nonpos", "parentIds": []}, {"id": "int.nat_abs_of_nonneg", "parentIds": ["int.of_nat_nat_abs_of_nonpos"]}, {"id": "int.nat_abs_neg", "parentIds": ["int.of_nat_nat_abs_of_nonpos"]}, {"id": "function.equiv.is_equivalence", "parentIds": []}, {"id": "function.equiv.symm", "parentIds": ["function.equiv.is_equivalence"]}, {"id": "simp_lemmas.add_simp", "parentIds": []}, {"id": "options.set_nat", "parentIds": ["tactic.set_nat_option"]}, {"id": "tactic.interactive.injections_and_clear", "parentIds": []}, {"id": "tactic.injections_and_clear", "parentIds": ["tactic.interactive.injections_and_clear"]}, {"id": "add_neg_of_nonpos_of_neg", "parentIds": []}, {"id": "mk_nat_val_ne_proof", "parentIds": ["tactic.comp_val"]}, {"id": "smt_tactic.interactive.dsimp", "parentIds": []}, {"id": "native.float.asinh", "parentIds": []}, {"id": "declaration.update_value_task", "parentIds": []}, {"id": "task.get", "parentIds": ["declaration.update_value_task", "tactic.explode", "declaration.value"]}, {"id": "ulift.inhabited", "parentIds": []}, {"id": "nat.mul_comm", "parentIds": ["nat.comm_semiring", "int.mul_comm", "nat.one_mul"]}, {"id": "nat.add_zero", "parentIds": ["nat.comm_semiring"]}, {"id": "nat.right_distrib", "parentIds": ["nat.comm_semiring", "int.distrib_left"]}, {"id": "nat.mul_zero", "parentIds": ["nat.comm_semiring", "nat.mul_comm"]}, {"id": "nat.one_mul", "parentIds": ["nat.comm_semiring"]}, {"id": "char.is_lower", "parentIds": ["char.is_alpha", "char.decidable_is_lower", "char.decidable_is_alpha"]}, {"id": "string.popn", "parentIds": ["print_decls_sorted_mathlib"]}, {"id": "well_founded_tactics.default", "parentIds": []}, {"id": "well_founded_tactics.default_dec_tac", "parentIds": ["well_founded_tactics.default"]}, {"id": "nat.shiftr_add", "parentIds": ["nat.shiftl'_sub", "nat.test_bit_succ"]}, {"id": "nonempty_psigma", "parentIds": []}, {"id": "environment.decl_filter_map", "parentIds": ["environment.get_trusted_decls", "list_linters", "tactic.find_private_decl", "tactic.suggest.library_defs", "environment.decl_map"]}, {"id": "norm_num.neg_add_pos_eq_of_eq_add", "parentIds": []}, {"id": "mul_lt_mul", "parentIds": ["nat.div_lt_self", "nat.mul_self_lt_mul_self"]}, {"id": "tactic.change_core", "parentIds": ["tactic.interactive.change'", "tactic.change_with_at", "tactic.interactive.elide", "tactic.interactive.unelide"]}, {"id": "sum.map", "parentIds": []}, {"id": "string.split", "parentIds": ["string.map_tokens"]}, {"id": "to_bool_true_eq_tt", "parentIds": ["nat.cond_to_bool_mod_two"]}, {"id": "nat.one_shiftl", "parentIds": []}, {"id": "imp_iff_right", "parentIds": []}, {"id": "tactic.interactive.congr_core'", "parentIds": []}, {"id": "tactic.apply_eq_congr_core", "parentIds": ["tactic.interactive.congr_core'", "tactic.congr_core"]}, {"id": "tactic.apply_heq_congr_core", "parentIds": ["tactic.interactive.congr_core'", "tactic.congr_core"]}, {"id": "ne_iff_lt_or_gt", "parentIds": []}, {"id": "tactic.change_with_at", "parentIds": ["tactic.interactive.change'"]}, {"id": "tactic.interactive.change", "parentIds": ["tactic.interactive.change'", "smt_tactic.interactive.change"]}, {"id": "sum.elim_inl", "parentIds": []}, {"id": "iff_eq_true_of_eq", "parentIds": []}, {"id": "smt_tactic.interactive.trace_state", "parentIds": []}, {"id": "classical.dec_rel", "parentIds": []}, {"id": "get_checks", "parentIds": ["lint", "lint_mathlib", "lint_all"]}, {"id": "tactic.has_attribute'", "parentIds": ["lint", "tactic.is_instance", "list_linters", "linter.doc_blame", "lint_mathlib", "lint_all", "has_inhabited_instance", "tactic.is_simp_lemma"]}, {"id": "declaration.is_auto_generated", "parentIds": ["lint", "lint_mathlib", "lint_all"]}, {"id": "fold_over_with_cond", "parentIds": ["lint", "fold_over_with_cond_sorted"]}, {"id": "lint_aux", "parentIds": ["lint", "lint_mathlib", "lint_all"]}, {"id": "environment.mfilter", "parentIds": ["lint", "lint_mathlib", "lint_all"]}, {"id": "native.float.fmod", "parentIds": []}, {"id": "exists_eq", "parentIds": []}, {"id": "native.float.exp", "parentIds": []}, {"id": "interaction_monad.get_result", "parentIds": ["lean.parser.of_tactic'"]}, {"id": "function.combine", "parentIds": []}, {"id": "rbnode.balance2_node", "parentIds": []}, {"id": "of_to_bool_ff", "parentIds": ["to_bool_congr"]}, {"id": "to_bool_ff_iff", "parentIds": ["of_to_bool_ff", "bool.ff_eq_to_bool_iff", "to_bool_ff"]}, {"id": "two_gt_one", "parentIds": ["two_ge_one"]}, {"id": "exceptional.has_to_string", "parentIds": []}, {"id": "exceptional.to_string", "parentIds": ["exceptional.has_to_string"]}, {"id": "local_context.lc_has_to_format", "parentIds": []}, {"id": "local_context.to_format", "parentIds": ["local_context.lc_has_to_format"]}, {"id": "nat.one_le_bit1", "parentIds": []}, {"id": "add_mul_self_eq", "parentIds": []}, {"id": "norm_num.neg_add_pos_helper2", "parentIds": []}, {"id": "tactic.returnopt", "parentIds": ["tactic.opt_to_tac"]}, {"id": "tactic.assoc_root", "parentIds": []}, {"id": "tactic.interactive.letI", "parentIds": []}, {"id": "tactic.reset_instance_cache", "parentIds": ["tactic.interactive.letI", "tactic.classical", "tactic.interactive.exactI", "tactic.interactive.haveI", "tactic.interactive.resetI", "tactic.interactive.introI", "tactic.delta_instance", "tactic.interactive.introsI"]}, {"id": "one_div_le_one_div_of_le_of_neg", "parentIds": ["lt_of_one_div_lt_one_div_of_neg", "one_div_le_neg_one"]}, {"id": "sum.inl.inj_iff", "parentIds": []}, {"id": "trace", "parentIds": ["trace_val"]}, {"id": "lt_add_of_nonneg_of_lt", "parentIds": []}, {"id": "old_conv.lhs", "parentIds": ["old_conv.trace_lhs"]}, {"id": "eq_neg_of_eq_neg", "parentIds": ["eq_neg_iff_eq_neg", "int.exists_eq_neg_of_nat"]}, {"id": "add_add_add_comm", "parentIds": []}, {"id": "array.drop", "parentIds": ["buffer.drop", "array.take_right"]}, {"id": "tactic.unsafe.type_context.monad_fail", "parentIds": []}, {"id": "tactic.unsafe.type_context.fail", "parentIds": ["tactic.unsafe.type_context.monad_fail", "tactic.unsafe.type_context.failure", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "if_simp_congr_prop", "parentIds": []}, {"id": "option_t.run_monad_map", "parentIds": []}, {"id": "option_t.monad_functor", "parentIds": ["option_t.run_monad_map"]}, {"id": "ordering.swap_or_else", "parentIds": []}, {"id": "ordering.or_else", "parentIds": ["ordering.swap_or_else", "ordering.or_else_eq_lt"]}, {"id": "ordering.swap", "parentIds": ["ordering.swap_or_else", "ordering.swap_swap", "cmp_swap"]}, {"id": "function.id_of_right_inverse", "parentIds": []}, {"id": "bex_or_distrib", "parentIds": []}, {"id": "exists_or_distrib", "parentIds": ["bex_or_distrib"]}, {"id": "dlist.to_list_append", "parentIds": []}, {"id": "dlist.append", "parentIds": ["dlist.to_list_append", "dlist.has_append"]}, {"id": "dlist.has_append", "parentIds": ["dlist.to_list_append"]}, {"id": "reader_t.is_lawful_monad", "parentIds": []}, {"id": "reader_t.pure", "parentIds": ["reader_t.is_lawful_monad", "reader_t.alternative", "reader_t.monad"]}, {"id": "reader_t.ext", "parentIds": ["reader_t.is_lawful_monad"]}, {"id": "reader_t.bind", "parentIds": ["reader_t.is_lawful_monad", "reader_t.alternative", "reader_t.monad"]}, {"id": "reader_t.run_bind", "parentIds": ["reader_t.is_lawful_monad"]}, {"id": "int.coe_nat_succ", "parentIds": ["int.coe_nat_lt_coe_nat_iff", "int.neg_succ_of_nat_lt_zero"]}, {"id": "int.lt_iff_add_one_le", "parentIds": ["int.coe_nat_lt_coe_nat_iff"]}, {"id": "cc_state.pp_eqc", "parentIds": []}, {"id": "tactic.suggest.head_symbol_match.to_string", "parentIds": []}, {"id": "push_neg.not_and_eq", "parentIds": []}, {"id": "not_and_distrib", "parentIds": ["push_neg.not_and_eq", "classical.not_and_distrib", "and_iff_not_or_not"]}, {"id": "vm_core.map", "parentIds": ["vm_core.monad"]}, {"id": "tactic.mk_congr_lemma_simp", "parentIds": ["conv.congr"]}, {"id": "congr_lemma", "parentIds": ["tactic.mk_congr_lemma_simp", "tactic.mk_specialized_congr_lemma", "tactic.apply_heq_congr_core", "tactic.apply_eq_congr_core", "tactic.apply_congr_core", "tactic.mk_specialized_congr_lemma_simp", "tactic.mk_hcongr_lemma", "conv.congr", "tactic.mk_congr_lemma"]}, {"id": "monad.sequence'", "parentIds": []}, {"id": "environment.in_current_file", "parentIds": ["environment.in_current_file'"]}, {"id": "list.mmap_filter", "parentIds": ["fold_over_with_cond"]}, {"id": "norm_num.zero_mul", "parentIds": ["norm_num.nonzero_of_div_helper"]}, {"id": "list.extractp", "parentIds": []}, {"id": "native.float.has_to_string", "parentIds": ["native.float.has_to_format"]}, {"id": "plift.down_inj", "parentIds": []}, {"id": "plift", "parentIds": ["plift.down_inj", "plift.ext", "nonempty_plift", "plift.inhabited", "plift.down_up", "plift.up_down"]}, {"id": "monad_map_refl", "parentIds": []}, {"id": "reflected.has_to_format", "parentIds": []}, {"id": "is_comm_applicative.commutative_map", "parentIds": ["comp.is_comm_applicative"]}, {"id": "map_seq", "parentIds": ["is_comm_applicative.commutative_map", "comp.seq_assoc"]}, {"id": "nat.lt_iff_le_not_le", "parentIds": ["nat.linear_order"]}, {"id": "nat.le_antisymm", "parentIds": ["nat.linear_order", "nat.lt_by_cases", "nat.decidable_linear_ordered_semiring"]}, {"id": "div_mul_left", "parentIds": []}, {"id": "option_t.orelse", "parentIds": ["option_t.alternative"]}, {"id": "tactic.instance_stub", "parentIds": []}, {"id": "tactic.expanded_field_list", "parentIds": ["tactic.instance_stub", "tactic.interactive.refine_one", "tactic.interactive.source_fields"]}, {"id": "lt_of_mul_lt_mul_right", "parentIds": []}, {"id": "tactic.mk_specialized_congr_lemma", "parentIds": ["tactic.apply_eq_congr_core"]}, {"id": "quot.lift_beta", "parentIds": []}, {"id": "decidable_of_iff'", "parentIds": ["list.decidable_pairwise"]}, {"id": "exists_of_exists_unique", "parentIds": []}, {"id": "expr.get_app_fn_args", "parentIds": ["tactic.alias.get_alias_target", "instance_priority"]}, {"id": "environment.relation_info", "parentIds": ["tactic.relation_lhs_rhs"]}, {"id": "cc_state.is_cg_root", "parentIds": []}, {"id": "imp_eq_true_of_eq", "parentIds": []}, {"id": "tactic.in_open_namespaces", "parentIds": []}, {"id": "list.any", "parentIds": ["tactic.in_open_namespaces", "list.bor", "dangerous_instance", "tactic.replacer_attr"]}, {"id": "where.get_includes_core", "parentIds": ["lean.parser.get_includes", "where.trace_includes"]}, {"id": "list.pairwise", "parentIds": ["list.nodup", "list.pairwise_cons", "list.decidable_pairwise"]}, {"id": "tactic.interactive.type_check", "parentIds": []}, {"id": "tactic.type_check", "parentIds": ["tactic.interactive.type_check"]}, {"id": "lean.parser.get_includes", "parentIds": []}, {"id": "set.functor", "parentIds": ["set.is_lawful_functor"]}, {"id": "trace_call_stack", "parentIds": ["tactic.trace_call_stack"]}, {"id": "nat.lt_of_le_of_lt", "parentIds": ["nat.le_lt_antisymm", "nat.lt_iff_le_not_le", "nat.le_antisymm"]}, {"id": "environment.is_refl_app", "parentIds": ["tactic.match_refl_app"]}, {"id": "environment.refl_for", "parentIds": ["environment.is_refl_app", "tactic.reflexivity"]}, {"id": "expr.app_arg", "parentIds": ["environment.is_refl_app", "tactic.comp_val", "expr.is_bin_arith_app", "has_inhabited_instance"]}, {"id": "int.coe_nat_mul_out", "parentIds": []}, {"id": "false_iff_true", "parentIds": []}, {"id": "tactic.set_env", "parentIds": ["tactic.updateex_env"]}, {"id": "tactic.returnex", "parentIds": ["tactic.updateex_env", "tactic.ex_to_tac"]}, {"id": "where.trace_includes", "parentIds": ["where.trace_where"]}, {"id": "smt_tactic.proof_for", "parentIds": []}, {"id": "smt_tactic.to_cc_state", "parentIds": ["smt_tactic.proof_for", "smt_tactic.get_facts", "smt_tactic.get_refuted_facts", "rsimp.collect_implied_eqs", "smt_tactic.interactive.rsimp", "smt_tactic.refutation_for"]}, {"id": "state_t.monad_except", "parentIds": []}, {"id": "state_t.lift", "parentIds": ["state_t.monad_except", "state_t.has_monad_lift"]}, {"id": "tactic.mk_iff_of_inductive_prop", "parentIds": []}, {"id": "tactic.add_theorem_by", "parentIds": ["tactic.mk_iff_of_inductive_prop"]}, {"id": "environment.recursor_of", "parentIds": ["tactic.mk_iff_of_inductive_prop"]}, {"id": "tactic.intro_lst", "parentIds": ["tactic.mk_iff_of_inductive_prop", "tactic.interactive.intros", "tactic.interactive.case", "tactic.rename'"]}, {"id": "nat.add_sub_assoc", "parentIds": ["nat.mod_add_div"]}, {"id": "int.sub_nat_nat_eq_coe", "parentIds": ["int.to_nat_sub"]}, {"id": "int.neg_succ_of_nat_eq", "parentIds": ["int.sub_nat_nat_eq_coe"]}, {"id": "int.coe_nat_one", "parentIds": ["int.sub_nat_nat_eq_coe", "int.neg_succ_of_nat_lt_zero"]}, {"id": "tactic.has_opt_auto_param", "parentIds": ["tactic.try_apply_opt_auto_param"]}, {"id": "where.get_namespace_core", "parentIds": ["lean.parser.get_namespace", "where.trace_where"]}, {"id": "tactic.simp_top_down", "parentIds": []}, {"id": "punit.inhabited", "parentIds": []}, {"id": "mul_pos", "parentIds": ["linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "nonpos_of_mul_nonpos_left", "div_pos_of_pos_of_pos", "nat.mul_self_lt_mul_self", "nonpos_of_mul_nonpos_right", "nat.div_div_eq_div_mul"]}, {"id": "tactic.trace_result", "parentIds": []}, {"id": "tactic.format_result", "parentIds": ["tactic.trace_result"]}, {"id": "tactic.iff_mp_core", "parentIds": ["tactic.iff_mp", "tactic.suggest.apply_declaration"]}, {"id": "occurrences.has_repr", "parentIds": []}, {"id": "no_rsimp", "parentIds": []}, {"id": "int.of_nat_nonneg", "parentIds": []}, {"id": "inv_image.irreflexive", "parentIds": []}, {"id": "inv_image", "parentIds": ["inv_image.irreflexive", "inv_image.accessible", "list.qsort_cons", "measure", "inv_image.wf", "inv_image.trans", "list.qsort", "list.qsort_nil"]}, {"id": "irreflexive", "parentIds": ["inv_image.irreflexive"]}, {"id": "nat.add_sub_add_right", "parentIds": ["nat.add_sub_cancel", "nat.le_of_sub_eq_zero", "nat.add_sub_add_left"]}, {"id": "functor.const.applicative", "parentIds": ["functor.const.is_lawful_applicative"]}, {"id": "tactic.suggest.replace_mvars", "parentIds": ["tactic.suggest.tactic_statement"]}, {"id": "not_of_eq_false", "parentIds": ["if_eq_of_eq_false"]}, {"id": "tactic.sleep", "parentIds": []}, {"id": "tactic.rintro", "parentIds": ["tactic.interactive.rintro"]}, {"id": "tactic.rcases.continue", "parentIds": ["tactic.rintro"]}, {"id": "or_imp_distrib", "parentIds": []}, {"id": "not_not_not_iff", "parentIds": []}, {"id": "tactic.interactive.generalize_a_aux", "parentIds": []}, {"id": "tactic.interactive.success_if_fail", "parentIds": []}, {"id": "exists_eq_mul_left_of_dvd", "parentIds": ["dvd.elim_left"]}, {"id": "false_implies_iff", "parentIds": ["string.iterator.zero_lt_length_next_to_string_of_has_next"]}, {"id": "rbmap.contains", "parentIds": []}, {"id": "rbmap.find_entry", "parentIds": ["rbmap.contains", "rbmap.find"]}, {"id": "option.decidable_exists_mem", "parentIds": []}, {"id": "native.float.sinh", "parentIds": []}, {"id": "int.one", "parentIds": ["int.comm_ring", "int.has_one"]}, {"id": "int.one_mul", "parentIds": ["int.comm_ring"]}, {"id": "int.mul_assoc", "parentIds": ["int.comm_ring"]}, {"id": "int.neg", "parentIds": ["int.comm_ring", "int.has_neg"]}, {"id": "int.mul", "parentIds": ["int.comm_ring", "int.has_mul"]}, {"id": "int.zero_add", "parentIds": ["int.comm_ring"]}, {"id": "combinator.I", "parentIds": []}, {"id": "setoid.trans", "parentIds": []}, {"id": "symmetric", "parentIds": ["setoid.trans", "equivalence", "mk_equivalence", "eq_equivalence", "setoid.symm", "setoid.refl"]}, {"id": "neg_neg_sub_neg", "parentIds": []}, {"id": "conv.funext", "parentIds": ["conv.interactive.funext"]}, {"id": "tactic.iterate", "parentIds": ["conv.funext", "tactic.interactive.iterate", "tactic.subst_vars"]}, {"id": "or.comm", "parentIds": ["false_or", "or.left_comm", "and_or_distrib_right", "imp_or_distrib", "le_iff_eq_or_lt", "or_iff_not_imp_right", "classical.iff_iff_not_or_and_or_not", "or_comm"]}, {"id": "except.monad", "parentIds": []}, {"id": "except.return", "parentIds": ["except.monad"]}, {"id": "except.bind", "parentIds": ["except.monad"]}, {"id": "left_identity", "parentIds": []}, {"id": "function.dcomp", "parentIds": []}, {"id": "tactic.suggest.match_head_symbol", "parentIds": ["tactic.suggest.process_declaration"]}, {"id": "old_conv.match_pattern", "parentIds": []}, {"id": "inv_image.accessible", "parentIds": ["inv_image.wf"]}, {"id": "list.split_on", "parentIds": ["string.split_on"]}, {"id": "list.split_on_p", "parentIds": ["list.split_on"]}, {"id": "quotient.sound", "parentIds": ["funext"]}, {"id": "where.strip_pi_binders_aux", "parentIds": ["where.strip_pi_binders"]}, {"id": "where.resolve_vars", "parentIds": ["where.strip_pi_binders"]}, {"id": "conv.interactive.done", "parentIds": []}, {"id": "plift.ext", "parentIds": []}, {"id": "strict_weak_order.etrans", "parentIds": ["strict_weak_order.is_equiv"]}, {"id": "incomp_trans", "parentIds": ["strict_weak_order.etrans", "incomp_trans_of"]}, {"id": "expr.get_pis", "parentIds": []}, {"id": "tactic.match_target_subexpr", "parentIds": []}, {"id": "format.space", "parentIds": ["format.inhabited", "tactic.interactive.rintro"]}, {"id": "forall_prop_of_false", "parentIds": []}, {"id": "int.of_nat_sub", "parentIds": ["int.coe_nat_sub"]}, {"id": "int.coe_nat_zero", "parentIds": ["int.le_antisymm", "int.lt_iff_le_and_ne"]}, {"id": "add_monoid_to_is_left_id", "parentIds": []}, {"id": "sum.has_to_string", "parentIds": []}, {"id": "tactic.constructor_idx", "parentIds": []}, {"id": "nat.div_le_of_le_mul", "parentIds": ["nat.div_le_self"]}, {"id": "le_of_mul_le_mul_left", "parentIds": ["nat.div_le_of_le_mul", "nat.eq_of_mul_eq_mul_left"]}, {"id": "string.iterator.next_to_string_mk_iterator", "parentIds": []}, {"id": "environment.inductive_type_of", "parentIds": ["tactic.constructor_num_fields", "tactic.interactive.case"]}, {"id": "tactic.get_pi_arity", "parentIds": ["tactic.constructor_num_fields", "tactic.get_arity"]}, {"id": "mk_fin_val_ne_proof", "parentIds": ["tactic.comp_val"]}, {"id": "tactic.clear_aux_decl_aux", "parentIds": ["tactic.clear_aux_decl"]}, {"id": "option.eq_none_of_is_none", "parentIds": ["option.is_none_iff_eq_none"]}, {"id": "mul_right_surjective", "parentIds": []}, {"id": "option_t.monad_map", "parentIds": ["option_t.monad_functor"]}, {"id": "add_eq_zero_iff_neg_eq", "parentIds": ["neg_eq_iff_add_eq_zero"]}, {"id": "add_eq_zero_iff_eq_neg", "parentIds": ["add_eq_zero_iff_neg_eq", "eq_neg_iff_add_eq_zero", "add_neg_eq_zero"]}, {"id": "rbnode.color.decidable_eq", "parentIds": []}, {"id": "rbnode.color", "parentIds": ["rbnode.color.decidable_eq", "rbnode.color.inhabited", "rbnode.mk_insert_result", "rbnode.get_color"]}, {"id": "and.left_comm", "parentIds": ["and.rotate", "and.right_comm"]}, {"id": "combinator.S", "parentIds": []}, {"id": "lt_of_incomp_of_lt", "parentIds": []}, {"id": "incomp_trans_of", "parentIds": ["lt_of_incomp_of_lt", "lt_of_lt_of_incomp"]}, {"id": "where.collect_by_aux", "parentIds": ["where.collect_by"]}, {"id": "le_of_eq_or_lt", "parentIds": []}, {"id": "interaction_monad_return", "parentIds": ["interaction_monad.monad"]}, {"id": "nat.add_lt_add_left", "parentIds": ["nat.lt_add_of_pos_right", "nat.lt_add_of_zero_lt_left", "nat.add_lt_add_right"]}, {"id": "linear_ordered_comm_ring", "parentIds": ["linear_ordered_comm_ring.to_linear_ordered_ring", "decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring", "linear_ordered_comm_ring.to_integral_domain", "linear_ordered_comm_ring.to_comm_monoid"]}, {"id": "mk_hinst_lemma_attr_from_simp_attr", "parentIds": []}, {"id": "get_name_set_for_attr", "parentIds": ["mk_hinst_lemma_attr_from_simp_attr", "rsimp_attr"]}, {"id": "psigma.rev_lex_accessible", "parentIds": []}, {"id": "reader_t.monad_reader_adapter", "parentIds": []}, {"id": "tactic.unprime", "parentIds": ["tactic.replaceable_attr"]}, {"id": "list.take_while", "parentIds": ["tactic.unprime"]}, {"id": "lean.parser_result", "parentIds": []}, {"id": "tactic.interactive.rw_rule_p", "parentIds": ["tactic.interactive.rw_rules"]}, {"id": "lean.parser.cur_pos", "parentIds": ["tactic.interactive.rw_rule_p", "tactic.interactive.rw_rules"]}, {"id": "mul_sub_mul_div_mul_neg", "parentIds": []}, {"id": "sub_lt_sub_right", "parentIds": ["mul_sub_mul_div_mul_neg"]}, {"id": "or.neg_resolve_left", "parentIds": ["imp_iff_not_or"]}, {"id": "old_conv.funext", "parentIds": []}, {"id": "expr.abstract", "parentIds": ["old_conv.funext"]}, {"id": "native.float.frexp", "parentIds": ["native.float.mantissa"]}, {"id": "quot.lift_on", "parentIds": ["quotient.lift_on"]}, {"id": "tactic.interactive.refine_struct", "parentIds": []}, {"id": "tactic.interactive.refine_recursively", "parentIds": ["tactic.interactive.refine_struct"]}, {"id": "tactic.interactive.collect_struct", "parentIds": ["tactic.interactive.refine_struct", "tactic.interactive.refine_one"]}, {"id": "rbmap.insert", "parentIds": ["rbmap.from_list"]}, {"id": "not_le_of_lt", "parentIds": []}, {"id": "anti_symmetric", "parentIds": []}, {"id": "parser.many1", "parentIds": ["parser.many_char1"]}, {"id": "eq_inv_mul_iff_mul_eq", "parentIds": []}, {"id": "mul_inv_cancel_left", "parentIds": ["eq_inv_mul_iff_mul_eq", "mul_eq_of_eq_inv_mul", "mul_left_surjective", "eq_mul_of_inv_mul_eq", "inv_mul_eq_iff_eq_mul"]}, {"id": "inv_mul_cancel_left", "parentIds": ["eq_inv_mul_iff_mul_eq", "group.mul_left_cancel", "inv_comm_of_comm", "eq_inv_mul_of_mul_eq", "inv_mul_eq_of_eq_mul", "inv_mul_eq_iff_eq_mul"]}, {"id": "nat.sub_pos_of_lt", "parentIds": ["nat.mul_sub_div"]}, {"id": "tactic.interactive.elide", "parentIds": []}, {"id": "int.of_nat_nat_abs_eq_of_nonneg", "parentIds": ["int.ne_of_nat_abs_ne_nat_abs_of_nonneg"]}, {"id": "tactic.interactive.repeat", "parentIds": []}, {"id": "and_implies", "parentIds": []}, {"id": "eq_one_div_of_mul_eq_one_left", "parentIds": ["division_ring.one_div_one_div"]}, {"id": "cc_state.eqc_size", "parentIds": []}, {"id": "cc_state.eqc_of", "parentIds": ["cc_state.eqc_size", "smt_tactic.get_facts", "smt_tactic.get_refuted_facts"]}, {"id": "fun_info.has_to_format", "parentIds": []}, {"id": "fun_info_to_format", "parentIds": ["fun_info.has_to_format"]}, {"id": "array.write'", "parentIds": ["buffer.write_eq_write'", "array.write_eq_write'"]}, {"id": "tactic.interactive.rec.to_tactic_format", "parentIds": ["tactic.interactive.parse_config"]}, {"id": "pexpr.get_structure_instance_info", "parentIds": ["tactic.interactive.rec.to_tactic_format"]}, {"id": "mzip_with", "parentIds": ["tactic.interactive.rec.to_tactic_format", "tactic.interactive.refine_one"]}, {"id": "environment.trans_for", "parentIds": ["tactic.transitivity"]}, {"id": "tactic.mllist.filter", "parentIds": []}, {"id": "tactic.is_type_app_of", "parentIds": []}, {"id": "user_attribute.dflt_cache_cfg", "parentIds": []}, {"id": "norm_num.neg_zero_helper", "parentIds": []}, {"id": "mul_self_le_mul_self", "parentIds": ["mul_self_le_mul_self_iff"]}, {"id": "nonneg_le_nonneg_of_squares_le", "parentIds": ["mul_self_le_mul_self_iff", "abs_abs_sub_abs_le_abs_sub"]}, {"id": "add_self_iff_eq_zero", "parentIds": []}, {"id": "add_left_inj", "parentIds": ["add_self_iff_eq_zero", "sub_left_inj"]}, {"id": "tactic.classical", "parentIds": ["tactic.interactive.classical"]}, {"id": "tactic.interactive.guard_hyp_strict", "parentIds": []}, {"id": "neg_mul_comm", "parentIds": []}, {"id": "add_div_eq_mul_add_div", "parentIds": []}, {"id": "string.inhabited", "parentIds": ["fold_over_with_cond_sorted"]}, {"id": "int.bitwise", "parentIds": []}, {"id": "tactic.simp_config.inhabited", "parentIds": []}, {"id": "nat.mul_mod_mul_left", "parentIds": ["nat.mul_mod_mul_right"]}, {"id": "nat.mul_sub_left_distrib", "parentIds": ["nat.mul_mod_mul_left", "nat.dvd_add_iff_right", "nat.mul_self_sub_mul_self_eq"]}, {"id": "nat.mod_zero", "parentIds": ["nat.mul_mod_mul_left", "nat.mod_le", "nat.gcd_rec", "nat.gcd_def"]}, {"id": "bool.dichotomy", "parentIds": []}, {"id": "format.inhabited", "parentIds": ["tactic.success_if_fail_with_msg"]}, {"id": "int.ne_neg_of_ne", "parentIds": []}, {"id": "ne_comm", "parentIds": []}, {"id": "smt_tactic.add_ematch_lhs_lemma", "parentIds": []}, {"id": "tactic.interactive.obtain_parse", "parentIds": ["tactic.interactive.obtain"]}, {"id": "tactic.interactive.unfold_aux", "parentIds": []}, {"id": "name_set.empty", "parentIds": ["tactic.interactive.unfold_aux"]}, {"id": "expr.list_names_with_prefix", "parentIds": ["tactic.interactive.unfold_aux"]}, {"id": "list.mem_append_right", "parentIds": ["list.subset_append_right"]}, {"id": "norm_num.sub_nat_zero_helper", "parentIds": []}, {"id": "tactic.interactive.ext1", "parentIds": []}, {"id": "tactic.ext1", "parentIds": ["tactic.interactive.ext1", "tactic.interactive.ext"]}, {"id": "array.read_write", "parentIds": []}, {"id": "bool.of_to_bool_iff", "parentIds": ["bool.tt_eq_to_bool_iff", "bool.to_bool_eq"]}, {"id": "of_to_bool_true", "parentIds": ["bool.of_to_bool_iff", "to_bool_congr"]}, {"id": "to_bool_true", "parentIds": ["bool.of_to_bool_iff", "to_bool_congr", "to_bool_tt"]}, {"id": "fish_pipe", "parentIds": []}, {"id": "list.remove_all", "parentIds": []}, {"id": "pi.subsingleton", "parentIds": []}, {"id": "list.rotate'", "parentIds": []}, {"id": "string.split_on", "parentIds": []}, {"id": "vm_decl.arity", "parentIds": []}, {"id": "not.intro", "parentIds": []}, {"id": "lean.parser.of_tactic'", "parentIds": ["lean.parser.has_coe'"]}, {"id": "tactic.interactive.guard_hyp_nums", "parentIds": []}, {"id": "quot.ind_beta", "parentIds": []}, {"id": "true.inhabited", "parentIds": []}, {"id": "tactic.get_lift_prf", "parentIds": ["tactic.lift"]}, {"id": "option.decidable_eq", "parentIds": ["tactic.lift", "tactic.interactive.field", "tactic.interactive.h_generalize"]}, {"id": "tactic.has_append", "parentIds": ["tactic.lift", "tactic.interactive.extract_goal", "tactic.get_lift_prf"]}, {"id": "option.get", "parentIds": ["tactic.lift", "option.eq_some_of_is_some", "tactic.suggest", "tactic.get_lift_prf"]}, {"id": "tactic.interactive.rw_rules_t", "parentIds": ["tactic.lift", "conv.interactive.rw", "tactic.interactive.simp_rw", "tactic.interactive.rw_rules_t.has_reflect", "tactic.interactive.erw", "tactic.interactive.assoc_rw", "tactic.interactive.erewrite", "tactic.interactive.assoc_rewrite", "conv.interactive.erw", "conv.interactive.rewrite", "tactic.interactive.rwa", "tactic.interactive.rw_rules", "tactic.interactive.rw", "tactic.interactive.rewrite"]}, {"id": "tactic.pformat", "parentIds": ["tactic.lift", "tactic.interactive.extract_goal", "tactic.pformat.has_to_tactic_format", "tactic.get_lift_prf", "tactic.has_append", "tactic.to_pfmt"]}, {"id": "list.nth_le", "parentIds": ["tactic.lift", "list.to_array"]}, {"id": "tactic.interactive.rw", "parentIds": ["tactic.lift"]}, {"id": "fin.has_add", "parentIds": ["fin.add_def"]}, {"id": "fin.add", "parentIds": ["fin.has_add", "fin.add_def", "unsigned.has_add"]}, {"id": "tactic.simp_intros_config", "parentIds": ["tactic.simp_intros", "tactic.interactive.simp_intros", "tactic.simp_intros_config.inhabited"]}, {"id": "list.permutations", "parentIds": []}, {"id": "list.permutations_aux", "parentIds": ["list.permutations"]}, {"id": "expr.mk_delayed_abstraction", "parentIds": []}, {"id": "tactic.add_aux_decl", "parentIds": ["tactic.abstract"]}, {"id": "tactic.num_goals", "parentIds": ["tactic.abstract", "tactic.fail_if_no_goals", "tactic.rotate_right", "conv.convert", "tactic.done"]}, {"id": "tactic.zeta", "parentIds": ["tactic.abstract"]}, {"id": "bool.coe_sort_ff", "parentIds": ["bool.not_ff"]}, {"id": "bool.ff_ne_tt", "parentIds": ["bool.coe_sort_ff"]}, {"id": "tactic.interactive.iterate", "parentIds": []}, {"id": "tactic.iterate_exactly", "parentIds": ["tactic.interactive.iterate"]}, {"id": "environment.import_dependencies", "parentIds": ["environment.import'", "environment.import_until_decl"]}, {"id": "tactic.unsafe.type_context.mk_mvar", "parentIds": []}, {"id": "function.uncurry_bicompr", "parentIds": []}, {"id": "int.lt_irrefl", "parentIds": ["int.add_lt_add_left", "int.ne_of_lt"]}, {"id": "iff_of_true", "parentIds": ["iff_true_left"]}, {"id": "option.rhoare", "parentIds": []}, {"id": "classical.dec_eq", "parentIds": []}, {"id": "list.map_id", "parentIds": ["list.is_lawful_monad"]}, {"id": "gt_irrefl", "parentIds": []}, {"id": "tactic.interactive.rintros", "parentIds": []}, {"id": "tactic.interactive.rintro", "parentIds": ["tactic.interactive.rintros"]}, {"id": "tactic.interactive.squeeze_simpa", "parentIds": []}, {"id": "tactic.interactive.simpa", "parentIds": ["tactic.interactive.squeeze_simpa"]}, {"id": "copy_decl_updating_type", "parentIds": []}, {"id": "declaration.update_type", "parentIds": ["copy_decl_updating_type", "copy_decl_using", "declaration.update_with_fun"]}, {"id": "declaration.update_name", "parentIds": ["copy_decl_updating_type", "copy_decl_using", "declaration.update_with_fun"]}, {"id": "declaration.update_value", "parentIds": ["copy_decl_updating_type", "declaration.update_with_fun"]}, {"id": "tactic.whnf_no_delta", "parentIds": []}, {"id": "int.bit1_pos", "parentIds": ["int.bit1_nonneg"]}, {"id": "add_nonneg", "parentIds": ["int.bit1_pos", "norm_num.nonneg_bit0_helper", "int.bit0_nonneg"]}, {"id": "prod.swap_swap", "parentIds": ["prod.swap_swap_eq", "prod.swap_left_inverse", "prod.swap_right_inverse"]}, {"id": "prod.swap", "parentIds": ["prod.swap_swap", "prod.swap_swap_eq", "prod.fst_swap", "prod.swap_left_inverse", "prod.snd_swap", "prod.swap_prod_mk", "prod.swap_right_inverse"]}, {"id": "tactic.interactive.try_for", "parentIds": []}, {"id": "tactic.interactive.admit", "parentIds": ["tactic.interactive.try_for"]}, {"id": "tactic.ematch_all_core", "parentIds": ["tactic.ematch_all"]}, {"id": "algebra.sub", "parentIds": ["add_group_has_sub"]}, {"id": "quot.exists_rep", "parentIds": ["quotient.exists_rep"]}, {"id": "quot.induction_on", "parentIds": ["quot.exists_rep", "quotient.induction_on"]}, {"id": "conv.dsimp", "parentIds": ["conv.interactive.dsimp"]}, {"id": "conv.change", "parentIds": ["conv.dsimp", "conv.whnf", "conv.interactive.change"]}, {"id": "level.has_to_format", "parentIds": ["tactic.has_to_tactic_format"]}, {"id": "level.to_format", "parentIds": ["level.has_to_format"]}, {"id": "int.add_lt_add_left", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "int.lt_iff_le_and_ne", "parentIds": ["int.add_lt_add_left", "int.lt_iff_le_not_le"]}, {"id": "int.add_le_add_left", "parentIds": ["int.add_lt_add_left", "int.decidable_linear_ordered_comm_ring"]}, {"id": "not_iff", "parentIds": []}, {"id": "not_iff_self", "parentIds": ["not_iff"]}, {"id": "function.uncurry'_curry", "parentIds": []}, {"id": "string.iterator.extract_core", "parentIds": []}, {"id": "group.to_right_cancel_semigroup", "parentIds": ["mul_eq_one_iff_eq_inv", "mul_left_eq_self"]}, {"id": "mul_left_inv", "parentIds": ["mul_eq_one_iff_eq_inv", "mul_right_inv", "inv_mul_cancel_left", "inv_mul_self", "inv_inv", "inv_eq_of_mul_eq_one", "inv_mul_cancel_right"]}, {"id": "le_add_of_neg_le_sub_left", "parentIds": []}, {"id": "le_add_of_neg_add_le_left", "parentIds": ["le_add_of_neg_le_sub_left"]}, {"id": "linter.dup_namespace", "parentIds": []}, {"id": "dup_namespace", "parentIds": ["linter.dup_namespace"]}, {"id": "ordering.has_repr", "parentIds": []}, {"id": "nat.mul_self_lt_mul_self_iff", "parentIds": []}, {"id": "tactic.assert_core", "parentIds": ["tactic.assert", "smt_tactic.assert"]}, {"id": "nat.coprime", "parentIds": []}, {"id": "tactic.successes", "parentIds": ["tactic.case_bash", "tactic.injections_and_clear"]}, {"id": "monad.sequence", "parentIds": ["tactic.successes"]}, {"id": "tactic.try_core", "parentIds": ["tactic.successes", "expr.is_eta_expansion_aux", "tactic.try", "tactic.interactive.replace", "tactic.alias.get_alias_target"]}, {"id": "neg_add_eq_iff_eq_add", "parentIds": []}, {"id": "nat.mod_le", "parentIds": []}, {"id": "lt_or_ge", "parentIds": ["nat.mod_le", "lt_or_le", "nat.mod_pow_succ", "nat.le_div_iff_mul_le", "le_or_gt"]}, {"id": "tactic.interactive.simp_core_aux", "parentIds": ["tactic.interactive.simp_core"]}, {"id": "tactic.simp_target", "parentIds": ["tactic.interactive.simp_core_aux", "tactic.reduce_ifs_at"]}, {"id": "list.sublists", "parentIds": []}, {"id": "list.sublists_aux", "parentIds": ["list.sublists"]}, {"id": "nat.nat.lt_asymm", "parentIds": []}, {"id": "sum.lex_wf", "parentIds": []}, {"id": "sum.lex_acc_inl", "parentIds": ["sum.lex_wf"]}, {"id": "lt_add_of_neg_lt_sub_left", "parentIds": []}, {"id": "comp.run_seq", "parentIds": ["comp.pure_seq_eq_map", "comp.seq_pure", "comp.seq_assoc"]}, {"id": "psum.inhabited_right", "parentIds": []}, {"id": "functor.add_const.functor", "parentIds": ["functor.add_const.is_lawful_functor"]}, {"id": "tactic.fail_if_success", "parentIds": ["tactic.interactive.fail_if_success"]}, {"id": "buffer.has_to_tactic_format", "parentIds": []}, {"id": "buffer.to_list", "parentIds": ["buffer.has_to_tactic_format", "buffer.has_repr", "buffer.has_to_format", "parser.char_buf"]}, {"id": "nat.add_le_add_left", "parentIds": ["nat.add_le_add_right", "nat.decidable_linear_ordered_semiring", "nat.add_lt_add_left"]}, {"id": "string.iterator.zero_lt_length_next_to_string_of_has_next", "parentIds": []}, {"id": "true_implies_iff", "parentIds": ["string.iterator.zero_lt_length_next_to_string_of_has_next"]}, {"id": "coe_sort_ff", "parentIds": ["string.iterator.zero_lt_length_next_to_string_of_has_next"]}, {"id": "coe_sort_tt", "parentIds": ["string.iterator.zero_lt_length_next_to_string_of_has_next"]}, {"id": "nat.gcd.induction", "parentIds": []}, {"id": "well_founded.induction", "parentIds": ["nat.gcd.induction"]}, {"id": "add_semigroup_to_is_eq_associative", "parentIds": []}, {"id": "quot.rec_on_subsingleton", "parentIds": ["quotient.rec_on_subsingleton"]}, {"id": "id.map_eq", "parentIds": []}, {"id": "classical.not_ball", "parentIds": []}, {"id": "not_ball", "parentIds": ["classical.not_ball"]}, {"id": "tactic.def_replacer_cmd", "parentIds": []}, {"id": "tactic.def_replacer", "parentIds": ["tactic.def_replacer_cmd", "tactic.replaceable_attr"]}, {"id": "int.of_nat_mul", "parentIds": []}, {"id": "rbtree.insert", "parentIds": ["rbtree.from_list", "rbmap.insert"]}, {"id": "tactic.trace_error", "parentIds": []}, {"id": "classical.exists_cases", "parentIds": []}, {"id": "tactic.mk_patterns", "parentIds": ["tactic.eqn_stub", "tactic.match_stub"]}, {"id": "nat.mul_div_cancel'", "parentIds": ["nat.div_mul_cancel"]}, {"id": "nat.eq_zero_of_mul_eq_zero", "parentIds": []}, {"id": "lint_all_cmd", "parentIds": []}, {"id": "lint_all", "parentIds": ["lint_all_cmd"]}, {"id": "left_cancelative", "parentIds": []}, {"id": "cc_state.eqc_of_core", "parentIds": ["cc_state.eqc_of"]}, {"id": "format.flatten", "parentIds": []}, {"id": "int.add_semigroup", "parentIds": ["int.le_antisymm", "int.le_trans", "int.add_le_add_left", "int.lt.dest"]}, {"id": "add_sub_add_right_eq_sub", "parentIds": []}, {"id": "sub_add_eq_sub_sub_swap", "parentIds": ["add_sub_add_right_eq_sub"]}, {"id": "sizeof_measure", "parentIds": ["has_well_founded_of_has_sizeof", "sizeof_measure_wf"]}, {"id": "measure", "parentIds": ["sizeof_measure", "measure_wf"]}, {"id": "tactic.generalizes", "parentIds": []}, {"id": "mul_eq_of_eq_inv_mul", "parentIds": []}, {"id": "nat.pos_of_dvd_of_pos", "parentIds": ["nat.eq_one_of_dvd_one"]}, {"id": "tactic.istep", "parentIds": ["conv.istep"]}, {"id": "list.mmap_accuml", "parentIds": []}, {"id": "tactic.mk_replacer\u2082", "parentIds": ["tactic.mk_replacer"]}, {"id": "conv.interactive.trace_lhs", "parentIds": []}, {"id": "tactic.interactive.clear", "parentIds": []}, {"id": "smt_tactic.focus1", "parentIds": []}, {"id": "pos.decidable_eq", "parentIds": ["lean.parser.parser_orelse"]}, {"id": "function.injective_of_partial_inv", "parentIds": []}, {"id": "array.pop_back_idx", "parentIds": []}, {"id": "tactic.alias.get_lambda_body", "parentIds": ["tactic.alias.get_alias_target"]}, {"id": "tactic.interactive.injection", "parentIds": []}, {"id": "tactic.injection_with", "parentIds": ["tactic.interactive.injection", "tactic.injection"]}, {"id": "tactic.interactive.assumption", "parentIds": ["tactic.interactive.injection", "tactic.interactive.simpa", "tactic.interactive.rwa", "tactic.interactive.injections", "tactic.mk_inj_eq"]}, {"id": "expr.is_gt", "parentIds": ["tactic.comp_val"]}, {"id": "conv.whnf", "parentIds": ["conv.interactive.whnf"]}, {"id": "smt_tactic.mk_ematch_eqn_lemmas_for_core", "parentIds": ["smt_tactic.add_ematch_eqn_lemmas_for_core"]}, {"id": "nat.div_eq_of_eq_mul_right", "parentIds": []}, {"id": "expr.is_false", "parentIds": ["smt_tactic.by_contradiction"]}, {"id": "name.append_suffix", "parentIds": []}, {"id": "list.map_cons", "parentIds": []}, {"id": "vm.call_stack_var_range", "parentIds": []}, {"id": "list.indexes_of", "parentIds": []}, {"id": "list.find_indexes", "parentIds": ["list.indexes_of"]}, {"id": "smt_tactic.alternative", "parentIds": ["rsimp.collect_implied_eqs", "smt_tactic.by_contradiction", "smt_tactic.by_cases", "smt_tactic.interactive.guard_expr_eq"]}, {"id": "state_t.alternative", "parentIds": ["smt_tactic.alternative"]}, {"id": "int.coe_nat_add_one_out", "parentIds": []}, {"id": "nat.mod_eq_zero_of_dvd", "parentIds": ["nat.mul_div_cancel'", "nat.dvd_iff_mod_eq_zero"]}, {"id": "inv_ne_one", "parentIds": []}, {"id": "inv_eq_one", "parentIds": ["inv_ne_one"]}, {"id": "int.le_antisymm", "parentIds": ["int.decidable_linear_ordered_comm_ring", "int.lt_iff_le_not_le"]}, {"id": "print_decls_sorted_mathlib", "parentIds": ["lint_mathlib"]}, {"id": "norm_num.bit0_add_bit1_helper", "parentIds": []}, {"id": "imp_congr", "parentIds": ["imp_congr_eq", "iff_congr", "exists_unique_congr"]}, {"id": "subtype.exists_of_subtype", "parentIds": []}, {"id": "list.is_suffix", "parentIds": []}, {"id": "int.div2", "parentIds": []}, {"id": "tactic.transparency.inhabited", "parentIds": []}, {"id": "doc_blame_report_defn", "parentIds": ["linter.doc_blame"]}, {"id": "string.has_sizeof", "parentIds": ["print_item_crawl"]}, {"id": "pos_of_mul_pos_right", "parentIds": []}, {"id": "environment.implicit_infer_kind", "parentIds": ["environment.intro_rule", "environment.implicit_infer_kind.inhabited"]}, {"id": "pos_line", "parentIds": ["print_item_crawl"]}, {"id": "eq_tt_eq_not_eq_ff", "parentIds": ["eq_tt_of_not_eq_ff"]}, {"id": "tactic.interactive.existsi", "parentIds": []}, {"id": "list.mem_cons_self", "parentIds": ["list.bex_cons", "list.ball_cons"]}, {"id": "tactic.fapply", "parentIds": ["tactic.interactive.fapply"]}, {"id": "mul_left_eq_self", "parentIds": []}, {"id": "except_t.run_map", "parentIds": ["except_t.is_lawful_monad"]}, {"id": "except_t.bind_cont", "parentIds": ["except_t.run_map", "except_t.is_lawful_monad", "except_t.run_bind", "except_t.bind"]}, {"id": "except.map", "parentIds": ["except_t.run_map", "except_t.is_lawful_monad"]}, {"id": "int.eq_one_of_mul_eq_self_left", "parentIds": []}, {"id": "int.monoid", "parentIds": ["int.eq_one_of_mul_eq_self_left", "int.semigroup", "int.sign_mul_nat_abs", "int.eq_one_of_mul_eq_self_right"]}, {"id": "mul_right_comm", "parentIds": []}, {"id": "tactic.apply_at_aux", "parentIds": ["tactic.apply_at"]}, {"id": "tactic.mllist.fix", "parentIds": ["tactic.mllist.range"]}, {"id": "int.sign_eq_one_iff_pos", "parentIds": []}, {"id": "int.sign_eq_one_of_pos", "parentIds": ["int.sign_eq_one_iff_pos"]}, {"id": "int.pos_of_sign_eq_one", "parentIds": ["int.sign_eq_one_iff_pos"]}, {"id": "state_t.run_monad_lift", "parentIds": []}, {"id": "tactic.unsafe.type_context.assign", "parentIds": []}, {"id": "zero_div", "parentIds": ["one_div_div"]}, {"id": "tactic.rewrite_hyp", "parentIds": []}, {"id": "tactic.replace_hyp", "parentIds": ["tactic.rewrite_hyp", "tactic.assoc_rewrite_hyp", "tactic.simp_hyp", "push_neg.push_neg_at_hyp"]}, {"id": "list.nodup", "parentIds": ["instance_priority", "list.nodup_decidable"]}, {"id": "decidable.rec_on_false", "parentIds": []}, {"id": "nat.lt_add_of_zero_lt_left", "parentIds": []}, {"id": "asymm_of", "parentIds": []}, {"id": "local_context.to_list", "parentIds": ["local_context.to_format"]}, {"id": "local_context.fold", "parentIds": ["local_context.to_list"]}, {"id": "abs_of_nonpos", "parentIds": ["abs_nonneg", "abs_mul", "abs_of_neg", "int.abs_eq_nat_abs", "abs_by_cases"]}, {"id": "decidable_lt_of_decidable_le", "parentIds": []}, {"id": "tactic.transport_with_prefix_dict", "parentIds": []}, {"id": "lean.parser.get_namespace", "parentIds": []}, {"id": "tc.wf", "parentIds": []}, {"id": "string.str_ne_str_right", "parentIds": []}, {"id": "list.decidable_chain", "parentIds": ["list.decidable_chain'"]}, {"id": "exists_eq_mul_right_of_dvd", "parentIds": []}, {"id": "state_t.run_get", "parentIds": []}, {"id": "state_t.get", "parentIds": ["state_t.run_get", "get"]}, {"id": "tactic.match_heq", "parentIds": ["tactic.apply_heq_congr_core"]}, {"id": "lift_pair", "parentIds": []}, {"id": "rec_heq_of_heq", "parentIds": []}, {"id": "true_eq_false_of_false", "parentIds": []}, {"id": "not_lt_iff_eq_or_lt", "parentIds": []}, {"id": "le_iff_eq_or_lt", "parentIds": ["not_lt_iff_eq_or_lt"]}, {"id": "sum.inhabited_right", "parentIds": []}, {"id": "functor.comp.functor_id_comp", "parentIds": []}, {"id": "functor.comp.is_lawful_functor", "parentIds": ["functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "comp.is_lawful_applicative"]}, {"id": "id.is_lawful_monad", "parentIds": ["functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "comp.applicative_id_comp", "comp.applicative_comp_id"]}, {"id": "functor.ext", "parentIds": ["functor.comp.functor_id_comp", "functor.comp.functor_comp_id", "applicative.ext"]}, {"id": "list.indexes_values", "parentIds": ["incorrect_type_class_argument", "dangerous_instance"]}, {"id": "list.indexes_values_aux", "parentIds": ["list.indexes_values"]}, {"id": "option.to_monad", "parentIds": ["tactic.interactive.case"]}, {"id": "tactic.interactive.suffices", "parentIds": []}, {"id": "tactic.interactive.have", "parentIds": ["tactic.interactive.suffices", "tactic.interactive.haveI", "tactic.interactive.replace"]}, {"id": "bool.band_elim_left", "parentIds": []}, {"id": "forall_prop_decidable", "parentIds": ["bool.band_elim_left", "bool.eq_tt_of_bnot_eq_ff", "bool.eq_tt_of_ne_ff", "bool.eq_ff_of_bnot_eq_tt", "bool.eq_ff_of_ne_tt", "bool.band_intro", "bool.band_elim_right"]}, {"id": "norm_num.nonneg_bit1_helper", "parentIds": []}, {"id": "native.float.log", "parentIds": []}, {"id": "nat.div", "parentIds": ["nat.has_div"]}, {"id": "function.injective_surj_inv", "parentIds": []}, {"id": "lt_add_of_pos_left", "parentIds": ["div_two_lt_of_pos"]}, {"id": "buffer.lt_aux_2", "parentIds": []}, {"id": "forall_of_ball", "parentIds": []}, {"id": "left_distributive", "parentIds": []}, {"id": "or.elim3", "parentIds": []}, {"id": "quotient.induction_on", "parentIds": []}, {"id": "std.prec.arrow", "parentIds": []}, {"id": "vm_decl.idx", "parentIds": []}, {"id": "eq_iff_eq_cancel_right", "parentIds": []}, {"id": "binder_info.has_reflect", "parentIds": []}, {"id": "fin.ne_of_vne", "parentIds": []}, {"id": "fin.veq_of_eq", "parentIds": ["fin.ne_of_vne"]}, {"id": "lt_of_one_lt_div", "parentIds": []}, {"id": "lt_mul_of_gt_one_right", "parentIds": ["lt_of_one_lt_div"]}, {"id": "mul_div_cancel'", "parentIds": ["lt_of_one_lt_div", "norm_num.add_div_helper", "le_of_one_le_div"]}, {"id": "loc.to_string_aux", "parentIds": ["loc.to_string"]}, {"id": "field.div_div_div_div_eq", "parentIds": []}, {"id": "field.div_div_eq_mul_div", "parentIds": ["field.div_div_div_div_eq"]}, {"id": "char.has_to_format", "parentIds": []}, {"id": "options.has_to_format", "parentIds": []}, {"id": "int.ne_of_lt", "parentIds": ["int.lt_iff_le_and_ne"]}, {"id": "nat.succ_pred_eq_of_pos", "parentIds": ["int.lt_iff_le_and_ne", "nat.zero_pow", "nat.mul_sub_div"]}, {"id": "char.decidable_is_digit", "parentIds": ["char.decidable_is_alphanum"]}, {"id": "char.is_digit", "parentIds": ["char.decidable_is_digit", "char.is_alphanum", "char.decidable_is_alphanum"]}, {"id": "to_additive.map_namespace", "parentIds": []}, {"id": "to_additive.aux_attr", "parentIds": ["to_additive.map_namespace"]}, {"id": "eq_add_of_add_neg_eq", "parentIds": []}, {"id": "rbmap.has_mem", "parentIds": []}, {"id": "abs_mul", "parentIds": ["abs_div", "abs_abs_sub_abs_le_abs_sub", "abs_mul_self"]}, {"id": "mul_nonneg", "parentIds": ["abs_mul", "neg_of_mul_neg_right", "neg_of_mul_neg_left", "div_nonneg_of_nonneg_of_pos", "mul_self_nonneg"]}, {"id": "mul_nonpos_of_nonneg_of_nonpos", "parentIds": ["abs_mul", "pos_of_mul_pos_left", "div_nonpos_of_nonneg_of_neg"]}, {"id": "nat.one_ne_bit1", "parentIds": []}, {"id": "nat.bit1_ne_one", "parentIds": ["nat.one_ne_bit1"]}, {"id": "function.partial_inv", "parentIds": ["function.partial_inv_left", "function.partial_inv_of_injective"]}, {"id": "vm_obj.to_declaration", "parentIds": []}, {"id": "mul_le_of_le_div", "parentIds": []}, {"id": "list.revzip", "parentIds": []}, {"id": "or_iff_left_of_imp", "parentIds": []}, {"id": "expr.is_mvar", "parentIds": ["expr.list_meta_vars", "tactic.suggest.replace_mvars"]}, {"id": "implies_true_iff", "parentIds": ["nat.add_left_cancel", "state_t.is_lawful_monad", "nat.eq_zero_of_add_eq_zero_right"]}, {"id": "right_inverse", "parentIds": []}, {"id": "smt_tactic.interactive.eblast", "parentIds": []}, {"id": "smt_tactic.eblast", "parentIds": ["smt_tactic.interactive.eblast"]}, {"id": "lift_trans", "parentIds": []}, {"id": "lift", "parentIds": ["lift_trans", "lift_base"]}, {"id": "print_all_content", "parentIds": []}, {"id": "tactic.get_string_option", "parentIds": []}, {"id": "tactic.explode.may_be_proof", "parentIds": ["tactic.explode_expr"]}, {"id": "level.nonzero", "parentIds": ["tactic.explode.may_be_proof"]}, {"id": "char.is_punctuation", "parentIds": ["char.decidable_is_punctuation"]}, {"id": "expr.lower_vars", "parentIds": []}, {"id": "mzip_with'", "parentIds": []}, {"id": "tactic.mllist.squash", "parentIds": []}, {"id": "tactic.mllist.join", "parentIds": ["tactic.mllist.squash", "tactic.mllist.concat", "tactic.suggest_core"]}, {"id": "list.has_dec_eq", "parentIds": ["list.decidable_eq"]}, {"id": "conv.interactive.rw", "parentIds": ["conv.interactive.erw"]}, {"id": "tactic.interactive.rw_rules_t.has_reflect", "parentIds": ["conv.interactive.rw", "tactic.interactive.simp_rw", "tactic.interactive.erw", "tactic.interactive.assoc_rw", "tactic.interactive.erewrite", "tactic.interactive.assoc_rewrite", "conv.interactive.erw", "conv.interactive.rewrite", "tactic.interactive.rwa", "tactic.interactive.rw", "tactic.interactive.rewrite"]}, {"id": "tactic.interactive.rw_rules", "parentIds": ["conv.interactive.rw", "tactic.interactive.simp_rw", "tactic.interactive.erw", "tactic.interactive.assoc_rw", "tactic.interactive.erewrite", "tactic.interactive.assoc_rewrite", "conv.interactive.erw", "conv.interactive.rewrite", "tactic.interactive.rwa", "tactic.interactive.rw", "tactic.interactive.rewrite"]}, {"id": "to_additive.value_type.inhabited", "parentIds": []}, {"id": "option.inhabited", "parentIds": ["to_additive.value_type.inhabited"]}, {"id": "classical.dec_pred", "parentIds": []}, {"id": "interaction_monad_seq", "parentIds": ["tactic.try", "tactic.step"]}, {"id": "interaction_monad_bind", "parentIds": ["interaction_monad_seq", "interaction_monad.monad"]}, {"id": "subtype.decidable_eq", "parentIds": []}, {"id": "and_comm", "parentIds": ["exists_and_distrib_right"]}, {"id": "le_of_one_div_le_one_div_of_neg", "parentIds": []}, {"id": "function.injective_prod", "parentIds": []}, {"id": "prod.mk.inj_iff", "parentIds": ["function.injective_prod", "prod.eq_iff_fst_eq_snd_eq", "prod.ext_iff"]}, {"id": "is_right_cancel", "parentIds": []}, {"id": "unsigned.of_nat'", "parentIds": ["mk_num_name", "unsigned.reflect"]}, {"id": "smt_tactic.has_andthen", "parentIds": []}, {"id": "list.map_accumr", "parentIds": ["list.length_map_accumr"]}, {"id": "coe_sort_coe_trans", "parentIds": []}, {"id": "list.append_nil", "parentIds": ["list.is_lawful_monad", "dlist.to_list_of_list"]}, {"id": "right_distributive", "parentIds": []}, {"id": "options.fold", "parentIds": []}, {"id": "tactic.case_bash", "parentIds": []}, {"id": "functor.comp.functor_comp_id", "parentIds": []}, {"id": "declaration.in_current_file", "parentIds": []}, {"id": "left_inverse_neg", "parentIds": []}, {"id": "native.float.pi", "parentIds": []}, {"id": "tactic.rewrite_cfg.inhabited", "parentIds": []}, {"id": "tactic.elim_gen_prod", "parentIds": []}, {"id": "interactive.executor.execute_with_explicit", "parentIds": []}, {"id": "tactic.seq", "parentIds": ["tactic.by_cases", "tactic.use", "tactic.andthen_seq"]}, {"id": "name.length", "parentIds": ["tactic.suggest.process_declaration"]}, {"id": "smt_tactic.to_expr", "parentIds": ["smt_tactic.interactive.guard_expr_eq"]}, {"id": "parser.fail", "parentIds": ["parser.monad_fail"]}, {"id": "dlist.singleton", "parentIds": ["parser.fail", "dlist.to_list_singleton"]}, {"id": "tactic.unsafe.type_context.level.mk_tmp_mvar", "parentIds": []}, {"id": "neg_add_le_right_of_le_add", "parentIds": []}, {"id": "neg_add_le_left_of_le_add", "parentIds": ["neg_add_le_right_of_le_add"]}, {"id": "rsimp_attr", "parentIds": []}, {"id": "native.rb_set.contains", "parentIds": []}, {"id": "native.rb_map.contains", "parentIds": ["native.rb_set.contains", "native.rb_lmap.contains", "tactic.explode.entries.add", "tactic.rename'"]}, {"id": "norm_num.div_add_helper", "parentIds": []}, {"id": "reader_t.monad_reader", "parentIds": []}, {"id": "char.veq_of_eq", "parentIds": ["char.ne_of_vne"]}, {"id": "show_goal_cmd", "parentIds": []}, {"id": "tactic.trace_state", "parentIds": ["show_goal_cmd", "tactic.interactive.trace_state"]}, {"id": "int.zero_lt_one", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "tactic.interactive.library_search", "parentIds": []}, {"id": "bool.ff_eq_to_bool_iff", "parentIds": []}, {"id": "tactic.mk_theorem", "parentIds": ["tactic.add_theorem_by"]}, {"id": "set.has_emptyc", "parentIds": []}, {"id": "state_t.pure", "parentIds": ["state_t.alternative", "state_t.monad", "state_t.is_lawful_monad"]}, {"id": "state_t.failure", "parentIds": ["state_t.alternative"]}, {"id": "state_t.orelse", "parentIds": ["state_t.alternative"]}, {"id": "false_of_true_eq_false", "parentIds": []}, {"id": "min_comm", "parentIds": ["min_left_comm", "min_eq_right"]}, {"id": "bool.eq_tt_of_bnot_eq_ff", "parentIds": []}, {"id": "tactic.when_tracing", "parentIds": []}, {"id": "int.le", "parentIds": ["int.has_le", "int.decidable_linear_ordered_comm_ring"]}, {"id": "list.map_with_index", "parentIds": []}, {"id": "list.map_with_index_core", "parentIds": ["list.map_with_index"]}, {"id": "list.traversable", "parentIds": []}, {"id": "tactic.by_contradiction", "parentIds": ["tactic.interactive.by_contradiction"]}, {"id": "add_neg_of_neg_of_nonpos", "parentIds": []}, {"id": "tactic.mk_inhabited_instance", "parentIds": []}, {"id": "expr.pos", "parentIds": []}, {"id": "tactic.intro_core", "parentIds": ["tactic.intro"]}, {"id": "expr.is_let", "parentIds": ["tactic.intro"]}, {"id": "int.bit1_nonneg", "parentIds": []}, {"id": "tactic.explode", "parentIds": ["tactic.explode_cmd"]}, {"id": "tactic.explode_expr", "parentIds": ["tactic.explode"]}, {"id": "tactic.explode.has_to_tactic_format", "parentIds": ["tactic.explode"]}, {"id": "tactic.simp_bottom_up", "parentIds": []}, {"id": "tactic.simplify_bottom_up", "parentIds": ["tactic.simp_bottom_up", "tactic.simp_bottom_up'"]}, {"id": "prod.inhabited", "parentIds": []}, {"id": "tactic.subobject_names", "parentIds": ["tactic.get_ancestors"]}, {"id": "tactic.var_names", "parentIds": ["tactic.subobject_names"]}, {"id": "mul_inv_eq_iff_eq_mul", "parentIds": []}, {"id": "list.qsort_cons", "parentIds": []}, {"id": "list.qsort.F", "parentIds": ["list.qsort_cons", "list.qsort", "list.qsort_nil"]}, {"id": "where.resolve_vars_aux", "parentIds": ["where.resolve_vars"]}, {"id": "and_eq_of_eq_false_right", "parentIds": []}, {"id": "sub_sub", "parentIds": []}, {"id": "bool.coe_sort_tt", "parentIds": []}, {"id": "tactic.unsafe.type_context.tmp_mode", "parentIds": []}, {"id": "implies", "parentIds": ["implies.trans"]}, {"id": "tactic.decorate_ex", "parentIds": ["tactic.iterate1"]}, {"id": "is_linear_order", "parentIds": []}, {"id": "is_partial_order", "parentIds": ["is_linear_order"]}, {"id": "tactic.simp_intros_aux", "parentIds": ["tactic.simp_intros"]}, {"id": "nat.sub_lt_of_pos_le", "parentIds": ["nat.mod_pow_succ", "nat.le_div_iff_mul_le"]}, {"id": "int.has_to_string", "parentIds": []}, {"id": "classical.not_forall", "parentIds": []}, {"id": "not_forall", "parentIds": ["classical.not_forall", "push_neg.not_forall_eq"]}, {"id": "vm.call_stack_size", "parentIds": []}, {"id": "heq_of_eq_of_heq", "parentIds": []}, {"id": "heq.trans", "parentIds": ["heq_of_eq_of_heq", "heq_of_heq_of_eq"]}, {"id": "list.map\u2082", "parentIds": ["list.length_map\u2082"]}, {"id": "native.float.ceil", "parentIds": []}, {"id": "tactic.interactive.rename", "parentIds": []}, {"id": "tactic.rename", "parentIds": ["tactic.interactive.rename"]}, {"id": "tactic.rcases_patt_inverted.invert_list", "parentIds": ["tactic.rcases_parse", "tactic.interactive.obtain"]}, {"id": "native.float.remainder", "parentIds": []}, {"id": "smt_tactic.interactive.add_simp_lemmas", "parentIds": []}, {"id": "get_hinst_lemmas_for_attr", "parentIds": ["smt_tactic.interactive.add_simp_lemmas"]}, {"id": "to_bool_iff", "parentIds": ["to_bool_true", "to_bool_ff_iff", "of_to_bool_true", "bool.coe_to_bool"]}, {"id": "exceptional.return", "parentIds": ["exceptional.monad"]}, {"id": "char.decidable_is_punctuation", "parentIds": []}, {"id": "tactic.interactive.mk_paragraph_aux", "parentIds": ["tactic.interactive.mk_paragraph"]}, {"id": "cc_state.root", "parentIds": ["rsimp.rsimplify"]}, {"id": "mul_sub", "parentIds": []}, {"id": "is_left_inv", "parentIds": []}, {"id": "classical.skolem", "parentIds": []}, {"id": "classical.axiom_of_choice", "parentIds": ["classical.skolem"]}, {"id": "nat.add_mod_right", "parentIds": ["nat.add_mod_left", "nat.add_mul_mod_self_left"]}, {"id": "int.le.intro_sub", "parentIds": ["int.le.intro"]}, {"id": "tactic.new_goals.inhabited", "parentIds": []}, {"id": "exists_and_distrib_right", "parentIds": []}, {"id": "exists_and_distrib_left", "parentIds": ["exists_and_distrib_right"]}, {"id": "pexpr.is_placeholder", "parentIds": []}, {"id": "smt_tactic.add_ematch_eqn_lemmas_for", "parentIds": []}, {"id": "smt_tactic.add_ematch_eqn_lemmas_for_core", "parentIds": ["smt_tactic.add_ematch_eqn_lemmas_for"]}, {"id": "conv.solve1", "parentIds": []}, {"id": "tactic.solve1", "parentIds": ["conv.solve1", "tactic.mk_inj_eq", "tactic.interactive.case", "tactic.interactive.solve1", "tactic.solve", "derive_struct_ext_lemma"]}, {"id": "dlist.join", "parentIds": []}, {"id": "bor_tt", "parentIds": ["ff_bor", "tt_bor"]}, {"id": "rbmap.find", "parentIds": []}, {"id": "rbmap.to_value", "parentIds": ["rbmap.find"]}, {"id": "name_set.insert_list", "parentIds": []}, {"id": "not_of_not_not_not", "parentIds": []}, {"id": "not_not_intro", "parentIds": ["not_of_not_not_not", "not_not", "not_true", "decidable.not_not_iff"]}, {"id": "char.has_sizeof", "parentIds": []}, {"id": "smt_tactic.interactive.let", "parentIds": []}, {"id": "smt_tactic.define", "parentIds": ["smt_tactic.interactive.let"]}, {"id": "neg_le_sub_left_of_le_add", "parentIds": []}, {"id": "le_neg_add_of_add_le", "parentIds": ["neg_le_sub_left_of_le_add"]}, {"id": "dvd.intro_left", "parentIds": ["dvd_of_mul_left_eq"]}, {"id": "expr.reduce_let", "parentIds": []}, {"id": "smt_tactic.interactive.try", "parentIds": []}, {"id": "smt_tactic.try", "parentIds": ["smt_tactic.interactive.try", "smt_tactic.define", "rsimp.collect_implied_eqs", "smt_tactic.assert", "smt_tactic.eblast", "smt_tactic.interactive.eblast_using"]}, {"id": "nat.bit_decomp", "parentIds": []}, {"id": "nat.bit_val", "parentIds": ["nat.bit_decomp", "nat.bodd_bit", "nat.div2_bit"]}, {"id": "buffer.reverse", "parentIds": []}, {"id": "nat.le_of_add_le_add_left", "parentIds": ["nat.le_of_add_le_add_right", "nat.lt_of_add_lt_add_left", "nat.decidable_linear_ordered_semiring"]}, {"id": "trichotomous", "parentIds": ["trichotomous_of"]}, {"id": "iff_subst", "parentIds": []}, {"id": "linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "parentIds": []}, {"id": "mul_neg_of_neg_of_pos", "parentIds": ["linear_ordered_ring.eq_zero_or_eq_zero_of_mul_eq_zero", "nonneg_of_mul_nonneg_right", "div_neg_of_neg_of_pos", "pos_and_pos_or_neg_and_neg_of_mul_pos"]}, {"id": "nat.add_sub_add_left", "parentIds": ["nat.add_sub_cancel_left", "nat.sub_self_add", "nat.mul_self_sub_mul_self_eq"]}, {"id": "function.involutive.injective", "parentIds": ["function.involutive.bijective"]}, {"id": "merge_hinst_lemma_attrs", "parentIds": ["ematch", "mk_hinst_lemma_attr_set"]}, {"id": "function.inv_fun_surjective", "parentIds": []}, {"id": "list.bag_inter", "parentIds": ["well_founded_tactics.cancel_nat_add_lt"]}, {"id": "nat.bit1_ne_bit0", "parentIds": ["nat.bit0_ne_bit1"]}, {"id": "nat.bit1_succ_eq", "parentIds": ["nat.bit1_ne_bit0", "nat.one_lt_bit1"]}, {"id": "native.rb_lmap.contains", "parentIds": []}, {"id": "bool.forall_bool", "parentIds": []}, {"id": "except_t.run_monad_lift", "parentIds": []}, {"id": "except_t.has_monad_lift", "parentIds": ["except_t.run_monad_lift"]}, {"id": "tactic.unsafe.type_context.get_assignment", "parentIds": []}, {"id": "native.float.acos", "parentIds": []}, {"id": "option.eq_some_of_is_some", "parentIds": []}, {"id": "int.one_nonneg", "parentIds": []}, {"id": "functor.add_const.is_lawful_functor", "parentIds": []}, {"id": "eq_div_of_mul_eq", "parentIds": ["abs_div", "norm_num.div_eq_div_helper"]}, {"id": "add_right_cancel_semigroup", "parentIds": ["add_right_cancel", "eq_of_add_eq_add_right", "add_right_injective", "add_right_cancel_semigroup.to_add_semigroup", "add_right_inj", "add_right_cancel_iff", "ordered_cancel_comm_monoid.to_add_right_cancel_semigroup", "add_group.to_right_cancel_add_semigroup"]}, {"id": "sub_eq_zero", "parentIds": ["sub_ne_zero", "eq_iff_eq_of_sub_eq_sub"]}, {"id": "ssuperset", "parentIds": []}, {"id": "linter_attr", "parentIds": []}, {"id": "add_neg_self", "parentIds": []}, {"id": "native.float.round_error", "parentIds": []}, {"id": "tactic.relation_lhs_rhs", "parentIds": ["tactic.target_lhs_rhs"]}, {"id": "buffer.append", "parentIds": ["buffer.has_append"]}, {"id": "decidable.le_imp_le_of_lt_imp_lt", "parentIds": ["decidable.le_imp_le_iff_lt_imp_lt"]}, {"id": "mjoin_map_pure", "parentIds": []}, {"id": "nat.gcd_one_left", "parentIds": []}, {"id": "comp.applicative_id_comp", "parentIds": []}, {"id": "applicative.ext", "parentIds": ["comp.applicative_id_comp", "comp.applicative_comp_id"]}, {"id": "comp.is_lawful_applicative", "parentIds": ["comp.applicative_id_comp", "comp.is_comm_applicative", "comp.applicative_comp_id"]}, {"id": "old_conv.interactive.find", "parentIds": ["tactic.interactive.find"]}, {"id": "old_conv.interactive.itactic", "parentIds": ["old_conv.interactive.find", "tactic.interactive.find", "tactic.interactive.old_conv"]}, {"id": "tactic.interactive.simp_rw", "parentIds": []}, {"id": "list.to_format", "parentIds": ["list.has_to_format"]}, {"id": "tactic.mk_id_eq", "parentIds": ["tactic.replace_target", "tactic.mk_eq_proof"]}, {"id": "tactic.mk_id_proof", "parentIds": ["tactic.mk_id_eq"]}, {"id": "tactic.eqn_stub", "parentIds": []}, {"id": "tactic.interactive.all_goals", "parentIds": []}, {"id": "old_conv.interactive.whnf", "parentIds": []}, {"id": "old_conv.whnf", "parentIds": ["old_conv.interactive.whnf"]}, {"id": "cc_state.mk_core", "parentIds": []}, {"id": "tactic.ac_refl", "parentIds": ["tactic.interactive.ac_reflexivity", "tactic.interactive.ac_refl"]}, {"id": "int.le_sub_one_of_lt", "parentIds": []}, {"id": "le_sub_right_of_add_le", "parentIds": ["int.le_sub_one_of_lt"]}, {"id": "where.trace_opens", "parentIds": ["where.trace_where"]}, {"id": "where.get_opens", "parentIds": ["where.trace_opens"]}, {"id": "is_right_inv", "parentIds": []}, {"id": "eq_false_of_or_eq_false_right", "parentIds": []}, {"id": "option_t.monad", "parentIds": ["option_t.alternative", "option_t.run_bind", "vm.trace", "option_t.is_lawful_monad", "tactic.find_private_decl"]}, {"id": "psigma.mk_skip_left", "parentIds": []}, {"id": "empty_relation", "parentIds": ["psigma.mk_skip_left", "psigma.skip_left_wf", "empty_wf", "psigma.skip_left"]}, {"id": "psigma.skip_left", "parentIds": ["psigma.mk_skip_left", "psigma.skip_left_wf"]}, {"id": "list.find_indexes_aux", "parentIds": ["list.find_indexes"]}, {"id": "ne_of_ne_of_eq", "parentIds": []}, {"id": "gt_of_mul_lt_mul_neg_left", "parentIds": ["one_div_neg_of_neg"]}, {"id": "le_mul_of_ge_one_left", "parentIds": []}, {"id": "int.quot", "parentIds": []}, {"id": "level.of_nat", "parentIds": []}, {"id": "where.find_var", "parentIds": []}, {"id": "tactic.set_tag", "parentIds": ["tactic.set_main_tag", "tactic.interactive.concat_tags"]}, {"id": "one_div_le_of_one_div_le_of_pos", "parentIds": []}, {"id": "function.restrict_eq", "parentIds": []}, {"id": "function.restrict", "parentIds": ["function.restrict_eq"]}, {"id": "list.ret", "parentIds": ["interactive.types.pexpr_list_or_texpr", "list.monad", "list.is_lawful_monad", "tactic.interactive.rw_rules"]}, {"id": "decidable.has_to_format", "parentIds": []}, {"id": "name.is_private", "parentIds": []}, {"id": "name.head", "parentIds": ["name.is_private"]}, {"id": "bool.eq_tt_of_ne_ff", "parentIds": []}, {"id": "tactic.apply_congr_core", "parentIds": ["tactic.apply_heq_congr_core", "tactic.apply_eq_congr_core"]}, {"id": "expr.is_app", "parentIds": ["tactic.apply_heq_congr_core", "tactic.apply_eq_congr_core", "tactic.comp_val", "tactic.fold_explicit_args"]}, {"id": "tactic.mk_hcongr_lemma", "parentIds": ["tactic.apply_heq_congr_core"]}, {"id": "nat.bitwise_swap", "parentIds": []}, {"id": "nat.bitwise_zero_right", "parentIds": ["nat.bitwise_swap"]}, {"id": "function.swap", "parentIds": ["nat.bitwise_swap", "imp.swap", "forall_swap"]}, {"id": "expr.is_lambda", "parentIds": []}, {"id": "nat.has_sizeof", "parentIds": []}, {"id": "nat.bitwise_bit_aux", "parentIds": ["nat.bitwise_zero_right", "nat.bitwise_bit"]}, {"id": "tactic.explode.entries.head", "parentIds": []}, {"id": "array.take_right", "parentIds": ["buffer.take_right"]}, {"id": "tactic.lock_tactic_state", "parentIds": ["conv.discharge_eq_lhs"]}, {"id": "nat.le_of_succ_le", "parentIds": ["nat.lt_of_succ_lt", "nat.le_of_lt"]}, {"id": "tactic.merge_list", "parentIds": []}, {"id": "lt_of_sub_pos", "parentIds": ["ordered_ring.mul_lt_mul_of_pos_right", "ordered_ring.mul_lt_mul_of_pos_left"]}, {"id": "list.sublists'", "parentIds": []}, {"id": "list.sublists'_aux", "parentIds": ["list.sublists'"]}, {"id": "simps_attr", "parentIds": []}, {"id": "mk_nat_val_lt_proof", "parentIds": ["tactic.comp_val"]}, {"id": "char.ne_of_vne", "parentIds": ["char.of_nat_ne_of_ne"]}, {"id": "decidable_eq_of_decidable_le", "parentIds": []}, {"id": "options.size", "parentIds": []}, {"id": "min_add_add_right", "parentIds": []}, {"id": "min_add_add_left", "parentIds": ["min_add_add_right"]}, {"id": "eq_rec_compose", "parentIds": []}, {"id": "string.backn", "parentIds": []}, {"id": "not_ball_of_bex_not", "parentIds": ["not_ball"]}, {"id": "nat.size", "parentIds": []}, {"id": "list.subset_append_left", "parentIds": []}, {"id": "int.le_trans", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "smt_tactic.interactive.iterate", "parentIds": []}, {"id": "nat.zero_min", "parentIds": ["list.length_take", "list.length_map\u2082"]}, {"id": "nat.min_succ_succ", "parentIds": ["list.length_take", "list.length_map\u2082", "list.length_map_accumr\u2082"]}, {"id": "nat.min_zero", "parentIds": ["list.length_take", "list.length_map\u2082"]}, {"id": "tactic.unsafe.type_context.is_stuck", "parentIds": []}, {"id": "mk_hinst_lemma_attrs_core", "parentIds": ["mk_hinst_lemma_attr_set"]}, {"id": "monad.join", "parentIds": []}, {"id": "buffer.write_eq_write'", "parentIds": []}, {"id": "array.write_eq_write'", "parentIds": ["buffer.write_eq_write'"]}, {"id": "buffer.write'", "parentIds": ["buffer.write_eq_write'"]}, {"id": "hidden", "parentIds": []}, {"id": "fin.add_def", "parentIds": []}, {"id": "nat.mul_pred_left", "parentIds": ["nat.mul_pred_right", "nat.mul_sub_right_distrib"]}, {"id": "prod.eq_iff_fst_eq_snd_eq", "parentIds": []}, {"id": "tactic.match_not", "parentIds": ["tactic.by_contradiction"]}, {"id": "expr.is_not", "parentIds": ["tactic.match_not"]}, {"id": "dec_em", "parentIds": []}, {"id": "smt_tactic.interactive.add_lemma", "parentIds": []}, {"id": "buffer.append_list", "parentIds": ["buffer.append_string", "list.to_buffer"]}, {"id": "prod.has_sizeof", "parentIds": []}, {"id": "list.mfirst", "parentIds": ["tactic.interactive.clear_", "tactic.assoc_rewrite"]}, {"id": "conv.interactive.change", "parentIds": []}, {"id": "or.left_comm", "parentIds": ["imp_or_distrib"]}, {"id": "mtry", "parentIds": ["old_conv.congr_core"]}, {"id": "prod.swap_swap_eq", "parentIds": []}, {"id": "is_strict_total_order_of_decidable_linear_order", "parentIds": []}, {"id": "is_strict_total_order", "parentIds": ["is_strict_total_order_of_decidable_linear_order"]}, {"id": "group.mul_right_cancel", "parentIds": ["group.to_right_cancel_semigroup"]}, {"id": "expr.instantiate_univ_params", "parentIds": ["tactic.decl_mk_const", "instance_derive_handler"]}, {"id": "sum.lex_inl_inl", "parentIds": []}, {"id": "option.map_id", "parentIds": []}, {"id": "native.rb_map.max", "parentIds": []}, {"id": "sub_right_le_of_le_add", "parentIds": ["neg_le_sub_right_of_le_add"]}, {"id": "tactic.unsafe.type_context.is_declared", "parentIds": []}, {"id": "tactic.interactive.exactI", "parentIds": []}, {"id": "sub_ne_zero", "parentIds": []}, {"id": "fin.mul_def", "parentIds": []}, {"id": "fin.has_mul", "parentIds": ["fin.mul_def"]}, {"id": "tactic.enum_assoc_subexpr", "parentIds": ["tactic.assoc_rewrite"]}, {"id": "tactic.enum_assoc_subexpr'", "parentIds": ["tactic.enum_assoc_subexpr"]}, {"id": "reflected.has_to_pexpr", "parentIds": []}, {"id": "well_founded_tactics.is_psigma_mk", "parentIds": []}, {"id": "expr.list_meta_vars", "parentIds": ["tactic.metavariables"]}, {"id": "name_set.inhabited", "parentIds": []}, {"id": "environment.structure_fields_full", "parentIds": ["print_item_crawl", "expr.is_eta_expansion"]}, {"id": "name.from_components", "parentIds": []}, {"id": "le_sub_left_of_add_le", "parentIds": ["neg_le_sub_right_of_le_add"]}, {"id": "not_eq_of_eq_false", "parentIds": []}, {"id": "name.deinternalize_field", "parentIds": []}, {"id": "level.size", "parentIds": []}, {"id": "eq_iff_eq_of_sub_eq_sub", "parentIds": []}, {"id": "tactic.define_core", "parentIds": ["smt_tactic.define", "tactic.define"]}, {"id": "eq_iff_eq_cancel_left", "parentIds": []}, {"id": "find_cmd", "parentIds": []}, {"id": "declaration.map_value", "parentIds": ["copy_decl_using"]}, {"id": "tactic.interactive.substs", "parentIds": []}, {"id": "tactic.subst", "parentIds": ["tactic.interactive.substs", "tactic.interactive.subst", "tactic.subst_vars"]}, {"id": "sub_sub_assoc_swap", "parentIds": []}, {"id": "add_le_of_nonpos_of_le", "parentIds": []}, {"id": "nat.zero_ne_bit1", "parentIds": []}, {"id": "nat.bit1_ne_zero", "parentIds": ["nat.zero_ne_bit1", "char.zero_lt_d800"]}, {"id": "nat.dvd_add_iff_right", "parentIds": ["nat.dvd_add_iff_left"]}, {"id": "dvd_add", "parentIds": ["nat.dvd_add_iff_right", "dvd_sub", "dvd_add_iff_left"]}, {"id": "tactic.mllist.range", "parentIds": []}, {"id": "rbmap.max", "parentIds": []}, {"id": "tactic.cc_dbg", "parentIds": []}, {"id": "classical.strong_indefinite_description", "parentIds": ["classical.epsilon_spec_aux", "classical.epsilon"]}, {"id": "add_comm_semigroup_to_is_eq_commutative", "parentIds": []}, {"id": "rbnode.inhabited", "parentIds": []}, {"id": "Exists.snd", "parentIds": []}, {"id": "rsimp.explicit_size", "parentIds": ["rsimp.choose"]}, {"id": "ne_zero_of_one_div_ne_zero", "parentIds": ["pos_of_one_div_pos", "eq_of_one_div_eq_one_div", "neg_of_one_div_neg"]}, {"id": "ematch", "parentIds": []}, {"id": "ge_iff_le", "parentIds": []}, {"id": "parser.fix_core", "parentIds": ["parser.fix"]}, {"id": "int.land", "parentIds": []}, {"id": "int.eq_neg_succ_of_lt_zero", "parentIds": ["int.sign_eq_neg_one_of_neg"]}, {"id": "int.coe_zero_le", "parentIds": ["int.eq_neg_succ_of_lt_zero", "int.abs_eq_nat_abs", "int.le_nat_abs"]}, {"id": "classical.em", "parentIds": ["classical.prop_complete"]}, {"id": "option_t.pure", "parentIds": ["option_t.is_lawful_monad", "option_t.monad"]}, {"id": "list.choose", "parentIds": []}, {"id": "coe_subtype", "parentIds": ["list.choose"]}, {"id": "std.prec.max_plus", "parentIds": []}, {"id": "add_neg", "parentIds": []}, {"id": "forall_2_true_iff", "parentIds": ["forall_3_true_iff"]}, {"id": "forall_true_iff", "parentIds": ["forall_2_true_iff"]}, {"id": "forall_true_iff'", "parentIds": ["forall_2_true_iff", "forall_3_true_iff"]}, {"id": "tactic.any_hyp", "parentIds": ["tactic.subst_vars"]}, {"id": "tactic.any_hyp_aux", "parentIds": ["tactic.any_hyp"]}, {"id": "level.dedup_size_aux", "parentIds": ["level.dedup_size"]}, {"id": "control_laws_tac", "parentIds": []}, {"id": "expr.mk_var", "parentIds": []}, {"id": "set.mem", "parentIds": ["set.has_mem"]}, {"id": "binder.has_to_string", "parentIds": []}, {"id": "binder.to_string", "parentIds": ["binder.has_to_string", "binder.has_to_format"]}, {"id": "native.float.asin", "parentIds": []}, {"id": "function.comp_apply", "parentIds": []}, {"id": "lt_iff_not_ge'", "parentIds": ["not_le"]}, {"id": "nat.dvd_mod_iff", "parentIds": []}, {"id": "nat.dvd_add_iff_left", "parentIds": ["nat.dvd_mod_iff", "nat.dvd_sub"]}, {"id": "hinst_lemmas.fold", "parentIds": ["hinst_lemmas.pp"]}, {"id": "tactic.decl_mk_const", "parentIds": ["tactic.suggest.apply_declaration"]}, {"id": "unsigned.inhabited", "parentIds": []}, {"id": "subtype.inhabited", "parentIds": []}, {"id": "tactic.interactive.assumption'", "parentIds": []}, {"id": "forall_eq", "parentIds": ["forall_eq'"]}, {"id": "smt_tactic.add_ematch_lemma", "parentIds": []}, {"id": "check_unused_arguments_aux", "parentIds": ["check_unused_arguments"]}, {"id": "eq_equivalence", "parentIds": []}, {"id": "nat.dvd_sub", "parentIds": []}, {"id": "nat.le", "parentIds": ["nat.decidable_linear_ordered_semiring"]}, {"id": "bool_iff_false", "parentIds": ["to_bool_ff_iff", "bool_eq_false"]}, {"id": "decidable.le_iff_lt_or_eq", "parentIds": []}, {"id": "list.has_emptyc", "parentIds": []}, {"id": "native.rb_set.mfold", "parentIds": []}, {"id": "tactic.interactive.collect_struct'", "parentIds": ["tactic.interactive.collect_struct"]}, {"id": "occurrences.has_to_format", "parentIds": []}, {"id": "tactic.iterate1", "parentIds": ["tactic.intros1"]}, {"id": "tactic.iterate'", "parentIds": ["tactic.iterate1"]}, {"id": "rbnode.find", "parentIds": []}, {"id": "nonempty_Prop", "parentIds": []}, {"id": "subsingleton_prop", "parentIds": []}, {"id": "proof_irrel", "parentIds": ["subsingleton_prop", "decidable_eq_inr_neg"]}, {"id": "eq_of_add_eq_add_right", "parentIds": []}, {"id": "tactic.back_chaining", "parentIds": []}, {"id": "le_of_mul_le_mul_right", "parentIds": ["le_of_mul_le_of_ge_one"]}, {"id": "exists_eq_left", "parentIds": ["exists_eq_right", "exists_eq_left'"]}, {"id": "tactic.apply_under_pis", "parentIds": ["tactic.delta_instance"]}, {"id": "d_array.of_beq_aux_eq_ff", "parentIds": ["d_array.of_beq_eq_ff"]}, {"id": "ite_eq_ff_distrib", "parentIds": ["d_array.of_beq_aux_eq_ff"]}, {"id": "nat.lt_succ_of_lt", "parentIds": ["d_array.of_beq_aux_eq_ff"]}, {"id": "tactic.interactive.haveI", "parentIds": []}, {"id": "native.float.specification.radix", "parentIds": []}, {"id": "tactic.olean_doc_strings", "parentIds": ["tactic.module_doc_strings"]}, {"id": "eq_zero_of_neg_eq", "parentIds": []}, {"id": "neg_neg_of_pos", "parentIds": ["eq_zero_of_neg_eq", "sub_lt_self"]}, {"id": "string.is_suffix_of", "parentIds": []}, {"id": "list.is_suffix_of", "parentIds": ["string.is_suffix_of"]}, {"id": "eq_of_forall_ge_iff", "parentIds": []}, {"id": "native.rb_map.values", "parentIds": []}, {"id": "char.decidable_is_upper", "parentIds": ["char.decidable_is_alpha"]}, {"id": "char.is_upper", "parentIds": ["char.decidable_is_upper", "char.is_alpha", "char.decidable_is_alpha"]}, {"id": "inv_inv", "parentIds": ["mul_right_inv", "eq_inv_of_eq_inv", "inv_inj'", "inv_involutive", "inv_inj", "mul_inv_eq_one", "eq_inv_of_mul_eq_one", "left_inverse_inv"]}, {"id": "function.surjective_iff_has_right_inverse", "parentIds": []}, {"id": "smt_tactic.get_refuted_facts", "parentIds": []}, {"id": "expr.mk_false", "parentIds": ["smt_tactic.get_refuted_facts"]}, {"id": "expr.is_var", "parentIds": ["instance_priority"]}, {"id": "field.div_mul_left", "parentIds": ["one_div_add_one_div"]}, {"id": "field.div_mul_right", "parentIds": ["field.div_mul_left", "div_mul_right", "one_div_add_one_div"]}, {"id": "sub_lt_self", "parentIds": ["sub_lt_of_abs_sub_lt_left"]}, {"id": "le_of_one_div_le_one_div", "parentIds": []}, {"id": "one_div_lt_one_div_of_lt", "parentIds": ["le_of_one_div_le_one_div", "div_lt_div_of_pos_of_lt_of_pos", "one_div_le_one_div_of_le", "one_lt_one_div"]}, {"id": "not_not", "parentIds": ["not_exists_not", "or_iff_not_and_not", "and_iff_not_or_not", "push_neg.not_not_eq", "classical.not_not"]}, {"id": "by_contradiction", "parentIds": ["not_not", "not.imp_symm", "of_not_imp", "not_imp_not", "of_not_not", "imp_of_not_imp_not"]}, {"id": "bool.eq_ff_of_bnot_eq_tt", "parentIds": []}, {"id": "smt_tactic.save_info", "parentIds": []}, {"id": "push_neg.not_forall_eq", "parentIds": []}, {"id": "or.intro_left", "parentIds": []}, {"id": "tactic.mllist.concat", "parentIds": []}, {"id": "tactic.mllist.of_list", "parentIds": ["tactic.mllist.concat"]}, {"id": "dif_ctx_congr", "parentIds": ["dif_ctx_simp_congr"]}, {"id": "tactic.match_ne", "parentIds": []}, {"id": "list.lt_eq_not_ge", "parentIds": []}, {"id": "list.has_lt", "parentIds": ["list.lt_eq_not_ge", "list.has_decidable_le", "string.has_lt", "list.has_decidable_lt", "list.le", "list.le_eq_not_gt"]}, {"id": "decidable.not_not_iff", "parentIds": ["list.lt_eq_not_ge"]}, {"id": "list.has_le", "parentIds": ["list.lt_eq_not_ge", "list.has_decidable_le", "list.le_eq_not_gt"]}, {"id": "list.has_decidable_lt", "parentIds": ["list.lt_eq_not_ge", "list.has_decidable_le", "string.has_decidable_lt"]}, {"id": "tactic.higher_order_attr", "parentIds": []}, {"id": "classical.indefinite_description", "parentIds": ["classical.strong_indefinite_description", "classical.some_spec", "classical.some"]}, {"id": "rsimp.rsimplify_at", "parentIds": ["tactic.rsimp_at"]}, {"id": "set.inter", "parentIds": ["set.has_inter"]}, {"id": "buffer.has_repr", "parentIds": []}, {"id": "list.decidable_chain'", "parentIds": ["dup_namespace"]}, {"id": "sub_eq_of_eq_add", "parentIds": []}, {"id": "tactic.rcases_patt_inverted.format", "parentIds": ["tactic.rcases_patt_inverted.has_to_format"]}, {"id": "old_conv.save_info", "parentIds": []}, {"id": "has_inter", "parentIds": ["set.has_inter", "list.has_inter"]}, {"id": "tactic.list_constructors_hole", "parentIds": []}, {"id": "tactic.interactive.compact_decl_aux", "parentIds": []}, {"id": "mul_lt_of_gt_div_of_neg", "parentIds": []}, {"id": "options.get_bool", "parentIds": ["tactic.get_bool_option"]}, {"id": "tactic.dunfold_target", "parentIds": ["well_founded_tactics.unfold_wf_rel", "tactic.interactive.dunfold"]}, {"id": "tactic.dunfold_config", "parentIds": ["tactic.dunfold_target", "tactic.dunfold_hyp", "well_founded_tactics.unfold_wf_rel", "tactic.dunfold_config.inhabited", "tactic.dunfold", "tactic.interactive.dunfold"]}, {"id": "tactic.dunfold", "parentIds": ["tactic.dunfold_target", "tactic.dunfold_hyp"]}, {"id": "tactic.introv", "parentIds": ["tactic.interactive.introv"]}, {"id": "name.lex_cmp", "parentIds": []}, {"id": "ball_of_forall", "parentIds": []}, {"id": "environment.get_decl_names", "parentIds": []}, {"id": "environment.decl_map", "parentIds": ["environment.get_decl_names", "environment.get_decls"]}, {"id": "function.comp_right", "parentIds": []}, {"id": "sub_sub_sub_cancel_left", "parentIds": []}, {"id": "sub_add_sub_cancel", "parentIds": ["sub_sub_sub_cancel_left", "sub_sub_sub_cancel_right", "sub_add_sub_cancel'"]}, {"id": "sub_neg_eq_add", "parentIds": ["sub_sub_sub_cancel_left", "sub_sub_sub_cancel_right"]}, {"id": "prod.fst_swap", "parentIds": []}, {"id": "to_bool_ff", "parentIds": ["to_bool_congr"]}, {"id": "field.div_mul_eq_mul_div_comm", "parentIds": ["norm_num.div_mul_helper", "mul_eq_mul_of_div_eq_div", "div_mul_eq_mul_div_comm"]}, {"id": "div_one", "parentIds": ["field.div_mul_eq_mul_div_comm"]}, {"id": "field.div_mul_div", "parentIds": ["field.div_mul_eq_mul_div_comm", "mul_div_mul_left", "field.div_div_eq_div_mul", "div_mul_div"]}, {"id": "vm.stack_obj_info", "parentIds": []}, {"id": "nat.eq_one_of_dvd_one", "parentIds": []}, {"id": "nat.le_of_dvd", "parentIds": ["nat.eq_one_of_dvd_one", "nat.dvd_antisymm"]}, {"id": "nat.iterate", "parentIds": ["tactic.explode.pad_right", "function.involutive_iff_iter_2_eq_id"]}, {"id": "format.color.inhabited", "parentIds": []}, {"id": "native.float.of_int_coe", "parentIds": []}, {"id": "native.float.of_int", "parentIds": ["native.float.of_int_coe"]}, {"id": "expr.lift_vars", "parentIds": ["expr.replace_with", "tactic.interactive.generalize"]}, {"id": "mul_le_mul_of_nonpos_left", "parentIds": []}, {"id": "tactic.suggest.apply_and_solve", "parentIds": ["tactic.suggest.apply_declaration"]}, {"id": "mul_inv_self", "parentIds": []}, {"id": "tactic.mk_local", "parentIds": []}, {"id": "int.abs_eq_nat_abs", "parentIds": ["int.sign_mul_abs", "int.nat_abs_abs"]}, {"id": "int.neg_succ_lt_zero", "parentIds": ["int.abs_eq_nat_abs", "int.neg_of_sign_eq_neg_one"]}, {"id": "int.decidable_linear_ordered_comm_group", "parentIds": ["int.abs_eq_nat_abs", "int.sign_mul_abs", "int.nat_abs_abs"]}, {"id": "le_of_mul_le_of_ge_one", "parentIds": []}, {"id": "or_eq_of_eq_true_right", "parentIds": []}, {"id": "option_t.run_bind", "parentIds": ["option_t.is_lawful_monad"]}, {"id": "simp_attr.functor_norm", "parentIds": []}, {"id": "set.has_sdiff", "parentIds": []}, {"id": "set.diff", "parentIds": ["set.has_sdiff"]}, {"id": "simp_attr.norm", "parentIds": []}, {"id": "nat.lt_succ_of_le", "parentIds": ["nat.case_strong_induction_on", "nat.pred_lt", "nat.bit0_lt_bit1", "nat.sub_lt", "nat.sub_lt_succ", "nat.bit1_lt_bit0"]}, {"id": "old_conv.alternative", "parentIds": ["old_conv.congr_core"]}, {"id": "tactic.unsafe.type_context.pure", "parentIds": ["tactic.unsafe.type_context.monad", "tactic.unsafe.type_context.type_context_alternative"]}, {"id": "hinst_lemma.mk_from_decl", "parentIds": []}, {"id": "hinst_lemma.mk_from_decl_core", "parentIds": ["hinst_lemma.mk_from_decl", "smt_tactic.add_ematch_lemma_from_decl_core"]}, {"id": "tactic.fill_args", "parentIds": ["tactic.assoc_rewrite"]}, {"id": "nonneg_of_mul_nonneg_right", "parentIds": []}, {"id": "add_right_injective", "parentIds": []}, {"id": "name.to_string_with_sep", "parentIds": ["name.to_string"]}, {"id": "forall_and_distrib", "parentIds": ["ball_and_distrib"]}, {"id": "name_with_opt", "parentIds": ["tactic.interactive.contrapose"]}, {"id": "sub_eq_of_eq_add'", "parentIds": []}, {"id": "expr.replace_with", "parentIds": []}, {"id": "parser.decorate_errors", "parentIds": ["parser.one_of", "parser.decorate_error"]}, {"id": "bool.to_bool_and", "parentIds": []}, {"id": "quotient.lift_on", "parentIds": []}, {"id": "tactic.mllist.monad_lift", "parentIds": ["tactic.suggest_core"]}, {"id": "set.powerset", "parentIds": []}, {"id": "neg_dvd_of_dvd", "parentIds": ["neg_dvd_iff_dvd", "dvd_of_neg_dvd"]}, {"id": "exceptional.fail", "parentIds": []}, {"id": "tactic.local_def_value", "parentIds": []}, {"id": "tactic.mllist.fixl_with", "parentIds": ["tactic.mllist.fixl"]}, {"id": "one_inv_eq", "parentIds": ["div_one"]}, {"id": "one_ne_zero", "parentIds": ["one_inv_eq"]}, {"id": "ordering.swap_swap", "parentIds": []}, {"id": "tactic.use", "parentIds": ["tactic.interactive.use"]}, {"id": "tactic.instantiate_mvars_in_target", "parentIds": ["tactic.use", "tactic.instantiate_mvars_in_goals"]}, {"id": "norm_num.one_add_bit1", "parentIds": []}, {"id": "neg_comm_of_comm", "parentIds": []}, {"id": "native.rb_map.for", "parentIds": []}, {"id": "subtype.has_sizeof", "parentIds": []}, {"id": "option_t.catch", "parentIds": ["option_t.monad_except"]}, {"id": "tactic.comp_val", "parentIds": ["tactic.interactive.comp_val"]}, {"id": "expr.is_le", "parentIds": ["tactic.comp_val"]}, {"id": "mk_char_val_ne_proof", "parentIds": ["tactic.comp_val"]}, {"id": "mk_string_val_ne_proof", "parentIds": ["tactic.comp_val"]}, {"id": "expr.is_lt", "parentIds": ["tactic.comp_val"]}, {"id": "coe_decidable_eq", "parentIds": []}, {"id": "rbtree.mem_exact", "parentIds": []}, {"id": "rbnode.mem_exact", "parentIds": ["rbtree.mem_exact"]}, {"id": "neg_dvd_iff_dvd", "parentIds": []}, {"id": "dvd_of_neg_dvd", "parentIds": ["neg_dvd_iff_dvd"]}, {"id": "prod.lex_accessible", "parentIds": ["prod.lex_wf"]}, {"id": "expr.instantiate_lambdas_or_apps", "parentIds": []}, {"id": "vm_obj.to_format", "parentIds": []}, {"id": "classical.or_iff_not_imp_right", "parentIds": []}, {"id": "or_iff_not_imp_right", "parentIds": ["classical.or_iff_not_imp_right"]}, {"id": "tactic.interactive.loc.get_local_uniq_names", "parentIds": []}, {"id": "mnot", "parentIds": ["print_item_crawl"]}, {"id": "environment.decl_pos", "parentIds": ["print_item_crawl"]}, {"id": "quot.indep", "parentIds": ["quot.lift_indep_pr1", "quot.indep_coherent"]}, {"id": "interaction_monad_fmap", "parentIds": ["interaction_monad.monad"]}, {"id": "tactic.mllist.bind_", "parentIds": []}, {"id": "level.to_string", "parentIds": ["level.has_to_string"]}, {"id": "bool.cond_ff", "parentIds": ["bool.cond_to_bool"]}, {"id": "list.of_fn_nth_val", "parentIds": []}, {"id": "old_conv.congr_core", "parentIds": ["old_conv.congr"]}, {"id": "subsingleton_pempty", "parentIds": []}, {"id": "list.ilast'", "parentIds": []}, {"id": "rbnode.insert", "parentIds": ["rbnode.well_formed"]}, {"id": "level.instantiate", "parentIds": []}, {"id": "native.rb_map.keys", "parentIds": []}, {"id": "nat.land", "parentIds": ["nat.land_bit", "nat.test_bit_land"]}, {"id": "reader_t.run_monad_lift", "parentIds": []}, {"id": "reader_t.has_monad_lift", "parentIds": ["reader_t.run_monad_lift"]}, {"id": "char.is_alpha", "parentIds": ["char.is_alphanum", "char.decidable_is_alpha", "char.decidable_is_alphanum"]}, {"id": "int.nonneg_of_pos", "parentIds": []}, {"id": "tactic.unsafe.type_context.print_mvars", "parentIds": []}, {"id": "tactic.unsafe.type_context.trace", "parentIds": ["tactic.unsafe.type_context.print_mvars"]}, {"id": "mul_eq_zero_iff_eq_zero_or_eq_zero", "parentIds": []}, {"id": "le_add_of_neg_add_le", "parentIds": []}, {"id": "ne_self_iff_false", "parentIds": []}, {"id": "native.rb_set.has_to_format", "parentIds": []}, {"id": "int.sign_mul_abs", "parentIds": []}, {"id": "int.sign_mul_nat_abs", "parentIds": ["int.sign_mul_abs"]}, {"id": "nat.discriminate", "parentIds": []}, {"id": "cc_state.gmt", "parentIds": []}, {"id": "tactic.interactive.obtain", "parentIds": []}, {"id": "tactic.rcases_patt_inverted.has_reflect", "parentIds": ["tactic.interactive.obtain"]}, {"id": "inv_image.wf", "parentIds": ["measure_wf"]}, {"id": "expr.size", "parentIds": ["print_item_crawl"]}, {"id": "parser.many_char1", "parentIds": []}, {"id": "exists_false", "parentIds": []}, {"id": "tactic.unsafe.type_context.unify", "parentIds": []}, {"id": "expr.is_eta_expansion_aux", "parentIds": ["expr.is_eta_expansion"]}, {"id": "expr.is_eta_expansion_test", "parentIds": ["expr.is_eta_expansion_aux"]}, {"id": "nonempty_of_inhabited", "parentIds": []}, {"id": "nat.test_bit_lxor", "parentIds": []}, {"id": "nat.lt_of_lt_of_le", "parentIds": ["nat.mul_lt_mul_of_pos_left"]}, {"id": "nat.succ_le_of_lt", "parentIds": ["nat.mul_lt_mul_of_pos_left", "nat.add_lt_add_left"]}, {"id": "native.float.log10", "parentIds": []}, {"id": "list.has_decidable_le", "parentIds": []}, {"id": "expr.is_num_eq", "parentIds": []}, {"id": "fin.has_repr", "parentIds": []}, {"id": "nat.sub_one_sub_lt", "parentIds": []}, {"id": "div_mul_le_div_mul_of_div_le_div_pos'", "parentIds": []}, {"id": "div_mul_eq_div_mul_one_div", "parentIds": ["div_mul_le_div_mul_of_div_le_div_pos'"]}, {"id": "discrete_linear_ordered_field.to_discrete_field", "parentIds": ["div_mul_le_div_mul_of_div_le_div_pos'", "abs_div", "pos_of_one_div_pos", "neg_of_one_div_neg"]}, {"id": "array.mem", "parentIds": ["array.has_mem"]}, {"id": "where.trace_end", "parentIds": ["where.trace_where"]}, {"id": "add_le_add_three", "parentIds": []}, {"id": "array.ext'", "parentIds": []}, {"id": "d_array.ext'", "parentIds": ["array.ext'", "d_array.of_beq_eq_tt"]}, {"id": "monad_fail_lift", "parentIds": []}, {"id": "interactive.decl_attributes.apply", "parentIds": []}, {"id": "interactive.decl_attributes", "parentIds": ["interactive.decl_attributes.apply", "interactive.single_inductive_decl", "interactive.decl_meta_info"]}, {"id": "norm_num.add1_bit1_helper", "parentIds": []}, {"id": "decidable.le_imp_le_iff_lt_imp_lt", "parentIds": []}, {"id": "list.range", "parentIds": []}, {"id": "interactive.decl_modifiers", "parentIds": ["interactive.decl_meta_info"]}, {"id": "well_founded.recursion", "parentIds": ["well_founded.induction"]}, {"id": "int.sign_neg_one", "parentIds": []}, {"id": "tactic.fold_explicit_args", "parentIds": []}, {"id": "tactic.get_fun_info", "parentIds": ["tactic.fold_explicit_args"]}, {"id": "tactic.fold_explicit_args_aux", "parentIds": ["tactic.fold_explicit_args"]}, {"id": "tactic.alias.mk_iff_mp_app", "parentIds": ["tactic.alias.alias_iff"]}, {"id": "expr.of_int", "parentIds": []}, {"id": "expr.of_nat", "parentIds": ["expr.of_int"]}, {"id": "bool.eq_ff_of_ne_tt", "parentIds": []}, {"id": "neg_nonpos_of_nonneg", "parentIds": ["abs_of_nonneg", "sub_le_self"]}, {"id": "fin.decidable_lt", "parentIds": []}, {"id": "not_not_of_not_imp", "parentIds": ["of_not_imp"]}, {"id": "nat.mul_le_mul_right", "parentIds": ["nat.div_le_self"]}, {"id": "tactic.interactive.guard_hyp", "parentIds": []}, {"id": "smt_tactic.to_em_state", "parentIds": []}, {"id": "list.forall\u2082", "parentIds": []}, {"id": "rbnode.min", "parentIds": []}, {"id": "linter.ge_or_gt", "parentIds": []}, {"id": "ge_or_gt_in_statement", "parentIds": ["linter.ge_or_gt"]}, {"id": "and_congr_right", "parentIds": ["and.congr_right_iff"]}, {"id": "function.inv_fun_neg", "parentIds": []}, {"id": "add_group.add_right_cancel", "parentIds": ["add_group.to_right_cancel_add_semigroup"]}, {"id": "int.sign_zero", "parentIds": ["int.sign_eq_zero_iff_zero"]}, {"id": "tactic.match_target", "parentIds": ["tactic.interactive.match_target"]}, {"id": "list.mmap_accumr", "parentIds": []}, {"id": "neg_of_mul_neg_right", "parentIds": []}, {"id": "tactic.ematch_core", "parentIds": ["tactic.ematch"]}, {"id": "add_mul", "parentIds": []}, {"id": "tactic.get_spec_subsingleton_info", "parentIds": []}, {"id": "nat.add_lt_add_right", "parentIds": []}, {"id": "tactic.interactive.resetI", "parentIds": []}, {"id": "quotient.lift", "parentIds": ["quotient.lift\u2082"]}, {"id": "expr.copy_pos_info", "parentIds": []}, {"id": "level.fold", "parentIds": []}, {"id": "sub_left_lt_of_lt_add", "parentIds": ["sub_lt_of_abs_sub_lt_left", "sub_lt_of_sub_lt", "neg_add_lt_left_of_lt_add", "neg_lt_sub_left_of_lt_add"]}, {"id": "or_iff_not_and_not", "parentIds": []}, {"id": "not_or_distrib", "parentIds": ["or_iff_not_and_not", "push_neg.not_or_eq"]}, {"id": "except_t.monad_map", "parentIds": ["except_t.monad_functor"]}, {"id": "subtype.eta", "parentIds": []}, {"id": "subtype.eq", "parentIds": ["subtype.eta"]}, {"id": "tactic.apply_core", "parentIds": ["tactic.apply"]}, {"id": "linter.has_inhabited_instance", "parentIds": []}, {"id": "has_inhabited_instance", "parentIds": ["linter.has_inhabited_instance"]}, {"id": "tactic.get_tag", "parentIds": ["tactic.get_main_tag", "tactic.interactive.field", "tactic.interactive.case"]}, {"id": "expr.pi_arity", "parentIds": ["check_unused_arguments"]}, {"id": "div_lt_div_of_lt_of_neg", "parentIds": []}, {"id": "expr.mfold", "parentIds": ["tactic.interactive.list_cast_of"]}, {"id": "nat.dvd_of_mul_dvd_mul_right", "parentIds": []}, {"id": "nat.dvd_of_mul_dvd_mul_left", "parentIds": ["nat.dvd_of_mul_dvd_mul_right"]}, {"id": "buffer.lt_aux_3", "parentIds": []}, {"id": "d_array.map", "parentIds": []}, {"id": "has_monad_lift_to_has_coe", "parentIds": []}, {"id": "push_neg.classical.implies_iff_not_or", "parentIds": []}, {"id": "imp_iff_not_or", "parentIds": ["push_neg.classical.implies_iff_not_or", "imp_or_distrib", "classical.imp_iff_not_or", "classical.iff_iff_not_or_and_or_not"]}, {"id": "and.elim_left", "parentIds": []}, {"id": "norm_num.add_div_helper", "parentIds": []}, {"id": "eq_of_mul_eq_mul_of_nonzero_left", "parentIds": ["norm_num.add_div_helper"]}, {"id": "ex_of_psig", "parentIds": []}, {"id": "let_value_eq", "parentIds": []}, {"id": "not_or", "parentIds": []}, {"id": "imp.swap", "parentIds": ["imp_not_comm"]}, {"id": "norm_num.pos_bit0_helper", "parentIds": []}, {"id": "add_pos", "parentIds": ["norm_num.pos_bit0_helper", "int.bit0_pos", "add_self_div_two", "two_pos", "abs_abs_sub_abs_le_abs_sub", "four_pos", "div_two_lt_of_pos"]}, {"id": "hex_digit_repr", "parentIds": ["char_to_hex"]}, {"id": "int.mul_pos", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "int.coe_nat_mul", "parentIds": ["int.mul_pos"]}, {"id": "tactic.mllist.mmap", "parentIds": []}, {"id": "int.eq_succ_of_zero_lt", "parentIds": ["int.sign_eq_one_of_pos"]}, {"id": "tactic.interactive.erw", "parentIds": []}, {"id": "monad.cond", "parentIds": []}, {"id": "prod.lt_def", "parentIds": []}, {"id": "tactic.interactive.intro", "parentIds": ["tactic.interactive.generalize", "tactic.interactive.introI", "tactic.mk_inj_eq"]}, {"id": "tactic.delta_config.inhabited", "parentIds": []}, {"id": "vm_obj.to_name", "parentIds": []}, {"id": "tactic.interactive.use", "parentIds": []}, {"id": "inv_image.trans", "parentIds": []}, {"id": "native.rb_map.mfilter", "parentIds": []}, {"id": "native.rb_map.to_list", "parentIds": ["native.rb_map.mfilter", "native.rb_map.mmap", "fold_over_with_cond_sorted", "tactic.rename'"]}, {"id": "tactic.rcases_patt_parse_core", "parentIds": ["tactic.rcases_patt_parse"]}, {"id": "function.injective.ne", "parentIds": ["function.update_comp"]}, {"id": "tactic.mk_has_reflect_instance", "parentIds": ["has_reflect_derive_handler"]}, {"id": "not_false", "parentIds": ["if_false", "not_false_iff", "decidable.false"]}, {"id": "infer_instance", "parentIds": []}, {"id": "is_valid_simp_lemma", "parentIds": []}, {"id": "nat.land_bit", "parentIds": []}, {"id": "state_t.monad_state_adapter", "parentIds": []}, {"id": "functor.map_id", "parentIds": ["functor.comp.id_map"]}, {"id": "division_ring.one_div_div", "parentIds": ["one_div_div", "field.div_div_eq_mul_div"]}, {"id": "division_ring.inv_inv", "parentIds": ["division_ring.one_div_div"]}, {"id": "tactic.set_env_core", "parentIds": []}, {"id": "tactic.rcases_patt.inhabited", "parentIds": []}, {"id": "one_div_mul_cancel", "parentIds": ["one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "eq_one_div_of_mul_eq_one"]}, {"id": "function.hfunext", "parentIds": []}, {"id": "type_eq_of_heq", "parentIds": ["function.hfunext"]}, {"id": "norm_num.subst_into_div", "parentIds": []}, {"id": "environment.get_trusted_decls", "parentIds": []}, {"id": "declaration.is_trusted", "parentIds": ["environment.get_trusted_decls", "tactic.suggest.process_declaration", "instance_derive_handler", "has_inhabited_instance", "tactic.import_private_cmd"]}, {"id": "environment.is_ginductive'", "parentIds": ["declaration.is_auto_generated"]}, {"id": "eq_false_of_not_eq_true", "parentIds": []}, {"id": "bool.has_to_string", "parentIds": []}, {"id": "mul_eq_of_eq_mul_inv", "parentIds": []}, {"id": "int.ldiff", "parentIds": []}, {"id": "push_neg.not_implies_eq", "parentIds": []}, {"id": "list.mem_cons_eq", "parentIds": []}, {"id": "sub_mul", "parentIds": []}, {"id": "imp_eq_of_eq_true_left", "parentIds": []}, {"id": "classical.forall_or_distrib_left", "parentIds": []}, {"id": "mul_right_cancel_iff", "parentIds": []}, {"id": "list.subset_append_right", "parentIds": []}, {"id": "subsingleton_info.inhabited", "parentIds": []}, {"id": "bool.bor_assoc", "parentIds": []}, {"id": "eq_sub_of_add_eq", "parentIds": []}, {"id": "decidable.has_to_string", "parentIds": []}, {"id": "environment.get_modifiers", "parentIds": ["print_item_crawl"]}, {"id": "list.has_to_string", "parentIds": ["print_item_crawl", "tactic.interactive.simp_intros"]}, {"id": "expr.get_pi_app_fn", "parentIds": ["print_item_crawl"]}, {"id": "declaration.get_kind_string", "parentIds": ["print_item_crawl"]}, {"id": "list_items", "parentIds": ["print_item_crawl"]}, {"id": "my_name_to_string", "parentIds": ["print_item_crawl"]}, {"id": "unsigned.has_one", "parentIds": ["saturate_fun"]}, {"id": "tactic.find_local", "parentIds": []}, {"id": "bool.cond_tt", "parentIds": ["bool.cond_to_bool"]}, {"id": "and_eq_of_eq_false_left", "parentIds": []}, {"id": "list.scanr", "parentIds": []}, {"id": "comp.is_comm_applicative", "parentIds": []}, {"id": "d_array.iterate", "parentIds": ["d_array.foreach", "array.iterate", "d_array.foldl"]}, {"id": "int.semigroup", "parentIds": []}, {"id": "symm_of", "parentIds": []}, {"id": "symm", "parentIds": ["symm_of"]}, {"id": "rbnode.color.inhabited", "parentIds": []}, {"id": "tactic.unsafe.type_context.is_regular_mvar", "parentIds": []}, {"id": "rbnode.rev_fold", "parentIds": []}, {"id": "smt_tactic.execute", "parentIds": []}, {"id": "native.float.has_zero", "parentIds": []}, {"id": "tactic.interactive.transitivity", "parentIds": []}, {"id": "state_t.ext", "parentIds": ["state_t.is_lawful_monad"]}, {"id": "dvd_mul_of_dvd_right", "parentIds": []}, {"id": "dvd_mul_of_dvd_left", "parentIds": ["dvd_mul_of_dvd_right"]}, {"id": "tactic.interactive.success_if_fail_with_msg", "parentIds": []}, {"id": "tactic.success_if_fail_with_msg", "parentIds": ["tactic.interactive.success_if_fail_with_msg"]}, {"id": "parser.sep_by", "parentIds": []}, {"id": "bool.cond_to_bool", "parentIds": []}, {"id": "except.to_option", "parentIds": []}, {"id": "interactive.inductive_decl.parse", "parentIds": []}, {"id": "interactive.inductive_decl", "parentIds": ["interactive.inductive_decl.parse"]}, {"id": "classical.not_and_distrib", "parentIds": []}, {"id": "eq_of_inv_eq_inv", "parentIds": []}, {"id": "inv_inj'", "parentIds": ["eq_of_inv_eq_inv", "inv_eq_one"]}, {"id": "band_self", "parentIds": ["band_ff", "band_tt"]}, {"id": "simp_lemmas.join", "parentIds": []}, {"id": "native.rb_set.union", "parentIds": []}, {"id": "native.rb_set.insert", "parentIds": ["native.rb_set.union"]}, {"id": "native.float.qNaN", "parentIds": []}, {"id": "buffer.has_mem", "parentIds": []}, {"id": "buffer.mem", "parentIds": ["buffer.has_mem"]}, {"id": "nat.mul_mod_left", "parentIds": []}, {"id": "nat.mul_mod_right", "parentIds": ["nat.mul_mod_left", "nat.mod_eq_zero_of_dvd"]}, {"id": "monad_except.orelse", "parentIds": []}, {"id": "nat.div_eq_sub_div", "parentIds": ["nat.add_div_right", "nat.sub_mul_div", "nat.le_div_iff_mul_le"]}, {"id": "peirce", "parentIds": []}, {"id": "decidable.le_or_lt", "parentIds": []}, {"id": "tactic.set_nat_option", "parentIds": []}, {"id": "tactic_state.set_options", "parentIds": ["tactic.set_nat_option", "tactic.set_string_option", "tactic.set_bool_option", "tactic.set_options"]}, {"id": "tactic.simp_intros", "parentIds": ["tactic.interactive.simp_intros"]}, {"id": "linter.doc_blame_thm", "parentIds": []}, {"id": "doc_blame_report_thm", "parentIds": ["linter.doc_blame_thm"]}, {"id": "unchecked_cast", "parentIds": ["tactic.suggest.replace_mvars"]}, {"id": "div_nonpos_of_nonpos_of_pos", "parentIds": []}, {"id": "sub_zero", "parentIds": []}, {"id": "tactic.match_and", "parentIds": []}, {"id": "expr.is_and", "parentIds": ["tactic.match_and"]}, {"id": "tactic.interactive.cases_type", "parentIds": []}, {"id": "or_eq_of_eq_false_left", "parentIds": []}, {"id": "tactic.alias.alias_cmd", "parentIds": []}, {"id": "tactic.alias.alias_direct", "parentIds": ["tactic.alias.alias_cmd"]}, {"id": "tactic.alias.alias_iff", "parentIds": ["tactic.alias.alias_cmd"]}, {"id": "tactic.alias.make_left_right", "parentIds": ["tactic.alias.alias_cmd"]}, {"id": "list.length_tail", "parentIds": []}, {"id": "list.tail", "parentIds": ["list.length_tail"]}, {"id": "tactic.mk_back_lemmas_core", "parentIds": ["tactic.back_chaining_core", "tactic.mk_back_lemmas"]}, {"id": "function.partial_inv_left", "parentIds": []}, {"id": "function.partial_inv_of_injective", "parentIds": ["function.partial_inv_left"]}, {"id": "function.is_partial_inv_left", "parentIds": ["function.partial_inv_left"]}, {"id": "tactic.unsafe.type_context.infer", "parentIds": []}, {"id": "nat.mul_lt_mul_of_pos_right", "parentIds": ["nat.decidable_linear_ordered_semiring"]}, {"id": "nonpos_of_mul_nonpos_left", "parentIds": []}, {"id": "list.bin_tree_to_list", "parentIds": []}, {"id": "add_succ_defeq_succ_add_hint", "parentIds": []}, {"id": "unification_hint", "parentIds": ["add_succ_defeq_succ_add_hint", "unification_hint.inhabited"]}, {"id": "sub_lt_sub_left", "parentIds": []}, {"id": "name.cmp", "parentIds": ["name.lt.decidable_rel", "name.lt"]}, {"id": "mul_self_lt_mul_self", "parentIds": ["nonneg_le_nonneg_of_squares_le"]}, {"id": "mul_lt_mul'", "parentIds": ["mul_self_lt_mul_self", "nat.pow_lt_pow_of_lt_left"]}, {"id": "eq_zero_of_abs_eq_zero", "parentIds": ["abs_div", "eq_of_abs_sub_eq_zero"]}, {"id": "nonneg_of_neg_nonpos", "parentIds": ["eq_zero_of_abs_eq_zero"]}, {"id": "tactic.interactive.eapply", "parentIds": []}, {"id": "list.bor", "parentIds": ["interactive.loc.include_goal"]}, {"id": "conv.interactive.find", "parentIds": ["tactic.interactive.conv"]}, {"id": "conv.convert", "parentIds": ["conv.interactive.find", "conv.interactive.for"]}, {"id": "int.decidable_le", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "int.decidable_eq", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "int.le_total", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "int.mul_nonneg", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "int.lt_iff_le_not_le", "parentIds": ["int.decidable_linear_ordered_comm_ring"]}, {"id": "ordered_ring.mul_le_mul_of_nonneg_right", "parentIds": ["ordered_ring.to_ordered_semiring"]}, {"id": "sub_nonneg_of_le", "parentIds": ["ordered_ring.mul_le_mul_of_nonneg_right", "ordered_ring.mul_le_mul_of_nonneg_left", "dist_bdd_within_interval"]}, {"id": "norm_num.nonzero_of_neg_helper", "parentIds": []}, {"id": "prod.swap_left_inverse", "parentIds": []}, {"id": "nat.div_lt_self", "parentIds": []}, {"id": "nat.div_lt_iff_lt_mul", "parentIds": ["nat.div_lt_self", "nat.div_eq_of_lt_le", "nat.mod_pow_succ", "nat.mul_sub_div"]}, {"id": "int.bit0_pos", "parentIds": []}, {"id": "function.comp.right_id", "parentIds": []}, {"id": "iff_iff_and_or_not_and_not", "parentIds": []}, {"id": "tactic.interactive.to_expr'", "parentIds": []}, {"id": "abs_zero", "parentIds": ["ne_zero_of_abs_ne_zero", "abs_div"]}, {"id": "exists_eq_right", "parentIds": ["exists_eq_right'"]}, {"id": "neg_le_sub_right_of_le_add", "parentIds": []}, {"id": "tactic.dsimp_config.inhabited", "parentIds": []}, {"id": "exists_unique.elim", "parentIds": ["unique_of_exists_unique"]}, {"id": "native.float.has_div", "parentIds": []}, {"id": "native.float.div", "parentIds": ["native.float.has_div"]}, {"id": "not_forall_of_exists_not", "parentIds": ["not_forall"]}, {"id": "int.fmod", "parentIds": []}, {"id": "mul_inv'", "parentIds": []}, {"id": "char.lt", "parentIds": ["char.has_lt"]}, {"id": "eq_true_of_and_eq_true_left", "parentIds": []}, {"id": "string.iterator.insert", "parentIds": []}, {"id": "get_ext_subject", "parentIds": ["tactic.ext1"]}, {"id": "rsimp.to_repr_map", "parentIds": ["rsimp.rsimplify"]}, {"id": "rsimp.mk_repr_map", "parentIds": ["rsimp.to_repr_map"]}, {"id": "rsimp.choose", "parentIds": ["rsimp.to_repr_map"]}, {"id": "mul_le_of_div_le_of_neg", "parentIds": []}, {"id": "bool.to_bool_coe", "parentIds": []}, {"id": "buffer.rev_iterate", "parentIds": []}, {"id": "char.vne_of_ne", "parentIds": []}, {"id": "fin.lt_def", "parentIds": []}, {"id": "classical.forall_or_distrib_right", "parentIds": []}, {"id": "int.coe_nat_lt_coe_nat_of_lt", "parentIds": ["int.pos_of_sign_eq_one", "int.coe_succ_pos"]}, {"id": "conv.interactive.whnf", "parentIds": []}, {"id": "tactic.interactive.ext", "parentIds": []}, {"id": "norm_num.bit0_add_bit0_helper", "parentIds": []}, {"id": "smt_tactic.istep", "parentIds": []}, {"id": "smt_tactic.solve_goals", "parentIds": ["smt_tactic.istep", "smt_tactic.step"]}, {"id": "tactic.interactive.unelide", "parentIds": []}, {"id": "list.transpose", "parentIds": []}, {"id": "nat.one_add", "parentIds": []}, {"id": "native.float.max", "parentIds": []}, {"id": "nat.bit1_val", "parentIds": ["nat.bit_val", "nat.shiftl'_tt_eq_mul_pow"]}, {"id": "le_implies_le_of_le_of_le", "parentIds": []}, {"id": "char.inhabited", "parentIds": []}, {"id": "interactive.interactive.executor", "parentIds": ["tactic.mk_inj_eq"]}, {"id": "eq_neg_iff_add_eq_zero", "parentIds": []}, {"id": "native.mk_rb_map", "parentIds": ["native.rb_map.inhabited", "native.mk_rb_set", "tactic.local_decls"]}, {"id": "tactic.solve_by_elim_aux", "parentIds": ["tactic.solve_by_elim"]}, {"id": "native.rb_map.mfold", "parentIds": []}, {"id": "norm_num.nonzero_of_pos_helper", "parentIds": []}, {"id": "string.iterator.has_prev", "parentIds": []}, {"id": "lint_hole_cmd", "parentIds": []}, {"id": "nat.le_succ_of_pred_le", "parentIds": []}, {"id": "vm.get_line", "parentIds": []}, {"id": "norm_num.bit1_add_bit0", "parentIds": []}, {"id": "nat.bit0_lt", "parentIds": []}, {"id": "nat.mul_div_left", "parentIds": []}, {"id": "lean.special_version_desc", "parentIds": []}, {"id": "ulift.down_up", "parentIds": []}, {"id": "tactic.interactive.show", "parentIds": []}, {"id": "lean.is_release", "parentIds": []}, {"id": "monad_state_trans", "parentIds": []}, {"id": "rbnode.balance2", "parentIds": []}, {"id": "tactic.ematch_all", "parentIds": []}, {"id": "rsimp.collect_implied_eqs", "parentIds": ["tactic.rsimp", "tactic.rsimp_at"]}, {"id": "smt_tactic.iterate_at_most", "parentIds": ["rsimp.collect_implied_eqs", "smt_tactic.iterate"]}, {"id": "using_smt_with", "parentIds": ["rsimp.collect_implied_eqs"]}, {"id": "list.tfae", "parentIds": []}, {"id": "set.has_union", "parentIds": []}, {"id": "set.union", "parentIds": ["set.has_union"]}, {"id": "combinator.K", "parentIds": []}, {"id": "iff.to_eq", "parentIds": ["iff_eq_eq"]}, {"id": "name.has_prefix", "parentIds": ["declaration.is_auto_generated"]}, {"id": "tactic.interactive.assoc_rw", "parentIds": []}, {"id": "tactic.interactive.assoc_rewrite", "parentIds": ["tactic.interactive.assoc_rw"]}, {"id": "list.sum", "parentIds": []}, {"id": "tactic.interactive.simp_intros", "parentIds": []}, {"id": "rbtree.from_list", "parentIds": ["rbtree_of"]}, {"id": "add_eq_of_eq_add_neg", "parentIds": []}, {"id": "eq_one_div_of_mul_eq_one", "parentIds": ["one_div_neg_one_eq_neg_one", "division_ring.one_div_mul_one_div"]}, {"id": "lt_add_of_neg_add_lt", "parentIds": []}, {"id": "norm_num.div_mul_helper", "parentIds": []}, {"id": "comp.pure_seq_eq_map", "parentIds": ["comp.is_lawful_applicative"]}, {"id": "applicative.pure_seq_eq_map'", "parentIds": ["comp.pure_seq_eq_map"]}, {"id": "prod.has_to_string", "parentIds": []}, {"id": "tactic.dunfold_hyp", "parentIds": ["tactic.interactive.dunfold"]}, {"id": "name.append_after", "parentIds": []}, {"id": "int.lnot", "parentIds": []}, {"id": "attribute.fingerprint", "parentIds": []}, {"id": "rbtree_of", "parentIds": []}, {"id": "tactic.interactive.erewrite", "parentIds": []}, {"id": "one_div_neg_eq_neg_one_div", "parentIds": []}, {"id": "division_ring.one_div_neg_eq_neg_one_div", "parentIds": ["one_div_neg_eq_neg_one_div", "div_neg_eq_neg_div", "neg_of_one_div_neg"]}, {"id": "list.bex_cons", "parentIds": []}, {"id": "list.mem_cons_of_mem", "parentIds": ["list.bex_cons", "list.subset_of_cons_subset", "list.ball_cons"]}, {"id": "native.rb_map.empty", "parentIds": ["native.rb_set.empty"]}, {"id": "int.eq_coe_of_zero_le", "parentIds": ["int.eq_nat_abs_of_zero_le", "int.neg_succ_lt_zero", "int.exists_eq_neg_of_nat", "int.nat_abs_of_nonneg"]}, {"id": "nat.div_eq_of_lt_le", "parentIds": ["nat.mul_sub_div"]}, {"id": "nat.le_div_iff_mul_le", "parentIds": ["nat.div_eq_of_lt_le", "nat.div_mul_le_self", "nat.mod_pow_succ", "nat.div_lt_iff_lt_mul", "nat.div_div_eq_div_mul"]}, {"id": "coe_fn_coe_base", "parentIds": []}, {"id": "format_macro", "parentIds": []}, {"id": "where.fetch_potential_variable_names", "parentIds": ["where.get_variables_core"]}, {"id": "where.is_variable_name", "parentIds": ["where.get_variables_core"]}, {"id": "monad.mapm", "parentIds": []}, {"id": "function.left_inverse_of_surjective_of_right_inverse", "parentIds": []}, {"id": "vm.curr_fn", "parentIds": []}, {"id": "tactic.interactive.intros", "parentIds": ["tactic.interactive.rintro", "tactic.mk_inj_eq", "tactic.interactive.introsI"]}, {"id": "except_t.monad_run", "parentIds": []}, {"id": "tactic.iterate_at_most_on_subgoals", "parentIds": ["tactic.apply_rules"]}, {"id": "tactic.iterate_at_most_on_all_goals", "parentIds": ["tactic.iterate_at_most_on_subgoals"]}, {"id": "list.length_map_accumr", "parentIds": []}, {"id": "int.coe_nat_eq_coe_nat_iff", "parentIds": []}, {"id": "int.of_nat_eq_of_nat_iff", "parentIds": ["int.coe_nat_eq_coe_nat_iff"]}, {"id": "int.bit0_nonneg", "parentIds": ["int.nat_abs_bit1_nonneg"]}, {"id": "ne_zero_of_abs_ne_zero", "parentIds": []}, {"id": "option.has_to_format", "parentIds": []}, {"id": "tactic.explode.pad_right", "parentIds": ["tactic.explode.has_to_tactic_format"]}, {"id": "bool.bnot_false", "parentIds": []}, {"id": "tactic.unsafe.type_context.to_tmp_mvars", "parentIds": []}, {"id": "pos_of_mul_pos_left", "parentIds": []}, {"id": "tactic.iff_mpr_core", "parentIds": ["tactic.iff_mpr", "tactic.suggest.apply_declaration"]}, {"id": "simp_lemmas.rewrites", "parentIds": []}, {"id": "lt_add_of_neg_add_lt_right", "parentIds": []}, {"id": "tactic.retrieve", "parentIds": []}, {"id": "binder_info.has_repr", "parentIds": []}, {"id": "tactic.join_user_simp_lemmas", "parentIds": ["tactic.mk_simp_set_core"]}, {"id": "tactic.interactive.guard_target'", "parentIds": []}, {"id": "tactic.interactive.guard_expr_eq'", "parentIds": ["tactic.interactive.guard_target'"]}, {"id": "interactive.single_inductive_decl", "parentIds": ["interactive.inductive_decl", "interactive.single_inductive_decl.name"]}, {"id": "is_valid_simp_lemma_cnst", "parentIds": []}, {"id": "tactic.unfold_projs", "parentIds": ["tactic.unfold_projs_target", "tactic.unfold_projs_hyp"]}, {"id": "tactic.unfold_proj", "parentIds": ["tactic.unfold_projs"]}, {"id": "options.has_add", "parentIds": []}, {"id": "tactic.unset_attribute", "parentIds": []}, {"id": "tactic.head_eta", "parentIds": []}, {"id": "cc_state.in_singlenton_eqc", "parentIds": []}, {"id": "cc_state.next", "parentIds": ["cc_state.in_singlenton_eqc"]}, {"id": "nat.one_succ_zero", "parentIds": []}, {"id": "prod.ext", "parentIds": ["prod.map_def"]}, {"id": "prod.ext_iff", "parentIds": ["prod.ext"]}, {"id": "copy_decl_using", "parentIds": ["transport_with_dict"]}, {"id": "coe_trans", "parentIds": ["coe_coe"]}, {"id": "native.float.atanh", "parentIds": []}, {"id": "int.of_nat_eq_coe", "parentIds": []}, {"id": "buffer.append_array", "parentIds": []}, {"id": "tactic.tags_enabled", "parentIds": ["tactic.interactive.concat_tags", "tactic.with_enable_tags"]}, {"id": "unique_of_exists_unique", "parentIds": []}, {"id": "mul_self_sub_mul_self_eq", "parentIds": ["mul_self_eq_mul_self_iff"]}, {"id": "interactive.parse_binders_core", "parentIds": ["interactive.parse_binders"]}, {"id": "smt_config.inhabited", "parentIds": []}, {"id": "sum.inl_ne_inr", "parentIds": []}, {"id": "tactic.mk_specialized_congr_lemma_simp", "parentIds": []}, {"id": "quotient.exists_rep", "parentIds": []}, {"id": "nat.dvd_iff_mod_eq_zero", "parentIds": []}, {"id": "nat.dvd_of_mod_eq_zero", "parentIds": ["nat.dvd_iff_mod_eq_zero"]}, {"id": "tactic.unsafe.type_context.is_tmp_mvar", "parentIds": []}, {"id": "int.coe_nat_sub", "parentIds": []}, {"id": "nat.mul_sub_right_distrib", "parentIds": ["nat.mul_sub_left_distrib", "nat.mul_sub_div"]}, {"id": "and_or_distrib_right", "parentIds": []}, {"id": "nat.mul_pred_right", "parentIds": []}, {"id": "tactic.unsafe.type_context.in_tmp_mode", "parentIds": []}, {"id": "expr.has_local_constant", "parentIds": ["dangerous_instance"]}, {"id": "nonempty_subtype", "parentIds": []}, {"id": "int.has_mod", "parentIds": ["int.nat_mod"]}, {"id": "list.last", "parentIds": []}, {"id": "and_iff_right_of_imp", "parentIds": []}, {"id": "tactic.interactive.replace", "parentIds": []}, {"id": "tactic.interactive.find", "parentIds": []}, {"id": "tactic.interactive.old_conv", "parentIds": ["tactic.interactive.find"]}, {"id": "functor.const.is_lawful_applicative", "parentIds": []}, {"id": "function.left_inverse.comp_eq_id", "parentIds": []}, {"id": "inv_involutive", "parentIds": []}, {"id": "reflected_value.expr", "parentIds": ["lean.parser.reflectable.expr"]}, {"id": "punit.subsingleton", "parentIds": []}, {"id": "sum.lex_inr_inr", "parentIds": []}, {"id": "nat.one_pos", "parentIds": []}, {"id": "tactic.interactive.subst", "parentIds": []}, {"id": "simp_attr.split_if_reduction", "parentIds": []}, {"id": "tactic.mllist.filter_map", "parentIds": []}, {"id": "norm_num.neg_mul_pos_helper", "parentIds": []}, {"id": "strict_weak_order.is_equiv", "parentIds": []}, {"id": "strict_weak_order.esymm", "parentIds": ["strict_weak_order.is_equiv"]}, {"id": "is_equiv", "parentIds": ["strict_weak_order.is_equiv", "eq_is_equiv"]}, {"id": "strict_weak_order.erefl", "parentIds": ["strict_weak_order.is_equiv"]}, {"id": "int.eq_nat_abs_of_zero_le", "parentIds": ["int.le_nat_abs"]}, {"id": "rbnode.balance1", "parentIds": []}, {"id": "eq_neg_add_of_add_eq", "parentIds": []}, {"id": "nat.bit0_ne_one", "parentIds": ["nat.one_ne_bit0"]}, {"id": "expr.app_of_list", "parentIds": []}, {"id": "cast_proof_irrel", "parentIds": []}, {"id": "tactic.find_ancestors", "parentIds": []}, {"id": "vm.put_str", "parentIds": []}, {"id": "tactic.interactive.clear_", "parentIds": []}, {"id": "string.front", "parentIds": ["tactic.interactive.clear_"]}, {"id": "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "parentIds": []}, {"id": "option.has_repr", "parentIds": []}, {"id": "int.nat_mod", "parentIds": []}, {"id": "int.to_nat", "parentIds": ["int.nat_mod", "int.to_nat_sub"]}, {"id": "tactic.interactive.return_cast", "parentIds": ["tactic.interactive.list_cast_of_aux"]}, {"id": "nat.sub_add_comm", "parentIds": []}, {"id": "tactic.explode.format_aux", "parentIds": ["tactic.explode.has_to_tactic_format"]}, {"id": "parser.monad_fail", "parentIds": []}, {"id": "cc_state.mfold_eqc", "parentIds": ["rsimp.choose"]}, {"id": "cc_state.fold_eqc", "parentIds": ["cc_state.mfold_eqc"]}, {"id": "lift_fn_dom", "parentIds": []}, {"id": "list.count", "parentIds": ["dup_namespace"]}, {"id": "conv.replace_lhs", "parentIds": []}, {"id": "except_t.adapt", "parentIds": ["except_t.monad_except_adapter"]}, {"id": "except.map_error", "parentIds": ["except_t.adapt"]}, {"id": "interaction_monad.failed", "parentIds": ["lean.parser.alternative", "tactic.alternative", "tactic.failed"]}, {"id": "tactic.match_iff", "parentIds": []}, {"id": "zero_gt_neg_one", "parentIds": []}, {"id": "iff_of_false", "parentIds": ["iff_false_left"]}, {"id": "iff_iff_implies_and_implies", "parentIds": ["iff_def", "classical.iff_iff_not_or_and_or_not", "iff_congr"]}, {"id": "assert", "parentIds": []}, {"id": "nat.succ_sub", "parentIds": []}, {"id": "nat.div_le_self", "parentIds": []}, {"id": "modify", "parentIds": []}, {"id": "state_t.modify", "parentIds": ["modify"]}, {"id": "congr_arg_kind.inhabited", "parentIds": []}, {"id": "reader_t.monad_functor", "parentIds": ["reader_t.run_monad_map"]}, {"id": "reader_t.monad_map", "parentIds": ["reader_t.monad_functor"]}, {"id": "bit1_zero", "parentIds": []}, {"id": "tactic.destruct", "parentIds": ["tactic.interactive.destruct", "smt_tactic.destruct"]}, {"id": "nat.le_of_le_of_sub_le_sub_right", "parentIds": ["nat.sub_le_sub_right_iff"]}, {"id": "not_lt_of_lt", "parentIds": []}, {"id": "vm.trace", "parentIds": []}, {"id": "vm_core.monad", "parentIds": ["vm.trace"]}, {"id": "bool.exists_bool", "parentIds": []}, {"id": "id_map'", "parentIds": []}, {"id": "unification_constraint.inhabited", "parentIds": ["unification_hint.inhabited"]}, {"id": "sort.inhabited'", "parentIds": ["unification_constraint.inhabited"]}, {"id": "sort.inhabited", "parentIds": ["unification_constraint.inhabited", "sort.inhabited'"]}, {"id": "heq.symm", "parentIds": []}, {"id": "simp_lemmas.erase", "parentIds": ["tactic.mk_simp_set_core"]}, {"id": "where.resolve_var", "parentIds": []}, {"id": "bool.has_to_format", "parentIds": []}, {"id": "bool.bxor_bnot_bnot", "parentIds": []}, {"id": "tactic.set_string_option", "parentIds": []}, {"id": "options.set_string", "parentIds": ["tactic.set_string_option"]}, {"id": "old_conv.bind", "parentIds": ["old_conv.monad"]}, {"id": "old_conv.pure", "parentIds": ["old_conv.monad"]}, {"id": "old_conv.map", "parentIds": ["old_conv.monad"]}, {"id": "environment.is_structure", "parentIds": ["environment.get_modifiers"]}, {"id": "nat.sub_mul_div", "parentIds": ["nat.mod_pow_succ"]}, {"id": "tactic.rcases_patt_inverted.has_to_format", "parentIds": []}, {"id": "tactic.match_refl_app", "parentIds": []}, {"id": "function.injective_iff_has_left_inverse", "parentIds": []}, {"id": "function.injective.has_left_inverse", "parentIds": ["function.injective_iff_has_left_inverse"]}, {"id": "native.rb_map.mmap", "parentIds": []}, {"id": "nat.bit0_ne_bit1", "parentIds": []}, {"id": "smt_tactic.get_lemmas", "parentIds": []}, {"id": "comm_monoid.to_monoid", "parentIds": []}, {"id": "fin.sub_def", "parentIds": []}, {"id": "nat.pred_lt", "parentIds": []}, {"id": "le_imp_le_iff_lt_imp_lt", "parentIds": []}, {"id": "le_imp_le_of_lt_imp_lt", "parentIds": ["le_imp_le_iff_lt_imp_lt"]}, {"id": "list.sections", "parentIds": []}, {"id": "set.piecewise", "parentIds": []}, {"id": "list.scanl", "parentIds": []}, {"id": "function.uncurry_def", "parentIds": []}, {"id": "cc_state.pp_core", "parentIds": ["cc_state.has_to_tactic_format"]}, {"id": "tactic.head_eta_expand", "parentIds": []}, {"id": "nat.exists_eq_succ_of_ne_zero", "parentIds": []}, {"id": "and_iff_not_or_not", "parentIds": []}, {"id": "function.comp_left", "parentIds": []}, {"id": "tactic.suggest.process_declaration", "parentIds": ["tactic.suggest.library_defs"]}, {"id": "tactic.suggest.decl_data", "parentIds": ["tactic.suggest.process_declaration", "tactic.suggest.library_defs", "tactic.suggest.apply_declaration"]}, {"id": "param_info.has_to_format", "parentIds": ["fun_info_to_format"]}, {"id": "format.dcbrace", "parentIds": ["fun_info_to_format"]}, {"id": "ne.intro", "parentIds": []}, {"id": "sum.traverse", "parentIds": ["sum.traversable"]}, {"id": "char.of_nat_ne_of_ne", "parentIds": []}, {"id": "div_nonpos_of_nonneg_of_neg", "parentIds": []}, {"id": "quot.eqv_gen_sound", "parentIds": []}, {"id": "inv_inj", "parentIds": []}, {"id": "div_div_eq_mul_div", "parentIds": ["div_div_div_div_eq"]}, {"id": "one_div_div", "parentIds": ["div_div_eq_mul_div"]}, {"id": "exists_prop_of_true", "parentIds": []}, {"id": "exists_const", "parentIds": ["exists_prop_of_true"]}, {"id": "option.lhoare", "parentIds": []}, {"id": "tactic.andthen_seq_focus", "parentIds": []}, {"id": "right_identity", "parentIds": []}, {"id": "tactic.instantiate_mvars_in_goals", "parentIds": []}, {"id": "list.for_each", "parentIds": []}, {"id": "tactic.rcases_core", "parentIds": ["tactic.rcases"]}, {"id": "int.neg_succ_of_nat_coe", "parentIds": ["int.neg_succ_of_nat_lt_zero"]}, {"id": "is_per", "parentIds": []}, {"id": "lt_iff_lt_of_le_iff_le", "parentIds": ["decidable.le_iff_le_iff_lt_iff_lt", "le_iff_le_iff_lt_iff_lt"]}, {"id": "nat.sub.right_comm", "parentIds": []}, {"id": "tactic.fsplit", "parentIds": ["tactic.interactive.fsplit"]}, {"id": "nat.add_left_comm", "parentIds": ["nat.left_distrib", "nat.right_distrib", "nat.succ_mul"]}, {"id": "cc_state.fold_eqc_core", "parentIds": ["cc_state.fold_eqc"]}, {"id": "native.float.has_neg", "parentIds": []}, {"id": "tactic.interactive.constructor_matching", "parentIds": []}, {"id": "expr.get_weight", "parentIds": []}, {"id": "rbnode.mk_insert_result", "parentIds": ["rbnode.insert"]}, {"id": "undefined_core", "parentIds": ["undefined"]}, {"id": "nat.mod_self", "parentIds": ["nat.gcd_self"]}, {"id": "neq_of_not_iff", "parentIds": []}, {"id": "nat.shiftl_succ", "parentIds": []}, {"id": "tactic.assoc_rewrite", "parentIds": ["tactic.assoc_rewrite_hyp", "tactic.assoc_rewrite_target"]}, {"id": "tactic.mk_assoc_instance", "parentIds": ["tactic.assoc_rewrite"]}, {"id": "expr.simp", "parentIds": []}, {"id": "functor.comp.id_map", "parentIds": ["functor.comp.is_lawful_functor"]}, {"id": "expr.is_numeral", "parentIds": ["well_founded_tactics.check_target_is_value_lt"]}, {"id": "open_locale_cmd", "parentIds": []}, {"id": "tactic.assoc_rewrite_hyp", "parentIds": []}, {"id": "le_of_forall_le'", "parentIds": []}, {"id": "min_assoc", "parentIds": ["min_left_comm"]}, {"id": "tactic.interactive.conv", "parentIds": ["tactic.interactive.conv_rhs", "tactic.interactive.conv_lhs"]}, {"id": "mul_dvd_mul_left", "parentIds": []}, {"id": "dvd_refl", "parentIds": ["mul_dvd_mul_left", "mul_dvd_mul_right"]}, {"id": "expr.dsimp", "parentIds": []}, {"id": "vm.get_options", "parentIds": []}, {"id": "rbtree.has_mem", "parentIds": []}, {"id": "ordering.ite_eq_eq_distrib", "parentIds": ["cmp_using_eq_eq"]}, {"id": "char.is_alphanum", "parentIds": ["char.decidable_is_alphanum"]}, {"id": "list.head'", "parentIds": []}, {"id": "has_well_founded_of_has_sizeof", "parentIds": []}, {"id": "sizeof_measure_wf", "parentIds": ["has_well_founded_of_has_sizeof"]}, {"id": "level.has_param", "parentIds": []}, {"id": "norm_num.bin_zero_add", "parentIds": []}, {"id": "simps_parser", "parentIds": []}, {"id": "name.last", "parentIds": ["simps_parser", "declaration.is_auto_generated", "tactic.delta_instance"]}, {"id": "smt_tactic.has_monad_lift", "parentIds": ["smt_tactic.has_coe"]}, {"id": "tactic_to_smt_tactic", "parentIds": ["smt_tactic.has_monad_lift"]}, {"id": "get_linters", "parentIds": ["get_checks"]}, {"id": "int.sign_eq_zero_iff_zero", "parentIds": []}, {"id": "int.eq_zero_of_sign_eq_zero", "parentIds": ["int.sign_eq_zero_iff_zero"]}, {"id": "norm_num.sub_nat_pos_helper", "parentIds": []}, {"id": "subtype.has_repr", "parentIds": []}, {"id": "eq_iff_le_not_lt", "parentIds": []}, {"id": "declaration.update_with_fun", "parentIds": []}, {"id": "expr.apply_replacement_fun", "parentIds": ["declaration.update_with_fun"]}, {"id": "imp_or_distrib", "parentIds": []}, {"id": "or_self", "parentIds": ["imp_or_distrib", "or_eq_of_eq", "bool.to_bool_or", "bor_eq_true_eq_eq_tt_or_eq_tt", "band_eq_false_eq_eq_ff_or_eq_ff"]}, {"id": "tactic.iterate_at_most", "parentIds": ["tactic.iterate"]}, {"id": "option.alternative", "parentIds": ["tactic.find_private_decl"]}, {"id": "list.filter_sublist", "parentIds": []}, {"id": "prod.snd_swap", "parentIds": []}, {"id": "tactic.interactive.trace_state", "parentIds": []}, {"id": "eq_iff_iff", "parentIds": []}, {"id": "rbnode.get_color", "parentIds": ["rbnode.insert"]}, {"id": "rbnode.ins", "parentIds": ["rbnode.insert"]}, {"id": "neg_involutive", "parentIds": []}, {"id": "sum.has_repr", "parentIds": []}, {"id": "function.involutive.right_inverse", "parentIds": []}, {"id": "native.float.has_le", "parentIds": ["native.float.decidable_le"]}, {"id": "native.float.le", "parentIds": ["native.float.has_le", "native.float.decidable_le"]}, {"id": "bool.tt_eq_to_bool_iff", "parentIds": []}, {"id": "lt_add_of_neg_lt_sub_right", "parentIds": []}, {"id": "add_lt_of_lt_sub_left", "parentIds": ["lt_add_of_neg_lt_sub_right"]}, {"id": "mul_inv_eq_one", "parentIds": []}, {"id": "tactic.mk_assoc", "parentIds": ["tactic.flatten", "tactic.mk_eq_proof"]}, {"id": "neg_of_mul_neg_left", "parentIds": []}, {"id": "nat.add_mod_left", "parentIds": []}, {"id": "mul_left_injective", "parentIds": []}, {"id": "environment.is_recursor", "parentIds": ["environment.get_modifiers"]}, {"id": "except_t.run_monad_map", "parentIds": []}, {"id": "except_t.monad_functor", "parentIds": ["except_t.run_monad_map"]}, {"id": "level.dedup_size", "parentIds": []}, {"id": "int.lt_of_sub_one_le", "parentIds": []}, {"id": "unsigned.has_div", "parentIds": []}, {"id": "fin.div", "parentIds": ["unsigned.has_div", "fin.has_div", "fin.div_def"]}, {"id": "expr.is_aux_decl", "parentIds": []}, {"id": "exceptional.monad", "parentIds": []}, {"id": "exceptional.bind", "parentIds": ["exceptional.monad"]}, {"id": "native.float.hypot", "parentIds": []}, {"id": "tactic.ematch", "parentIds": []}, {"id": "semigroup_to_is_associative", "parentIds": []}, {"id": "list.is_lawful_monad", "parentIds": []}, {"id": "list.nil_bind", "parentIds": ["list.is_lawful_monad"]}, {"id": "list.cons_bind", "parentIds": ["list.is_lawful_monad", "list.append_bind"]}, {"id": "list.append_bind", "parentIds": ["list.is_lawful_monad"]}, {"id": "map_ext_congr", "parentIds": ["except_t.is_lawful_monad", "option_t.is_lawful_monad"]}, {"id": "tactic.interactive.convert_to", "parentIds": ["tactic.interactive.ac_change"]}, {"id": "inv_comm_of_comm", "parentIds": []}, {"id": "level.has_to_string", "parentIds": []}, {"id": "or.neg_resolve_right", "parentIds": []}, {"id": "reader_t.orelse", "parentIds": ["reader_t.alternative"]}, {"id": "char.decidable_le", "parentIds": []}, {"id": "vm_decl.pos", "parentIds": []}, {"id": "nat.zero_lt_bit1", "parentIds": []}, {"id": "char.decidable_is_lower", "parentIds": ["char.decidable_is_alpha"]}, {"id": "old_conv.apply_simp_set", "parentIds": []}, {"id": "tactic.set_options", "parentIds": ["tactic.save_options"]}, {"id": "bxor_tt", "parentIds": ["ff_bxor", "tt_bxor"]}, {"id": "nat.one_ne_bit0", "parentIds": []}, {"id": "tactic.unsafe.type_context.is_assigned", "parentIds": []}, {"id": "smt_tactic.interactive.apply", "parentIds": []}, {"id": "tactic.interactive.funext", "parentIds": []}, {"id": "tactic.funext_lst", "parentIds": ["tactic.interactive.funext"]}, {"id": "tactic.funext", "parentIds": ["tactic.interactive.funext"]}, {"id": "nat.bit1_inj", "parentIds": ["nat.bit1_ne"]}, {"id": "nat.bit1_eq_succ_bit0", "parentIds": ["nat.bit1_inj", "nat.bit1_succ_eq"]}, {"id": "int.shiftr", "parentIds": []}, {"id": "int.shiftl", "parentIds": ["int.shiftr"]}, {"id": "smt_tactic.interactive.close", "parentIds": []}, {"id": "nat.eq_or_lt_of_not_lt", "parentIds": []}, {"id": "get_attribute_cache_dyn", "parentIds": ["get_hinst_lemmas_for_attr", "get_name_set_for_attr", "tactic.get_user_simp_lemmas"]}, {"id": "eq_is_equiv", "parentIds": []}, {"id": "unification_hint.inhabited", "parentIds": []}, {"id": "parser.ch", "parentIds": ["parser.str", "parser.char_buf", "tactic.alias.make_left_right"]}, {"id": "sub_le_of_abs_sub_le_right", "parentIds": []}, {"id": "lt_neg_of_lt_neg", "parentIds": []}, {"id": "psum.has_sizeof", "parentIds": []}, {"id": "vm.get_decl", "parentIds": []}, {"id": "state_t.run_put", "parentIds": []}, {"id": "char_to_hex", "parentIds": ["char.quote_core"]}, {"id": "norm_num.subst_into_prod", "parentIds": []}, {"id": "cmp_compares", "parentIds": []}, {"id": "cmp", "parentIds": ["cmp_compares", "cmp_swap"]}, {"id": "le_of_forall_le", "parentIds": []}, {"id": "tactic.fconstructor", "parentIds": ["tactic.interactive.fconstructor"]}, {"id": "hinst_lemmas.pp", "parentIds": ["hinst_lemmas.has_to_tactic_format"]}, {"id": "format.is_nil", "parentIds": ["hinst_lemmas.pp"]}, {"id": "min_left_comm", "parentIds": []}, {"id": "lift_pair\u2082", "parentIds": []}, {"id": "tactic.interactive.exacts", "parentIds": []}, {"id": "division_ring.neg_div_neg_eq", "parentIds": ["neg_div_neg_eq"]}, {"id": "div_neg_eq_neg_div", "parentIds": ["division_ring.neg_div_neg_eq"]}, {"id": "neg_div", "parentIds": ["division_ring.neg_div_neg_eq", "div_sub_div_same"]}, {"id": "tactic.collect_ctx_simps", "parentIds": ["tactic.mk_simp_set_core"]}, {"id": "tactic.simp_bottom_up'", "parentIds": []}, {"id": "or_eq_of_eq_false_right", "parentIds": []}, {"id": "environment.get_class_attribute_symbols", "parentIds": []}, {"id": "max_neg_neg", "parentIds": ["min_eq_neg_max_neg_neg"]}, {"id": "bool.default_bool", "parentIds": []}, {"id": "name.last_string", "parentIds": []}, {"id": "ordering.or_else_eq_lt", "parentIds": []}, {"id": "let_eq", "parentIds": []}, {"id": "native.float.mantissa", "parentIds": []}, {"id": "mul_dvd_mul_right", "parentIds": []}, {"id": "tactic.match_stub", "parentIds": []}, {"id": "eq_zero_of_mul_self_add_mul_self_eq_zero", "parentIds": []}, {"id": "mul_self_nonneg", "parentIds": ["eq_zero_of_mul_self_add_mul_self_eq_zero"]}, {"id": "list.lookmap", "parentIds": []}, {"id": "seq_bind_eq", "parentIds": []}, {"id": "option.mem_to_list", "parentIds": []}, {"id": "option.mem_def", "parentIds": ["option.mem_to_list"]}, {"id": "option.to_list", "parentIds": ["option.mem_to_list"]}, {"id": "nat.lt_of_add_lt_add_left", "parentIds": []}, {"id": "tactic.mk_constructor_fresh_names", "parentIds": []}, {"id": "cc_state.inc_gmt", "parentIds": []}, {"id": "sum.elim_inr", "parentIds": []}, {"id": "lt_add_of_pos_of_lt", "parentIds": []}, {"id": "bex.imp_left", "parentIds": []}, {"id": "tactic.delta_hyp", "parentIds": ["tactic.interactive.delta"]}, {"id": "buffer.has_to_format", "parentIds": []}, {"id": "list.inth", "parentIds": []}, {"id": "cmp_swap", "parentIds": []}, {"id": "nat.prio", "parentIds": []}, {"id": "guard_true", "parentIds": []}, {"id": "eq_of_neg_eq_neg", "parentIds": []}, {"id": "where.is_in_namespace_nonsynthetic", "parentIds": ["where.get_all_in_namespace"]}, {"id": "nat.bit0_lt_bit1", "parentIds": []}, {"id": "vm.stack_size", "parentIds": []}, {"id": "prod.has_well_founded", "parentIds": []}, {"id": "setoid.symm", "parentIds": []}, {"id": "tactic.i_to_expr_no_subgoals", "parentIds": ["tactic.interactive.has_to_tactic_format"]}, {"id": "list_linters", "parentIds": []}, {"id": "eq_tt_of_not_eq_ff", "parentIds": []}, {"id": "eq_true", "parentIds": []}, {"id": "iff_eq_eq", "parentIds": ["eq_true", "eq_false"]}, {"id": "mul_eq_mul_of_div_eq_div", "parentIds": []}, {"id": "neg_lt_of_neg_lt", "parentIds": []}, {"id": "fin.elim0", "parentIds": ["mk_buffer"]}, {"id": "classical.imp_iff_not_or", "parentIds": []}, {"id": "is_symm_op_of_is_commutative", "parentIds": []}, {"id": "eq_mul_inv_of_mul_eq", "parentIds": []}, {"id": "and_eq_of_eq", "parentIds": []}, {"id": "subtype.tag_irrelevant", "parentIds": []}, {"id": "of_iff_true", "parentIds": ["forall_true_iff'"]}, {"id": "native.rb_lmap.insert", "parentIds": []}, {"id": "environment.is_constructor", "parentIds": ["declaration.is_auto_generated", "environment.is_constructor_app", "environment.get_modifiers"]}, {"id": "list.map_last", "parentIds": []}, {"id": "tactic.interactive.list_cast_of", "parentIds": ["tactic.interactive.h_generalize"]}, {"id": "tactic.interactive.list_cast_of_aux", "parentIds": ["tactic.interactive.list_cast_of"]}, {"id": "or_eq_of_eq", "parentIds": []}, {"id": "nat.sub_add_min_cancel", "parentIds": []}, {"id": "tactic.mk_simp_set_core", "parentIds": ["tactic.interactive.simp_core", "tactic.mk_simp_set"]}, {"id": "tactic.simp_all", "parentIds": ["tactic.interactive.simp_core"]}, {"id": "add_add_neg_cancel'_right", "parentIds": []}, {"id": "list.append_assoc", "parentIds": ["list.append_bind"]}, {"id": "level.normalize", "parentIds": []}, {"id": "if_eq_of_eq_false", "parentIds": []}, {"id": "declaration.univ_levels", "parentIds": ["tactic.import_private_cmd"]}, {"id": "tactic.unsafe.type_context.instantiate_mvars", "parentIds": []}, {"id": "native.float.exp2", "parentIds": []}, {"id": "vm_core.bind", "parentIds": ["vm_core.monad"]}, {"id": "function.surjective_id", "parentIds": ["function.bijective_id"]}, {"id": "string.str_ne_str_left", "parentIds": []}, {"id": "list.le", "parentIds": ["list.has_le"]}, {"id": "array.map\u2082", "parentIds": []}, {"id": "array.foreach", "parentIds": ["array.map\u2082", "array.map"]}, {"id": "where.binder_priority", "parentIds": ["where.binder_less_important"]}, {"id": "option.rel", "parentIds": []}, {"id": "mul_left_surjective", "parentIds": []}, {"id": "nat.succ_ne_self", "parentIds": []}, {"id": "list.has_union", "parentIds": []}, {"id": "lean.parser.reflectable.cast", "parentIds": []}, {"id": "mul_lt_of_lt_div", "parentIds": []}, {"id": "classical.eq_false_or_eq_true", "parentIds": []}, {"id": "or.symm", "parentIds": ["classical.eq_false_or_eq_true", "eq_or_lt_of_le"]}, {"id": "tactic.add_meta_definition", "parentIds": ["tactic.def_replacer", "mk_name_set_attr"]}, {"id": "tactic.replacer_attr", "parentIds": ["tactic.def_replacer", "tactic.replaceable_attr"]}, {"id": "tactic.mk_replacer", "parentIds": ["tactic.def_replacer"]}, {"id": "tactic.injection", "parentIds": ["tactic.injections_and_clear", "derive_struct_ext_lemma"]}, {"id": "tactic.interactive.conv_rhs", "parentIds": []}, {"id": "conv.interactive.to_rhs", "parentIds": ["tactic.interactive.conv_rhs"]}, {"id": "occurrences.contains", "parentIds": []}, {"id": "conv.interactive.erw", "parentIds": []}, {"id": "list.disjoint", "parentIds": []}, {"id": "tactic.interactive.done", "parentIds": ["tactic.interactive.field"]}, {"id": "nat.mul_self_sub_mul_self_eq", "parentIds": []}, {"id": "pprod.inhabited", "parentIds": []}, {"id": "interaction_monad_orelse", "parentIds": ["tactic.alternative"]}, {"id": "dvd_sub", "parentIds": ["dvd_add_iff_left"]}, {"id": "pure_id_seq", "parentIds": ["pure_id'_seq"]}, {"id": "div_eq_one_iff_eq", "parentIds": ["eq_of_div_eq_one"]}, {"id": "lt_or_le", "parentIds": []}, {"id": "lean.parser.reflectable.expr", "parentIds": ["lean.parser.reflect"]}, {"id": "tactic.interactive.match_target", "parentIds": []}, {"id": "string.append", "parentIds": ["string.has_append"]}, {"id": "tactic.mk_eq_mpr", "parentIds": ["tactic.replace_target"]}, {"id": "native.float.sNaN", "parentIds": []}, {"id": "simp_lemmas.append", "parentIds": ["tactic.mk_simp_set_core"]}, {"id": "sum.exists", "parentIds": []}, {"id": "eq_mul_of_inv_mul_eq", "parentIds": []}, {"id": "fun_info.inhabited", "parentIds": []}, {"id": "array.pop_back", "parentIds": []}, {"id": "forall_not_of_not_exists", "parentIds": []}, {"id": "norm_num.bit1_add_bit1", "parentIds": []}, {"id": "except_t.monad_except", "parentIds": []}, {"id": "except_t.catch", "parentIds": ["except_t.monad_except"]}, {"id": "nat.zero_ne_bit0", "parentIds": []}, {"id": "nat.bit0_ne_zero", "parentIds": ["nat.zero_ne_bit0", "char.zero_lt_d800"]}, {"id": "tactic.interactive.async", "parentIds": []}, {"id": "tactic.prove_goal_async", "parentIds": ["tactic.interactive.async"]}, {"id": "inv_mul_self", "parentIds": []}, {"id": "measure_wf", "parentIds": ["sizeof_measure_wf"]}, {"id": "sum.swap_swap_eq", "parentIds": []}, {"id": "debugger.attr", "parentIds": []}, {"id": "left_inverse_sub_add_left", "parentIds": []}, {"id": "buffer.lt_aux_1", "parentIds": []}, {"id": "nat.gcd_zero_right", "parentIds": ["nat.gcd_rec"]}, {"id": "monad_except.orelse'", "parentIds": []}, {"id": "exists_prop_of_false", "parentIds": []}, {"id": "iff_eq_of_eq_true_left", "parentIds": []}, {"id": "tactic.back_chaining_using", "parentIds": []}, {"id": "list.inter", "parentIds": ["list.has_inter"]}, {"id": "tactic.simp_hyp", "parentIds": ["tactic.reduce_ifs_at"]}, {"id": "neg_eq_iff_add_eq_zero", "parentIds": []}, {"id": "function.involutive.bijective", "parentIds": []}, {"id": "function.cantor_surjective", "parentIds": ["function.cantor_injective"]}, {"id": "iff_not_self", "parentIds": ["function.cantor_surjective"]}, {"id": "psigma.skip_left_wf", "parentIds": []}, {"id": "empty_wf", "parentIds": ["psigma.skip_left_wf"]}, {"id": "binder.has_to_format", "parentIds": []}, {"id": "le_add_of_neg_add_le_right", "parentIds": []}, {"id": "std.priority.max", "parentIds": []}, {"id": "function.comp_const_right", "parentIds": []}, {"id": "derive_handler_attr", "parentIds": []}, {"id": "nat.pow_lt_pow_of_lt_left", "parentIds": []}, {"id": "tactic.back_lemmas_insert", "parentIds": []}, {"id": "add_left_surjective", "parentIds": []}, {"id": "is_lawful_applicative.map_comp_pure", "parentIds": []}, {"id": "nat.sub_le_sub_right_iff", "parentIds": ["nat.add_le_to_le_sub"]}, {"id": "nat.sub_le_sub_right", "parentIds": ["nat.sub_le_sub_right_iff"]}, {"id": "unsigned.has_to_format", "parentIds": []}, {"id": "linter.doc_blame", "parentIds": []}, {"id": "dvd.elim_left", "parentIds": []}, {"id": "tactic.mllist.mfilter_map", "parentIds": ["tactic.mllist.mfirst"]}, {"id": "lean.parser_state.env", "parentIds": []}, {"id": "smt_tactic.interactive.eblast_using", "parentIds": []}, {"id": "native.rb_lmap.erase", "parentIds": []}, {"id": "trace_val", "parentIds": []}, {"id": "mul_div_mul_right'", "parentIds": []}, {"id": "tactic.mk_eq_trans", "parentIds": []}, {"id": "hinst_lemmas.has_to_tactic_format", "parentIds": []}, {"id": "norm_num.one_add_one", "parentIds": []}, {"id": "mjoin_map_mjoin", "parentIds": []}, {"id": "add_left_cancel_iff", "parentIds": []}, {"id": "sub_lt_of_sub_lt", "parentIds": []}, {"id": "bool_eq_false", "parentIds": []}, {"id": "vm_obj.kind", "parentIds": []}, {"id": "parser.fix", "parentIds": []}, {"id": "neg_eq_zero", "parentIds": ["neg_ne_zero"]}, {"id": "lt_sub_right_of_add_lt", "parentIds": []}, {"id": "nat.mod_def_aux", "parentIds": ["nat.mod_def"]}, {"id": "ordered_ring.mul_lt_mul_of_pos_right", "parentIds": ["ordered_ring.to_ordered_semiring"]}, {"id": "vm.get_env", "parentIds": []}, {"id": "native.float.has_repr", "parentIds": []}, {"id": "exists.classical_rec_on", "parentIds": []}, {"id": "tactic.unsafe.type_context.orelse", "parentIds": ["tactic.unsafe.type_context.type_context_alternative"]}, {"id": "tactic.unsafe.type_context.try", "parentIds": ["tactic.unsafe.type_context.orelse"]}, {"id": "reader_t.alternative", "parentIds": []}, {"id": "reader_t.failure", "parentIds": ["reader_t.alternative"]}, {"id": "well_founded.fix_F_eq", "parentIds": ["well_founded.fix_eq"]}, {"id": "tactic.mllist.take", "parentIds": ["tactic.suggest"]}, {"id": "sub_add_eq_add_sub", "parentIds": []}, {"id": "unit.has_to_string", "parentIds": []}, {"id": "dif_ctx_simp_congr", "parentIds": []}, {"id": "tactic.unsafe.type_context.get_context", "parentIds": []}, {"id": "mk_array", "parentIds": []}, {"id": "sum.swap_left_inverse", "parentIds": []}, {"id": "and.rotate", "parentIds": []}, {"id": "classical.nonempty_pi", "parentIds": []}, {"id": "function.comp.left_id", "parentIds": []}, {"id": "decidable_eq_of_bool_pred", "parentIds": []}, {"id": "nat.shiftl_add", "parentIds": []}, {"id": "exists_eq_right'", "parentIds": []}, {"id": "conv.interactive.for", "parentIds": []}, {"id": "div_lt_div_of_pos_of_lt_of_pos", "parentIds": []}, {"id": "lt_of_sub_neg", "parentIds": ["div_lt_div_of_pos_of_lt_of_pos"]}, {"id": "sub_neg_of_lt", "parentIds": ["div_lt_div_of_pos_of_lt_of_pos", "dist_bdd_within_interval"]}, {"id": "int.sub_one_le_of_lt", "parentIds": []}, {"id": "int.lt_add_one_of_le", "parentIds": ["int.sub_one_le_of_lt"]}, {"id": "neg_ne_zero", "parentIds": []}, {"id": "le_antisymm_iff", "parentIds": []}, {"id": "coe_fn_b", "parentIds": []}, {"id": "sum.lex_inr_inl", "parentIds": []}, {"id": "eq_of_mul_eq_mul_left", "parentIds": ["int.eq_one_of_mul_eq_self_right"]}, {"id": "tactic.backward_chaining_core", "parentIds": ["tactic.back_chaining_core"]}, {"id": "tactic.get_nat_option", "parentIds": ["tactic.back_chaining_core"]}, {"id": "rbtree.find", "parentIds": ["rbtree.contains"]}, {"id": "int.bodd", "parentIds": []}, {"id": "rbmap.rbmap_lt_dec", "parentIds": ["rbmap.insert"]}, {"id": "max_add_add_right", "parentIds": []}, {"id": "int.exists_eq_neg_of_nat", "parentIds": []}, {"id": "norm_num.neg_mul_neg_helper", "parentIds": []}, {"id": "forall_or_of_or_forall", "parentIds": ["forall_or_distrib_left"]}, {"id": "one_div_one_div", "parentIds": []}, {"id": "tactic.interactive.mapply", "parentIds": []}, {"id": "cc_state.is_not_eqv", "parentIds": []}, {"id": "sequence", "parentIds": []}, {"id": "abs_abs", "parentIds": []}, {"id": "tactic.interactive.specialize", "parentIds": []}, {"id": "nonempty.congr", "parentIds": []}, {"id": "tactic.get_assignment", "parentIds": []}, {"id": "comp.applicative_comp_id", "parentIds": []}, {"id": "list.remove_nth", "parentIds": ["tactic.interactive.swap", "list.length_remove_nth"]}, {"id": "tactic.mk_meta_pis", "parentIds": []}, {"id": "native.float.epsilon", "parentIds": []}, {"id": "tactic.interactive.refine_one", "parentIds": []}, {"id": "tactic.interactive.source_fields", "parentIds": ["tactic.interactive.refine_one"]}, {"id": "tactic.interactive.apply_auto_param", "parentIds": ["tactic.interactive.refine_one"]}, {"id": "decidable.not_and_iff_or_not", "parentIds": []}, {"id": "function.right_inverse.comp", "parentIds": []}, {"id": "function.left_inverse.comp", "parentIds": ["function.right_inverse.comp"]}, {"id": "eq_sub_iff_add_eq", "parentIds": ["eq_sub_iff_add_eq'"]}, {"id": "tactic.new_aux_decl_name", "parentIds": ["tactic.prove_goal_async", "tactic.import_private_cmd"]}, {"id": "tactic.run_async", "parentIds": ["tactic.prove_goal_async", "derive_struct_ext_lemma"]}, {"id": "lean.parser.parser_orelse", "parentIds": ["lean.parser.alternative"]}, {"id": "ball_and_distrib", "parentIds": []}, {"id": "buffer.to_string", "parentIds": ["parser.char_buf"]}, {"id": "native.float.has_mul", "parentIds": []}, {"id": "native.float.mul", "parentIds": ["native.float.has_mul"]}, {"id": "char.decidable_is_whitespace", "parentIds": []}, {"id": "tactic.kabstract", "parentIds": []}, {"id": "string.has_repr", "parentIds": []}, {"id": "tactic.interactive.apply_with", "parentIds": []}, {"id": "tactic.interactive.left", "parentIds": []}, {"id": "d_array.of_beq_eq_tt", "parentIds": []}, {"id": "mul_inv_eq_of_eq_mul", "parentIds": []}, {"id": "heq.subst", "parentIds": ["heq.trans"]}, {"id": "expr.to_binder", "parentIds": ["dangerous_instance"]}, {"id": "punit_eq_punit", "parentIds": []}, {"id": "nat.two_step_induction", "parentIds": []}, {"id": "tactic.interactive.exfalso", "parentIds": []}, {"id": "list.take'", "parentIds": []}, {"id": "environment.for_decl_of_imported_module_name", "parentIds": []}, {"id": "options.contains", "parentIds": []}, {"id": "except_t.is_lawful_monad", "parentIds": []}, {"id": "except_t.bind", "parentIds": ["except_t.is_lawful_monad", "except_t.monad"]}, {"id": "except_t.run_bind", "parentIds": ["except_t.is_lawful_monad"]}, {"id": "tactic.dunfold_config.inhabited", "parentIds": []}, {"id": "tactic.funext_core", "parentIds": ["tactic.funext", "tactic.funext_lst"]}, {"id": "unsigned.has_add", "parentIds": []}, {"id": "heq_of_eq_rec_right", "parentIds": []}, {"id": "bool.band_intro", "parentIds": []}, {"id": "tactic.mk_congr", "parentIds": []}, {"id": "format.of_nat", "parentIds": ["nat.has_to_format", "nat_to_format"]}, {"id": "decidable.le_iff_le_iff_lt_iff_lt", "parentIds": []}, {"id": "vm_local_info", "parentIds": ["vm_decl.args_info"]}, {"id": "nat.test_bit_land", "parentIds": []}, {"id": "eq_of_abs_sub_eq_zero", "parentIds": []}, {"id": "nonpos_of_neg_nonneg", "parentIds": []}, {"id": "tactic.interactive.fapply", "parentIds": ["smt_tactic.interactive.fapply"]}, {"id": "nat.repeat", "parentIds": []}, {"id": "two_ge_one", "parentIds": []}, {"id": "dvd_of_mul_left_eq", "parentIds": []}, {"id": "band_coe_iff", "parentIds": []}, {"id": "ordered_ring.mul_le_mul_of_nonneg_left", "parentIds": ["ordered_ring.to_ordered_semiring"]}, {"id": "sum.forall", "parentIds": []}, {"id": "expr.bind_lambda", "parentIds": []}, {"id": "old_conv.find", "parentIds": []}, {"id": "name.pop_nth_prefix", "parentIds": ["name.pop_prefix"]}, {"id": "array.iterate", "parentIds": ["array.foreach", "array.foldl"]}, {"id": "neg_add_lt_left_of_lt_add", "parentIds": ["neg_add_lt_right_of_lt_add"]}, {"id": "tactic.unsafe.type_context.level.assign", "parentIds": []}, {"id": "option.lift_or_get_is_right_id", "parentIds": []}, {"id": "rbnode.fold", "parentIds": []}, {"id": "lean.parser.itactic", "parentIds": []}, {"id": "lean.parser.itactic_reflected", "parentIds": ["lean.parser.itactic"]}, {"id": "fold_over_with_cond_sorted", "parentIds": ["lint_mathlib", "lint_all"]}, {"id": "decidable.not_or_iff_and_not", "parentIds": []}, {"id": "bxor_ff", "parentIds": ["ff_bxor", "tt_bxor"]}, {"id": "except.to_bool", "parentIds": []}, {"id": "state_t.monad_run", "parentIds": []}, {"id": "tactic.rcases_patt.invert_list", "parentIds": []}, {"id": "mul_div_mul_right", "parentIds": ["div_add_div"]}, {"id": "default_has_sizeof", "parentIds": []}, {"id": "conv.interactive.rewrite", "parentIds": []}, {"id": "vm_monitor", "parentIds": []}, {"id": "eq_zero_of_mul_eq_self_left", "parentIds": []}, {"id": "bool.bor_inr", "parentIds": []}, {"id": "char.quote_core", "parentIds": ["char.has_repr"]}, {"id": "if_true_left_eq_or", "parentIds": []}, {"id": "native.float.decidable_le", "parentIds": []}, {"id": "tactic.interactive.casesm", "parentIds": []}, {"id": "push_neg.push_neg_at_goal", "parentIds": ["tactic.interactive.push_neg"]}, {"id": "old_conv.top_down", "parentIds": []}, {"id": "tactic.get_pi_binders_dep", "parentIds": ["impossible_instance"]}, {"id": "monad.unlessb", "parentIds": []}, {"id": "classical.eq_true_or_eq_false", "parentIds": []}, {"id": "parser.str", "parentIds": []}, {"id": "native.rb_set.inhabited", "parentIds": []}, {"id": "parser.many_char", "parentIds": ["tactic.alias.make_left_right"]}, {"id": "int.test_bit", "parentIds": []}, {"id": "iff_eq_of_eq_true_right", "parentIds": []}, {"id": "eq_sub_of_add_eq'", "parentIds": []}, {"id": "unfolds_to_class", "parentIds": ["incorrect_type_class_argument"]}, {"id": "expr.pi_codomain", "parentIds": ["incorrect_type_class_argument", "instance_priority", "ge_or_gt_in_statement", "has_inhabited_instance"]}, {"id": "reader_t.run_monad_map", "parentIds": []}, {"id": "tactic.interactive.clean", "parentIds": []}, {"id": "tactic.interactive.clean_ids", "parentIds": ["tactic.interactive.clean"]}, {"id": "int.nat_abs_one", "parentIds": []}, {"id": "prop.inhabited", "parentIds": []}, {"id": "psigma.lex_accessible", "parentIds": []}, {"id": "expr.is_eta_expansion", "parentIds": []}, {"id": "environment.trust_lvl", "parentIds": []}, {"id": "bool.bnot_true", "parentIds": []}, {"id": "int.to_nat_sub", "parentIds": []}, {"id": "sum.has_sizeof", "parentIds": []}, {"id": "tactic.select", "parentIds": []}, {"id": "tactic.apply_rules", "parentIds": ["tactic.interactive.apply_rules"]}, {"id": "options.inhabited", "parentIds": []}, {"id": "bool.decidable_exists_bool", "parentIds": []}, {"id": "list.pw_filter", "parentIds": ["list.erase_dup"]}, {"id": "native.nat_map", "parentIds": ["native.mk_nat_map"]}, {"id": "cc_config.inhabited", "parentIds": []}, {"id": "native.float.has_float_pow", "parentIds": []}, {"id": "environment.inhabited", "parentIds": []}, {"id": "tactic.rexact", "parentIds": []}, {"id": "bex_of_exists", "parentIds": []}, {"id": "decidable.has_repr", "parentIds": []}, {"id": "int.of_nat_one", "parentIds": []}, {"id": "d_array.ext", "parentIds": ["array.ext"]}, {"id": "tactic.up", "parentIds": []}, {"id": "mul_self_eq_mul_self_iff", "parentIds": ["mul_self_eq_one_iff"]}, {"id": "eq_neg_of_add_eq_zero", "parentIds": ["mul_self_eq_mul_self_iff"]}, {"id": "classical.exists_true_of_nonempty", "parentIds": []}, {"id": "and_not_self", "parentIds": []}, {"id": "tactic.unsafe.type_context.tmp_get_assignment", "parentIds": []}, {"id": "list.subset_of_cons_subset", "parentIds": []}, {"id": "string.iterator.inhabited", "parentIds": []}, {"id": "string.iterator_imp.inhabited", "parentIds": ["string.iterator.inhabited"]}, {"id": "fun.inhabited", "parentIds": []}, {"id": "tactic.intro1_aux", "parentIds": []}, {"id": "abs_le_of_le_of_neg_le", "parentIds": []}, {"id": "dist_bdd_within_interval", "parentIds": []}, {"id": "sub_le_sub", "parentIds": ["dist_bdd_within_interval"]}, {"id": "expr.to_raw_fmt", "parentIds": []}, {"id": "pos_of_neg_neg", "parentIds": []}, {"id": "to_bool_congr", "parentIds": ["bool.to_bool_eq"]}, {"id": "imp_eq_of_eq_true_right", "parentIds": []}, {"id": "eq_inv_of_mul_eq_one", "parentIds": []}, {"id": "prod.swap_prod_mk", "parentIds": []}, {"id": "expr.is_constant", "parentIds": ["tactic.alias.get_alias_target", "list_items", "environment.is_constructor_app", "expr.list_constant", "interactive.param_desc"]}, {"id": "conv.interactive.simp", "parentIds": []}, {"id": "sub_lt_sub_of_le_of_lt", "parentIds": []}, {"id": "conv.interactive.congr", "parentIds": ["conv.interactive.to_lhs", "conv.interactive.to_rhs"]}, {"id": "conv.congr", "parentIds": ["conv.interactive.congr", "conv.discharge_eq_lhs"]}, {"id": "int.of_nat_add", "parentIds": []}, {"id": "name_set.filter", "parentIds": []}, {"id": "pos_of_one_div_pos", "parentIds": ["neg_of_one_div_neg"]}, {"id": "list.map_singleton", "parentIds": []}, {"id": "smt_tactic.step", "parentIds": []}, {"id": "monad_except_adapter", "parentIds": ["monad_except_adapter_trans", "except_t.monad_except_adapter"]}, {"id": "conv.step", "parentIds": []}, {"id": "left_inverse_inv", "parentIds": []}, {"id": "expr.ith_arg", "parentIds": ["tactic.alias.get_alias_target"]}, {"id": "expr.ith_arg_aux", "parentIds": ["expr.ith_arg"]}, {"id": "nonempty_plift", "parentIds": []}, {"id": "neg_div_neg_eq", "parentIds": []}, {"id": "interactive.single_inductive_decl.name", "parentIds": []}, {"id": "distrib_three_right", "parentIds": []}, {"id": "eq_of_div_eq_one", "parentIds": []}, {"id": "int.distrib", "parentIds": []}, {"id": "heq_self_iff_true", "parentIds": []}, {"id": "tactic.mk_constructors_fresh_names", "parentIds": []}, {"id": "array.push_back", "parentIds": []}, {"id": "function.bijective_id", "parentIds": []}, {"id": "function.injective_id", "parentIds": ["function.bijective_id"]}, {"id": "list.span", "parentIds": ["tactic.alias.make_left_right"]}, {"id": "tactic.alias.get_alias_target", "parentIds": []}, {"id": "cmp_using_eq_eq", "parentIds": []}, {"id": "div_nonneg_of_nonneg_of_pos", "parentIds": []}, {"id": "sub_nonpos_of_le", "parentIds": []}, {"id": "lean.parser.reflect", "parentIds": []}, {"id": "lt_add_of_pos_right", "parentIds": []}, {"id": "set.has_inter", "parentIds": []}, {"id": "native.rb_lmap.inhabited", "parentIds": []}, {"id": "nat.zero_shiftl", "parentIds": []}, {"id": "tactic.mllist.mfilter", "parentIds": []}, {"id": "tactic.get_ancestors", "parentIds": []}, {"id": "eq_inv_mul_of_mul_eq", "parentIds": []}, {"id": "array.rev_iterate", "parentIds": ["array.rev_foldl"]}, {"id": "cond_a_a", "parentIds": []}, {"id": "ff_bxor", "parentIds": []}, {"id": "char.decidable_is_alpha", "parentIds": ["char.decidable_is_alphanum"]}, {"id": "expr.get_nat_value", "parentIds": []}, {"id": "tactic.mllist.append", "parentIds": []}, {"id": "pure_id'_seq", "parentIds": []}, {"id": "fish_assoc", "parentIds": []}, {"id": "list.length_map\u2082", "parentIds": []}, {"id": "pi.inhabited", "parentIds": ["tactic.success_if_fail_with_msg"]}, {"id": "eq_add_of_neg_add_eq", "parentIds": []}, {"id": "list.product", "parentIds": []}, {"id": "eq.congr_right", "parentIds": []}, {"id": "tactic.interactive.rwa", "parentIds": []}, {"id": "tactic.interactive.rewrite", "parentIds": ["tactic.interactive.rwa"]}, {"id": "sub_sub_sub_cancel_right", "parentIds": []}, {"id": "unit.has_repr", "parentIds": []}, {"id": "int.sign_of_succ", "parentIds": []}, {"id": "char.zero_lt_d800", "parentIds": []}, {"id": "nat.zero_lt_bit0", "parentIds": ["char.zero_lt_d800"]}, {"id": "lt_add_of_lt_of_pos", "parentIds": []}, {"id": "tactic.interactive.apply_instance", "parentIds": []}, {"id": "fish_pure", "parentIds": []}, {"id": "expr.instantiate_local", "parentIds": []}, {"id": "norm_num.pos_add_neg_helper", "parentIds": []}, {"id": "tactic.eapplyc", "parentIds": []}, {"id": "division_ring.eq_of_one_div_eq_one_div", "parentIds": ["eq_of_one_div_eq_one_div"]}, {"id": "quot.lift_indep_pr1", "parentIds": []}, {"id": "quot.indep_coherent", "parentIds": ["quot.lift_indep_pr1"]}, {"id": "nat.find_spec", "parentIds": []}, {"id": "pexpr.mk_explicit", "parentIds": []}, {"id": "mk_hinst_lemma_attr_set", "parentIds": []}, {"id": "pexpr.is_choice_macro", "parentIds": []}, {"id": "nat.div_self", "parentIds": []}, {"id": "exists_swap", "parentIds": []}, {"id": "functor.const.map", "parentIds": ["functor.const.functor"]}, {"id": "monad.mapm'", "parentIds": []}, {"id": "decidable.ne_iff_lt_or_gt", "parentIds": []}, {"id": "smt_tactic.interactive.by_contra", "parentIds": []}, {"id": "tactic.trace_call_stack", "parentIds": []}, {"id": "nat_to_format", "parentIds": ["pos.has_to_format"]}, {"id": "list.length_map_accumr\u2082", "parentIds": []}, {"id": "div_mul_eq_mul_div_comm", "parentIds": []}, {"id": "implies.trans", "parentIds": []}, {"id": "tactic.mk_replacer\u2081", "parentIds": ["tactic.mk_replacer"]}, {"id": "tactic.interactive.guard_target", "parentIds": []}, {"id": "to_bool_tt", "parentIds": []}, {"id": "bool.band_assoc", "parentIds": []}, {"id": "old_conv.bottom_up", "parentIds": []}, {"id": "id.pure_eq", "parentIds": []}, {"id": "quotient.induction_on\u2082", "parentIds": []}, {"id": "nat.div_mul_le_self", "parentIds": ["nat.mul_sub_div"]}, {"id": "int.semiring", "parentIds": []}, {"id": "div_div_div_div_eq", "parentIds": []}, {"id": "native.float.modf", "parentIds": []}, {"id": "int.eq_one_of_mul_eq_self_right", "parentIds": []}, {"id": "tactic.rsimp_at", "parentIds": []}, {"id": "eq_of_one_div_eq_one_div", "parentIds": []}, {"id": "eq_zero_of_one_div_eq_zero", "parentIds": ["eq_of_one_div_eq_one_div"]}, {"id": "prod.lex_def", "parentIds": []}, {"id": "push_neg.push_neg_at_hyp", "parentIds": ["tactic.interactive.push_neg"]}, {"id": "sformat_macro", "parentIds": []}, {"id": "bool.bxor_left_comm", "parentIds": []}, {"id": "function.uncurry'_bicompr", "parentIds": []}, {"id": "norm_num.bit1_add_bit1_helper", "parentIds": []}, {"id": "list.subset.refl", "parentIds": []}, {"id": "lt_of_le_of_ne'", "parentIds": []}, {"id": "list.index_of", "parentIds": ["tactic.interactive.case"]}, {"id": "list.find_index", "parentIds": ["list.index_of"]}, {"id": "tactic.trace_algebra_info", "parentIds": []}, {"id": "parser.char_buf", "parentIds": []}, {"id": "native.float.abs", "parentIds": []}, {"id": "bool.band_left_comm", "parentIds": []}, {"id": "eq_add_of_sub_eq'", "parentIds": []}, {"id": "environment.get_decls", "parentIds": []}, {"id": "vm_decl.args_info", "parentIds": []}, {"id": "int.fdiv", "parentIds": []}, {"id": "list.pairwise_cons", "parentIds": ["list.decidable_pairwise"]}, {"id": "nat.shiftl_zero", "parentIds": []}, {"id": "bex.intro", "parentIds": []}, {"id": "instance_priority", "parentIds": ["linter.instance_priority"]}, {"id": "expr.pi_binders", "parentIds": ["instance_priority"]}, {"id": "list.nodup_decidable", "parentIds": ["instance_priority"]}, {"id": "bool.has_repr", "parentIds": []}, {"id": "tactic.interactive.introI", "parentIds": []}, {"id": "fin.decidable_le", "parentIds": []}, {"id": "int.of_nat_succ", "parentIds": []}, {"id": "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "parentIds": []}, {"id": "vm_obj.cidx", "parentIds": []}, {"id": "decidable_of_decidable_of_eq", "parentIds": []}, {"id": "prod.map_def", "parentIds": []}, {"id": "lt_iff_le_and_ne", "parentIds": []}, {"id": "tactic.interactive.dunfold", "parentIds": []}, {"id": "where.get_all_in_namespace", "parentIds": ["where.fetch_potential_variable_names"]}, {"id": "smt_tactic.by_cases", "parentIds": ["smt_tactic.interactive.by_cases"]}, {"id": "nat.sub_eq_zero_iff_le", "parentIds": []}, {"id": "ematch_config.inhabited", "parentIds": []}, {"id": "function.app", "parentIds": []}, {"id": "tactic.mk_back_lemmas", "parentIds": []}, {"id": "eq_of_eqv_lt", "parentIds": []}, {"id": "nat.pow_zero", "parentIds": ["nat.shiftl'_tt_eq_mul_pow", "nat.pow_one"]}, {"id": "expr.bind_pi", "parentIds": ["instance_derive_handler"]}, {"id": "smt_tactic.interactive.from", "parentIds": []}, {"id": "smt_tactic.interactive.exact", "parentIds": ["smt_tactic.interactive.from"]}, {"id": "tactic.interactive.mk_paragraph", "parentIds": ["tactic.interactive.extract_goal"]}, {"id": "heq_iff_eq", "parentIds": []}, {"id": "tactic.inhabited_instance", "parentIds": []}, {"id": "native.float.trunc", "parentIds": []}, {"id": "interaction_monad.result_has_string", "parentIds": []}, {"id": "library_note", "parentIds": []}, {"id": "classical.iff_iff_not_or_and_or_not", "parentIds": []}, {"id": "nat.div_eq_of_eq_mul_left", "parentIds": []}, {"id": "tactic.simp_arg", "parentIds": ["tactic.simp_arg_list"]}, {"id": "native.rb_map.mk_core", "parentIds": []}, {"id": "bool.coe_to_bool", "parentIds": ["bool.to_bool_eq"]}, {"id": "int.comm_monoid", "parentIds": []}, {"id": "d_array.of_beq_eq_ff", "parentIds": []}, {"id": "smt_tactic.interactive.rsimp", "parentIds": []}, {"id": "rbtree.inhabited", "parentIds": []}, {"id": "neg_lt_sub_left_of_lt_add", "parentIds": []}, {"id": "lt_neg_add_of_add_lt", "parentIds": ["neg_lt_sub_left_of_lt_add"]}, {"id": "vm_decl.kind", "parentIds": []}, {"id": "bool.bor_left_comm", "parentIds": []}, {"id": "exists_true_iff_nonempty", "parentIds": []}, {"id": "set.has_insert", "parentIds": []}, {"id": "set.insert", "parentIds": ["set.has_insert"]}, {"id": "pexpr.mk_field_macro", "parentIds": []}, {"id": "eq_rec_heq", "parentIds": []}, {"id": "forall_3_true_iff", "parentIds": []}, {"id": "param_info.inhabited", "parentIds": []}, {"id": "min_self", "parentIds": []}, {"id": "int.ne_neg_of_pos", "parentIds": []}, {"id": "native.rb_map.min", "parentIds": []}, {"id": "tactic.interactive.extract_goal", "parentIds": []}, {"id": "tactic.interactive.compact_decl", "parentIds": ["tactic.interactive.extract_goal"]}, {"id": "list.last'", "parentIds": ["tactic.interactive.extract_goal"]}, {"id": "tactic.interactive.clear_except", "parentIds": ["tactic.interactive.extract_goal"]}, {"id": "tactic.setup_tactic_parser_cmd", "parentIds": []}, {"id": "ne.elim", "parentIds": []}, {"id": "expr.instantiate_lambdas", "parentIds": []}, {"id": "norm_num.mul_zero", "parentIds": []}, {"id": "tactic.unsafe.type_context.is_def_eq", "parentIds": []}, {"id": "classical.subtype_of_exists", "parentIds": []}, {"id": "rsimp.is_value_like", "parentIds": []}, {"id": "lean.version", "parentIds": []}, {"id": "tactic.pformat.has_to_tactic_format", "parentIds": []}, {"id": "native.float.of_nat_coe", "parentIds": []}, {"id": "conv.istep", "parentIds": []}, {"id": "norm_num.mk_cong", "parentIds": []}, {"id": "nonpos_of_mul_nonpos_right", "parentIds": []}, {"id": "native.float.has_to_format", "parentIds": []}, {"id": "tactic.unsafe.type_context.tmp_is_assigned", "parentIds": []}, {"id": "mul_left_cancel_iff", "parentIds": []}, {"id": "smt_tactic.induction", "parentIds": []}, {"id": "native.rb_map.filter", "parentIds": []}, {"id": "expr.is_macro", "parentIds": []}, {"id": "add_pos_of_pos_of_nonneg", "parentIds": []}, {"id": "one_div_add_one_div", "parentIds": []}, {"id": "level.inhabited", "parentIds": []}, {"id": "fin.has_div", "parentIds": ["fin.div_def"]}, {"id": "tactic.explode.status.inhabited", "parentIds": []}, {"id": "nat.gcd_rec", "parentIds": []}, {"id": "option_t.has_monad_lift", "parentIds": ["tactic.find_private_decl", "option_t.run_monad_lift"]}, {"id": "option_t.lift", "parentIds": ["option_t.has_monad_lift"]}, {"id": "tactic.interactive.field", "parentIds": []}, {"id": "push_neg.not_exists_eq", "parentIds": []}, {"id": "bool.bxor_bnot_right", "parentIds": []}, {"id": "iff_congr", "parentIds": []}, {"id": "bool.band_elim_right", "parentIds": []}, {"id": "norm_num.neg_add_neg_helper", "parentIds": []}, {"id": "fin.div_def", "parentIds": []}, {"id": "psigma.eq", "parentIds": ["quot.indep_coherent"]}, {"id": "fin.pred", "parentIds": []}, {"id": "tactic.is_prop_decl", "parentIds": []}, {"id": "level.eqv", "parentIds": []}, {"id": "cast_heq", "parentIds": []}, {"id": "tactic.add_defn_equations", "parentIds": []}, {"id": "environment.add_defn_eqns", "parentIds": ["tactic.add_defn_equations"]}, {"id": "tactic.local_decls", "parentIds": []}, {"id": "abs_lt_of_lt_of_neg_lt", "parentIds": []}, {"id": "tactic.delta_instance", "parentIds": []}, {"id": "nat.digit_succ", "parentIds": []}, {"id": "native.float.tanh", "parentIds": []}, {"id": "list.ball_cons", "parentIds": []}, {"id": "smt_tactic.interactive.simp", "parentIds": []}, {"id": "sub_left_inj", "parentIds": []}, {"id": "list.map_map", "parentIds": []}, {"id": "norm_num.one_add_bit1_helper", "parentIds": []}, {"id": "nat.lt_of_succ_le", "parentIds": ["nat.add_lt_add_left"]}, {"id": "sum.traversable", "parentIds": []}, {"id": "and.right_comm", "parentIds": []}, {"id": "nat.pred_inj", "parentIds": []}, {"id": "functor.add_const.run", "parentIds": []}, {"id": "classical.epsilon_singleton", "parentIds": []}, {"id": "bool.to_bool_or", "parentIds": []}, {"id": "tactic.interactive.injections", "parentIds": []}, {"id": "is_right_null", "parentIds": []}, {"id": "push_neg.not_or_eq", "parentIds": []}, {"id": "nonempty.exists", "parentIds": []}, {"id": "set.is_lawful_functor", "parentIds": []}, {"id": "plift.inhabited", "parentIds": []}, {"id": "int.coe_succ_pos", "parentIds": []}, {"id": "tactic.suggest.head_symbol", "parentIds": []}, {"id": "simp_lemmas.has_to_tactic_format", "parentIds": []}, {"id": "simp_lemmas.pp", "parentIds": ["simp_lemmas.has_to_tactic_format", "tactic.interactive.trace_simp_set"]}, {"id": "plift.down_up", "parentIds": []}, {"id": "list.map_head", "parentIds": []}, {"id": "tactic.interactive.fail_if_success", "parentIds": []}, {"id": "native.float.lt", "parentIds": ["native.float.has_lt", "native.float.decidable_lt"]}, {"id": "sum.inr_ne_inl", "parentIds": []}, {"id": "unsigned.reflect", "parentIds": []}, {"id": "nat.div2_two", "parentIds": []}, {"id": "neg_add'", "parentIds": []}, {"id": "congr_arg_kind.has_repr", "parentIds": []}, {"id": "environment.import_only_until_decl", "parentIds": ["environment.import_until_decl"]}, {"id": "string_imp.inhabited", "parentIds": []}, {"id": "option.has_to_string", "parentIds": []}, {"id": "expr.instantiate_nth_var", "parentIds": []}, {"id": "eq_or_lt_of_le", "parentIds": []}, {"id": "tactic.interactive.guard_hyp'", "parentIds": []}, {"id": "smt_tactic.interactive.apply_instance", "parentIds": []}, {"id": "monoid_to_is_right_id", "parentIds": []}, {"id": "list.qsort_nil", "parentIds": []}, {"id": "guard_false", "parentIds": []}, {"id": "if_eq_of_eq", "parentIds": []}, {"id": "tactic.mk_inj_eq", "parentIds": []}, {"id": "tactic.interactive.congr", "parentIds": ["tactic.mk_inj_eq"]}, {"id": "interactive.executor.execute_explicit", "parentIds": ["tactic.mk_inj_eq"]}, {"id": "environment.is_constructor_app", "parentIds": []}, {"id": "neg_of_one_div_neg", "parentIds": []}, {"id": "smt_tactic.interactive.change", "parentIds": []}, {"id": "native.float.has_lt", "parentIds": ["native.float.decidable_lt"]}, {"id": "to_additive.attr", "parentIds": []}, {"id": "nat.lt_add_right", "parentIds": []}, {"id": "array.map", "parentIds": []}, {"id": "min_eq_right_of_lt", "parentIds": []}, {"id": "sum.decidable_eq", "parentIds": []}, {"id": "empty.subsingleton", "parentIds": []}, {"id": "norm_num.mul_bit1", "parentIds": []}, {"id": "smt_tactic.interactive.ematch_using", "parentIds": []}, {"id": "smt_tactic.interactive.add_fact", "parentIds": []}, {"id": "dlist.to_list_of_list", "parentIds": []}, {"id": "tactic.unify_prefix", "parentIds": []}, {"id": "eq_of_forall_le_iff", "parentIds": []}, {"id": "or.intro_right", "parentIds": []}, {"id": "conv.save_info", "parentIds": []}, {"id": "add_lt_of_neg_of_le", "parentIds": []}, {"id": "environment.import'", "parentIds": ["environment.from_imported_module"]}, {"id": "smt_tactic.set_lemmas", "parentIds": []}, {"id": "lt_add_of_lt_of_nonneg", "parentIds": []}, {"id": "push_neg.not_not_eq", "parentIds": []}, {"id": "tactic.mk_eq_symm", "parentIds": ["tactic.interactive.list_cast_of_aux"]}, {"id": "tactic.interactive.apply_rules", "parentIds": []}, {"id": "tactic.interactive.destruct", "parentIds": []}, {"id": "sub_eq_zero_iff_eq", "parentIds": []}, {"id": "norm_num.bin_add_zero", "parentIds": []}, {"id": "old_conv.seq", "parentIds": []}, {"id": "sigma.eq", "parentIds": []}, {"id": "tactic.decidable_eq_derive_handler", "parentIds": []}, {"id": "ordered_ring.mul_lt_mul_of_pos_left", "parentIds": ["ordered_ring.to_ordered_semiring"]}, {"id": "nat.sub_one", "parentIds": []}, {"id": "where.format_variable", "parentIds": ["where.compile_variable_list"]}, {"id": "array.ext", "parentIds": []}, {"id": "list.decidable_pairwise", "parentIds": ["list.nodup_decidable"]}, {"id": "tactic.interactive.h_generalize", "parentIds": []}, {"id": "tactic.unsafe.type_context.failure", "parentIds": []}, {"id": "tactic.get_univ_assignment", "parentIds": ["tactic.mk_instance_cache"]}, {"id": "interactive.param_desc", "parentIds": []}, {"id": "forall_eq'", "parentIds": []}, {"id": "if_congr_prop", "parentIds": []}, {"id": "nat.bits", "parentIds": []}, {"id": "eq_false_of_or_eq_false_left", "parentIds": []}, {"id": "nat.bit1_ne", "parentIds": []}, {"id": "classical.dec", "parentIds": []}, {"id": "mul_right_injective", "parentIds": []}, {"id": "smt_tactic.skip", "parentIds": []}, {"id": "ordering.inhabited", "parentIds": []}, {"id": "nat.mod_pow_succ", "parentIds": []}, {"id": "linter.def_lemma", "parentIds": []}, {"id": "tactic.interactive.ac_change", "parentIds": []}, {"id": "tactic.interactive.ac_refl", "parentIds": ["tactic.interactive.ac_change"]}, {"id": "nat.zero_pow", "parentIds": []}, {"id": "classical.not_imp_not", "parentIds": []}, {"id": "norm_num.div_helper", "parentIds": []}, {"id": "nat.can_lift", "parentIds": []}, {"id": "expr.is_internal_cnstr", "parentIds": []}, {"id": "native.float.round", "parentIds": []}, {"id": "eq_neg_add_iff_add_eq", "parentIds": []}, {"id": "norm_num.add1_one", "parentIds": []}, {"id": "or_comm", "parentIds": ["forall_or_distrib_right"]}, {"id": "tactic.interactive.fsplit", "parentIds": []}, {"id": "vm_obj.to_environment", "parentIds": []}, {"id": "forall_swap", "parentIds": []}, {"id": "abs_abs_sub_abs_le_abs_sub", "parentIds": []}, {"id": "tactic.replaceable_attr", "parentIds": []}, {"id": "psigma.lex_ndep_wf", "parentIds": []}, {"id": "psigma.lex_ndep", "parentIds": ["psigma.lex_ndep_wf"]}, {"id": "mk_name_set_attr", "parentIds": []}, {"id": "decidable_eq_of_subsingleton", "parentIds": []}, {"id": "lt_of_lt_of_incomp", "parentIds": []}, {"id": "monad_except_adapter_trans", "parentIds": []}, {"id": "nonempty_psum", "parentIds": []}, {"id": "tactic.interactive.case", "parentIds": []}, {"id": "function.inv_fun_comp", "parentIds": []}, {"id": "sub_eq_sub_add_sub", "parentIds": []}, {"id": "tactic.interactive.introv", "parentIds": []}, {"id": "norm_num.neg_neg_helper", "parentIds": []}, {"id": "comp.seq_pure", "parentIds": ["comp.is_lawful_applicative"]}, {"id": "comp.seq_assoc", "parentIds": ["comp.is_lawful_applicative"]}, {"id": "option_t.monad_except", "parentIds": []}, {"id": "tactic.unfold_config.inhabited", "parentIds": []}, {"id": "native.float.dec_eq", "parentIds": []}, {"id": "rbmap.empty", "parentIds": []}, {"id": "list.func.add", "parentIds": []}, {"id": "tactic.explode.entries.add", "parentIds": []}, {"id": "not_nonempty_iff_imp_false", "parentIds": []}, {"id": "decidable_eq_inr_neg", "parentIds": []}, {"id": "nat.succ_sub_one", "parentIds": []}, {"id": "option.lift_or_get_assoc", "parentIds": []}, {"id": "saturate_fun", "parentIds": ["equiv_type_constr"]}, {"id": "expr.get_free_var_range", "parentIds": []}, {"id": "nonempty_prod", "parentIds": []}, {"id": "tactic.interactive.choose", "parentIds": []}, {"id": "tactic.rotate_right", "parentIds": []}, {"id": "eq_false", "parentIds": []}, {"id": "dangerous_instance", "parentIds": ["linter.dangerous_instance"]}, {"id": "mk_hinst_lemma_attr_core", "parentIds": []}, {"id": "option_t.is_lawful_monad", "parentIds": []}, {"id": "div_le_of_le_mul", "parentIds": []}, {"id": "sub_right_inj", "parentIds": []}, {"id": "not.imp", "parentIds": []}, {"id": "lift_list", "parentIds": []}, {"id": "nonempty_pprod", "parentIds": []}, {"id": "tactic.interactive.solve1", "parentIds": []}, {"id": "abs_sub_abs_le_abs_sub", "parentIds": []}, {"id": "strict_weak_order.not_lt_of_equiv'", "parentIds": []}, {"id": "max_left_comm", "parentIds": []}, {"id": "right_cancelative", "parentIds": []}, {"id": "of_not_not", "parentIds": []}, {"id": "option.iget_some", "parentIds": []}, {"id": "nat.one_lt_bit1", "parentIds": []}, {"id": "smt_tactic.interactive.by_cases", "parentIds": []}, {"id": "fin.val_zero", "parentIds": []}, {"id": "native.mk_nat_map", "parentIds": []}, {"id": "exists_eq_left'", "parentIds": []}, {"id": "inv_eq_iff_mul_eq_one", "parentIds": []}, {"id": "conv.interactive.to_lhs", "parentIds": ["tactic.interactive.conv_lhs"]}, {"id": "inv_mul_eq_of_eq_mul", "parentIds": []}, {"id": "nat.add_le_to_le_sub", "parentIds": ["nat.le_div_iff_mul_le"]}, {"id": "tactic.rcases_patt.invert'", "parentIds": []}, {"id": "tactic.interactive.fconstructor", "parentIds": []}, {"id": "array.rev_list", "parentIds": []}, {"id": "array.foldl", "parentIds": ["array.rev_list"]}, {"id": "sub_lt_sub", "parentIds": []}, {"id": "native.float.decidable_lt", "parentIds": []}, {"id": "not_nonempty_pempty", "parentIds": []}, {"id": "d_array.foldl", "parentIds": []}, {"id": "if_eq_of_eq_true", "parentIds": []}, {"id": "norm_num.bit0_add_one", "parentIds": []}, {"id": "norm_num.nonzero_of_div_helper", "parentIds": []}, {"id": "lt_iff_lt_of_le_iff_le'", "parentIds": []}, {"id": "sub_add_sub_cancel'", "parentIds": []}, {"id": "tactic.write_ref", "parentIds": []}, {"id": "iff.elim", "parentIds": []}, {"id": "task.delay", "parentIds": ["tactic.run_async"]}, {"id": "expr.binding_info", "parentIds": []}, {"id": "coe_trans_aux", "parentIds": []}, {"id": "tactic.explode_cmd", "parentIds": []}, {"id": "norm_num.div_eq_div_helper", "parentIds": []}, {"id": "int.le_nat_abs", "parentIds": []}, {"id": "tactic.find_private_decl", "parentIds": ["tactic.import_private_cmd"]}, {"id": "local_context.get_local", "parentIds": []}, {"id": "le_of_one_le_div", "parentIds": []}, {"id": "cast_eq", "parentIds": []}, {"id": "smt_tactic.interactive.all_goals", "parentIds": []}, {"id": "tactic.interactive.trace_simp_set", "parentIds": []}, {"id": "native.float.floor", "parentIds": []}, {"id": "order_laws_tac", "parentIds": []}, {"id": "nat.decidable_dvd", "parentIds": []}, {"id": "expr.pi_binders_aux", "parentIds": ["expr.pi_binders"]}, {"id": "native.float.has_sub", "parentIds": []}, {"id": "forall_pempty", "parentIds": []}, {"id": "exists_eq'", "parentIds": []}, {"id": "list.length_repeat", "parentIds": []}, {"id": "sub_eq_iff_eq_add'", "parentIds": []}, {"id": "tactic.split_if1", "parentIds": []}, {"id": "tactic.reduce_ifs_at", "parentIds": ["tactic.split_if1"]}, {"id": "options.has_decidable_eq", "parentIds": []}, {"id": "has_reflect_derive_handler", "parentIds": []}, {"id": "le_of_not_le", "parentIds": ["min_le_left", "le_max_right"]}, {"id": "tactic.mllist.fixl", "parentIds": []}, {"id": "nat.lt.base", "parentIds": ["nat.lt_succ_self"]}, {"id": "tactic.induction'", "parentIds": []}, {"id": "add_lt_of_lt_of_neg", "parentIds": []}, {"id": "int.gcd", "parentIds": []}, {"id": "native.rb_map.find_def", "parentIds": []}, {"id": "native.rb_set.filter", "parentIds": []}, {"id": "max_eq_right_of_lt", "parentIds": []}, {"id": "and.congr_right_iff", "parentIds": []}, {"id": "le_iff_le_iff_lt_iff_lt", "parentIds": []}, {"id": "eq_sub_iff_add_eq'", "parentIds": []}, {"id": "except_t.monad_except_adapter", "parentIds": []}, {"id": "bool.bor_comm", "parentIds": []}, {"id": "tactic.interactive.introsI", "parentIds": []}, {"id": "expr.has_local", "parentIds": []}, {"id": "list.length_remove_nth", "parentIds": []}, {"id": "id.monad_run", "parentIds": []}, {"id": "tactic.solve", "parentIds": []}, {"id": "nat.sub_lt_succ", "parentIds": []}, {"id": "imp_and_distrib", "parentIds": []}, {"id": "tactic.valid_types", "parentIds": ["tactic.replacer_attr"]}, {"id": "is_right_distrib", "parentIds": []}, {"id": "equiv_type_constr", "parentIds": []}, {"id": "buffer.foldl", "parentIds": []}, {"id": "norm_num.bit0_add_bit0", "parentIds": []}, {"id": "mul_mul_mul_comm", "parentIds": []}, {"id": "coe_tt", "parentIds": []}, {"id": "ordered_comm_group.le_of_add_le_add_left", "parentIds": ["ordered_comm_group.to_ordered_cancel_comm_monoid"]}, {"id": "tactic.simp_intros_config.inhabited", "parentIds": []}, {"id": "smt_config.set_classical", "parentIds": []}, {"id": "tactic.interactive.classical", "parentIds": []}, {"id": "norm_num.mul_div_helper", "parentIds": []}, {"id": "tactic.interactive.suggest", "parentIds": []}, {"id": "classical.type_decidable_eq", "parentIds": []}, {"id": "rbtree.contains", "parentIds": []}, {"id": "nat.bit0_ne", "parentIds": []}, {"id": "div_neg_of_neg_of_pos", "parentIds": []}, {"id": "tactic.unsafe.type_context.level.tmp_is_assigned", "parentIds": []}, {"id": "implies_of_if_neg", "parentIds": []}, {"id": "option_t.run_monad_lift", "parentIds": []}, {"id": "state_t.is_lawful_monad", "parentIds": []}, {"id": "pos.has_to_format", "parentIds": []}, {"id": "old_conv.step", "parentIds": []}, {"id": "not_eq_of_eq_true", "parentIds": []}, {"id": "eq_mul_of_mul_inv_eq", "parentIds": []}, {"id": "list.is_nil", "parentIds": []}, {"id": "old_conv.congr", "parentIds": []}, {"id": "is_left_distrib", "parentIds": []}, {"id": "reader_t.monad_run", "parentIds": []}, {"id": "smt_tactic.interactive.add_lhs_lemma", "parentIds": []}, {"id": "nat.decidable_linear_ordered_cancel_comm_monoid", "parentIds": []}, {"id": "tactic.has_to_tactic_format", "parentIds": []}, {"id": "expr.lambda_body", "parentIds": []}, {"id": "tactic.interactive.contrapose", "parentIds": []}, {"id": "linter.instance_priority", "parentIds": []}, {"id": "function.cantor_injective", "parentIds": []}, {"id": "neg_lt_sub_right_of_lt_add", "parentIds": []}, {"id": "lt_sub_left_of_add_lt", "parentIds": ["neg_lt_sub_right_of_lt_add"]}, {"id": "old_conv.interactive.dsimp", "parentIds": []}, {"id": "fin.has_to_string", "parentIds": []}, {"id": "classical.not_not", "parentIds": []}, {"id": "or_eq_of_eq_true_left", "parentIds": []}, {"id": "add_right_cancel_iff", "parentIds": []}, {"id": "environment.implicit_infer_kind.inhabited", "parentIds": []}, {"id": "nat.bit1_lt_bit0", "parentIds": []}, {"id": "prod.swap_right_inverse", "parentIds": []}, {"id": "array.nil", "parentIds": []}, {"id": "conv.interactive.dsimp", "parentIds": []}, {"id": "tactic.interactive.ac_reflexivity", "parentIds": []}, {"id": "mul_self_eq_one_iff", "parentIds": []}, {"id": "old_conv.fail", "parentIds": []}, {"id": "array.to_buffer", "parentIds": []}, {"id": "nat.mul_mod_mul_right", "parentIds": []}, {"id": "tactic.suggest.library_defs", "parentIds": []}, {"id": "hinst_lemmas.merge", "parentIds": []}, {"id": "eq_mpr_heq", "parentIds": []}, {"id": "pos_and_pos_or_neg_and_neg_of_mul_pos", "parentIds": []}, {"id": "list.insert_nth", "parentIds": []}, {"id": "seq_eq_bind_map", "parentIds": []}, {"id": "tactic.interactive.push_neg", "parentIds": []}, {"id": "exists_pempty", "parentIds": []}, {"id": "bool.bxor_bnot_left", "parentIds": []}, {"id": "le_of_sub_nonpos", "parentIds": []}, {"id": "nat.gcd_self", "parentIds": []}, {"id": "tactic.unsafe.type_context.pop_local", "parentIds": []}, {"id": "function.funext_iff", "parentIds": ["function.involutive_iff_iter_2_eq_id"]}, {"id": "bxor_coe_iff", "parentIds": []}, {"id": "nat.shiftl'_tt_eq_mul_pow", "parentIds": []}, {"id": "function.left_id", "parentIds": []}, {"id": "heq_of_heq_of_eq", "parentIds": []}, {"id": "tactic.interactive.conv_lhs", "parentIds": []}, {"id": "four_pos", "parentIds": []}, {"id": "tactic.intros1", "parentIds": []}, {"id": "mk_expr_map", "parentIds": []}, {"id": "strict_weak_order.not_lt_of_equiv", "parentIds": []}, {"id": "function.right_inverse_inv_fun", "parentIds": []}, {"id": "div_two_lt_of_pos", "parentIds": []}, {"id": "list.le_eq_not_gt", "parentIds": []}, {"id": "derive_struct_ext_lemma", "parentIds": []}, {"id": "tactic.exact_dec_trivial", "parentIds": []}, {"id": "bnot_bnot", "parentIds": []}, {"id": "function.bijective_iff_has_inverse", "parentIds": []}, {"id": "unsigned.has_sub", "parentIds": []}, {"id": "dvd_zero", "parentIds": []}, {"id": "coe_coe", "parentIds": []}, {"id": "add_eq_of_eq_neg_add", "parentIds": []}, {"id": "inv_mul_eq_iff_eq_mul", "parentIds": []}, {"id": "smt_tactic.refutation_for", "parentIds": []}, {"id": "ball.imp_left", "parentIds": []}, {"id": "int.comm_semigroup", "parentIds": []}, {"id": "tactic.mk_instance_cache", "parentIds": []}, {"id": "native.float.specification.precision", "parentIds": []}, {"id": "le_add_of_nonneg_left", "parentIds": []}, {"id": "lint_mathlib", "parentIds": ["lint_mathlib_cmd"]}, {"id": "psum.inhabited_left", "parentIds": []}, {"id": "ordering.compares.eq_eq", "parentIds": []}, {"id": "nat.gcd_def", "parentIds": []}, {"id": "rec_subsingleton", "parentIds": []}, {"id": "neg_le_of_neg_le", "parentIds": ["max_neg_neg"]}, {"id": "expr.contains_constant", "parentIds": ["ge_or_gt_in_statement"]}, {"id": "norm_num.one_add_bit0", "parentIds": []}, {"id": "int.nat_abs_abs", "parentIds": []}, {"id": "nat.cond_to_bool_mod_two", "parentIds": []}, {"id": "function.involutive_iff_iter_2_eq_id", "parentIds": []}, {"id": "char.decidable_is_alphanum", "parentIds": []}, {"id": "tactic.assoc_rewrite_target", "parentIds": []}, {"id": "tactic.get_classes", "parentIds": []}, {"id": "nat.mul_sub_div", "parentIds": []}, {"id": "old_conv.interactive.change", "parentIds": []}, {"id": "tactic.interactive.sorry", "parentIds": []}, {"id": "nonempty.forall", "parentIds": []}, {"id": "abs_mul_self", "parentIds": []}, {"id": "smt_tactic.interactive.executor", "parentIds": []}, {"id": "exists_of_bex", "parentIds": []}, {"id": "int.lor", "parentIds": []}, {"id": "list.partition_eq_filter_filter", "parentIds": []}, {"id": "add_eq_of_eq_sub", "parentIds": []}, {"id": "pempty.decidable_eq", "parentIds": []}, {"id": "dedup", "parentIds": []}, {"id": "tactic.import_private_cmd", "parentIds": []}, {"id": "string.to_nat", "parentIds": []}, {"id": "tactic.interactive.delta", "parentIds": []}, {"id": "tactic.unsafe.type_context.get_local_context", "parentIds": []}, {"id": "lint_mathlib_cmd", "parentIds": []}, {"id": "simp_lemmas.drewrite", "parentIds": []}, {"id": "one_lt_one_div", "parentIds": []}, {"id": "norm_num.add1_bit0", "parentIds": []}, {"id": "setoid.refl", "parentIds": []}, {"id": "buffer.push_back", "parentIds": []}, {"id": "old_conv.mk_match_expr", "parentIds": []}, {"id": "bool.to_bool_eq", "parentIds": []}, {"id": "module_info.has_to_string", "parentIds": []}, {"id": "tactic.congr_core", "parentIds": []}, {"id": "sum.inr.inj_iff", "parentIds": []}, {"id": "list.to_buffer", "parentIds": []}, {"id": "unit.has_to_format", "parentIds": []}, {"id": "tactic.unsafe.type_context.mk_tmp_mvar", "parentIds": []}, {"id": "nat.div2_one", "parentIds": []}, {"id": "linear_ordered_comm_ring.to_comm_monoid", "parentIds": []}, {"id": "native.rb_set.empty", "parentIds": []}, {"id": "native.float.tan", "parentIds": []}, {"id": "psigma.has_sizeof", "parentIds": []}, {"id": "conv.discharge_eq_lhs", "parentIds": []}, {"id": "native.rb_map.ifind", "parentIds": []}, {"id": "prod.exists", "parentIds": []}, {"id": "bor_eq_true_eq_eq_tt_or_eq_tt", "parentIds": []}, {"id": "imp_of_not_imp_not", "parentIds": []}, {"id": "vm_obj.to_expr", "parentIds": []}, {"id": "native.float.is_finite", "parentIds": []}, {"id": "vm.obj_to_string", "parentIds": []}, {"id": "ordered_cancel_comm_monoid.to_add_right_cancel_semigroup", "parentIds": []}, {"id": "linter.dangerous_instance", "parentIds": []}, {"id": "expr.lift", "parentIds": []}, {"id": "false_of_true_iff_false", "parentIds": []}, {"id": "eq_of_add_eq_add_left", "parentIds": []}, {"id": "tactic.fail_macro", "parentIds": []}, {"id": "list.has_inter", "parentIds": []}, {"id": "nat.lt_trans", "parentIds": []}, {"id": "dvd_of_mul_right_eq", "parentIds": []}, {"id": "option.decidable_forall_mem", "parentIds": []}, {"id": "tt_bxor", "parentIds": []}, {"id": "tactic.get_pi_binders_dep_aux", "parentIds": ["tactic.get_pi_binders_dep"]}, {"id": "total", "parentIds": []}, {"id": "forall_lt_iff_le'", "parentIds": []}, {"id": "max_eq_left_of_lt", "parentIds": []}, {"id": "print_name", "parentIds": []}, {"id": "native.float.has_nat_pow", "parentIds": []}, {"id": "tactic.mk_sorry", "parentIds": []}, {"id": "function.bicompl", "parentIds": []}, {"id": "not_and_of_not_right", "parentIds": []}, {"id": "add_le_of_le_of_nonpos", "parentIds": []}, {"id": "list.tails", "parentIds": []}, {"id": "smt_tactic.interactive.fapply", "parentIds": []}, {"id": "imp_imp_imp", "parentIds": []}, {"id": "module_info.has_to_format", "parentIds": []}, {"id": "vm_obj.to_tactic_state", "parentIds": []}, {"id": "neg_add_lt_right_of_lt_add", "parentIds": []}, {"id": "bool.has_sizeof", "parentIds": []}, {"id": "tactic.suggest.apply_declaration", "parentIds": []}, {"id": "smt_tactic.num_goals", "parentIds": []}, {"id": "expr.lex_lt", "parentIds": []}, {"id": "tactic.unsafe.type_context.push_local", "parentIds": []}, {"id": "smt_tactic.preprocess", "parentIds": []}, {"id": "tactic.get_local_type", "parentIds": []}, {"id": "tactic.perm_ac", "parentIds": []}, {"id": "tactic.interactive.comp_val", "parentIds": []}, {"id": "or_of_or_of_imp_left", "parentIds": []}, {"id": "tactic_result", "parentIds": []}, {"id": "not_bex", "parentIds": []}, {"id": "vm_obj_kind.inhabited", "parentIds": []}, {"id": "bool.not_ff", "parentIds": []}, {"id": "list.to_array", "parentIds": []}, {"id": "nat.dvd_antisymm", "parentIds": []}, {"id": "sigma.has_repr", "parentIds": []}, {"id": "tactic.interactive.generalize_proofs", "parentIds": []}, {"id": "add_neg_eq_zero", "parentIds": []}, {"id": "well_founded_tactics.check_target_is_value_lt", "parentIds": []}, {"id": "tactic.module_doc_strings", "parentIds": []}, {"id": "expr.to_implicit_binder", "parentIds": []}, {"id": "int.nat_abs_zero", "parentIds": []}, {"id": "tactic.get_spec_prefix_size", "parentIds": []}, {"id": "band_eq_false_eq_eq_ff_or_eq_ff", "parentIds": []}, {"id": "one_div_le_neg_one", "parentIds": []}, {"id": "div_lt_div_of_mul_sub_mul_div_neg", "parentIds": []}, {"id": "interaction_monad.silent_fail", "parentIds": []}, {"id": "int.lxor", "parentIds": []}, {"id": "nat.pow_one", "parentIds": []}, {"id": "conv.interactive.funext", "parentIds": []}, {"id": "derive_attr", "parentIds": []}, {"id": "bool.bxor_assoc", "parentIds": []}, {"id": "list.eq_nil_of_length_eq_zero", "parentIds": []}, {"id": "occurrences.inhabited", "parentIds": []}, {"id": "tactic.note_anon", "parentIds": []}, {"id": "where.select_for_which", "parentIds": []}, {"id": "ulift.ext", "parentIds": []}, {"id": "function.update_comp", "parentIds": []}, {"id": "dlist.to_list_singleton", "parentIds": []}, {"id": "tactic.match_fn", "parentIds": []}, {"id": "tactic.mk_congr_lemma", "parentIds": []}, {"id": "exists_unique_congr", "parentIds": []}, {"id": "nat.bodd_two", "parentIds": []}, {"id": "mul_add", "parentIds": []}, {"id": "tactic.unsafe.type_context.type_context_alternative", "parentIds": []}, {"id": "tactic.is_simp_lemma", "parentIds": []}, {"id": "old_conv.match_expr", "parentIds": []}, {"id": "plift.up_down", "parentIds": []}]